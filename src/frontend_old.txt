
================================================================================
### PLIK: main.js
================================================================================

// PLIK: src/main.js

import { createApp } from 'vue';
import { createPinia } from 'pinia';
import App from './App.vue';
import router from './router';
import './assets/main.css';

const app = createApp(App);
app.use(createPinia());

// Inicjalizujemy stan autoryzacji z localStorage bez blokowania renderowania.
// To wywołanie jest synchroniczne i bardzo szybkie.
import { useAuthStore } from './stores/authStore';
const authStore = useAuthStore();
authStore.initializeAuth();

app.use(router);
app.mount('#app');

================================================================================
### PLIK: adapters\GoogleGeocodingAdapter.js
================================================================================

/**
 * ARCHITECTURE: GoogleGeocodingAdapter wraps the Maps JS Geocoder into a provider-agnostic API.
 * It follows the manifesto by providing a single responsibility: address → {lat,lon,normalizedFields}.
 * Responsibilities:
 * - Accept Address-like input and call google.maps.Geocoder.
 * - Normalize results into a plain object usable by the Editor (street, houseNumber, postalCode, city, country, lat, lon).
 */
export class GoogleGeocodingAdapter {
  constructor(googleObj) {
    this.google = googleObj;
    this.geocoder = new this.google.maps.Geocoder();
  }

  async geocodeAddress(address) {
    if (!address || !address.street || !address.postalCode || !address.city) {
      return null;
    }
    const line1 = address.houseNumber ? `${address.street} ${address.houseNumber}` : address.street;
    const country = address.country || "PL";
    const query = `${line1}, ${address.postalCode} ${address.city}, ${country}`;
    const res = await this.geocoder.geocode({ address: query });
    if (!res || !Array.isArray(res.results) || res.results.length === 0) {
      return null;
    }
    const best = res.results[0];
    const components = this._indexComponents(best.address_components || []);
    const normalized = {
      street: components.route || address.street,
      houseNumber: components.street_number || address.houseNumber || null,
      postalCode: components.postal_code || address.postalCode,
      city: components.locality || components.postal_town || components.administrative_area_level_2 || address.city,
      country: components.country_code || country,
      latitude: best.geometry?.location?.lat?.() ?? null,
      longitude: best.geometry?.location?.lng?.() ?? null,
    };
    return normalized;
  }

  _indexComponents(parts) {
    const map = {};
    for (const c of parts) {
      for (const t of c.types) {
        if (t === "country") {
          map.country = c.long_name;
          map.country_code = c.short_name;
        } else if (t === "locality") {
          map.locality = c.long_name;
        } else if (t === "postal_town") {
          map.postal_town = c.long_name;
        } else if (t === "administrative_area_level_2") {
          map.administrative_area_level_2 = c.long_name;
        } else if (t === "route") {
          map.route = c.long_name;
        } else if (t === "street_number") {
          map.street_number = c.long_name;
        } else if (t === "postal_code") {
          map.postal_code = c.long_name;
        }
      }
    }
    return map;
  }
}


================================================================================
### PLIK: adapters\GoogleMapAdapter.js
================================================================================

/**
 * ARCHITECTURE: GoogleMapAdapter provides a concrete map implementation for MapController using Google Maps JS API.
 * It follows the manifesto by encapsulating all vendor-specific map calls behind a small, explicit interface.
 * Responsibilities:
 * - Create/destroy a map instance, set center/zoom, and manage a single primary marker.
 * - Avoid leaking Google objects to callers; expose only success/failure via resolved promises.
 */
export class GoogleMapAdapter {
  constructor(googleObj) {
    if (!googleObj || !googleObj.maps) throw new Error("GoogleMapAdapter: google maps object required.");
    this.google = googleObj;
    this._map = null;
    this._marker = null;
  }

  async create(container, options) {
    if (!container) throw new Error("GoogleMapAdapter.create: container is required.");
    const center = { lat: options?.lat ?? 52.2297, lng: options?.lon ?? 21.0122 };
    const zoom = options?.zoom ?? 12;
    this._map = new this.google.maps.Map(container, { center, zoom, mapTypeControl: false, streetViewControl: false });
    this._marker = new this.google.maps.Marker({ position: center, map: this._map });
    return true;
  }

  async setCenter(lat, lon, zoom) {
    if (!this._map) throw new Error("GoogleMapAdapter.setCenter: map not created.");
    const center = { lat, lng: lon };
    this._map.setCenter(center);
    if (typeof zoom === "number") this._map.setZoom(zoom);
    return true;
  }

  async setMarker(lat, lon) {
    if (!this._map || !this._marker) throw new Error("GoogleMapAdapter.setMarker: map not created.");
    const pos = { lat, lng: lon };
    this._marker.setPosition(pos);
    return true;
  }

  async fit(lat, lon) {
    if (!this._map) throw new Error("GoogleMapAdapter.fit: map not created.");
    const bounds = new this.google.maps.LatLngBounds();
    bounds.extend(new this.google.maps.LatLng(lat, lon));
    this._map.fitBounds(bounds, 64);
    return true;
  }

  async destroy() {
    if (this._marker) {
      this._marker.setMap(null);
      this._marker = null;
    }
    if (this._map) {
      this._map = null;
    }
    return true;
  }
}


================================================================================
### PLIK: adapters\GoogleMapsScriptLoader.js
================================================================================

/**
 * ARCHITECTURE: GoogleMapsScriptLoader ensures exactly-once loading of the Google Maps JS API.
 * It follows the manifesto by isolating third-party script lifecycle and exposing a minimal contract.
 * Responsibilities:
 * - Load the script with an API key and optional libraries only once per app session.
 * - Resolve when window.google is available; reject on network or auth errors.
 */
export class GoogleMapsScriptLoader {
  constructor() {
    this._promise = null;
    this._loadedKey = null;
    this._loadedLibsKey = null;
  }

  load(apiKey, libraries = []) {
    if (!apiKey || typeof apiKey !== "string") {
      return Promise.reject(new Error("GoogleMapsScriptLoader: missing apiKey."));
    }
    const libs = Array.isArray(libraries) ? libraries.slice().sort() : [];
    const libsKey = libs.join(",");
    if (this._promise && this._loadedKey === apiKey && this._loadedLibsKey === libsKey) {
      return this._promise;
    }
    if (typeof window !== "undefined" && window.google && window.google.maps) {
      this._promise = Promise.resolve(window.google);
      this._loadedKey = apiKey;
      this._loadedLibsKey = libsKey;
      return this._promise;
    }
    const src = new URL("https://maps.googleapis.com/maps/api/js");
    src.searchParams.set("key", apiKey);
    if (libs.length) src.searchParams.set("libraries", libsKey);
    src.searchParams.set("v", "weekly");
    this._promise = new Promise((resolve, reject) => {
      const s = document.createElement("script");
      s.src = src.toString();
      s.async = true;
      s.defer = true;
      s.onerror = () => reject(new Error("Google Maps script failed to load."));
      s.onload = () => {
        if (window.google && window.google.maps) {
          this._loadedKey = apiKey;
          this._loadedLibsKey = libsKey;
          resolve(window.google);
        } else {
          reject(new Error("Google Maps script loaded but window.google is undefined."));
        }
      };
      document.head.appendChild(s);
    });
    return this._promise;
  }
}


================================================================================
### PLIK: adapters\GooglePlacesAutocompleteAdapter.js
================================================================================

/**
 * ARCHITECTURE: GooglePlacesAutocompleteAdapter wraps Places Autocomplete for type-ahead address hints.
 * It follows the manifesto by isolating vendor-specific API calls and returning normalized suggestion DTOs.
 * Responsibilities:
 * - Create and reuse a session token, query AutocompleteService, and detail lookup for precise fields.
 * - Normalize results into street, houseNumber, postalCode, city, country, latitude, longitude.
 */
export class GooglePlacesAutocompleteAdapter {
  constructor(googleObj) {
    if (!googleObj || !googleObj.maps) throw new Error("GooglePlacesAutocompleteAdapter: google maps object required.");
    this.google = googleObj;
    this.service = new this.google.maps.places.AutocompleteService();
    this.details = new this.google.maps.places.PlacesService(document.createElement("div"));
    this.sessionToken = new this.google.maps.places.AutocompleteSessionToken();
  }

  async suggest(text, country = "PL") {
    if (!text || !text.trim()) return [];
    const r = await this._getPredictions(text, country);
    const picks = Array.isArray(r) ? r.slice(0, 5) : [];
    const enriched = [];
    for (const p of picks) {
      const d = await this._getDetails(p.place_id);
      if (d) {
        enriched.push(d);
      }
    }
    return enriched;
  }

  async _getPredictions(input, country) {
    return new Promise((resolve, reject) => {
      this.service.getPlacePredictions(
        { input, sessionToken: this.sessionToken, componentRestrictions: { country } },
        (predictions, status) => {
          if (status !== this.google.maps.places.PlacesServiceStatus.OK || !predictions) return resolve([]);
          resolve(predictions);
        }
      );
    });
  }

  async _getDetails(placeId) {
    return new Promise((resolve) => {
      this.details.getDetails({ placeId, sessionToken: this.sessionToken, fields: ["address_components", "geometry"] }, (place, status) => {
        if (status !== this.google.maps.places.PlacesServiceStatus.OK || !place) return resolve(null);
        const comps = this._indexComponents(place.address_components || []);
        resolve({
          fullAddressLabel: null,
          street: comps.route || null,
          houseNumber: comps.street_number || null,
          postalCode: comps.postal_code || null,
          city: comps.locality || comps.postal_town || comps.administrative_area_level_2 || null,
          countryCode: comps.country_code || null,
          countryName: comps.country || null,
          latitude: place.geometry?.location?.lat?.() ?? null,
          longitude: place.geometry?.location?.lng?.() ?? null,
          matchScore: 0.9,
          matchLevel: "PLACES",
          providerSource: "GOOGLE_PLACES",
        });
      });
    });
  }

  _indexComponents(parts) {
    const map = {};
    for (const c of parts) {
      for (const t of c.types) {
        if (t === "country") {
          map.country = c.long_name;
          map.country_code = c.short_name;
        } else if (t === "locality") {
          map.locality = c.long_name;
        } else if (t === "postal_town") {
          map.postal_town = c.long_name;
        } else if (t === "administrative_area_level_2") {
          map.administrative_area_level_2 = c.long_name;
        } else if (t === "route") {
          map.route = c.long_name;
        } else if (t === "street_number") {
          map.street_number = c.long_name;
        } else if (t === "postal_code") {
          map.postal_code = c.long_name;
        }
      }
    }
    return map;
  }
}


================================================================================
### PLIK: adapters\MapGeocoderAdapter.js
================================================================================


================================================================================
### PLIK: assets\main.css
================================================================================

@tailwind base;
@tailwind components;
@tailwind utilities;


================================================================================
### PLIK: controllers\AddressVerificationController.js
================================================================================

/**
 * ARCHITECTURE: AddressVerificationController orchestrates Google-first verification and TES-backed suggestions.
 * It follows the manifesto by isolating IO, retries, and provider alignment (set GOOGLE) behind simple methods.
 * Responsibilities:
 * - Ensure TES provider is set to GOOGLE via admin API.
 * - Trigger on-demand suggestions and poll operation status (Kafka-based flow).
 * - Perform instant client-side geocode with Google for live map feedback.
 * - Merge and return a unified suggestion list and a normalized best candidate for the Editor.
 */
import apiClient from "@/services/api";
import { GoogleMapsScriptLoader } from "@/adapters/GoogleMapsScriptLoader";
import { GoogleGeocodingAdapter } from "@/adapters/GoogleGeocodingAdapter";

export class AddressVerificationController {
  constructor() {
    this._google = null;
    this._mapsLoader = new GoogleMapsScriptLoader();
    this._geocoder = null;
    this.providerAligned = false;
    this.loading = false;
    this.error = null;
  }

  async alignProviderToGoogle() {
    try {
      const current = await apiClient.get("/api/admin/address-verification/providers/current");
      if (current?.data?.provider !== "GOOGLE") {
        await apiClient.post("/api/admin/address-verification/providers/current", "GOOGLE", {
          headers: { "Content-Type": "text/plain" },
        });
      }
      this.providerAligned = true;
      return true;
    } catch (e) {
      this.providerAligned = false;
      throw new Error("Failed to align TES provider to GOOGLE.");
    }
  }

  async initGoogle(apiKey, libraries = []) {
    this._google = await this._mapsLoader.load(apiKey, libraries);
    this._geocoder = new GoogleGeocodingAdapter(this._google);
    return true;
  }

  async geocodeInstant(addressDto) {
    if (!this._geocoder) throw new Error("Google not initialized.");
    const normalized = await this._geocoder.geocodeAddress(addressDto);
    return normalized;
  }

  async suggestOnDemand(addressQuery) {
    if (!addressQuery || Object.values(addressQuery).every(v => !v)) {
      return [];
    }
    const start = await apiClient.post("/api/admin/address-verification/suggest-on-demand", addressQuery);
    const correlationId = start?.data?.correlationId;
    if (!correlationId) throw new Error("Missing correlationId for suggest-on-demand.");
    const suggestions = await this._pollOperation(correlationId);
    return suggestions;
  }

  async searchByName(query) {
    if (!query || !query.trim()) {
      return [];
    }
    const start = await apiClient.post("/api/admin/address-verification/search-by-name", query, {
      headers: { "Content-Type": "text/plain" },
    });
    const correlationId = start?.data?.correlationId;
    if (!correlationId) throw new Error("Missing correlationId for search-by-name.");
    const suggestions = await this._pollOperation(correlationId);
    return suggestions;
  }

  async verifyAddressFlow(googleApiKey, addressDto) {
    this.loading = true;
    this.error = null;
    try {
      await this.alignProviderToGoogle(); /* aligns TES provider to GOOGLE. :contentReference[oaicite:0]{index=0} */
      await this.initGoogle(googleApiKey, ["geocoding"]);
      const instant = await this.geocodeInstant(addressDto);
      const backendSuggestions = await this.suggestOnDemand({
        street: addressDto.street || "",
        houseNumber: addressDto.houseNumber || "",
        postalCode: addressDto.postalCode || "",
        city: addressDto.city || "",
        country: addressDto.country || "PL",
      }); /* uses async TES operation and polls status. :contentReference[oaicite:1]{index=1} */
      const merged = this._mergeSuggestions(instant, backendSuggestions);
      this.loading = false;
      return { instant, suggestions: merged };
    } catch (e) {
      this.loading = false;
      this.error = e?.message || "Verification failed.";
      throw e;
    }
  }

  _mergeSuggestions(instant, backendList) {
    const list = Array.isArray(backendList) ? backendList.slice() : [];
    const fromInstant = instant
      ? {
          fullAddressLabel: `${instant.street || ""} ${instant.houseNumber || ""}, ${instant.postalCode || ""} ${instant.city || ""}`,
          street: instant.street || null,
          houseNumber: instant.houseNumber || null,
          postalCode: instant.postalCode || null,
          city: instant.city || null,
          countryCode: instant.country || null,
          countryName: null,
          latitude: instant.latitude ?? null,
          longitude: instant.longitude ?? null,
          matchScore: 1.0,
          matchLevel: "GEOCODER",
          providerSource: "GOOGLE_CLIENT",
        }
      : null;
    if (fromInstant) list.unshift(fromInstant);
    return list;
  }

  async _pollOperation(correlationId) {
    const maxRetries = 10;
    const interval = 2000;
    for (let i = 0; i < maxRetries; i++) {
      await new Promise(r => setTimeout(r, interval));
      const status = await apiClient.get(`/api/admin/address-verification/operations/${correlationId}`);
      const op = status?.data;
      if (op?.status === "COMPLETED") {
        return op?.result?.suggestions || [];
      }
      if (op?.status === "FAILED") {
        throw new Error(op?.errorDetails || "Suggestion operation failed.");
      }
    }
    throw new Error("Address suggestion polling timeout.");
  }
}


================================================================================
### PLIK: controllers\AddressVerificationWorkflow.js
================================================================================

/**
 * ARCHITECTURE: AddressVerificationWorkflow coordinates normalization → validation → Google geocode → TES suggestions.
 * It follows the manifesto by composing small services behind one explicit "verify" method consumed by Editor.
 * Responsibilities:
 * - Normalize input, validate it, short-circuit on errors, and produce user-facing diagnostics.
 * - Call AddressVerificationController for provider alignment, instant geocode, and backend suggestions.
 * - Return a unified result: normalized input, validation, instant geocode, merged suggestions.
 */
import { AddressNormalizer } from "@/services/AddressNormalizer";
import { ValidationService } from "@/services/ValidationService";
import { AddressVerificationController } from "@/controllers/AddressVerificationController";

export class AddressVerificationWorkflow {
  constructor(googleApiKey, normalizer = new AddressNormalizer(), validator = new ValidationService(), controller = new AddressVerificationController()) {
    this.googleApiKey = googleApiKey;
    this.normalizer = normalizer;
    this.validator = validator;
    this.controller = controller;
  }

  async verify(addressDto) {
    const normalized = this.normalizer.normalize(addressDto);
    const check = this.validator.validate(normalized);
    if (!check.valid) {
      return {
        success: false,
        reason: "VALIDATION",
        normalized,
        validation: check,
        instant: null,
        suggestions: [],
      };
    }
    const result = await this.controller.verifyAddressFlow(this.googleApiKey, normalized);
    return {
      success: true,
      reason: "OK",
      normalized,
      validation: check,
      instant: result.instant || null,
      suggestions: Array.isArray(result.suggestions) ? result.suggestions : [],
    };
  }
}


================================================================================
### PLIK: controllers\BulkEditController.js
================================================================================


================================================================================
### PLIK: controllers\CorrectionEditorController.js
================================================================================

/**
 * ARCHITECTURE: CorrectionEditorController orchestrates the "side-by-side diff" editor.
 * It follows the manifesto by isolating all IO and decision logic away from the component tree.
 * Responsibilities:
 * - Loads OrderDetail and related suggestions for pickup/delivery.
 * - Maintains editable copies of addresses, integrates optional geocoder.
 * - Applies Accept Suggestion, Use Original, Manual Edit, Save, and Save & Next.
 * - Shields UI from API details via AddressExceptionApi and from map choice via MapGeocoderAdapter.
 */
import { Address } from "@/domain/WorkbenchModels";
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";
import { MapGeocoderAdapter } from "@/adapters/MapGeocoderAdapter";

export class CorrectionEditorController {
  constructor(api = new AddressExceptionApi(), geocoder = null) {
    this.api = api;
    this.geocoder = geocoder instanceof MapGeocoderAdapter ? geocoder : null;
    this.orderId = null;
    this.detail = null;
    this.loading = false;
    this.error = null;
    this.editedPickup = null;
    this.editedDelivery = null;
  }

  setGeocoderAdapter(adapter) {
    this.geocoder = adapter instanceof MapGeocoderAdapter ? adapter : null;
    return this.geocoder;
  }

  async loadOrder(orderId) {
    this.loading = true;
    this.error = null;
    this.orderId = orderId;
    this.detail = null;
    this.editedPickup = null;
    this.editedDelivery = null;
    const res = await this.api.getOrderDetail(orderId);
    if (!res.ok) {
      this.loading = false;
      this.error = res.error.message;
      return Result.fail(res.error);
    }
    this.detail = res.value;
    this.editedPickup = new Address(
      this.detail.originalPickup.street,
      this.detail.originalPickup.houseNumber,
      this.detail.originalPickup.postalCode,
      this.detail.originalPickup.city,
      this.detail.originalPickup.country,
      this.detail.originalPickup.latitude,
      this.detail.originalPickup.longitude
    );
    this.editedDelivery = new Address(
      this.detail.originalDelivery.street,
      this.detail.originalDelivery.houseNumber,
      this.detail.originalDelivery.postalCode,
      this.detail.originalDelivery.city,
      this.detail.originalDelivery.country,
      this.detail.originalDelivery.latitude,
      this.detail.originalDelivery.longitude
    );
    this.loading = false;
    return Result.ok(this.detail);
  }

  async refreshSuggestions(side) {
    if (!this.orderId) return Result.fail(new Error("Order not loaded."));
    const s = side === "pickup" ? "pickup" : "delivery";
    const res = await this.api.refreshSuggestions(this.orderId, s);
    if (!res.ok) return Result.fail(res.error);
    if (s === "pickup") this.detail.suggestedPickup = res.value;
    if (s === "delivery") this.detail.suggestedDelivery = res.value;
    return Result.ok(res.value);
  }

  acceptSuggestion(side, index = 0) {
    if (!this.detail) return Result.fail(new Error("Order not loaded."));
    const list = side === "pickup" ? this.detail.suggestedPickup : this.detail.suggestedDelivery;
    if (!Array.isArray(list) || !list[index]) return Result.fail(new Error("Suggestion not found."));
    const s = list[index];
    const addr = new Address(
      s.street || "",
      s.houseNumber || null,
      s.postalCode || "",
      s.city || "",
      s.countryCode || this._defaultCountry(),
      s.latitude ?? null,
      s.longitude ?? null
    );
    if (side === "pickup") this.editedPickup = addr;
    if (side === "delivery") this.editedDelivery = addr;
    return Result.ok(addr);
  }

  useOriginal(side) {
    if (!this.detail) return Result.fail(new Error("Order not loaded."));
    if (side === "pickup") {
      const o = this.detail.originalPickup;
      this.editedPickup = new Address(o.street, o.houseNumber, o.postalCode, o.city, o.country, o.latitude, o.longitude);
      return Result.ok(this.editedPickup);
    }
    if (side === "delivery") {
      const o = this.detail.originalDelivery;
      this.editedDelivery = new Address(o.street, o.houseNumber, o.postalCode, o.city, o.country, o.latitude, o.longitude);
      return Result.ok(this.editedDelivery);
    }
    return Result.fail(new Error("Unknown side."));
  }

  setManualAddress(side, address) {
    if (!(address instanceof Address)) return Result.fail(new Error("Invalid Address."));
    if (side === "pickup") this.editedPickup = address;
    else if (side === "delivery") this.editedDelivery = address;
    else return Result.fail(new Error("Unknown side."));
    return Result.ok(address);
  }

  async geocodeEdited(side) {
    if (!this.geocoder) return Result.fail(new Error("No geocoder."));
    const addr = side === "pickup" ? this.editedPickup : this.editedDelivery;
    if (!(addr instanceof Address)) return Result.fail(new Error("No edited address."));
    const r = await this.geocoder.geocodeAddress({
      street: addr.street,
      houseNumber: addr.houseNumber,
      postalCode: addr.postalCode,
      city: addr.city,
      country: addr.country,
    });
    if (!r) return Result.fail(new Error("Geocode not found."));
    addr.latitude = r.lat;
    addr.longitude = r.lon;
    return Result.ok({ lat: r.lat, lon: r.lon });
  }

  async saveAcceptSuggestion(side) {
    if (!this.orderId) return Result.fail(new Error("Order not loaded."));
    const payload = {
      orderId: this.orderId,
      side: side === "both" ? "both" : side === "pickup" ? "pickup" : "delivery",
      correctedPickup: side === "pickup" || side === "both" ? this.editedPickup : null,
      correctedDelivery: side === "delivery" || side === "both" ? this.editedDelivery : null,
      resolution: "ACCEPT_SUGGESTION",
    };
    const res = await this.api.saveCorrection(payload);
    if (!res.ok) return Result.fail(res.error);
    return Result.ok(res.value);
  }

  async saveUseOriginal(side) {
    if (!this.orderId) return Result.fail(new Error("Order not loaded."));
    const payload = {
      orderId: this.orderId,
      side: side === "both" ? "both" : side === "pickup" ? "pickup" : "delivery",
      correctedPickup: side === "pickup" || side === "both" ? this.editedPickup : null,
      correctedDelivery: side === "delivery" || side === "both" ? this.editedDelivery : null,
      resolution: "USE_ORIGINAL",
    };
    const res = await this.api.saveCorrection(payload);
    if (!res.ok) return Result.fail(res.error);
    return Result.ok(res.value);
  }

  async saveManual(side) {
    if (!this.orderId) return Result.fail(new Error("Order not loaded."));
    const payload = {
      orderId: this.orderId,
      side: side === "both" ? "both" : side === "pickup" ? "pickup" : "delivery",
      correctedPickup: side === "pickup" || side === "both" ? this.editedPickup : null,
      correctedDelivery: side === "delivery" || side === "both" ? this.editedDelivery : null,
      resolution: "MANUAL_EDIT",
    };
    const res = await this.api.saveCorrection(payload);
    if (!res.ok) return Result.fail(res.error);
    return Result.ok(res.value);
  }

  async saveAndNext(side, worklistStore) {
    const saveRes = await this._saveBySideKind(side);
    if (!saveRes.ok) return saveRes;
    const nextIdRes = await worklistStore.getNextAndLoad(this.orderId);
    if (!nextIdRes.ok) return Result.fail(nextIdRes.error);
    const nextId = nextIdRes.value;
    if (!nextId) return Result.ok(null);
    const loadRes = await this.loadOrder(nextId);
    if (!loadRes.ok) return Result.fail(loadRes.error);
    return Result.ok(nextId);
  }

  snapshot() {
    return {
      orderId: this.orderId,
      detail: this.detail,
      editedPickup: this.editedPickup,
      editedDelivery: this.editedDelivery,
      loading: this.loading,
      error: this.error,
    };
  }

  _defaultCountry() {
    return "PL";
  }

  async _saveBySideKind(side) {
    if (side === "pickup") return this.saveManual("pickup");
    if (side === "delivery") return this.saveManual("delivery");
    if (side === "both") return this.saveManual("both");
    return Result.fail(new Error("Unknown side."));
  }
}


================================================================================
### PLIK: controllers\EditorVerificationController.js
================================================================================

/**
 * ARCHITECTURE: EditorVerificationController coordinates live verification for the Correction Editor input fields.
 * It follows the manifesto by composing debounce, normalization, validation, Google geocode, and Places hints.
 * Responsibilities:
 * - Debounce user input; on settle, normalize+validate; if valid, geocode and suggest via Places.
 * - Update a MapController through an injected adapter to visualize the current candidate.
 * - Provide a snapshot for the component to render without exposing third-party APIs.
 */
import { AddressNormalizer } from "@/services/AddressNormalizer";
import { ValidationService } from "@/services/ValidationService";
import { DebounceTimer } from "@/services/DebounceTimer";

export class EditorVerificationController {
  constructor(geocoderAdapter, placesAdapter, mapController, debounceMs = 400) {
    this.normalizer = new AddressNormalizer();
    this.validator = new ValidationService();
    this.debouncer = new DebounceTimer(debounceMs);
    this.geocoder = geocoderAdapter || null;
    this.places = placesAdapter || null;
    this.map = mapController || null;
    this.input = { street: "", houseNumber: "", postalCode: "", city: "", country: "PL" };
    this.validation = { valid: false, errors: {} };
    this.instant = null;
    this.suggestions = [];
    this.loading = false;
    this.error = null;
  }

  setInputPatch(patch) {
    this.input = { ...this.input, ...(patch || {}) };
    return this.input;
  }

  async runVerification() {
    return this.debouncer.run(async () => {
      this.loading = true;
      this.error = null;
      const normalized = this.normalizer.normalize(this.input);
      const check = this.validator.validate(normalized);
      this.validation = check;
      if (!check.valid) {
        this.instant = null;
        this.suggestions = [];
        this.loading = false;
        return this.snapshot();
      }
      const instant = this.geocoder ? await this.geocoder.geocodeAddress(normalized) : null;
      if (instant && typeof instant.latitude === "number" && typeof instant.longitude === "number" && this.map) {
        await this.map.updateMarker(instant.latitude, instant.longitude, true);
      }
      const hints = this.places ? await this.places.suggest(this._composeFreeText(normalized), normalized.country) : [];
      this.instant = instant;
      this.suggestions = Array.isArray(hints) ? hints : [];
      this.loading = false;
      return this.snapshot();
    });
  }

  snapshot() {
    return {
      input: { ...this.input },
      validation: { ...this.validation },
      instant: this.instant ? { ...this.instant } : null,
      suggestions: this.suggestions.slice(),
      loading: this.loading,
      error: this.error,
    };
  }

  _composeFreeText(a) {
    const line1 = a.houseNumber ? `${a.street} ${a.houseNumber}` : a.street;
    return `${line1}, ${a.postalCode} ${a.city}`;
  }
}


================================================================================
### PLIK: controllers\MapController.js
================================================================================

/**
 * ARCHITECTURE: MapController manages a single map instance and a primary marker via an injected adapter.
 * It follows the manifesto by abstracting rendering concerns and exposing explicit lifecycle methods.
 * Responsibilities:
 * - Initialize map with center/zoom, update marker on address changes, and dispose cleanly.
 * - Accept any adapter implementing create(container), setCenter(lat,lon), setMarker(lat,lon), fit(lat,lon), destroy().
 * - Avoid direct coupling to Google/Leaflet; adapters perform the concrete work.
 */
export class MapController {
  constructor(adapter) {
    if (!adapter || typeof adapter.create !== "function") throw new Error("MapController: invalid adapter.");
    this.adapter = adapter;
    this._ready = false;
    this._container = null;
    this._lastLat = null;
    this._lastLon = null;
  }

  async init(container, options = { lat: 52.2297, lon: 21.0122, zoom: 12 }) {
    this._container = container;
    await this.adapter.create(container, options);
    this._ready = true;
    this._lastLat = options.lat;
    this._lastLon = options.lon;
    await this.adapter.setCenter(options.lat, options.lon, options.zoom || 12);
    return true;
  }

  async updateMarker(lat, lon, fit = false) {
    if (!this._ready) throw new Error("MapController: not initialized.");
    if (typeof lat !== "number" || typeof lon !== "number") return false;
    await this.adapter.setMarker(lat, lon);
    if (fit) await this.adapter.fit(lat, lon);
    this._lastLat = lat;
    this._lastLon = lon;
    return true;
  }

  async recenter(zoom) {
    if (!this._ready) return false;
    await this.adapter.setCenter(this._lastLat ?? 0, this._lastLon ?? 0, zoom || 12);
    return true;
  }

  async destroy() {
    if (!this._ready) return false;
    await this.adapter.destroy();
    this._ready = false;
    this._container = null;
    this._lastLat = null;
    this._lastLon = null;
    return true;
  }
}


================================================================================
### PLIK: controllers\ProviderGuard.js
================================================================================

/**
 * ARCHITECTURE: ProviderGuard enforces that TES address provider is GOOGLE before verification flows run.
 * It follows the manifesto by isolating cross-cutting preconditions and exposing a single guard method.
 * Responsibilities:
 * - Read current provider; if not GOOGLE, set it to GOOGLE using admin API.
 * - Cache the result to avoid redundant network calls during the session.
 */
import apiClient from "@/services/api";

export class ProviderGuard {
  constructor() {
    this._aligned = false;
    this._inFlight = null;
  }

  async ensureGoogle() {
    if (this._aligned) return true;
    if (this._inFlight) return this._inFlight;
    this._inFlight = this._align();
    try {
      const r = await this._inFlight;
      this._aligned = true;
      return r;
    } finally {
      this._inFlight = null;
    }
  }

  async _align() {
    const current = await apiClient.get("/api/admin/address-verification/providers/current");
    if (current?.data?.provider === "GOOGLE") return true;
    await apiClient.post("/api/admin/address-verification/providers/current", "GOOGLE", {
      headers: { "Content-Type": "text/plain" },
    });
    return true;
  }
}


================================================================================
### PLIK: controllers\TriageDashboardController.js
================================================================================

/**
 * ARCHITECTURE: TriageDashboardController orchestrates KPI tiles, batch/source lists, and error-type groupings.
 * It follows the manifesto by separating read-model orchestration from UI and router glue.
 * Responsibilities:
 * - Load KPIs, recent batches, and pending-by-error-type using AddressExceptionApi.
 * - Expose immutable snapshots for rendering.
 * - Integrate PollingService to keep the dashboard fresh without duplicating timers.
 */
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";
import { PollingService } from "@/services/PollingService";

export class TriageDashboardController {
  constructor(api = new AddressExceptionApi(), polling = new PollingService()) {
    this.api = api;
    this.polling = polling;
    this.loading = false;
    this.error = null;
    this.kpis = null;
    this.recentBatches = [];
    this.pendingByErrorType = [];
    this._pollHandles = [];
  }

  async loadAll() {
    this.loading = true;
    this.error = null;
    const [kpiRes, batchRes, typeRes] = await Promise.all([
      this.api.getTriageKpis(),
      this.api.getRecentBatches(),
      this.api.getPendingByErrorType(),
    ]);
    if (!kpiRes.ok) return this._fail(kpiRes.error);
    if (!batchRes.ok) return this._fail(batchRes.error);
    if (!typeRes.ok) return this._fail(typeRes.error);
    this.kpis = kpiRes.value;
    this.recentBatches = Array.isArray(batchRes.value) ? batchRes.value : [];
    this.pendingByErrorType = Array.isArray(typeRes.value) ? typeRes.value : [];
    this.loading = false;
    return Result.ok(this.snapshot());
  }

  startPolling(intervalMs = 10000) {
    this.stopPolling();
    const k = this.polling.start("kpis", intervalMs, async () => {
      const r = await this.api.getTriageKpis();
      if (r.ok) this.kpis = r.value;
    });
    const b = this.polling.start("batches", intervalMs, async () => {
      const r = await this.api.getRecentBatches();
      if (r.ok) this.recentBatches = Array.isArray(r.value) ? r.value : [];
    });
    const e = this.polling.start("errorsByType", intervalMs, async () => {
      const r = await this.api.getPendingByErrorType();
      if (r.ok) this.pendingByErrorType = Array.isArray(r.value) ? r.value : [];
    });
    this._pollHandles = [k, b, e];
    return this._pollHandles.slice();
  }

  stopPolling() {
    this.polling.stopAll();
    this._pollHandles = [];
  }

  snapshot() {
    return {
      loading: this.loading,
      error: this.error,
      kpis: this.kpis,
      recentBatches: this.recentBatches.slice(),
      pendingByErrorType: this.pendingByErrorType.slice(),
    };
  }

  _fail(err) {
    this.loading = false;
    this.error = err?.message || "Dashboard load failed.";
    return Result.fail(err);
  }
}


================================================================================
### PLIK: domain\BulkEditPlan.js
================================================================================

/**
 * ARCHITEKTURA: Deklaratywna definicja operacji masowej korekty adresów z podglądem i zastosowaniem.
 * Zaprojektowana do walidacji po stronie serwera oraz ponownej weryfikacji partii.
 */
export class BulkEditPlan {
  constructor(orderIds, field, mode, findPattern, replaceWith) {
    this.orderIds = Array.isArray(orderIds) ? orderIds : [];
    this.field = field;
    this.mode = mode;
    this.findPattern = findPattern;
    this.replaceWith = replaceWith;
  }

  static findReplace(orderIds, field, findPattern, replaceWith) {
    return new BulkEditPlan(orderIds, field, "FIND_REPLACE", findPattern, replaceWith);
  }

  static append(orderIds, field, suffix) {
    return new BulkEditPlan(orderIds, field, "APPEND", null, suffix);
  }

  static prepend(orderIds, field, prefix) {
    return new BulkEditPlan(orderIds, field, "PREPEND", null, prefix);
  }
}


================================================================================
### PLIK: domain\Result.js
================================================================================

/**
 * ARCHITEKTURA: Uniwersalny nośnik wyniku operacji (sukces/porażka) bez nulli i wyjątków sterujących przepływem.
 * Zapewnia spójny kontrakt dla wywołań usług oraz ułatwia kompozycję wyników.
 */
export class Result {
  constructor(ok, value, error) {
    this.ok = ok;
    this._value = value;
    this._error = error;
  }

  static ok(value) {
    return new Result(true, value, undefined);
  }

  static fail(error) {
    return new Result(false, undefined, error instanceof Error ? error : new Error(String(error)));
  }

  get value() {
    if (!this.ok) throw new Error("Attempt to get value from failed Result.");
    return this._value;
    }

  get error() {
    if (this.ok) throw new Error("Attempt to get error from successful Result.");
    return this._error;
  }

  map(fn) {
    return this.ok ? Result.ok(fn(this._value)) : Result.fail(this._error);
  }

  asyncMap(fn) {
    if (!this.ok) return Promise.resolve(Result.fail(this._error));
    return fn(this._value).then(Result.ok).catch(err => Result.fail(err));
  }
}


================================================================================
### PLIK: domain\WorkbenchModels.js
================================================================================

/**
 * ARCHITEKTURA: Zbiór prostych, niemutujących DTO dla Workbencha (Triage → Worklist → Editor).
 * Odzwierciedlają encje backendu (zamówienie, adres, sugestia) bez logiki biznesowej.
 */
export class Address {
  constructor(street, houseNumber, postalCode, city, country = "PL", latitude = null, longitude = null) {
    this.street = street;
    this.houseNumber = houseNumber;
    this.postalCode = postalCode;
    this.city = city;
    this.country = country;
    this.latitude = latitude;
    this.longitude = longitude;
  }
}

export class Suggestion {
  constructor(fullAddressLabel, street, houseNumber, postalCode, city, countryCode, countryName, latitude, longitude, matchScore, matchLevel, providerSource) {
    this.fullAddressLabel = fullAddressLabel;
    this.street = street;
    this.houseNumber = houseNumber;
    this.postalCode = postalCode;
    this.city = city;
    this.countryCode = countryCode;
    this.countryName = countryName;
    this.latitude = latitude;
    this.longitude = longitude;
    this.matchScore = matchScore;
    this.matchLevel = matchLevel;
    this.providerSource = providerSource;
  }
}

export class OrderSummary {
  constructor(orderId, requestId, barcode, customerName, source, processingStatus, errorType, updatedAt) {
    this.orderId = orderId;
    this.requestId = requestId;
    this.barcode = barcode;
    this.customerName = customerName;
    this.source = source;
    this.processingStatus = processingStatus;
    this.errorType = errorType;
    this.updatedAt = updatedAt;
  }
}

export class OrderDetail {
  constructor(orderId, barcode, originalPickup, originalDelivery, suggestedPickup, suggestedDelivery, pickupStatus, deliveryStatus, providerRawQuery, errorMessage) {
    this.orderId = orderId;
    this.barcode = barcode;
    this.originalPickup = originalPickup;
    this.originalDelivery = originalDelivery;
    this.suggestedPickup = suggestedPickup;
    this.suggestedDelivery = suggestedDelivery;
    this.pickupStatus = pickupStatus;
    this.deliveryStatus = deliveryStatus;
    this.providerRawQuery = providerRawQuery;
    this.errorMessage = errorMessage;
  }
}

export class BatchKpi {
  constructor(label, total, failed, filename = undefined) {
    this.label = label;
    this.total = total;
    this.failed = failed;
    this.filename = filename;
  }
}

export class TriageKpis {
  constructor(pendingReview, automatedClearancePercent, avgTimeToResolutionMinutes) {
    this.pendingReview = pendingReview;
    this.automatedClearancePercent = automatedClearancePercent;
    this.avgTimeToResolutionMinutes = avgTimeToResolutionMinutes;
  }
}


================================================================================
### PLIK: domain\WorklistFilter.js
================================================================================

/**
 * ARCHITEKTURA: Niemutowalny obiekt zapytania do listy roboczej. Odpowiada za serializację filtrów do parametrów URL.
 * Separuje szczegóły filtrowania od komponentów UI oraz usług sieciowych.
 */
export class WorklistFilter {
  constructor(search = null, source = null, errorTypes = [], minConfidence = null, maxConfidence = null, page = 1, pageSize = 50) {
    this.search = search;
    this.source = source;
    this.errorTypes = Array.isArray(errorTypes) ? errorTypes : [];
    this.minConfidence = minConfidence;
    this.maxConfidence = maxConfidence;
    this.page = page;
    this.pageSize = pageSize;
  }

  withPatch(patch) {
    return new WorklistFilter(
      patch.search ?? this.search,
      patch.source ?? this.source,
      patch.errorTypes ?? this.errorTypes.slice(),
      patch.minConfidence ?? this.minConfidence,
      patch.maxConfidence ?? this.maxConfidence,
      patch.page ?? this.page,
      patch.pageSize ?? this.pageSize
    );
  }

  toQueryRecord() {
    const q = {};
    if (this.search) q.q = this.search;
    if (this.source) q.source = this.source;
    if (this.errorTypes.length) q.errorTypes = this.errorTypes.join(",");
    if (this.minConfidence != null) q.minConfidence = String(this.minConfidence);
    if (this.maxConfidence != null) q.maxConfidence = String(this.maxConfidence);
    q.page = String(this.page);
    q.pageSize = String(this.pageSize);
    return q;
  }
}


================================================================================
### PLIK: router\index.js
================================================================================

// PLIK: src/router/index.js

import { createRouter, createWebHistory } from 'vue-router';
import { useAuthStore } from '@/stores/authStore';
import DashboardLayout from '@/layouts/DashboardLayout.vue';
import LoginView from '@/views/LoginView.vue';

const routes = [
  { path: '/', redirect: '/dashboard' },
  { path: '/login', name: 'login', component: LoginView },
  {
    path: '/dashboard',
    component: DashboardLayout,
    meta: { requiresAuth: true },
    children: [
      { path: '', name: 'dashboard', component: () => import('@/views/DashboardView.vue') },
      { path: 'processing-errors', name: 'processing-errors', component: () => import('@/views/ProcessingErrorsListView.vue') },
      { path: 'rules', name: 'rules', component: () => import('@/views/RulesView.vue') },
      // --- NOWA ŚCIEŻKA ---
      { 
        path: 'verification-cockpit', 
        name: 'verification-cockpit', 
        component: () => import('@/views/VerificationCockpitView.vue') 
      },
    ],
  },
];

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes,
});

/**
 * ARCHITEKTURA: Globalny strażnik nawigacji (Navigation Guard).
 * Przed każdą zmianą trasy sprawdza, czy użytkownik jest uwierzytelniony.
 * Ta logika jest wykonywana po inicjalizacji aplikacji, nie blokując jej startu.
 */
router.beforeEach((to, from, next) => {
  const authStore = useAuthStore();
  const requiresAuth = to.matched.some(record => record.meta.requiresAuth);

  if (requiresAuth && !authStore.isAuthenticated) {
    next({ name: 'login', query: { redirect: to.fullPath } });
  } else if (to.name === 'login' && authStore.isAuthenticated) {
    next('/dashboard');
  } else {
    next();
  }
});

export default router;

================================================================================
### PLIK: services\AddressExceptionApi.js
================================================================================

/**
 * ARCHITEKTURA: Klient BFF dla Workbencha oparty o istniejący axios apiClient.
 * Udostępnia metody dla KPI, listy roboczej, edytora oraz operacji masowych, zgodnie z asynchronicznym przepływem.
 * Wykorzystuje istniejące endpointy admin/verification oraz sugerowane kontrakty dla orders/address-exceptions.
 */
import apiClient from "@/services/api";
import { Result } from "@/domain/Result";

export class AddressExceptionApi {
  async getTriageKpis() {
    return apiClient
      .get("/status/triage-kpis")
      .then(r => Result.ok(r.data))
      .catch(e => Result.fail(e));
  }

  async getRecentBatches() {
    return apiClient
      .get("/status/recent-batches")
      .then(r => Result.ok(r.data))
      .catch(e => Result.fail(e));
  }

  async getPendingByErrorType() {
    return apiClient
      .get("/processing-errors/pending/by-type")
      .then(r => Result.ok(r.data))
      .catch(e => Result.fail(e));
  }

  async searchWorklist(filter) {
    const params = new URLSearchParams(filter.toQueryRecord()).toString();
    return apiClient
      .get(`/orders/address-exceptions?${params}`)
      .then(r => Result.ok(r.data))
      .catch(e => Result.fail(e));
  }

  async getOrderDetail(orderId) {
    return apiClient
      .get(`/orders/${encodeURIComponent(orderId)}/address-exception/detail`)
      .then(r => Result.ok(r.data))
      .catch(e => Result.fail(e));
  }

  async refreshSuggestions(orderId, side) {
    return apiClient
      .get(`/api/admin/address-verification/operations/${encodeURIComponent(orderId)}?side=${encodeURIComponent(side)}`)
      .then(r => Result.ok(r.data))
      .catch(e => Result.fail(e));
  }

  async saveCorrection(payload) {
    return apiClient
      .post(`/orders/${encodeURIComponent(payload.orderId)}/address-exception/resolve`, payload)
      .then(r => Result.ok(r.data))
      .catch(e => Result.fail(e));
  }

  async getNextOrderId(currentOrderId, filter) {
    const params = new URLSearchParams({ ...filter.toQueryRecord(), after: currentOrderId }).toString();
    return apiClient
      .get(`/orders/address-exceptions/next?${params}`)
      .then(r => Result.ok(r.data))
      .catch(e => Result.fail(e));
  }

  async bulkPreview(plan) {
    return apiClient
      .post("/orders/address-exceptions/bulk/preview", plan)
      .then(r => Result.ok(r.data))
      .catch(e => Result.fail(e));
  }

  async bulkApply(plan) {
    return apiClient
      .post("/orders/address-exceptions/bulk/apply", plan)
      .then(r => Result.ok(r.data))
      .catch(e => Result.fail(e));
  }

  async getCurrentProvider() {
    return apiClient
      .get("/api/admin/address-verification/providers/current")
      .then(r => Result.ok(r.data))
      .catch(e => Result.fail(e));
  }

  async setCurrentProvider(provider) {
    return apiClient
      .post("/api/admin/address-verification/providers/current", provider, { headers: { "Content-Type": "text/plain" } })
      .then(r => Result.ok(r.data))
      .catch(e => Result.fail(e));
  }
}


================================================================================
### PLIK: services\AddressNormalizer.js
================================================================================

/**
 * ARCHITECTURE: AddressNormalizer produces a clean, canonical Address DTO for verification and saving.
 * It follows the manifesto by separating normalization concerns from validation and transport layers.
 * Responsibilities:
 * - Trim whitespace, collapse multiple spaces, fix common abbreviations, and upper-case postal code patterns.
 * - Preserve diacritics and avoid lossy transformations.
 * - Return a new plain object without mutating the input instance.
 */
export class AddressNormalizer {
  constructor() {
    this._abbr = new Map([
      [" ul. ", " "],
      [" al. ", " "],
      [" st ", " street "],
      [" str ", " street "],
    ]);
  }

  normalize(address) {
    if (!address || typeof address !== "object") throw new Error("AddressNormalizer: invalid input.");
    const clean = (v) => (typeof v === "string" ? v.replace(/\s+/g, " ").trim() : v);
    let street = clean(address.street || "");
    let city = clean(address.city || "");
    let postal = clean(address.postalCode || "");
    let house = clean(address.houseNumber || null);
    let country = clean(address.country || "PL");
    for (const [k, v] of this._abbr.entries()) {
      street = street.replace(new RegExp(k, "ig"), v);
    }
    postal = postal.toUpperCase();
    return {
      street,
      houseNumber: house,
      postalCode: postal,
      city,
      country,
      latitude: address.latitude ?? null,
      longitude: address.longitude ?? null,
    };
  }
}


================================================================================
### PLIK: services\addressSuggestionService.js
================================================================================

// PLIK: services/addressSuggestionService.js

import apiClient from '@/services/Api.js';

/**
 * ARCHITEKTURA: Serwis frontendowy do obsługi asynchronicznej weryfikacji adresów.
 * Komunikuje się ze starym, opartym na Kafce i pollingu, API w DANXILS_API.
 * Funkcja pollForResults cyklicznie odpytuje backend o status operacji
 * zainicjowanej przez fetchOnDemandSuggestions lub fetchByNameSearch.
 */
const pollForResults = async (correlationId) => {
  const maxRetries = 10;
  const interval = 2000;

  for (let i = 0; i < maxRetries; i++) {
    await new Promise(resolve => setTimeout(resolve, interval));
    
    // POPRAWKA: Usunięto prefiks '/api' ze ścieżki.
    // Ścieżka jest teraz względna do 'baseURL' zdefiniowanego w apiClient.
    const statusResponse = await apiClient.get(`/api/admin/address-verification/operations/${correlationId}`);
    const operation = statusResponse.data;

    if (operation.status === 'COMPLETED') {
      return operation.result?.suggestions || [];
    }
    if (operation.status === 'FAILED') {
      throw new Error(operation.errorDetails || 'Operacja wyszukiwania sugestii nie powiodła się.');
    }
  }
  throw new Error('Przekroczono czas oczekiwania na sugestie adresowe.');
};

export const fetchOnDemandSuggestions = async (addressQuery) => {
  if (!addressQuery || Object.values(addressQuery).every(v => !v)) {
    return [];
  }
  
  try {
    // POPRAWKA: Usunięto prefiks '/api'.
    const initiateResponse = await apiClient.post('/api/admin/address-verification/suggest-on-demand', addressQuery);
    const correlationId = initiateResponse.data.correlationId;
    if (!correlationId) {
        throw new Error("API nie zwróciło correlationId dla operacji sugestii.");
    }
    return await pollForResults(correlationId);
  } catch (error) {
    console.error('Błąd podczas pobierania dynamicznych sugestii:', error);
    return [];
  }
};

export const fetchByNameSearch = async (searchQuery) => {
  if (!searchQuery || searchQuery.trim() === '') {
    return [];
  }
  
  try {
    // POPRAWKA: Usunięto prefiks '/api'.
    const initiateResponse = await apiClient.post('/api/admin/address-verification/search-by-name', searchQuery, {
        headers: { 'Content-Type': 'text/plain' }
    });
    const correlationId = initiateResponse.data.correlationId;
    if (!correlationId) {
        throw new Error("API nie zwróciło correlationId dla operacji wyszukiwania.");
    }
    return await pollForResults(correlationId);
  } catch (error) {
    console.error('Błąd podczas wyszukiwania po nazwie:', error);
    return [];
  }
};

================================================================================
### PLIK: services\addressVerificationService.js
================================================================================

// PLIK: src/services/addressVerificationService.js
import apiClient from '@/services/Api.js';

/**
 * ARCHITEKTURA: Serwis frontendowy do obsługi synchronicznej weryfikacji adresów.
 * Komunikuje się z nowym, synchronicznym endpointem proxy w DANXILS_API,
 * który z kolei odpytuje TES-service. Zapewnia natychmiastową odpowiedź
 * dla interfejsu użytkownika, stanowiąc dedykowane rozwiązanie dla interaktywnych
 * komponentów UI i celowo oddzielone od asynchronicznego `addressSuggestionService`.
 */
export const verifyAddress = async (addressQuery) => {
    if (!addressQuery || !addressQuery.street || !addressQuery.city || !addressQuery.postalCode) {
        throw new Error("Ulica, miasto i kod pocztowy są wymagane do weryfikacji.");
    }
    
    try {
        const response = await apiClient.get('/api/address-tools/verify', {
            params: addressQuery
        });
        return response.data;
    } catch (error) {
        console.error('Błąd podczas synchronicznej weryfikacji adresu:', error);
        const errorMessage = error.response?.data?.error || 'Wystąpił błąd podczas weryfikacji adresu.';
        throw new Error(errorMessage);
    }
};

================================================================================
### PLIK: services\Api.js
================================================================================

// PLIK: src/services/Api.js

import axios from 'axios';
import { useAuthStore } from '@/stores/authStore';

/**
 * ARCHITEKTURA: Scentralizowany i ujednolicony klient API (Axios).
 * Jest to jedyny punkt w aplikacji odpowiedzialny za komunikację z backendem.
 * Został w pełni przystosowany do obsługi uwierzytelniania opartego na tokenach JWT,
 * włączając w to mechanizm automatycznego odświeżania tokena (Refresh Token).
 * Logika związana z CSRF została usunięta jako niekompatybilna z architekturą JWT.
 */
const apiClient = axios.create({
  // URL bazowy dla wszystkich zapytań jest kierowany do naszego BFF (admin-panel-service).
  // Proxy w vite.config.js zajmie się przekierowaniem do odpowiedniego mikroserwisu.
  baseURL: '/api',
});

// Interceptor do dynamicznego dodawania tokenu JWT do każdego wychodzącego żądania.
apiClient.interceptors.request.use(
  (config) => {
    // Używamy dynamicznego importu, aby uniknąć problemów z cyklicznymi zależnościami przy starcie.
    const authStore = useAuthStore();
    const token = authStore.accessToken;
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Interceptor do obsługi wygasłych tokenów i automatycznego ich odświeżania.
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;
    const authStore = useAuthStore();

    // Sprawdzamy, czy błąd to 401 Unauthorized i czy nie jest to ponowiona próba.
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      console.warn("Access Token wygasł. Próba odświeżenia...");

      try {
        // Wywołujemy akcję odświeżenia tokena.
        const newAccessToken = await authStore.refreshToken();
        originalRequest.headers.Authorization = `Bearer ${newAccessToken}`;
        // Ponawiamy oryginalne żądanie z nowym tokenem.
        return apiClient(originalRequest);
      } catch (refreshError) {
        console.error("Nie udało się odświeżyć tokena. Wylogowywanie.", refreshError);
        // Jeśli odświeżenie się nie powiedzie, wylogowujemy użytkownika.
        authStore.logout();
        return Promise.reject(refreshError);
      }
    }
    // Zwracamy błąd, aby mógł być obsłużony dalej (np. w komponencie).
    return Promise.reject(error);
  }
);

export default apiClient;

================================================================================
### PLIK: services\DebounceTimer.js
================================================================================

/**
 * ARCHITECTURE: DebounceTimer provides deterministic debouncing for keystroke-driven verification.
 * It follows the manifesto by encapsulating timing concerns and exposing a minimal, testable contract.
 * Responsibilities:
 * - Debounce a single async task, cancelling the previous one if a new call arrives within the interval.
 * - Prevent overlapping executions by using a monotonically increasing token.
 */
export class DebounceTimer {
  constructor(delayMs = 400) {
    this.delayMs = delayMs;
    this._timer = null;
    this._token = 0;
  }

  run(asyncFn) {
    return new Promise((resolve, reject) => {
      const current = ++this._token;
      if (this._timer) clearTimeout(this._timer);
      this._timer = setTimeout(async () => {
        try {
          if (current !== this._token) return resolve(null);
          const r = await asyncFn();
          if (current !== this._token) return resolve(null);
          resolve(r);
        } catch (e) {
          reject(e);
        }
      }, this.delayMs);
    });
  }

  cancel() {
    if (this._timer) clearTimeout(this._timer);
    this._timer = null;
    this._token++;
  }
}


================================================================================
### PLIK: services\DiffService.js
================================================================================


================================================================================
### PLIK: services\PollingService.js
================================================================================


================================================================================
### PLIK: services\RetryPolicy.js
================================================================================

/**
 * ARCHITECTURE: RetryPolicy executes async operations with bounded retries and jittered backoff.
 * It follows the manifesto by centralizing resilience concerns away from controllers and adapters.
 * Responsibilities:
 * - Execute a provided async function up to maxAttempts with exponential backoff and random jitter.
 * - Allow fast-fail on non-retryable errors via predicate.
 */
export class RetryPolicy {
  constructor(maxAttempts = 5, baseDelayMs = 300, jitterMs = 150, isRetryable = () => true) {
    this.maxAttempts = Math.max(1, maxAttempts);
    this.baseDelayMs = Math.max(0, baseDelayMs);
    this.jitterMs = Math.max(0, jitterMs);
    this.isRetryable = isRetryable;
  }

  async execute(fn) {
    let attempt = 0;
    let lastError = null;
    while (attempt < this.maxAttempts) {
      try {
        return await fn();
      } catch (e) {
        lastError = e;
        attempt++;
        if (attempt >= this.maxAttempts || !this.isRetryable(e)) break;
        const backoff = this.baseDelayMs * Math.pow(2, attempt - 1);
        const jitter = Math.floor(Math.random() * this.jitterMs);
        await new Promise((r) => setTimeout(r, backoff + jitter));
      }
    }
    throw lastError || new Error("RetryPolicy: execution failed.");
  }
}


================================================================================
### PLIK: services\ValidationService.js
================================================================================


================================================================================
### PLIK: stores\addressUploadStore.js
================================================================================

import { defineStore } from 'pinia';
import apiClient from '@/services/api';

export const useAddressUploadStore = defineStore('addressUpload', {
  state: () => ({
    jobs: {}, // Będzie przechowywać statusy zadań, np. { 'jobId': { status: 'PROCESSING', ... } }
    isLoading: false,
    error: null,
  }),
  getters: {
    // Getter do pobierania zadań jako posortowana lista (najnowsze pierwsze)
    jobList: (state) => {
      return Object.values(state.jobs).sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    },
  },
  actions: {
    async uploadFile(file) {
      if (!file) {
        this.error = 'No file selected.';
        return;
      }
      this.isLoading = true;
      this.error = null;

      const formData = new FormData();
      formData.append('file', file);

      try {
        const response = await apiClient.post('/api/address-upload', formData, {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        });
        
        const { jobId } = response.data;
        if (jobId) {
          // Inicjalizuj status zadania i zacznij go śledzić
          this.jobs[jobId] = {
            jobId,
            originalFilename: file.name,
            status: 'PENDING',
            progress: 0,
            createdAt: new Date().toISOString()
          };
          this.pollJobStatus(jobId);
        }
      } catch (err) {
        console.error('File upload failed:', err);
        this.error = err.response?.data?.error || 'File upload failed.';
      } finally {
        this.isLoading = false;
      }
    },

    async pollJobStatus(jobId) {
      const intervalId = setInterval(async () => {
        try {
          const response = await apiClient.get(`/api/address-upload/jobs/${jobId}`);
          const jobData = response.data;
          
          // Aktualizuj status zadania w store
          this.jobs[jobId] = { ...this.jobs[jobId], ...jobData };

          // Zatrzymaj śledzenie, jeśli status jest końcowy
          if (['COMPLETED', 'FAILED_WITH_ERRORS'].includes(jobData.status)) {
            clearInterval(intervalId);
          }
        } catch (error) {
          console.error(`Failed to fetch status for job ${jobId}:`, error);
          this.jobs[jobId].status = 'POLLING_ERROR';
          this.jobs[jobId].errorDetails = 'Could not fetch job status.';
          clearInterval(intervalId);
        }
      }, 3000); // Sprawdzaj status co 3 sekundy
    },
  },
});

================================================================================
### PLIK: stores\authStore.js
================================================================================

// PLIK: src/stores/authStore.js

import { defineStore } from 'pinia';
import apiClient from '@/services/api';
import router from '@/router';
import { jwtDecode } from 'jwt-decode';

/**
 * ARCHITEKTURA: Magazyn stanu (Pinia Store) odpowiedzialny za uwierzytelnianie i autoryzację.
 * Zarządza cyklem życia tokenów JWT (Access i Refresh Token), przechowując je bezpiecznie
 * w localStorage. Odpowiada za logowanie, wylogowywanie oraz mechanizm odświeżania tokena.
 */
export const useAuthStore = defineStore('auth', {
  state: () => ({
    accessToken: localStorage.getItem('accessToken') || null,
    refreshTokenValue: localStorage.getItem('refreshToken') || null,
    user: JSON.parse(localStorage.getItem('user')) || null,
    _isInitialized: false, // Flaga zapobiegająca wielokrotnej inicjalizacji
  }),
  getters: {
    isAuthenticated: (state) => !!state.accessToken,
  },
  actions: {
    async login(credentials) {
      try {
        const response = await apiClient.post('/auth/login', credentials);
        const { accessToken, refreshToken, username, roles } = response.data;

        // Przechowujemy tokeny i dane użytkownika
        this.accessToken = accessToken;
        this.refreshTokenValue = refreshToken;
        this.user = { username, roles };

        // Zapisujemy w localStorage, aby przetrwać odświeżenie strony
        localStorage.setItem('accessToken', accessToken);
        localStorage.setItem('refreshToken', refreshToken);
        localStorage.setItem('user', JSON.stringify({ username, roles }));

        await router.push('/dashboard');
      } catch (error) {
        this.logout(); // Wyczyść stan w razie błędu
        console.error("Błąd logowania:", error);
        throw new Error('Logowanie nie powiodło się. Sprawdź login i hasło.');
      }
    },

    async refreshToken() {
      if (!this.refreshTokenValue) {
        throw new Error("Brak refresh tokena do odświeżenia sesji.");
      }
      try {
        const response = await apiClient.post('/auth/refresh', { refreshToken: this.refreshTokenValue });
        const { accessToken } = response.data;

        this.accessToken = accessToken;
        localStorage.setItem('accessToken', accessToken);

        return accessToken;
      } catch (error) {
        console.error("Błąd odświeżania tokena:", error);
        // Rzucamy błąd dalej, aby interceptor mógł go obsłużyć (np. wylogowując użytkownika)
        throw error;
      }
    },

    logout() {
      // Zerujemy stan
      this.accessToken = null;
      this.refreshTokenValue = null;
      this.user = null;

      // Czyścimy localStorage
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
      localStorage.removeItem('user');

      // Przekierowujemy na stronę logowania
      router.push('/login');
    },

    // Sprawdza ważność tokena przy starcie aplikacji, bez blokowania backendu.
    initializeAuth() {
      if (this.accessToken) {
        try {
          const decodedToken = jwtDecode(this.accessToken);
          // Sprawdzamy, czy token wygasł
          if (decodedToken.exp * 1000 < Date.now()) {
            console.warn("Token wygasł przy inicjalizacji. Wylogowywanie.");
            this.logout();
          }
        } catch (error) {
          console.error("Błąd dekodowania tokena. Token jest nieprawidłowy. Wylogowywanie.", error);
          this.logout();
        }
      }
      this._isInitialized = true;
    }
  },
});

================================================================================
### PLIK: stores\EditorSessionStore.js
================================================================================

/**
 * ARCHITECTURE: EditorSessionStore preserves cross-view context for the Correction Editor.
 * It follows the manifesto by providing a simple, framework-agnostic state carrier.
 * Responsibilities:
 * - Remember the last worklist filter snapshot and the current orderId under edit.
 * - Expose methods to persist/restore navigation context and support "Save & Next".
 */
export class EditorSessionStore {
  constructor() {
    this.lastFilterSnapshot = null;
    this.currentOrderId = null;
  }

  setFilterSnapshot(snapshot) {
    this.lastFilterSnapshot = snapshot ? { ...snapshot } : null;
    return this.lastFilterSnapshot;
  }

  setCurrentOrder(orderId) {
    this.currentOrderId = orderId || null;
    return this.currentOrderId;
  }

  clear() {
    this.lastFilterSnapshot = null;
    this.currentOrderId = null;
  }

  snapshot() {
    return {
      lastFilterSnapshot: this.lastFilterSnapshot,
      currentOrderId: this.currentOrderId,
    };
  }
}


================================================================================
### PLIK: stores\errorStore.js
================================================================================

// PLIK: stores/processingErrorsStore.js (NOWY PLIK)

import { defineStore } from 'pinia';
import apiClient from '@/services/api';

/**
 * ARCHITEKTURA: Dedykowany magazyn stanu (Pinia Store) dla zarządzania błędami przetwarzania.
 * Hermetyzuje całą logikę biznesową związaną z pobieraniem, filtrowaniem i ponawianiem
 * błędnych zleceń, komunikując się z backendem przez ujednolicony apiClient.
 */
export const useProcessingErrorsStore = defineStore('processingErrors', {
  state: () => ({
    errors: [],
    pagination: {
      page: 0,
      size: 15,
      totalElements: 0,
      totalPages: 0,
    },
    currentErrorDetails: null,
    isLoading: false,
    error: null,
  }),
  actions: {
    async fetchProcessingErrors(params) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.get('/processing-errors', { params });
        this.errors = response.data.content;
        this.pagination = {
          page: response.data.number,
          size: response.data.size,
          totalElements: response.data.totalElements,
          totalPages: response.data.totalPages,
        };
      } catch (err) {
        this.error = "Nie udało się pobrać błędów przetwarzania.";
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async fetchErrorDetails(errorId) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.get(`/processing-errors/${errorId}`);
        this.currentErrorDetails = response.data;
      } catch (err) {
        this.error = `Nie udało się pobrać szczegółów błędu o ID ${errorId}.`;
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async resubmitCorrectedOrder(eventId, resubmitPayload) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.post(`/processing-errors/${eventId}/resubmit`, resubmitPayload);
        // Można dodać logikę odświeżenia listy po udanym ponowieniu
        return response.data;
      } catch (err) {
        this.error = "Ponowne przetworzenie zlecenia nie powiodło się.";
        console.error(err);
        throw err; // Rzuć błąd dalej, aby komponent mógł na niego zareagować
      } finally {
        this.isLoading = false;
      }
    },
  },
});

================================================================================
### PLIK: stores\invoicingRulesStore.js
================================================================================

import { defineStore } from 'pinia';
import apiClient from '@/services/Api.js'; // Using your existing API client [cite: 26, 30]

export const useInvoicingRulesStore = defineStore('invoicingRules', {
  state: () => ({
    hubRules: [],
    isLoading: false,
    error: null,
  }),
  getters: {
    // A getter to return rules, perhaps sorted by HUB name
    sortedHubRules: (state) => {
      return [...state.hubRules].sort((a, b) => a.hubId.localeCompare(b.hubId));
    },
  },
  actions: {
    async fetchHubRules() {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.get('/api/admin/invoicing-rules?ruleType=INTERIOR');
        this.hubRules = response.data;
      } catch (err) {
        this.error = 'Failed to fetch HUB rules.';
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async saveRule(rule) {
      this.isLoading = true;
      this.error = null;
      try {
        if (rule.id) {
          // Update existing rule
          await apiClient.put(`/api/admin/invoicing-rules/${rule.id}`, rule);
        } else {
          // Create new rule
          await apiClient.post('/api/admin/invoicing-rules', rule);
        }
        // Refresh the list after saving
        await this.fetchHubRules();
      } catch (err) {
        this.error = 'Failed to save rule.';
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async deleteRule(ruleId) {
      this.isLoading = true;
      this.error = null;
      try {
        await apiClient.delete(`/api/admin/invoicing-rules/${ruleId}`);
        // Refresh the list after deleting
        await this.fetchHubRules();
      } catch (err) {
        this.error = 'Failed to delete rule.';
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },
  },
});

================================================================================
### PLIK: stores\processingErrorsStore.js
================================================================================

// PLIK: src/stores/processingErrorsStore.js (NOWY PLIK)

import { defineStore } from 'pinia';
import apiClient from '@/services/api';

/**
 * ARCHITEKTURA: Dedykowany magazyn stanu (Pinia Store) dla zarządzania błędami przetwarzania.
 * Hermetyzuje całą logikę biznesową związaną z pobieraniem, filtrowaniem i ponawianiem
 * błędnych zleceń, komunikując się z backendem przez ujednolicony apiClient.
 */
export const useProcessingErrorsStore = defineStore('processingErrors', {
  state: () => ({
    errors: [],
    pagination: {
      page: 0,
      size: 15,
      totalElements: 0,
      totalPages: 0,
    },
    currentErrorDetails: null,
    isLoading: false,
    error: null,
  }),
  actions: {
    async fetchProcessingErrors(params) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.get('/processing-errors', { params });
        this.errors = response.data.content;
        this.pagination = {
          page: response.data.number,
          size: response.data.size,
          totalElements: response.data.totalElements,
          totalPages: response.data.totalPages,
        };
      } catch (err) {
        this.error = "Nie udało się pobrać błędów przetwarzania.";
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async fetchErrorDetails(errorId) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.get(`/processing-errors/${errorId}`);
        this.currentErrorDetails = response.data;
      } catch (err) {
        this.error = `Nie udało się pobrać szczegółów błędu o ID ${errorId}.`;
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async resubmitCorrectedOrder(eventId, resubmitPayload) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.post(`/processing-errors/${eventId}/resubmit`, resubmitPayload);
        // Po udanym ponowieniu można odświeżyć listę
        await this.fetchProcessingErrors({ page: this.pagination.page, size: this.pagination.size });
        return response.data;
      } catch (err) {
        this.error = "Ponowne przetworzenie zlecenia nie powiodło się.";
        console.error(err);
        throw err; // Rzuć błąd dalej, aby komponent mógł na niego zareagować
      } finally {
        this.isLoading = false;
      }
    },
  },
});

================================================================================
### PLIK: stores\WorklistStore.js
================================================================================

/**
 * ARCHITECTURE: WorklistStore is a self-contained state holder for the Address Exception "to-do" grid.
 * It follows the manifesto by separating concerns: pure state + orchestration, no UI, no framework glue.
 * Responsibilities:
 * - Holds filter, paging, selection, rows, totals, loading/error flags.
 * - Talks to AddressExceptionApi for search, bulk preview/apply, and "next item" navigation.
 * - Exposes simple methods that views or Pinia wrappers can call without knowing API details.
 */
import { WorklistFilter } from "@/domain/WorklistFilter";
import { BulkEditPlan } from "@/domain/BulkEditPlan";
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

export class WorklistStore {
  constructor(api = new AddressExceptionApi()) {
    this.api = api;
    this.filter = new WorklistFilter();
    this.items = [];
    this.total = 0;
    this.loading = false;
    this.error = null;
    this.selection = new Set();
  }

  async loadPage() {
    this.loading = true;
    this.error = null;
    this.items = [];
    const res = await this.api.searchWorklist(this.filter);
    if (!res.ok) {
      this.loading = false;
      this.error = res.error.message;
      return Result.fail(res.error);
    }
    this.items = Array.isArray(res.value.items) ? res.value.items : [];
    this.total = typeof res.value.total === "number" ? res.value.total : 0;
    this.loading = false;
    return Result.ok({ items: this.items, total: this.total });
  }

  setFilterPatch(patch) {
    this.filter = this.filter.withPatch(patch || {});
    return this.filter;
  }

  resetFilter() {
    this.filter = new WorklistFilter();
    return this.filter;
  }

  setPage(pageNumber) {
    this.filter = this.filter.withPatch({ page: pageNumber });
    return this.filter.page;
  }

  setPageSize(size) {
    this.filter = this.filter.withPatch({ pageSize: size, page: 1 });
    return this.filter.pageSize;
  }

  select(orderId) {
    if (orderId) this.selection.add(orderId);
    return this.getSelection();
  }

  unselect(orderId) {
    if (orderId) this.selection.delete(orderId);
    return this.getSelection();
  }

  clearSelection() {
    this.selection.clear();
    return this.getSelection();
  }

  getSelection() {
    return Array.from(this.selection.values());
  }

  createFindReplacePlan(field, findPattern, replaceWith) {
    return BulkEditPlan.findReplace(this.getSelection(), field, findPattern, replaceWith);
  }

  createAppendPlan(field, suffix) {
    return BulkEditPlan.append(this.getSelection(), field, suffix);
  }

  createPrependPlan(field, prefix) {
    return BulkEditPlan.prepend(this.getSelection(), field, prefix);
  }

  async bulkPreview(plan) {
    if (!(plan instanceof BulkEditPlan)) return Result.fail(new Error("Invalid BulkEditPlan."));
    const res = await this.api.bulkPreview(plan);
    if (!res.ok) return Result.fail(res.error);
    return Result.ok(res.value);
  }

  async bulkApply(plan) {
    if (!(plan instanceof BulkEditPlan)) return Result.fail(new Error("Invalid BulkEditPlan."));
    const res = await this.api.bulkApply(plan);
    if (!res.ok) return Result.fail(res.error);
    await this.loadPage();
    this.clearSelection();
    return Result.ok(res.value);
  }

  async getNextAndLoad(currentOrderId) {
    const nextIdRes = await this.api.getNextOrderId(currentOrderId, this.filter);
    if (!nextIdRes.ok) return Result.fail(nextIdRes.error);
    const nextId = nextIdRes.value || null;
    if (!nextId) return Result.ok(null);
    return Result.ok(nextId);
  }

  snapshot() {
    return {
      filter: this.filter,
      items: this.items.slice(),
      total: this.total,
      loading: this.loading,
      error: this.error,
      selection: this.getSelection(),
    };
  }
}


================================================================================
### PLIK: viewmodels\KpiViewModel.js
================================================================================

