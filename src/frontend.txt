
================================================================================
### PLIK: main.js
================================================================================

// ============================================================================
// Frontend: Update main.js (Final Version)
// FILE: src/main.js
// REASON: Align GeoRuntime config, ensure correct CSS import, provide orchestrator.
// ============================================================================
// FILE: src/main.js
import { createApp } from "vue";
import { createPinia } from "pinia";
import App from "@/App.vue";
import { createRouter } from "@/router/index";
import { AppBootstrapController } from "@/controllers/AppBootstrapController";
import { AuthController } from "@/controllers/AuthController";
import { GeoRuntime } from "@/adapters/GeoRuntime";
// Import Orchestrator for global singleton
import { IntegrationOrchestrator } from "@/controllers/IntegrationOrchestrator";
// *** CORRECTED CSS IMPORT PATH ***
import '@/assets/theme.css'; // Use theme.css directly
// *** END CORRECTION ***

(async () => {
    // 1. Setup Pinia & Auth Controller early
    const pinia = createPinia();
    const auth = new AuthController();
    auth.hydrateFromStorage(); // Load auth state from localStorage

    // 2. Bootstrap App (load config, check health)
    const bootstrap = new AppBootstrapController();
    const boot = await bootstrap.bootstrap(); // Gets config object { config, health }
    const config = boot.config || {}; // Loaded config (contains VITE_ vars)
    const health = boot.health || { ok: false }; // Basic health info

    // 3. Configure GeoRuntime
    const geoProviderConfig = {
        map: (config?.VITE_MAP_PROVIDER || 'leaflet').toLowerCase(),
        geocode: (config?.VITE_GEOCODE_PROVIDER || 'nominatim').toLowerCase(),
        places: (config?.VITE_PLACES_PROVIDER || 'none').toLowerCase(),
        nominatimEmail: config?.VITE_NOMINATIM_EMAIL || 'triage-app@example.com',
        nominatimUrl: config?.VITE_NOMINATIM_URL || null, // Allow override
        routingUrl: config?.VITE_ROUTING_PROVIDER_URL || null, // Pass routing URL
    };
    const googleKey = config?.GOOGLE_MAPS_API_KEY || config?.VITE_GOOGLE_MAPS_API_KEY || null;
    const geoRuntime = new GeoRuntime(geoProviderConfig);

    // 4. Initialize GeoRuntime (loads Google scripts if needed)
    try {
        await geoRuntime.init(googleKey);
        console.log("[main.js] Geo Runtime initialization attempted.");
    } catch(err) {
        console.error("[main.js] Global Geo Runtime initialization failed:", err?.message || err);
    }

    // 5. Create Router (needs GeoRuntime for editor guard)
    const router = createRouter(geoRuntime);

    // 6. Create Vue App
    const app = createApp(App);

    // 7. Global Error handlers
    app.config.errorHandler = (err, instance, info) => console.error("[vue-error]", err, info, instance);
    window.addEventListener("error", (e) => console.error("[window-error]", e?.error || e?.message || e));
    window.addEventListener("unhandledrejection", (e) => console.error("[unhandled-rejection]", e?.reason || e));

    // 8. Use plugins
    app.use(pinia);
    app.use(router);

    // 9. Provide global singletons
    // Orchestrator provides editor/worklist facades
    const orchestrator = new IntegrationOrchestrator(geoRuntime, null);
    app.provide("orchestrator", orchestrator);
    app.provide("auth", auth);
    app.provide("config", config);
    app.provide("health", health);
    app.provide("geoRuntime", geoRuntime);

    // 10. Mount App
    app.mount("#app");
})();

================================================================================
### PLIK: viewmodels/DiffPresenter.js
================================================================================

/**
 * ARCHITECTURE: DiffPresenter formats DiffService output into UI-ready rows with labels.
 * It follows the manifesto by separating presentation decisions from diff computation.
 * Responsibilities:
 * - Map diff entries to rows; provide changed count and stable labels.
 */
export class DiffPresenter {
  constructor() {
    this.labels = {
      street: "Street",
      houseNumber: "House No.",
      postalCode: "Postal",
      city: "City",
      country: "Country",
      latitude: "Latitude",
      longitude: "Longitude",
    };
  }

  present(diffResult) {
    const entries = Array.isArray(diffResult?.entries) ? diffResult.entries : [];
    const rows = entries.map(e => ({
      field: e.field,
      label: this.labels[e.field] || e.field,
      before: e.before ?? null,
      after: e.after ?? null,
      changed: !!e.changed,
    }));
    const changed = rows.filter(r => r.changed).length;
    return { rows, changed };
  }
}


================================================================================
### PLIK: viewmodels/ErrorBannerViewModel.js
================================================================================

/**
 * ARCHITECTURE: ErrorBannerViewModel formats technical errors into concise, user-facing banner messages.
 * It follows the manifesto by separating message mapping and ensuring deterministic display content.
 * Responsibilities:
 * - Map common categories to short titles and detailed descriptions.
 * - Provide a stable shape consumable by any banner/toast component.
 */
export class ErrorBannerViewModel {
  constructor(error) {
    this.error = error instanceof Error ? error : new Error(String(error || "Unknown error"));
    this.title = this._titleFor(this.error);
    this.detail = this._detailFor(this.error);
  }

  toObject() {
    return { title: this.title, detail: this.detail };
  }

  _titleFor(err) {
    const m = (err.message || "").toLowerCase();
    if (m.includes("network")) return "Network issue";
    if (m.includes("timeout")) return "Request timeout";
    if (m.includes("unauthorized") || m.includes("forbidden")) return "Access denied";
    if (m.includes("google")) return "Google maps error";
    return "Something went wrong";
  }

  _detailFor(err) {
    const msg = err.message || "Unexpected failure.";
    return msg.length > 180 ? msg.slice(0, 177) + "..." : msg;
  }
}


================================================================================
### PLIK: viewmodels/KpiViewModel.js
================================================================================

/**
 * ARCHITECTURE: KpiViewModel formats KPI values for dashboard tiles and badges.
 * It follows the manifesto by separating presentation formatting from calculation and transport.
 * Responsibilities:
 * - Hold raw numeric KPIs and expose formatted strings for UI consumption.
 */
export class KpiViewModel {
  constructor({ pending = 0, clearancePercent = 0, avgMinutes = 0 } = {}) {
    this.pending = Number(pending || 0);
    this.clearancePercent = Number(clearancePercent || 0);
    this.avgMinutes = Number(avgMinutes || 0);
  }

  pendingText() {
    return `${this.pending}`;
  }

  clearanceText() {
    if (!Number.isFinite(this.clearancePercent)) return "0.0%";
    return `${this.clearancePercent.toFixed(1)}%`;
  }

  avgResolutionText() {
    if (!Number.isFinite(this.avgMinutes)) return "â€”";
    if (this.avgMinutes < 60) return `${Math.round(this.avgMinutes)} min`;
    const h = Math.floor(this.avgMinutes / 60);
    const m = Math.round(this.avgMinutes % 60);
    return `${h}h ${m}m`;
  }
}


================================================================================
### PLIK: viewmodels/StatusBadgeViewModel.js
================================================================================

// ============================================================================
// Frontend: Update StatusBadgeViewModel (Supersedes previous version)
// FILE: src/viewmodels/StatusBadgeViewModel.js
// REASON: Align status map with canonical mission states (now including AWAITING_ALIAS_CHECK).
// ============================================================================
// FILE: src/viewmodels/StatusBadgeViewModel.js (Supersedes previous version)

/**
 * ARCHITECTURE: StatusBadgeViewModel converts processing status codes into stable badge shape for UI.
 * It follows the manifesto by separating presentation mapping from models and services.
 * Responsibilities:
 * - Map codes to {label,tone,icon} and provide a toObject() helper for templates.
 * UPDATED: Aligned status map with canonical mission states.
 */
export class StatusBadgeViewModel {
  constructor(statusCode) {
    this.status = (statusCode || "").toUpperCase();
    this.map = {
      // --- Canonical States ---
      INGESTED: { label: "Ingested", tone: "neutral", icon: "arrow-down-circle" },
      AWAITING_ALIAS_CHECK: { label: "Checking Alias", tone: "info", icon: "search" }, // Added
      HAPPY_PATH_MATCHED: { label: "Auto-Matched", tone: "success", icon: "check-circle" },
      PENDING_VERIFICATION: { label: "Needs Review", tone: "warning", icon: "alert-triangle" },
      APPROVED: { label: "Approved", tone: "info", icon: "check" },
      SENT_TO_TRACKIT: { label: "Sent to TrackIT", tone: "info", icon: "send" },
      ACK_TRACKIT: { label: "In TrackIT", tone: "success", icon: "check-circle" },
      CDC_EVENT: { label: "CDC Event", tone: "neutral", icon: "database" },
      FAILED: { label: "Failed", tone: "danger", icon: "x-circle" },

      // --- Legacy/Compatibility States (Mapped to canonical visuals where possible) ---
      ADDRESS_NEEDS_REVIEW: { label: "Needs Review", tone: "warning", icon: "alert-triangle" },
      ADDRESS_VALIDATED: { label: "Validated", tone: "success", icon: "check-circle" }, // Maps roughly to ACK_TRACKIT or HAPPY_PATH_MATCHED
      MANUALLY_CORRECTED: { label: "Corrected", tone: "info", icon: "edit-3" }, // Maps roughly to APPROVED
      PENDING_ADDRESS_VALIDATION: { label: "Pending", tone: "info", icon: "clock" }, // Maps roughly to SENT_TO_TRACKIT or AWAITING_ALIAS_CHECK
    };
  }

  toObject() {
    return this.map[this.status] || { label: this.status || "Unknown", tone: "neutral", icon: "help-circle" };
  }
}

================================================================================
### PLIK: viewmodels/VerificationProgressViewModel.js
================================================================================

/**
 * ARCHITECTURE: VerificationProgressViewModel translates workflow milestones into a stable progress model.
 * It follows the manifesto by separating presentation state from controllers and network logic.
 * Responsibilities:
 * - Track phases (normalize, validate, geocode, suggest, merge, save) and compute % complete deterministically.
 * - Provide immutable snapshots for progress bars or step indicators.
 */
export class VerificationProgressViewModel {
  constructor() {
    this.steps = [
      { key: "normalize", done: false },
      { key: "validate", done: false },
      { key: "geocode", done: false },
      { key: "suggest", done: false },
      { key: "merge", done: false },
      { key: "save", done: false },
    ];
  }

  mark(key, done = true) {
    const idx = this.steps.findIndex(s => s.key === key);
    if (idx >= 0) this.steps[idx].done = !!done;
    return this.snapshot();
  }

  percent() {
    const total = this.steps.length || 1;
    const done = this.steps.filter(s => s.done).length;
    return Math.round((done / total) * 100);
  }

  reset() {
    for (const s of this.steps) s.done = false;
    return this.snapshot();
  }

  snapshot() {
    return { steps: this.steps.map(s => ({ key: s.key, done: s.done })), percent: this.percent() };
  }
}


================================================================================
### PLIK: viewmodels/VerificationStatusViewModel.js
================================================================================


================================================================================
### PLIK: bootstrap/GoogleAddressVerificationBootstrap.js
================================================================================

/**
 * ARCHITECTURE: GoogleAddressVerificationBootstrap initializes Google runtime, map, and adapters for the editor.
 * It follows the manifesto by centralizing third-party setup and returning ready-to-use controllers/adapters.
 * Responsibilities:
 * - Load Google script, create MapController with GoogleMapAdapter, and provide geocoder + places adapters.
 */
import { GoogleMapsScriptLoader } from "@/adapters/GoogleMapsScriptLoader";
import { GoogleMapAdapter } from "@/adapters/GoogleMapAdapter";
import { GoogleGeocodingAdapter } from "@/adapters/GoogleGeocodingAdapter";
import { GooglePlacesAutocompleteAdapter } from "@/adapters/GooglePlacesAutocompleteAdapter";
import { MapController } from "@/controllers/MapController";

export class GoogleAddressVerificationBootstrap {
  constructor(loader = new GoogleMapsScriptLoader()) {
    this.loader = loader;
    this.google = null;
    this.mapController = null;
    this.geocoderAdapter = null;
    this.placesAdapter = null;
  }

  async init(mapContainerEl, apiKey) {
    this.google = await this.loader.load(apiKey, ["places"]);
    const mapAdapter = new GoogleMapAdapter(this.google);
    this.mapController = new MapController(mapAdapter);
    await this.mapController.init(mapContainerEl, { lat: 52.2297, lon: 21.0122, zoom: 12 });
    this.geocoderAdapter = new GoogleGeocodingAdapter(this.google);
    this.placesAdapter = new GooglePlacesAutocompleteAdapter(this.google);
    return {
      google: this.google,
      mapController: this.mapController,
      geocoderAdapter: this.geocoderAdapter,
      placesAdapter: this.placesAdapter,
    };
  }
}


================================================================================
### PLIK: tests/example.spec.js
================================================================================

// src/tests/example.spec.js
import { describe, it, expect } from 'vitest';

// Example basic test to ensure Vitest setup is working
describe('Basic Math', () => {
    it('should add two numbers correctly', () => {
        expect(1 + 1).toBe(2);
    });

    it('should handle floating point numbers', () => {
        expect(0.1 + 0.2).toBeCloseTo(0.3);
    });
});

// Example test for a simple utility function (if you had one)
/*
import { simpleUtilFunction } from '@/utils/helpers'; // Assuming a helper exists

describe('simpleUtilFunction', () => {
    it('should return uppercase', () => {
        expect(simpleUtilFunction('hello')).toBe('HELLO');
    });

     it('should handle empty string', () => {
        expect(simpleUtilFunction('')).toBe('');
    });
});
*/

================================================================================
### PLIK: stores/addressUploadStore.js
================================================================================

import { defineStore } from 'pinia';
import apiClient from '@/services/api';

export const useAddressUploadStore = defineStore('addressUpload', {
  state: () => ({
    jobs: {}, // BÄ™dzie przechowywaÄ‡ statusy zadaÅ„, np. { 'jobId': { status: 'PROCESSING', ... } }
    isLoading: false,
    error: null,
  }),
  getters: {
    // Getter do pobierania zadaÅ„ jako posortowana lista (najnowsze pierwsze)
    jobList: (state) => {
      return Object.values(state.jobs).sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    },
  },
  actions: {
    async uploadFile(file) {
      if (!file) {
        this.error = 'No file selected.';
        return;
      }
      this.isLoading = true;
      this.error = null;

      const formData = new FormData();
      formData.append('file', file);

      try {
        const response = await apiClient.post('/api/address-upload', formData, {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        });
        
        const { jobId } = response.data;
        if (jobId) {
          // Inicjalizuj status zadania i zacznij go Å›ledziÄ‡
          this.jobs[jobId] = {
            jobId,
            originalFilename: file.name,
            status: 'PENDING',
            progress: 0,
            createdAt: new Date().toISOString()
          };
          this.pollJobStatus(jobId);
        }
      } catch (err) {
        console.error('File upload failed:', err);
        this.error = err.response?.data?.error || 'File upload failed.';
      } finally {
        this.isLoading = false;
      }
    },

    async pollJobStatus(jobId) {
      const intervalId = setInterval(async () => {
        try {
          const response = await apiClient.get(`/api/address-upload/jobs/${jobId}`);
          const jobData = response.data;
          
          // Aktualizuj status zadania w store
          this.jobs[jobId] = { ...this.jobs[jobId], ...jobData };

          // Zatrzymaj Å›ledzenie, jeÅ›li status jest koÅ„cowy
          if (['COMPLETED', 'FAILED_WITH_ERRORS'].includes(jobData.status)) {
            clearInterval(intervalId);
          }
        } catch (error) {
          console.error(`Failed to fetch status for job ${jobId}:`, error);
          this.jobs[jobId].status = 'POLLING_ERROR';
          this.jobs[jobId].errorDetails = 'Could not fetch job status.';
          clearInterval(intervalId);
        }
      }, 3000); // Sprawdzaj status co 3 sekundy
    },
  },
});

================================================================================
### PLIK: stores/authStore.js
================================================================================

// PLIK: src/stores/authStore.js
import { defineStore } from 'pinia';
import apiClient from '@/services/api';
import { jwtDecode } from 'jwt-decode';

/**
 * ARCHITEKTURA: Magazyn stanu (Pinia Store) odpowiedzialny za uwierzytelnianie i autoryzacjÄ™.
 * Nie zaleÅ¼y od routera; komponenty nawigujÄ… po udanym logowaniu.
 */
export const useAuthStore = defineStore('auth', {
  state: () => ({
    accessToken: localStorage.getItem('accessToken') || null,
    refreshTokenValue: localStorage.getItem('refreshToken') || null,
    user: JSON.parse(localStorage.getItem('user')) || null,
    _isInitialized: false,
  }),
  getters: {
    isAuthenticated: (state) => !!state.accessToken,
  },
  actions: {
    async login(credentials) {
      try {
        const response = await apiClient.post('/auth/login', credentials);
        const { accessToken, refreshToken, username, roles } = response.data;

        this.accessToken = accessToken;
        this.refreshTokenValue = refreshToken;
        this.user = { username, roles };

        localStorage.setItem('accessToken', accessToken);
        localStorage.setItem('refreshToken', refreshToken);
        localStorage.setItem('user', JSON.stringify({ username, roles }));

        return true;
      } catch (error) {
        this.logout();
        console.error("BÅ‚Ä…d logowania:", error);
        throw new Error('Logowanie nie powiodÅ‚o siÄ™. SprawdÅº login i hasÅ‚o.');
      }
    },

    async refreshToken() {
      if (!this.refreshTokenValue) {
        throw new Error("Brak refresh tokena do odÅ›wieÅ¼enia sesji.");
      }
      const response = await apiClient.post('/auth/refresh', { refreshToken: this.refreshTokenValue });
      const { accessToken } = response.data;
      this.accessToken = accessToken;
      localStorage.setItem('accessToken', accessToken);
      return accessToken;
    },

    logout() {
      this.accessToken = null;
      this.refreshTokenValue = null;
      this.user = null;
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
      localStorage.removeItem('user');
    },

    initializeAuth() {
      if (this.accessToken) {
        try {
          const decodedToken = jwtDecode(this.accessToken);
          if (decodedToken.exp * 1000 < Date.now()) {
            console.warn("Token wygasÅ‚ przy inicjalizacji. Wylogowywanie.");
            this.logout();
          }
        } catch (error) {
          console.error("BÅ‚Ä…d dekodowania tokena. Token jest nieprawidÅ‚owy. Wylogowywanie.", error);
          this.logout();
        }
      }
      this._isInitialized = true;
    }
  },
});


================================================================================
### PLIK: stores/EditorSessionStore.js
================================================================================

/**
 * ARCHITECTURE: EditorSessionStore preserves cross-view context for the Correction Editor.
 * It follows the manifesto by providing a simple, framework-agnostic state carrier.
 * Responsibilities:
 * - Remember the last worklist filter snapshot and the current orderId under edit.
 * - Expose methods to persist/restore navigation context and support "Save & Next".
 */
export class EditorSessionStore {
  constructor() {
    this.lastFilterSnapshot = null;
    this.currentOrderId = null;
  }

  setFilterSnapshot(snapshot) {
    this.lastFilterSnapshot = snapshot ? { ...snapshot } : null;
    return this.lastFilterSnapshot;
  }

  setCurrentOrder(orderId) {
    this.currentOrderId = orderId || null;
    return this.currentOrderId;
  }

  clear() {
    this.lastFilterSnapshot = null;
    this.currentOrderId = null;
  }

  snapshot() {
    return {
      lastFilterSnapshot: this.lastFilterSnapshot,
      currentOrderId: this.currentOrderId,
    };
  }
}


================================================================================
### PLIK: stores/invoicingRulesStore.js
================================================================================

import { defineStore } from 'pinia';
import apiClient from '@/services/api.js'; // Using your existing API client [cite: 26, 30]

export const useInvoicingRulesStore = defineStore('invoicingRules', {
  state: () => ({
    hubRules: [],
    isLoading: false,
    error: null,
  }),
  getters: {
    // A getter to return rules, perhaps sorted by HUB name
    sortedHubRules: (state) => {
      return [...state.hubRules].sort((a, b) => a.hubId.localeCompare(b.hubId));
    },
  },
  actions: {
    async fetchHubRules() {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.get('/api/admin/invoicing-rules?ruleType=INTERIOR');
        this.hubRules = response.data;
      } catch (err) {
        this.error = 'Failed to fetch HUB rules.';
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async saveRule(rule) {
      this.isLoading = true;
      this.error = null;
      try {
        if (rule.id) {
          // Update existing rule
          await apiClient.put(`/api/admin/invoicing-rules/${rule.id}`, rule);
        } else {
          // Create new rule
          await apiClient.post('/api/admin/invoicing-rules', rule);
        }
        // Refresh the list after saving
        await this.fetchHubRules();
      } catch (err) {
        this.error = 'Failed to save rule.';
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async deleteRule(ruleId) {
      this.isLoading = true;
      this.error = null;
      try {
        await apiClient.delete(`/api/admin/invoicing-rules/${ruleId}`);
        // Refresh the list after deleting
        await this.fetchHubRules();
      } catch (err) {
        this.error = 'Failed to delete rule.';
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },
  },
});

================================================================================
### PLIK: stores/processingErrorsStore.js
================================================================================

// PLIK: src/stores/processingErrorsStore.js (NOWY PLIK)

import { defineStore } from 'pinia';
import apiClient from '@/services/api';

/**
 * ARCHITEKTURA: Dedykowany magazyn stanu (Pinia Store) dla zarzÄ…dzania bÅ‚Ä™dami przetwarzania.
 * Hermetyzuje caÅ‚Ä… logikÄ™ biznesowÄ… zwiÄ…zanÄ… z pobieraniem, filtrowaniem i ponawianiem
 * bÅ‚Ä™dnych zleceÅ„, komunikujÄ…c siÄ™ z backendem przez ujednolicony apiClient.
 */
export const useProcessingErrorsStore = defineStore('processingErrors', {
  state: () => ({
    errors: [],
    pagination: {
      page: 0,
      size: 15,
      totalElements: 0,
      totalPages: 0,
    },
    currentErrorDetails: null,
    isLoading: false,
    error: null,
  }),
  actions: {
    async fetchProcessingErrors(params) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.get('/processing-errors', { params });
        this.errors = response.data.content;
        this.pagination = {
          page: response.data.number,
          size: response.data.size,
          totalElements: response.data.totalElements,
          totalPages: response.data.totalPages,
        };
      } catch (err) {
        this.error = "Nie udaÅ‚o siÄ™ pobraÄ‡ bÅ‚Ä™dÃ³w przetwarzania.";
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async fetchErrorDetails(errorId) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.get(`/processing-errors/${errorId}`);
        this.currentErrorDetails = response.data;
      } catch (err) {
        this.error = `Nie udaÅ‚o siÄ™ pobraÄ‡ szczegÃ³Å‚Ã³w bÅ‚Ä™du o ID ${errorId}.`;
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async resubmitCorrectedOrder(eventId, resubmitPayload) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.post(`/processing-errors/${eventId}/resubmit`, resubmitPayload);
        // Po udanym ponowieniu moÅ¼na odÅ›wieÅ¼yÄ‡ listÄ™
        await this.fetchProcessingErrors({ page: this.pagination.page, size: this.pagination.size });
        return response.data;
      } catch (err) {
        this.error = "Ponowne przetworzenie zlecenia nie powiodÅ‚o siÄ™.";
        console.error(err);
        throw err; // RzuÄ‡ bÅ‚Ä…d dalej, aby komponent mÃ³gÅ‚ na niego zareagowaÄ‡
      } finally {
        this.isLoading = false;
      }
    },
  },
});

================================================================================
### PLIK: stores/useAedSftpStore.js
================================================================================

// ============================================================================
// Frontend âžœ stores/useAedSftpStore.js (NEW FILE)
// ARCHITECTURE: Pinia store for the new AED SFTP Admin view.
// ============================================================================
import { defineStore } from 'pinia';
import apiClient from '@/services/api'; // Use the shared API client
import { ref } from 'vue';

export const useAedSftpStore = defineStore('aedSftpAdmin', () => {
    const isLoading = ref(false);
    const error = ref(null);
    const successMessage = ref(null);
    const lastExportCount = ref(0);

    // Get current time minus 1 month as default
    const getDefaultStartTime = () => {
        const d = new Date();
        d.setMonth(d.getMonth() - 1);
        // Format as YYYY-MM-DDTHH:MM:SS
        return d.toISOString().substring(0, 19);
    };

    const startTime = ref(getDefaultStartTime());

    async function triggerManualExport() {
        isLoading.value = true;
        error.value = null;
        successMessage.value = null;
        lastExportCount.value = 0;

        if (!startTime.value) {
            error.value = "Start time is required.";
            isLoading.value = false;
            return;
        }

        try {
            const params = new URLSearchParams({
                startTime: startTime.value
            });

            const response = await apiClient.post(`/api/admin/aed/outbound/export-from?${params.toString()}`);

            lastExportCount.value = response.data?.exportedCount || 0;
            successMessage.value = `Successfully exported ${lastExportCount.value} 'MG' status(es) recorded since ${startTime.value}.`;

        } catch (err) {
            console.error("Failed to trigger manual AED export:", err);
            error.value = err.response?.data?.error || err.message || "Failed to trigger export.";
        } finally {
            isLoading.value = false;
        }
    }

    return {
        isLoading,
        error,
        successMessage,
        lastExportCount,
        startTime,
        triggerManualExport
    };
});

================================================================================
### PLIK: stores/useLogStore.js
================================================================================

// FILE: src/stores/useLogStore.js
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import apiClient from '@/services/api.js';
import { useAuthStore } from '@/stores/authStore.js';

export const useLogStore = defineStore('logStore', () => {
    const logs = ref([]);
    const totalElements = ref(0);
    const totalPages = ref(0);
    const currentPage = ref(0);
    const loading = ref(false);
    const error = ref(null);

    const queryFilter = ref('');
    const correlationIdFilter = ref('');
    const appNameFilter = ref('');
    const levelFilter = ref('');
    const startTimeFilter = ref('');
    const endTimeFilter = ref('');
    const pageable = ref({
        page: 0,
        size: 50,
        sort: '@timestamp,desc'
    });

    async function fetchLogs() {
        if (loading.value) return;
        loading.value = true;
        error.value = null;

        const params = new URLSearchParams({
            page: pageable.value.page,
            size: pageable.value.size,
            sort: pageable.value.sort,
        });
        if (queryFilter.value) params.set('query', queryFilter.value);
        if (correlationIdFilter.value) params.set('correlationId', correlationIdFilter.value);
        if (appNameFilter.value) params.set('appName', appNameFilter.value);
        if (levelFilter.value) params.set('level', levelFilter.value);
        if (startTimeFilter.value) params.set('startTime', startTimeFilter.value);
        if (endTimeFilter.value) params.set('endTime', endTimeFilter.value);

        try {
            // *** FIX: Added /api prefix ***
            const response = await apiClient.get(`/api/admin/logs/query?${params.toString()}`);
            // *** END FIX ***
            const data = response.data || {};

            if (data && data.content) {
                logs.value = data.content;
                totalElements.value = data.totalElements;
                totalPages.value = data.totalPages;
                currentPage.value = data.number;
            } else {
                // Fallback for potential direct response without 'data' wrapper if API changes
                if (response && response.content) {
                    logs.value = response.content;
                    totalElements.value = response.totalElements;
                    totalPages.value = response.totalPages;
                    currentPage.value = response.number;
                } else {
                    throw new Error("Invalid response format received from log query API.");
                }
            }
        } catch (err) {
            console.error("Failed to fetch logs:", err);
            // Check for 404 specifically if needed
            if (err.response?.status === 404) {
                error.value = 'Log query endpoint not found. Please check the API path.';
            } else {
                error.value = err.message || 'Failed to fetch logs.';
            }
            logs.value = [];
            totalElements.value = 0;
            totalPages.value = 0;
            currentPage.value = 0;
        } finally {
            loading.value = false;
        }
    }

    function setPage(pageNumber) {
        if (pageNumber >= 0 && pageNumber < (totalPages.value || 1) ) {
            pageable.value.page = pageNumber;
            fetchLogs();
        }
    }

    function applyFiltersAndFetch() {
        pageable.value.page = 0; // Reset to first page on filter change
        fetchLogs();
    }

    // Initial fetch can be triggered here or from the component
    // fetchLogs();

    return {
        logs, totalElements, totalPages, currentPage, loading, error,
        queryFilter, correlationIdFilter, appNameFilter, levelFilter,
        startTimeFilter, endTimeFilter, pageable,
        fetchLogs, setPage, applyFiltersAndFetch,
    };
});

================================================================================
### PLIK: stores/WorklistStore.js
================================================================================

// ============================================================================
// Frontend: Update WorklistStore (Supersedes previous version)
// FILE: src/stores/WorklistStore.js
// REASON: Align default status with canonical mission state 'PENDING_VERIFICATION'.
// ============================================================================
// FILE: src/stores/WorklistStore.js (Supersedes previous version)

import { defineStore } from 'pinia';
import { WorklistFilter } from "@/domain/WorklistFilter";
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

/**
 * ARCHITECTURE: Pinia store for managing the state of the Address Exception Worklist.
 * REFACTORED: Default filter status set to PENDING_VERIFICATION.
 */
export const useWorklistStore = defineStore('worklist', {
    state: () => ({
        // *** MODIFIED: Use PENDING_VERIFICATION ***
        filter: new WorklistFilter({
            status: 'PENDING_VERIFICATION',
            barcode: '',
            customerId: '',
            dateFrom: '', // YYYY-MM-DD
            dateTo: '',   // YYYY-MM-DD
        }), // Use domain object for filter state
        items: [], // Array of OrderSummaryDTO { id, barcode, customerId, processingStatus, createdAt, updatedAt, sourceSystem }
        pagination: {
            currentPage: 1, // Use 1-based indexing for UI
            itemsPerPage: 25,
            totalItems: 0,
            totalPages: 0,
        },
        selection: [], // Array of selected order IDs (UUIDs)
        loading: false,
        error: null, // Stores error message string or Error object
    }),
    getters: {
        isSelected: (state) => (orderId) => {
            return state.selection.includes(orderId);
        },
        currentFilter: (state) => {
            return state.filter.toPlainObject ? state.filter.toPlainObject() : { ...state.filter };
        },
        currentPageInfo: (state) => {
            return { ...state.pagination };
        },
        selectedCount: (state) => {
            return state.selection.length;
        }
    },
    actions: {
        _getApi() {
            return new AddressExceptionApi();
        },

        async loadWorklistPage() {
            this.loading = true;
            this.error = null;
            this.clearSelection();
            const api = this._getApi();
            try {
                const filterParams = {
                    ...(this.filter.toQueryRecord ? this.filter.toQueryRecord() : this.filter),
                    page: this.pagination.currentPage > 0 ? this.pagination.currentPage - 1 : 0,
                    size: this.pagination.itemsPerPage,
                };
                Object.keys(filterParams).forEach(key => (filterParams[key] == null || filterParams[key] === '') && delete filterParams[key]);
                const result = await api.getWorklist(filterParams);

                if (result.ok) {
                    this.items = result.value.items || [];
                    this.pagination.totalItems = result.value.total || 0;
                    this.pagination.totalPages = this.pagination.itemsPerPage > 0
                        ? Math.ceil(this.pagination.totalItems / this.pagination.itemsPerPage) || 1
                        : 1;
                    if (this.pagination.currentPage > this.pagination.totalPages) {
                        this.pagination.currentPage = this.pagination.totalPages;
                    }
                    return Result.ok();
                } else {
                    throw result.error;
                }
            } catch (err) {
                console.error("Failed to load worklist page:", err);
                this.error = err.message || "Failed to load worklist.";
                this.items = [];
                this.pagination.totalItems = 0;
                this.pagination.totalPages = 1;
                this.pagination.currentPage = 1;
                return Result.fail(err);
            } finally {
                this.loading = false;
            }
        },

        async applyFilterPatch(patch) {
            this.pagination.currentPage = 1;
            this.filter = this.filter.withPatch(patch || {});
            await this.loadWorklistPage();
        },

        async resetFilter() {
            // *** MODIFIED: Use PENDING_VERIFICATION ***
            this.filter = new WorklistFilter({
                status: 'PENDING_VERIFICATION',
                barcode: '',
                customerId: '',
                dateFrom: '',
                dateTo: '',
            });
            this.pagination.currentPage = 1;
            await this.loadWorklistPage();
        },

        async goToPage(pageNumber) {
            const newPage = Math.max(1, Math.min(pageNumber, this.pagination.totalPages || 1));
            if (newPage !== this.pagination.currentPage) {
                this.pagination.currentPage = newPage;
                await this.loadWorklistPage();
            }
        },

        async changePageSize(size) {
            const newSize = Math.max(5, size);
            if (newSize !== this.pagination.itemsPerPage) {
                this.pagination.itemsPerPage = newSize;
                this.pagination.currentPage = 1;
                await this.loadWorklistPage();
            }
        },

        // --- Selection Actions ---
        toggleSelection(orderId) {
            const index = this.selection.indexOf(orderId);
            if (index > -1) {
                this.selection.splice(index, 1);
            } else {
                this.selection.push(orderId);
            }
        },
        setSelection(orderIds) {
            if (Array.isArray(orderIds)) {
                this.selection = [...new Set(orderIds)];
            }
        },
        clearSelection() {
            this.selection = [];
        },
        selectAllOnPage() {
            this.selection = this.items.map(item => item.id);
        },
    },
});

================================================================================
### PLIK: adapters/GeoRuntime.js
================================================================================

// ============================================================================
// Frontend: Update GeoRuntime (Final Version)
// FILE: src/adapters/GeoRuntime.js
// REASON: Pass routing URL correctly, handle initialization errors gracefully.
// ============================================================================
// FILE: src/adapters/GeoRuntime.js
import { GoogleMapsScriptLoader } from "@/adapters/GoogleMapsScriptLoader";
import { GoogleMapAdapter } from "@/adapters/GoogleMapAdapter";
import { GoogleGeocodingAdapter } from "@/adapters/GoogleGeocodingAdapter";
import { GooglePlacesAutocompleteAdapter } from "@/adapters/GooglePlacesAutocompleteAdapter";
import { LeafletMapAdapter } from "@/adapters/LeafletMapAdapter";
import { NominatimGeocodingAdapter } from "@/adapters/NominatimGeocodingAdapter";

/**
 * ARCHITECTURE: Manages initialization and access for geographic service adapters.
 * REFACTORED: Passes OSRM routing URL (VITE_ROUTING_PROVIDER_URL) to LeafletMapAdapter. Handles errors better.
 */
export class GeoRuntime {
    constructor(providerConfig = {}) {
        this._config = {
            map: (providerConfig.map || 'leaflet').toLowerCase(),
            geocode: (providerConfig.geocode || 'nominatim').toLowerCase(),
            places: (providerConfig.places || 'none').toLowerCase(),
            nominatimEmail: providerConfig.nominatimEmail || 'danxils-triage@example.com',
            nominatimUrl: providerConfig.nominatimUrl || null,
            routingUrl: providerConfig.routingUrl || null,
        };
        log.info(`[GeoRuntime] Configured Providers - Map: ${this._config.map}, Geocode: ${this._config.geocode}, Places: ${this._config.places}, Routing: ${this._config.routingUrl ? 'OSRM' : 'None'}`);

        this._googleLoader = new GoogleMapsScriptLoader();
        this._googleInstance = null;
        this._googleApiKey = null;
        this._googleLibs = ["places", "geocoding", "marker"];
        this._googleMapAdapterInstance = null;
        this._googleGeocodingAdapterInstance = null;
        this._googlePlacesAdapterInstance = null;

        this._leafletMapAdapterInstance = null;
        this._nominatimGeocodingAdapterInstance = null;

        this._initializationPromise = null;
        this._isGoogleInitialized = false;
        this._isNonGoogleInitialized = false;
    }

    async init(googleApiKey = null) {
        if (this._initializationPromise) return this._initializationPromise;

        this._googleApiKey = googleApiKey;
        const needsGoogle = this._config.map === 'google' || this._config.geocode === 'google' || this._config.places === 'google';

        const initNonGooglePromise = Promise.resolve().then(() => {
            try {
                if (this._config.map === 'leaflet' && !this._leafletMapAdapterInstance) {
                    this._leafletMapAdapterInstance = new LeafletMapAdapter(this._config.routingUrl);
                    log.info("[GeoRuntime] LeafletMapAdapter instantiated.");
                }
                if (this._config.geocode === 'nominatim' && !this._nominatimGeocodingAdapterInstance) {
                    this._nominatimGeocodingAdapterInstance = new NominatimGeocodingAdapter(this._config.nominatimUrl, this._config.nominatimEmail);
                    log.info("[GeoRuntime] NominatimGeocodingAdapter instantiated.");
                }
                this._isNonGoogleInitialized = true;
            } catch(e) {
                log.error("[GeoRuntime] Failed to instantiate non-Google adapters:", e);
                this._isNonGoogleInitialized = false;
            }
        });

        if (needsGoogle && this._googleApiKey) {
            log.info("[GeoRuntime] Google provider configured and API Key provided. Loading Google Maps script...");
            this._initializationPromise = Promise.all([
                initNonGooglePromise,
                this._googleLoader.load(this._googleApiKey, this._googleLibs)
                    .then(google => {
                        this._googleInstance = google;
                        try {
                            if (this._config.map === 'google') this._googleMapAdapterInstance = new GoogleMapAdapter(this._googleInstance);
                            if (this._config.geocode === 'google') this._googleGeocodingAdapterInstance = new GoogleGeocodingAdapter(this._googleInstance);
                            if (this._config.places === 'google') this._googlePlacesAdapterInstance = new GooglePlacesAutocompleteAdapter(this._googleInstance);
                            this._isGoogleInitialized = true;
                            log.info("[GeoRuntime] Google Maps script loaded successfully. Relevant adapters created.");
                            return true;
                        } catch (adapterError) {
                            log.error("[GeoRuntime] Error creating Google adapters after script load:", adapterError);
                            this._isGoogleInitialized = false;
                            return false;
                        }
                    })
                    .catch(err => {
                        log.error("[GeoRuntime] Failed to load Google Maps script:", err.message);
                        this._googleInstance = null;
                        this._isGoogleInitialized = false;
                        return false;
                    })
            ]).then(() => this._isGoogleInitialized || this._isNonGoogleInitialized);
        } else {
            if (needsGoogle && !this._googleApiKey) {
                log.warn("[GeoRuntime] Google provider configured but no API Key provided. Google features unavailable.");
            }
            this._initializationPromise = initNonGooglePromise.then(() => this._isNonGoogleInitialized);
        }
        return this._initializationPromise;
    }

    mapAdapter() {
        const provider = this._config.map;
        if (provider === 'google') {
            if (!this._isGoogleInitialized || !this._googleMapAdapterInstance) {
                throw new Error("GeoRuntime: Google Maps not initialized or map adapter failed. Cannot get GoogleMapAdapter.");
            }
            return this._googleMapAdapterInstance;
        }
        if (provider === 'leaflet') {
            if (!this._leafletMapAdapterInstance) {
                throw new Error("GeoRuntime: Leaflet Map adapter not initialized.");
            }
            return this._leafletMapAdapterInstance;
        }
        throw new Error(`GeoRuntime: No map adapter configured or available for provider: ${provider}`);
    }

    geocodingAdapter() {
        const provider = this._config.geocode;
        if (provider === 'google') {
            if (!this._isGoogleInitialized || !this._googleGeocodingAdapterInstance) {
                throw new Error("GeoRuntime: Google Maps not initialized or geocoding adapter failed. Cannot get GoogleGeocodingAdapter.");
            }
            return this._googleGeocodingAdapterInstance;
        }
        if (provider === 'nominatim') {
            if (!this._nominatimGeocodingAdapterInstance) {
                throw new Error("GeoRuntime: Nominatim Geocoding adapter not initialized.");
            }
            return this._nominatimGeocodingAdapterInstance;
        }
        throw new Error(`GeoRuntime: No geocoding adapter configured or available for provider: ${provider}`);
    }

    placesAdapter() {
        const provider = this._config.places;
        if (provider === 'google') {
            if (!this._isGoogleInitialized || !this._googlePlacesAdapterInstance) {
                log.warn("GeoRuntime: Google Places requested but not initialized or adapter failed.");
                return null;
            }
            return this._googlePlacesAdapterInstance;
        }
        if (provider === 'none') {
            return null;
        }
        log.warn(`GeoRuntime: Places adapter requested for unsupported provider: ${provider}`);
        return null;
    }

    isGoogleReady() {
        return this._isGoogleInitialized;
    }

    isProviderReady(type = 'map' | 'geocode' | 'places', providerName = null) {
        if (!this._initializationPromise) return false;

        const targetProvider = (providerName || this._config[type]).toLowerCase();

        if(targetProvider === 'google') return this.isGoogleReady();
        if(targetProvider === 'leaflet' && type === 'map') return !!this._leafletMapAdapterInstance;
        if(targetProvider === 'nominatim' && type === 'geocode') return !!this._nominatimGeocodingAdapterInstance;
        if(targetProvider === 'none' && type === 'places') return true;

        log.warn(`[GeoRuntime] Readiness check for unknown or uninitialized provider type/name: ${type}/${targetProvider}`);
        return false;
    }
}

// Basic logger shim
const log = {
    info: (...args) => console.info(...args),
    warn: (...args) => console.warn(...args),
    error: (...args) => console.error(...args),
};

================================================================================
### PLIK: adapters/GoogleGeocodingAdapter.js
================================================================================

// FILE: src/adapters/GoogleGeocodingAdapter.js
// KEPT AS IS (from previous restore) - needed for optional Google usage
/**
 * ARCHITECTURE: GoogleGeocodingAdapter wraps the Maps JS Geocoder into a provider-agnostic API.
 * Provides address â†’ {lat, lon, normalizedFields}.
 */
export class GoogleGeocodingAdapter {
  constructor(googleObj) {
    if (!googleObj || !googleObj.maps) throw new Error("GoogleGeocodingAdapter: google maps object required.");
    this.google = googleObj;
    this.geocoder = new this.google.maps.Geocoder();
  }

  async geocodeAddress(address) {
    // ... (implementation kept from previous restore) ...
    if (!address || !address.street || !address.postalCode || !address.city) {
      console.warn("[GoogleGeocode] Geocode skipped: Missing required fields.");
      return null;
    }
    const line1 = address.houseNumber ? `${address.street} ${address.houseNumber}` : address.street;
    const country = address.country || "PL";
    const query = `${line1}, ${address.postalCode} ${address.city}, ${country}`;
    const request = { address: query, region: country };
    log.debug(`[GoogleGeocode] Geocoding query: ${query}`);

    try {
      const res = await this.geocoder.geocode(request);
      if (!res || !Array.isArray(res.results) || res.results.length === 0) {
        log.warn(`[GoogleGeocode] No results found for query: ${query}`);
        return null;
      }
      const best = res.results[0];
      const components = this._indexComponents(best.address_components || []);
      const lat = best.geometry?.location?.lat?.() ?? null;
      const lon = best.geometry?.location?.lng?.() ?? null;

      if (lat == null || lon == null) {
        log.warn(`[GoogleGeocode] Result for query '${query}' missing valid coordinates.`);
        return null;
      }
      const normalized = {
        street: components.route || address.street || null,
        houseNumber: components.street_number || address.houseNumber || null,
        postalCode: components.postal_code || address.postalCode || null,
        city: components.locality || components.postal_town || components.administrative_area_level_2 || address.city || null,
        country: components.country_code || country,
        latitude: lat,
        longitude: lon,
        _provider: 'Google',
        _displayName: best.formatted_address,
        _confidence: best.geometry?.location_type === 'ROOFTOP' ? 1.0 : (best.geometry?.location_type === 'RANGE_INTERPOLATED' ? 0.9 : 0.7),
        _locationType: best.geometry?.location_type
      };
      log.debug(`[GoogleGeocode] Geocode success for query '${query}'. Result: Lat=${normalized.latitude}, Lon=${normalized.longitude}, Type=${normalized._locationType}`);
      return normalized;

    } catch (error) {
      log.error(`[GoogleGeocode] Geocoding error for query '${query}': ${error.message}`, error);
      return null;
    }
  }

  _indexComponents(parts) {
    // ... (implementation kept from previous restore) ...
    const map = {};
    for (const c of parts) {
      for (const t of c.types) {
        if (t === "country") {
          map.country = c.long_name; map.country_code = c.short_name;
        } else if (t === "locality") { map.locality = c.long_name;
        } else if (t === "postal_town") { map.postal_town = c.long_name;
        } else if (t === "administrative_area_level_2") { map.administrative_area_level_2 = c.long_name;
        } else if (t === "administrative_area_level_1") { map.administrative_area_level_1 = c.long_name;
        } else if (t === "route") { map.route = c.long_name;
        } else if (t === "street_number") { map.street_number = c.long_name;
        } else if (t === "postal_code") { map.postal_code = c.long_name; }
      }
    }
    return map;
  }
}

const log = {
  debug: (...args) => console.debug(...args),
  info: (...args) => console.info(...args),
  warn: (...args) => console.warn(...args),
  error: (...args) => console.error(...args),
};

================================================================================
### PLIK: adapters/GoogleMapAdapter.js
================================================================================

// FILE: src/adapters/GoogleMapAdapter.js
// KEPT AS IS (from previous restore) - needed for optional Google usage
/**
 * ARCHITECTURE: GoogleMapAdapter provides a concrete map implementation for MapController using Google Maps JS API.
 * Encapsulates vendor-specific map calls behind a small, explicit interface.
 * Responsibilities: Create/destroy map, set center/zoom, manage a single primary marker.
 */
export class GoogleMapAdapter {
  constructor(googleObj) {
    if (!googleObj || !googleObj.maps) throw new Error("GoogleMapAdapter: google maps object required.");
    this.google = googleObj;
    this._map = null;
    this._marker = null;
  }

  async create(container, options) {
    if (!container) throw new Error("GoogleMapAdapter.create: container is required.");
    const center = { lat: options?.lat ?? 52.2297, lng: options?.lon ?? 21.0122 };
    const zoom = options?.zoom ?? 12;
    this._map = new this.google.maps.Map(container, { center, zoom, mapTypeControl: false, streetViewControl: false });
    if (this.google.maps.marker?.AdvancedMarkerElement) {
      this._marker = new this.google.maps.marker.AdvancedMarkerElement({ position: center, map: this._map, gmpDraggable: false });
    } else {
      this._marker = new this.google.maps.Marker({ position: center, map: this._map });
    }
    return true;
  }

  async setCenter(lat, lon, zoom) {
    if (!this._map) throw new Error("GoogleMapAdapter.setCenter: map not created.");
    const center = { lat, lng: lon };
    this._map.setCenter(center);
    if (typeof zoom === "number") this._map.setZoom(zoom);
    return true;
  }

  async setMarker(lat, lon) {
    if (!this._map || !this._marker) throw new Error("GoogleMapAdapter.setMarker: map not created.");
    const pos = { lat, lng: lon };
    if (typeof this._marker. G === 'function') { // Legacy Marker
      this._marker.setPosition(pos);
    } else if (this._marker.position) { // AdvancedMarkerElement
      this._marker.position = pos;
    }
    return true;
  }

  async fit(lat, lon) {
    if (!this._map) throw new Error("GoogleMapAdapter.fit: map not created.");
    const bounds = new this.google.maps.LatLngBounds();
    bounds.extend(new this.google.maps.LatLng(lat, lon));
    this._map.fitBounds(bounds, 64);
    return true;
  }

  async destroy() {
    if (this._marker) {
      this._marker.map = null;
      if (typeof this._marker.setMap === 'function') { this._marker.setMap(null); }
      this._marker = null;
    }
    if (this._map) {
      this._map = null;
    }
    return true;
  }
}

================================================================================
### PLIK: adapters/GoogleMapsScriptLoader.js
================================================================================

// FILE: src/adapters/GoogleMapsScriptLoader.js
// KEPT AS IS (from previous restore) - needed for optional Google usage
/**
 * ARCHITECTURE: GoogleMapsScriptLoader ensures exactly-once loading of the Google Maps JS API.
 * Uses a static promise to prevent multiple script injections across the application.
 */
export class GoogleMapsScriptLoader {
  static _promise = null;
  static _loadedKey = null;
  static _loadedLibsKey = null;

  load(apiKey, libraries = []) {
    // ... (implementation kept from previous restore) ...
    if (!apiKey || typeof apiKey !== "string") { return Promise.reject(new Error("GoogleMapsScriptLoader: missing apiKey.")); }
    const libs = Array.isArray(libraries) ? libraries.slice().sort() : [];
    const libsKey = libs.join(",");
    if (GoogleMapsScriptLoader._promise && GoogleMapsScriptLoader._loadedKey === apiKey && GoogleMapsScriptLoader._loadedLibsKey === libsKey) { return GoogleMapsScriptLoader._promise; }
    if (typeof window !== "undefined" && window.google && window.google.maps) {
      if (GoogleMapsScriptLoader._promise && (GoogleMapsScriptLoader._loadedKey !== apiKey || GoogleMapsScriptLoader._loadedLibsKey !== libsKey)) { console.warn("GoogleMapsScriptLoader: Google Maps already loaded, potentially with different settings."); }
      GoogleMapsScriptLoader._promise = Promise.resolve(window.google);
      GoogleMapsScriptLoader._loadedKey = apiKey; GoogleMapsScriptLoader._loadedLibsKey = libsKey;
      return GoogleMapsScriptLoader._promise;
    }
    const src = new URL("https://maps.googleapis.com/maps/api/js");
    src.searchParams.set("key", apiKey);
    if (libs.length) src.searchParams.set("libraries", libsKey);
    src.searchParams.set("v", "weekly"); src.searchParams.set("loading", "async");
    const callbackName = `__googleMapsApiOnLoadCallback_${Date.now()}`;
    GoogleMapsScriptLoader._promise = new Promise((resolve, reject) => {
      window[callbackName] = () => {
        if (window.google && window.google.maps) {
          console.log("Google Maps API script loaded successfully via callback.");
          GoogleMapsScriptLoader._loadedKey = apiKey; GoogleMapsScriptLoader._loadedLibsKey = libsKey;
          resolve(window.google);
        } else {
          console.error("Google Maps callback executed, but window.google.maps is still undefined.");
          reject(new Error("Google Maps script loaded but window.google.maps is undefined."));
        }
        delete window[callbackName];
      };
      const scriptElement = document.createElement("script");
      scriptElement.src = `${src.toString()}&callback=${callbackName}`;
      scriptElement.async = true; scriptElement.defer = true;
      scriptElement.onerror = (err) => {
        console.error("Google Maps script failed to load.", err);
        GoogleMapsScriptLoader._promise = null; GoogleMapsScriptLoader._loadedKey = null; GoogleMapsScriptLoader._loadedLibsKey = null;
        reject(new Error("Google Maps script failed to load. Check API Key, network, and browser console."));
        delete window[callbackName];
      };
      document.head.appendChild(scriptElement);
    });
    GoogleMapsScriptLoader._loadedKey = apiKey; GoogleMapsScriptLoader._loadedLibsKey = libsKey;
    return GoogleMapsScriptLoader._promise;
  }
}

================================================================================
### PLIK: adapters/GooglePlacesAutocompleteAdapter.js
================================================================================

// FILE: src/adapters/GooglePlacesAutocompleteAdapter.js
// KEPT AS IS (from previous restore) - needed for optional Google usage
import { GooglePlacesSessionManager } from "@/adapters/GooglePlacesSessionManager";

/**
 * ARCHITECTURE: GooglePlacesAutocompleteAdapter wraps Places Autocomplete for type-ahead hints.
 * Isolates vendor API calls and returns normalized suggestion DTOs.
 */
export class GooglePlacesAutocompleteAdapter {
  constructor(googleObj) {
    if (!googleObj || !googleObj.maps || !googleObj.maps.places) {
      throw new Error("GooglePlacesAutocompleteAdapter: google maps places library required.");
    }
    this.google = googleObj;
    this.service = new this.google.maps.places.AutocompleteService();
    const mapDiv = (typeof document !== 'undefined') ? document.createElement("div") : null;
    this.detailsService = mapDiv ? new this.google.maps.places.PlacesService(mapDiv) : null;
    this.sessionManager = new GooglePlacesSessionManager(this.google);
  }

  async suggest(text, country = "PL") {
    // ... (implementation kept from previous restore) ...
    if (!this.service || !text || !text.trim()) return [];
    log.debug(`[GooglePlaces] Suggesting for: "${text}"`);
    const sessionToken = this.sessionManager.getToken();
    if (!sessionToken) {
      log.warn("[GooglePlaces] No session token available for suggestion.");
      this.sessionManager.renew();
      return [];
    }
    try {
      const predictions = await this._getPredictions(text, country, sessionToken);
      const predictionItems = Array.isArray(predictions) ? predictions.slice(0, 5) : [];
      const detailPromises = predictionItems.map(p => this._getDetails(p.place_id, sessionToken));
      const detailedResults = await Promise.all(detailPromises);
      const enriched = detailedResults
          .filter(d => d !== null)
          .map(d => this._mapDetailsToSuggestion(d));
      if (enriched.length > 0) {
        this.sessionManager.renew();
        log.debug(`[GooglePlaces] Session token renewed after fetching ${enriched.length} details.`);
      }
      return enriched;
    } catch (error) {
      log.error(`[GooglePlaces] Suggestion error for "${text}": ${error.message}`, error);
      return [];
    }
  }

  _getPredictions(input, country, sessionToken) {
    // ... (implementation kept from previous restore) ...
    return new Promise((resolve, reject) => {
      if (!this.service) return reject(new Error("Places AutocompleteService not initialized."));
      this.service.getPlacePredictions(
          { input, sessionToken, componentRestrictions: { country }, types: ['address'] },
          (predictions, status) => {
            if (status === this.google.maps.places.PlacesServiceStatus.OK) { resolve(predictions || []); }
            else if (status === this.google.maps.places.PlacesServiceStatus.ZERO_RESULTS) { resolve([]); }
            else {
              log.warn(`[GooglePlaces] getPlacePredictions failed with status: ${status}`);
              reject(new Error(`Places Autocomplete prediction failed: ${status}`));
            }
          }
      );
    });
  }

  _getDetails(placeId, sessionToken) {
    // ... (implementation kept from previous restore) ...
    return new Promise((resolve) => {
      if (!this.detailsService) { log.error("[GooglePlaces] PlacesService for details not initialized."); return resolve(null); }
      if (!placeId) return resolve(null);
      this.detailsService.getDetails(
          { placeId, sessionToken, fields: ["address_components", "geometry.location", "formatted_address"] },
          (place, status) => {
            if (status === this.google.maps.places.PlacesServiceStatus.OK && place) { resolve(place); }
            else { log.warn(`[GooglePlaces] getDetails failed for placeId ${placeId} with status: ${status}`); resolve(null); }
          }
      );
    });
  }

  _mapDetailsToSuggestion(place) {
    // ... (implementation kept from previous restore) ...
    if (!place) return null;
    const comps = this._indexComponents(place.address_components || []);
    const lat = place.geometry?.location?.lat?.() ?? null;
    const lon = place.geometry?.location?.lng?.() ?? null;
    return {
      fullAddressLabel: place.formatted_address || null,
      street: comps.route || null, houseNumber: comps.street_number || null,
      postalCode: comps.postal_code || null, city: comps.locality || comps.postal_town || comps.administrative_area_level_2 || null,
      countryCode: comps.country_code || null, countryName: comps.country || null,
      latitude: lat, longitude: lon,
      matchScore: 0.9, matchLevel: "PLACES_DETAIL", providerSource: "GOOGLE_PLACES",
    };
  }

  _indexComponents(parts) {
    // ... (implementation kept from previous restore) ...
    const map = {};
    for (const c of parts) {
      for (const t of c.types) {
        if (t === "country") { map.country = c.long_name; map.country_code = c.short_name; }
        else if (t === "locality") { map.locality = c.long_name; }
        else if (t === "postal_town") { map.postal_town = c.long_name; }
        else if (t === "administrative_area_level_2") { map.administrative_area_level_2 = c.long_name; }
        else if (t === "route") { map.route = c.long_name; }
        else if (t === "street_number") { map.street_number = c.long_name; }
        else if (t === "postal_code") { map.postal_code = c.long_name; }
      }
    }
    return map;
  }
}

const log = {
  debug: (...args) => console.debug(...args),
  warn: (...args) => console.warn(...args),
  error: (...args) => console.error(...args),
};

================================================================================
### PLIK: adapters/GooglePlacesSessionManager.js
================================================================================

/**
 * ARCHITECTURE: GooglePlacesSessionManager encapsulates the creation, retrieval,
 * and renewal of Google Places AutocompleteSessionToken objects.
 * This is crucial for managing billing correctly with the Places API.
 * This is a stub implementation as the 'google' object is not available here directly.
 */
export class GooglePlacesSessionManager {
    constructor(googleMapsInstance) {
        if (!googleMapsInstance || !googleMapsInstance.maps || !googleMapsInstance.maps.places) {
            console.warn("[GooglePlacesSessionManager] Google Maps Places library not found. Session management will be non-functional.");
            this._googlePlaces = null;
        } else {
            this._googlePlaces = googleMapsInstance.maps.places;
        }
        this._token = null;
        this._renewToken(); // Initialize first token
    }

    /**
     * Retrieves the current session token.
     * @returns {google.maps.places.AutocompleteSessionToken | null} The current token.
     */
    getToken() {
        if (!this._token) {
            // Attempt to create one if it was missed, though it should be initialized.
            this._renewToken();
        }
        return this._token;
    }

    /**
     * Renews the session token. This should be called after a successful
     * 'getDetails' call, invalidating the previous token.
     */
    renew() {
        this._renewToken();
    }

    /**
     * Internal helper to create a new token.
     */
    _renewToken() {
        if (this._googlePlaces) {
            try {
                this._token = new this._googlePlaces.AutocompleteSessionToken();
            } catch (e) {
                console.error("[GooglePlacesSessionManager] Failed to create new AutocompleteSessionToken:", e);
                this._token = null;
            }
        } else {
            this._token = null;
        }
    }
}

================================================================================
### PLIK: adapters/GoogleRuntime.js
================================================================================

// FILE: src/adapters/GoogleRuntime.js
import { GoogleMapsScriptLoader } from "@/adapters/GoogleMapsScriptLoader";
import { GoogleMapAdapter } from "@/adapters/GoogleMapAdapter";
import { GoogleGeocodingAdapter } from "@/adapters/GoogleGeocodingAdapter";
import { GooglePlacesAutocompleteAdapter } from "@/adapters/GooglePlacesAutocompleteAdapter";

export class GoogleRuntime {
  constructor() {
    // Use the static loader instance
    this._loader = new GoogleMapsScriptLoader();
    this._google = null;
  }

  async init(apiKey, libraries = ["places", "geocoding"]) {
    // Check static property on the loader class
    if (GoogleMapsScriptLoader._promise) {
      this._google = await GoogleMapsScriptLoader._promise;
      return this._google;
    }
    // Call the instance method if not already loading/loaded
    this._google = await this._loader.load(apiKey, libraries);
    return this._google;
  }

  mapAdapter() {
    if (!this._google) throw new Error("GoogleRuntime: not initialized.");
    return new GoogleMapAdapter(this._google);
  }

  geocodingAdapter() {
    if (!this._google) throw new Error("GoogleRuntime: not initialized.");
    return new GoogleGeocodingAdapter(this._google);
  }

  placesAdapter() {
    if (!this._google) throw new Error("GoogleRuntime: not initialized.");
    return new GooglePlacesAutocompleteAdapter(this._google);
  }
}

================================================================================
### PLIK: adapters/LeafletMapAdapter.js
================================================================================

// FILE: src/adapters/LeafletMapAdapter.js
// MODIFIED - Added multiple markers, routing, and proper config
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import iconRetinaUrl from 'leaflet/dist/images/marker-icon-2x.png';
import iconUrl from 'leaflet/dist/images/marker-icon.png';
import shadowUrl from 'leaflet/dist/images/marker-shadow.png';

// --- Create custom Green and Red icons ---
const greenIcon = new L.Icon({
    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    shadowSize: [41, 41]
});

const redIcon = new L.Icon({
    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    shadowSize: [41, 41]
});
// --- End custom icons ---

/**
 * ARCHITECTURE: LeafletMapAdapter provides a map implementation using Leaflet JS.
 * REFACTORED: Now supports distinct pickup/delivery markers and OSRM routing.
 */
export class LeafletMapAdapter {
    constructor(osrmRoutingUrl = null) {
        this._map = null;
        this._pickupMarker = null;
        this._deliveryMarker = null;
        this._routeLine = null;
        this._osrmRoutingUrl = osrmRoutingUrl; // URL for OSRM service
        this._defaultCenter = { lat: 52.2297, lon: 21.0122 }; // Warsaw
        this._defaultZoom = 6;
    }

    async create(container, options) {
        if (!container) throw new Error("LeafletMapAdapter.create: container is required.");
        if (this._map) {
            await this.destroy();
        }
        const center = L.latLng(options?.lat ?? this._defaultCenter.lat, options?.lon ?? this._defaultCenter.lon);
        const zoom = options?.zoom ?? this._defaultZoom;
        const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        });
        this._map = L.map(container, { center, zoom, layers: [osmLayer], zoomControl: true });

        // Initialize markers (hidden at first)
        this._pickupMarker = L.marker(center, { icon: greenIcon, opacity: 0 });
        this._deliveryMarker = L.marker(center, { icon: redIcon, opacity: 0 });
        this._pickupMarker.addTo(this._map);
        this._deliveryMarker.addTo(this._map);

        setTimeout(() => this._map?.invalidateSize(), 100);
        return true;
    }

    async setCenter(lat, lon, zoom) {
        if (!this._map) throw new Error("LeafletMapAdapter.setCenter: map not created.");
        const center = L.latLng(lat, lon);
        const newZoom = (typeof zoom === "number")? zoom : this._map.getZoom();
        this._map.setView(center, newZoom);
        return true;
    }

    // --- NEW MARKER METHODS ---
    async setMarker(lat, lon) {
        // Legacy method, just moves the pickup marker
        return this.setPickupMarker(lat, lon);
    }

    async setPickupMarker(lat, lon, zoomTo = false) {
        if (!this._map || !this._pickupMarker) throw new Error("LeafletMapAdapter.setPickupMarker: map/marker not created.");
        const pos = L.latLng(lat, lon);
        this._pickupMarker.setLatLng(pos).setOpacity(1); // Make visible
        if(zoomTo) this._map.setView(pos, 15);
        return true;
    }

    async setDeliveryMarker(lat, lon, zoomTo = false) {
        if (!this._map || !this._deliveryMarker) throw new Error("LeafletMapAdapter.setDeliveryMarker: map/marker not created.");
        const pos = L.latLng(lat, lon);
        this._deliveryMarker.setLatLng(pos).setOpacity(1); // Make visible
        if(zoomTo) this._map.setView(pos, 15);
        return true;
    }
    // --- END NEW MARKER METHODS ---

    async fitBounds(pickupPos, deliveryPos) {
        if (!this._map) return false;
        if (!pickupPos || !deliveryPos) return false;

        const pLatLon = L.latLng(pickupPos.lat, pickupPos.lon);
        const dLatLon = L.latLng(deliveryPos.lat, deliveryPos.lon);

        this._map.fitBounds(L.latLngBounds([pLatLon, dLatLon]), { padding: [50, 50] }); // Add 50px padding
        return true;
    }

    async drawRoute(pickupPos, deliveryPos) {
        if (!this._osrmRoutingUrl) {
            console.warn("MapAdapter: OSRM routing URL not configured. Skipping route line.");
            return false;
        }
        if (!this._map) return false;
        if (!pickupPos || !deliveryPos) return false;

        // Clear existing route
        if (this._routeLine) {
            this._routeLine.remove();
            this._routeLine = null;
        }

        // OSRM expects {lon},{lat};{lon},{lat}
        const coords = `${pickupPos.lon},${pickupPos.lat};${deliveryPos.lon},${deliveryPos.lat}`;
        const url = `${this._osrmRoutingUrl}/route/v1/driving/${coords}?overview=full&geometries=polyline`;

        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`OSRM responded with ${response.status}`);
            const data = await response.json();

            if (data.routes && data.routes[0] && data.routes[0].geometry) {
                // Need to decode polyline. Using a simple decoder.
                const geometry = data.routes[0].geometry;
                const latlngs = this.decodePolyline(geometry); // Implement decoder

                this._routeLine = L.polyline(latlngs, { color: 'var(--color-primary)', weight: 3, opacity: 0.7 }).addTo(this._map);
                return true;
            }
        } catch (e) {
            console.error("LeafletMapAdapter: Failed to fetch route from OSRM:", e);
        }
        return false;
    }

    // Polyline decoder (common algorithm)
    decodePolyline(str, precision = 5) {
        let index = 0, lat = 0, lng = 0, coordinates = [],
            shift = 0, result = 0,
            byte = null, latitude_change, longitude_change,
            factor = Math.pow(10, precision);

        while (index < str.length) {
            byte = null; shift = 0; result = 0;
            do {
                byte = str.charCodeAt(index++) - 63;
                result |= (byte & 0x1f) << shift;
                shift += 5;
            } while (byte >= 0x20);
            latitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));
            shift = result = 0;
            do {
                byte = str.charCodeAt(index++) - 63;
                result |= (byte & 0x1f) << shift;
                shift += 5;
            } while (byte >= 0x20);
            longitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));
            lat += latitude_change;
            lng += longitude_change;
            coordinates.push([lat / factor, lng / factor]);
        }
        return coordinates;
    }

    async destroy() {
        if (this._pickupMarker) this._pickupMarker.remove();
        if (this._deliveryMarker) this._deliveryMarker.remove();
        if (this._routeLine) this._routeLine.remove();
        if (this._map) this._map.remove();

        this._map = null;
        this._pickupMarker = null;
        this._deliveryMarker = null;
        this._routeLine = null;
        return true;
    }
}

================================================================================
### PLIK: adapters/MapGeocoderAdapter.js
================================================================================

/**
 * ARCHITECTURE: MapGeocoderAdapter abstracts a geocoding function behind a stable contract.
 * It follows the manifesto by isolating vendor-specific logic and exposing a single responsibility.
 * Responsibilities:
 * - Accept an Address-like DTO and delegate to an injected geocode function.
 * - Return a normalized { lat, lon } object or null without leaking provider details.
 */
export class MapGeocoderAdapter {
  constructor(geocodeFn) {
    if (typeof geocodeFn !== "function") throw new Error("MapGeocoderAdapter: geocode function required.");
    this.geocodeFn = geocodeFn;
  }

  async geocodeAddress(address) {
    if (!address || typeof address !== "object") return null;
    const r = await this.geocodeFn({
      street: address.street,
      houseNumber: address.houseNumber ?? null,
      postalCode: address.postalCode,
      city: address.city,
      country: address.country || "PL",
    });
    if (!r || typeof r.lat !== "number" || typeof r.lon !== "number") return null;
    return { lat: r.lat, lon: r.lon };
  }
}


================================================================================
### PLIK: adapters/NominatimGeocodingAdapter.js
================================================================================

// FILE: src/adapters/NominatimGeocodingAdapter.js
import { AddressNormalizer } from '@/services/AddressNormalizer';
/**
 * ARCHITECTURE: NominatimGeocodingAdapter wraps OpenStreetMap Nominatim API for geocoding.
 * Provides address -> {lat, lon, normalizedFields} via fetch.
 * Adheres to geocoding adapter interface.
 *
 * REFACTORED: Constructor is now null-safe and applies defaults internally
 * if 'nominatimUrl' or 'email' are passed as null/undefined from GeoRuntime.
 */
export class NominatimGeocodingAdapter {
    constructor(nominatimUrl, email) {
        // *** FIX: Apply defaults internally to handle null/undefined inputs ***
        const effectiveUrl = nominatimUrl || 'http://10.105.0.188:5001'; // *** UPDATED DEFAULT ***
        const effectiveEmail = email || 'YOUR_APP_EMAIL_FOR_POLICY@example.com';
        // *** END FIX ***

        this.baseUrl = effectiveUrl.replace(/\/+$/, "");
        this.email = effectiveEmail;
        this.normalizer = new AddressNormalizer();
        this.fetchOptions = {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
                'User-Agent': `DanxilsTriageApp/1.0 (${this.email})`,
            },
        };
    }

    async geocodeAddress(address) {
        if (!address || !address.street || !address.postalCode || !address.city) {
            console.warn("[Nominatim] Geocode skipped: Missing required fields (street, postalCode, city).");
            return null;
        }

        const params = new URLSearchParams({
            street: `${address.houseNumber || ''} ${address.street || ''}`.trim(),
            city: address.city || '',
            postalcode: address.postalCode || '',
            country: address.country || 'PL',
            format: 'jsonv2',
            addressdetails: '1',
            limit: '1',
            email: this.email,
        });
        const url = `${this.baseUrl}/search?${params.toString()}`;
        const queryDesc = `${params.get('street')}, ${params.get('postalcode')} ${params.get('city')}`;
        log.debug(`[Nominatim] Geocoding query: ${queryDesc}`);
        try {
            const response = await fetch(url, this.fetchOptions);
            if (!response.ok) {
                const errorBody = await response.text();
                log.error(`[Nominatim] API error ${response.status} for query '${queryDesc}'. Body: ${errorBody}`);
                throw new Error(`Nominatim API error ${response.status}`);
            }
            const results = await response.json();
            if (!Array.isArray(results) || results.length === 0) {
                log.warn(`[Nominatim] No results found for query: ${queryDesc}`);
                return null;
            }
            const best = results[0];
            const components = best.address || {};
            const lat = best.lat ? parseFloat(best.lat) : null;
            const lon = best.lon ?
                parseFloat(best.lon) : null;

            if (lat == null || lon == null || isNaN(lat) || isNaN(lon)) {
                log.warn(`[Nominatim] Result for query '${queryDesc}' missing valid coordinates. Lat: ${best.lat}, Lon: ${best.lon}`);
                return null;
            }

            const normalized = {
                street: components.road ||
                    address.street || null,
                houseNumber: components.house_number ||
                    address.houseNumber || null,
                postalCode: components.postcode ||
                    address.postalCode || null,
                city: components.city ||
                    components.town || components.village || address.city || null,
                country: (components.country_code || address.country || 'pl').toUpperCase(),
                latitude: lat,
                longitude: lon,
                _provider: 'Nominatim',
                _displayName: best.display_name,
                _osmType: best.osm_type,
                _osmId: best.osm_id,
                _confidence: best.importance ?
                    parseFloat(best.importance) : null,
            };
            log.debug(`[Nominatim] Geocode success for query '${queryDesc}'. Result: Lat=${normalized.latitude}, Lon=${normalized.longitude}`);
            return normalized;
        } catch (error) {
            log.error(`[Nominatim] Network or processing error during geocode for query '${queryDesc}': ${error.message}`, error);
            return null;
        }
    }
}

const log = {
    debug: (...args) => console.debug(...args),
    info: (...args) => console.info(...args),
    warn: (...args) => console.warn(...args),
    error: (...args) => console.error(...args),
};

================================================================================
### PLIK: controllers/AddressFormController.js
================================================================================

/**
 * ARCHITECTURE: AddressFormController coordinates field masking, editability rules, guard checks, and realtime verification.
 * It follows the manifesto by isolating input lifecycle from components and wiring existing services behind one API.
 * Responsibilities:
 * - Apply masks on change, consult AddressFieldGuard for editability, and gate verification with VerificationGuardController.
 * - Invoke RealtimeVerificationOrchestrator and MapViewportPolicyController to produce instant geocode + ranked hints.
 * - Expose a stable snapshot with input, validation, instant, suggestions, and busy flags for the view.
 *
 * REFACTORED: Constructor aligned with RealtimeVerificationOrchestrator dependencies.
 * This class requires (geoRuntime, geocodeWithCacheController, mapController) to be injected.
 */
import { AddressInputMaskService } from "@/services/AddressInputMaskService";
import { AddressFieldGuard } from "@/services/AddressFieldGuard";
import { VerificationGuardController } from "@/controllers/VerificationGuardController";
import { RealtimeVerificationOrchestrator } from "@/controllers/RealtimeVerificationOrchestrator";
import { MapViewportPolicyController } from "@/controllers/MapViewportPolicyController";
import { ValidationService } from "@/services/ValidationService";
import { AddressNormalizer } from "@/services/AddressNormalizer";

export class AddressFormController {
  constructor(
      geoRuntime, // *** Injected GeoRuntime ***
      geocodeWithCacheController, // Geocode controller (uses Nominatim/Google adapter)
      mapController // Map controller (uses Leaflet/Google adapter)
  ) {
    if (!geoRuntime || !geocodeWithCacheController || !mapController) {
      const missing = [!geoRuntime && "geoRuntime", !geocodeWithCacheController && "geocodeWithCacheController", !mapController && "mapController"].filter(Boolean).join(', ');
      log.error(`[AddressFormController] CRITICAL: Missing required dependencies in constructor: ${missing}.`);
      // This controller is often instantiated by a view; throwing might be too harsh.
    }

    this.mask = new AddressInputMaskService("PL");
    this.guard = new AddressFieldGuard();
    this.verifyGuard = new VerificationGuardController();

    // *** FIX: Instantiate orchestrator with correct (geoRuntime, geocodeController, debounce) ***
    this.realtime = new RealtimeVerificationOrchestrator(
        geoRuntime,
        geocodeWithCacheController,
        300 // Debounce time
    );
    this.viewport = new MapViewportPolicyController(mapController);
    this.validator = new ValidationService("PL");
    this.normalizer = new AddressNormalizer();
    this.input = { street: "", houseNumber: "", postalCode: "", city: "", country: "PL" };
    this.validation = { valid: false, errors: {} };
    this.instant = null;
    this.suggestions = [];
    this.loading = false;
    this.error = null;
  }

  setField(field, value) {
    if (!this.guard.canEdit(field, { country: this.input.country })) return this.snapshot();

    // Apply masks (implementation is currently stubbed)
    if (field === "postalCode") this.input.postalCode = this.mask.maskPostal(value, this.input.country);
    else if (field === "street") this.input.street = this.mask.maskStreet(value);
    else if (field === "city") this.input.city = this.mask.maskCity(value);
    else if (field === "houseNumber") this.input.houseNumber = this.mask.maskHouseNo(value);
    else if (field === "country") this.input.country = String(value || "PL").toUpperCase();
    else this.input[field] = value; // Handle other fields directly

    // Trigger verification after field update (will be debounced by orchestrator)
    this.verifyIfReady(); // No await needed, runs async

    return this.snapshot(); // Return current state immediately
  }

  async verifyIfReady() {
    // Check if enough fields are present to trigger verification
    const gate = this.verifyGuard.shouldVerify(this.input);
    const currentNormalized = this.normalizer.normalize(this.input); // Normalize for validation
    this.validation = this.validator.validate(currentNormalized); // Update validation state regardless

    if (!gate.allow) {
      log.debug("[AddressForm] Verification skipped:", gate.reason, gate.missing);
      this.loading = false;
      this.error = null;
      this.instant = null; // Clear previous results if input becomes invalid
      this.suggestions = [];
      return this.snapshot(); // Return updated validation state
    }

    // Input is sufficient, trigger debounced verification
    this.loading = true;
    this.error = null;
    try {
      const res = await this.realtime.verify(this.input); // Await the debounced result
      this.instant = res.instant || null;
      this.suggestions = Array.isArray(res.suggestions) ? res.suggestions : [];

      // Focus map on the instant result if available
      if (this.instant && this.instant.latitude != null && this.instant.longitude != null && this.viewport) {
        await this.viewport.focusInstant({ ...this.instant, matchLevel: "GEOCODER" });
      }
    } catch (err) {
      log.error("[AddressForm] Realtime verification failed:", err);
      this.error = "Verification failed.";
      this.instant = null;
      this.suggestions = [];
    } finally {
      this.loading = false;
    }

    return this.snapshot();
  }

  snapshot() {
    return {
      input: { ...this.input },
      validation: { ...this.validation },
      instant: this.instant ? { ...this.instant } : null,
      suggestions: this.suggestions.slice(),
      loading: this.loading,
      error: this.error,
    };
  }
}

// Basic logger shim
const log = {
  debug: (...args) => console.debug(...args),
  warn: (...args) => console.warn(...args),
  error: (...args) => console.error(...args),
};


================================================================================
### PLIK: controllers/AddressVerificationController.js
================================================================================

/**
 * ARCHITECTURE: Coordinates address form field interactions and triggers realtime verification.
 * REFACTORED: Constructor aligned with RealtimeVerificationOrchestrator dependencies.
 * This class requires (geoRuntime, geocodeWithCacheController, mapController) to be injected.
 * NOTE: This file appears to be a duplicate of AddressFormController.js and exports
 * the same class name. Both files have been corrected to the same implementation.
 */
import { AddressInputMaskService } from "@/services/AddressInputMaskService";
import { AddressFieldGuard } from "@/services/AddressFieldGuard";
import { VerificationGuardController } from "@/controllers/VerificationGuardController";
import { RealtimeVerificationOrchestrator } from "@/controllers/RealtimeVerificationOrchestrator";
import { MapViewportPolicyController } from "@/controllers/MapViewportPolicyController";
import { ValidationService } from "@/services/ValidationService";
import { AddressNormalizer } from "@/services/AddressNormalizer";

export class AddressFormController {
    constructor(
        geoRuntime, // *** Injected GeoRuntime ***
        geocodeWithCacheController, // Geocode controller (uses Nominatim/Google adapter)
        mapController // Map controller (uses Leaflet/Google adapter)
    ) {
        if (!geoRuntime || !geocodeWithCacheController || !mapController) {
            const missing = [!geoRuntime && "geoRuntime", !geocodeWithCacheController && "geocodeWithCacheController", !mapController && "mapController"].filter(Boolean).join(', ');
            log.error(`[AddressFormController-Verification] CRITICAL: Missing required dependencies in constructor: ${missing}.`);
            // This controller is often instantiated by a view; throwing might be too harsh.
        }

        this.mask = new AddressInputMaskService("PL");
        this.guard = new AddressFieldGuard();
        this.verifyGuard = new VerificationGuardController();

        // *** FIX: Instantiate orchestrator with correct (geoRuntime, geocodeController, debounce) ***
        this.realtime = new RealtimeVerificationOrchestrator(
            geoRuntime,
            geocodeWithCacheController,
            300 // Debounce time
        );
        this.viewport = new MapViewportPolicyController(mapController);
        this.validator = new ValidationService("PL");
        this.normalizer = new AddressNormalizer();
        this.input = { street: "", houseNumber: "", postalCode: "", city: "", country: "PL" };
        this.validation = { valid: false, errors: {} };
        this.instant = null;
        this.suggestions = [];
        this.loading = false;
        this.error = null;
    }

    setField(field, value) {
        if (!this.guard.canEdit(field, { country: this.input.country })) return this.snapshot();

        if (field === "postalCode") this.input.postalCode = this.mask.maskPostal(value, this.input.country);
        else if (field === "street") this.input.street = this.mask.maskStreet(value);
        else if (field === "city") this.input.city = this.mask.maskCity(value);
        else if (field === "houseNumber") this.input.houseNumber = this.mask.maskHouseNo(value);
        else if (field === "country") this.input.country = String(value || "PL").toUpperCase();
        else this.input[field] = value;

        this.verifyIfReady(); // No await needed, runs async
        return this.snapshot(); // Return current state immediately
    }

    async verifyIfReady() {
        const gate = this.verifyGuard.shouldVerify(this.input);
        const currentNormalized = this.normalizer.normalize(this.input);
        this.validation = this.validator.validate(currentNormalized);

        if (!gate.allow) {
            log.debug("[AddressForm-Verification] Verification skipped:", gate.reason, gate.missing);
            this.loading = false;
            this.error = null;
            this.instant = null;
            this.suggestions = [];
            return this.snapshot();
        }

        this.loading = true;
        this.error = null;
        try {
            const res = await this.realtime.verify(this.input);
            this.instant = res.instant || null;
            this.suggestions = Array.isArray(res.suggestions) ? res.suggestions : [];

            if (this.instant && this.instant.latitude != null && this.instant.longitude != null && this.viewport) {
                await this.viewport.focusInstant({ ...this.instant, matchLevel: "GEOCODER" });
            }
        } catch (err) {
            log.error("[AddressForm-Verification] Realtime verification failed:", err);
            this.error = "Verification failed.";
            this.instant = null;
            this.suggestions = [];
        } finally {
            this.loading = false;
        }

        return this.snapshot();
    }

    snapshot() {
        return {
            input: { ...this.input },
            validation: { ...this.validation },
            instant: this.instant ? { ...this.instant } : null,
            suggestions: this.suggestions.slice(),
            loading: this.loading,
            error: this.error,
        };
    }
}

// Basic logger shim
const log = {
    debug: (...args) => console.debug(...args),
    warn: (...args) => console.warn(...args),
    error: (...args) => console.error(...args),
};


================================================================================
### PLIK: controllers/AddressVerificationFacade.js
================================================================================

/**
 * ARCHITECTURE: AddressVerificationFacade provides a minimal API to run Google-first verification end-to-end.
 * It follows the manifesto by composing workflow, merger, ranker, and TES suggestions behind a single call.
 * Responsibilities:
 * - Accept an Address-like DTO; return {normalized, validation, instant, suggestions} ready for the editor.
 * - Optionally enrich with TES suggestions and merge/rank them alongside Google-derived candidates.
 */
import { AddressVerificationWorkflow } from "@/controllers/AddressVerificationWorkflow";
import { TesSuggestionController } from "@/controllers/TesSuggestionController";
import { AddressSuggestionMerger } from "@/services/AddressSuggestionMerger";
import { AddressSuggestionRanker } from "@/services/AddressSuggestionRanker";

export class AddressVerificationFacade {
  constructor(googleApiKey, tes = new TesSuggestionController(), merger = new AddressSuggestionMerger(), ranker = new AddressSuggestionRanker()) {
    this.workflow = new AddressVerificationWorkflow(googleApiKey);
    this.tes = tes;
    this.merger = merger;
    this.ranker = ranker;
  }

  async verify(address) {
    const base = await this.workflow.verify(address);
    if (!base.success) return base;
    const tes = await this.tes.suggestOnDemand(base.normalized, base.normalized);
    const merged = this.merger.merge(base.normalized, [base.suggestions, tes]);
    const ranked = this.ranker.rank(base.normalized, merged);
    return { ...base, suggestions: ranked };
  }
}


================================================================================
### PLIK: controllers/AddressVerificationWorkflow.js
================================================================================

/**
 * ARCHITECTURE: AddressVerificationWorkflow runs normalizeâ†’validateâ†’(optional)geocode to build a result model.
 * It follows the manifesto by keeping verification orchestration independent from UI and transport details.
 * Responsibilities:
 * - Normalize and validate input; if geocoder is injected, resolve coordinates as an "instant" candidate.
 * - Return {success, normalized, validation, instant, suggestions[]} without throwing on user errors.
 */
import { AddressNormalizer } from "@/services/AddressNormalizer";
import { ValidationService } from "@/services/ValidationService";

export class AddressVerificationWorkflow {
  constructor(googleApiKey = null, geocoderAdapter = null) {
    void googleApiKey;
    this.normalizer = new AddressNormalizer();
    this.validator = new ValidationService("PL");
    this.geocoder = geocoderAdapter || null;
  }

  async verify(address) {
    const normalized = this.normalizer.normalize(address);
    const validation = this.validator.validate(normalized);
    if (!validation.valid) {
      return {
        success: false,
        normalized,
        validation,
        instant: null,
        suggestions: [],
      };
    }
    let instant = null;
    if (this.geocoder && typeof this.geocoder.geocodeAddress === "function") {
      try {
        const r = await this.geocoder.geocodeAddress(normalized);
        if (r && typeof r.lat === "number" && typeof r.lon === "number") {
          instant = { latitude: r.lat, longitude: r.lon, providerSource: "GOOGLE_CLIENT", matchLevel: "GEOCODER", matchScore: 1.0 };
        }
      } catch (_) {
        instant = null;
      }
    }
    return {
      success: true,
      normalized,
      validation,
      instant,
      suggestions: [],
    };
  }
}


================================================================================
### PLIK: controllers/AppBootstrapController.js
================================================================================

// FILE: src/controllers/AppBootstrapController.js
// CORRECTED FILE
import { EnvironmentConfigService } from "@/services/EnvironmentConfigService";
import { HealthGateController } from "@/controllers/HealthGateController";
// import { IntegrationOrchestrator } from "@/controllers/IntegrationOrchestrator"; // REMOVED

/**
 * ARCHITECTURE: Controller responsible for initial application bootstrap steps.
 * Loads configuration, checks basic health, and prepares core services.
 * REFACTORED: Removed unnecessary placeholder creation of IntegrationOrchestrator.
 */
export class AppBootstrapController {
  constructor(
      cfg = new EnvironmentConfigService(),
      health = new HealthGateController()
  ) {
    this.cfg = cfg;
    this.healthCtrl = health;
  }

  async bootstrap() {
    const config = await this.cfg.load();

    const health = await this.healthCtrl.readiness(config?.GOOGLE_MAPS_API_KEY);

    // REMOVED: Unnecessary and failing placeholder instantiation:
    // const orchestrator = new IntegrationOrchestrator(null, null);

    return {
      config,
      health
      // REMOVED: orchestrator
    };
  }
}

================================================================================
### PLIK: controllers/AuthController.js
================================================================================

/**
 * ARCHITECTURE: AuthController coordinates login/logout by composing AuthApi, AuthSessionService, and ApiAuthBinder.
 * It follows the manifesto by exposing intent-driven methods and returning Result objects for views/guards.
 * Responsibilities:
 * - login(username,password): call AuthApi, persist session, bind Authorization header.
 * - logout(): clear session and unbind header.
 * - hydrateFromStorage(): reapply header on app start.
 * - snapshot(): expose {isAuthenticated,user}.
 */
import { Result } from "@/domain/Result";
import { AuthApi } from "@/services/AuthApi";
import { AuthSessionService } from "@/services/AuthSessionService";
import { ApiAuthBinder } from "@/services/ApiAuthBinder";

export class AuthController {
  constructor(api = new AuthApi(), session = new AuthSessionService(), binder = new ApiAuthBinder()) {
    this.api = api;
    this.session = session;
    this.binder = binder;
  }

  async login(username, password) {
    const r = await this.api.login(username, password);
    if (!r.ok) return Result.fail(r.error);
    this.session.save(r.value);
    this.binder.bind(r.value.accessToken, r.value.tokenType);
    return Result.ok(this.snapshot());
  }

  async logout() {
    this.session.clear();
    this.binder.unbind();
    return Result.ok(true);
  }

  hydrateFromStorage() {
    const token = this.session.getAccessToken();
    const type = this.session.getTokenType();
    if (token) this.binder.bind(token, type);
    return this.snapshot();
  }

  snapshot() {
    return {
      isAuthenticated: this.session.isAuthenticated(),
      user: this.session.getUser(),
      tokenPresent: !!this.session.getAccessToken(),
    };
  }
}


================================================================================
### PLIK: controllers/AuthController.spec.js
================================================================================

// src/controllers/AuthController.spec.js
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { AuthController } from '@/controllers/AuthController';
import { Result } from '@/domain/Result';

// Mock the dependencies (AuthApi, AuthSessionService, ApiAuthBinder)
const mockAuthApi = {
    login: vi.fn(),
};
const mockSessionService = {
    save: vi.fn(),
    clear: vi.fn(),
    isAuthenticated: vi.fn(),
    getUser: vi.fn(),
    getAccessToken: vi.fn(),
    getTokenType: vi.fn(),
};
const mockApiBinder = {
    bind: vi.fn(),
    unbind: vi.fn(),
};

describe('AuthController', () => {
    let authController;

    beforeEach(() => {
        vi.resetAllMocks();
        authController = new AuthController(mockAuthApi, mockSessionService, mockApiBinder);
    });

    describe('login', () => {
        it('should call AuthApi, save session, bind token, and return Ok Result on success', async () => {
            // Arrange
            const username = 'test';
            const password = 'pw';
            const mockSessionData = {
                accessToken: 'atoken',
                refreshToken: 'rtoken',
                tokenType: 'Bearer',
                username: username,
                roles: ['USER'],
            };
            const mockSnapshot = { isAuthenticated: true, user: { username: username, roles: ['USER'] } };
            mockAuthApi.login.mockResolvedValue(Result.ok(mockSessionData));
            // Mock snapshot call within the controller's login method
            vi.spyOn(authController, 'snapshot').mockReturnValue(mockSnapshot);

            // Act
            const result = await authController.login(username, password);

            // Assert
            expect(mockAuthApi.login).toHaveBeenCalledWith(username, password);
            expect(mockSessionService.save).toHaveBeenCalledWith(mockSessionData);
            expect(mockApiBinder.bind).toHaveBeenCalledWith(mockSessionData.accessToken, mockSessionData.tokenType);
            expect(result.ok).toBe(true);
            expect(result.value).toEqual(mockSnapshot); // Login returns the snapshot
        });

        it('should return Fail Result if AuthApi.login fails', async () => {
            // Arrange
            const username = 'test';
            const password = 'pw';
            const mockError = new Error('Invalid credentials');
            mockAuthApi.login.mockResolvedValue(Result.fail(mockError));

            // Act
            const result = await authController.login(username, password);

            // Assert
            expect(mockAuthApi.login).toHaveBeenCalledWith(username, password);
            expect(mockSessionService.save).not.toHaveBeenCalled();
            expect(mockApiBinder.bind).not.toHaveBeenCalled();
            expect(result.ok).toBe(false);
            expect(result.error).toBe(mockError);
        });
    });

    describe('logout', () => {
        it('should clear session and unbind token', async () => {
            // Act
            const result = await authController.logout();

            // Assert
            expect(mockSessionService.clear).toHaveBeenCalledTimes(1);
            expect(mockApiBinder.unbind).toHaveBeenCalledTimes(1);
            expect(result.ok).toBe(true);
        });
    });

    describe('hydrateFromStorage', () => {
        it('should bind token if found in session', () => {
            // Arrange
            mockSessionService.getAccessToken.mockReturnValue('storedToken');
            mockSessionService.getTokenType.mockReturnValue('Bearer');

            // Act
            authController.hydrateFromStorage();

            // Assert
            expect(mockApiBinder.bind).toHaveBeenCalledWith('storedToken', 'Bearer');
        });

        it('should not bind token if not found in session', () => {
            // Arrange
            mockSessionService.getAccessToken.mockReturnValue(null);

            // Act
            authController.hydrateFromStorage();

            // Assert
            expect(mockApiBinder.bind).not.toHaveBeenCalled();
        });
    });

    describe('snapshot', () => {
        it('should return current auth state from session service', () => {
            // Arrange
            mockSessionService.isAuthenticated.mockReturnValue(true);
            mockSessionService.getUser.mockReturnValue({ username: 'snapUser', roles: ['TEST']});
            mockSessionService.getAccessToken.mockReturnValue('snapToken');

            // Act
            const snapshot = authController.snapshot();

            // Assert
            expect(snapshot).toEqual({
                isAuthenticated: true,
                user: { username: 'snapUser', roles: ['TEST']},
                tokenPresent: true
            });
        });
    });
});

================================================================================
### PLIK: controllers/BulkEditController.js
================================================================================

/**
 * ARCHITECTURE: BulkEditController previews and applies batch text transforms across selected orders.
 * It follows the manifesto by isolating batch logic and delegating transport to AddressExceptionApi.
 * Responsibilities:
 * - Preview client-side transformations for confidence; apply changes via backend endpoint.
 * - Accept BulkEditPlan JSON and return Result objects for both preview and apply.
 */
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

export class BulkEditController {
  constructor(storeOrApi = null) {
    this.api = storeOrApi instanceof AddressExceptionApi ? storeOrApi : new AddressExceptionApi();
  }

  async preview(plan) {
    try {
      const { data } = await this._post("/bulk/preview", plan);
      return Result.ok(Array.isArray(data?.items) ? data.items : []);
    } catch (e) {
      return Result.fail(e);
    }
  }

  async apply(plan) {
    try {
      const { data } = await this._post("/bulk/apply", plan);
      return Result.ok(data || true);
    } catch (e) {
      return Result.fail(e);
    }
  }

  async _post(path, plan) {
    const url = `/api/address-exceptions${path}`;
    return await (await import("@/services/api")).default.post(url, plan.toJSON ? plan.toJSON() : plan);
  }
}


================================================================================
### PLIK: controllers/CorrectionEditorController.js
================================================================================

/**
 * ARCHITECTURE: CorrectionEditorController orchestrates the "side-by-side diff" editor.
 * It follows the manifesto by isolating all IO and decision logic away from the component tree.
 * Responsibilities:
 * - Loads OrderDetail and related suggestions for pickup/delivery.
 * - Maintains editable copies of addresses, integrates optional geocoder.
 * - Applies Accept Suggestion, Use Original, Manual Edit, Save, and Save & Next.
 * - Shields UI from API details via AddressExceptionApi and from map choice via GeocodeWithCacheController.
 * REFACTORED: Now accepts a GeocodeWithCacheController instead of MapGeocoderAdapter.
 */
import { Address } from "@/domain/WorkbenchModels";
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";
// *** MODIFIED: Import GeocodeWithCacheController ***
import { GeocodeWithCacheController } from "@/controllers/GeocodeWithCacheController";
// *** REMOVED: MapGeocoderAdapter import

export class CorrectionEditorController {
  constructor(api = new AddressExceptionApi(), geocoder = null) {
    this.api = api;
    // *** FIX: Check for GeocodeWithCacheController instance ***
    this.geocoder = geocoder instanceof GeocodeWithCacheController ? geocoder : null;
    if (!this.geocoder) {
      console.warn("[CorrectionEditorController] Geocoder (GeocodeWithCacheController) was not provided or invalid.");
    }
    this.orderId = null;
    this.detail = null;
    this.loading = false;
    this.error = null;
    this.editedPickup = null;
    this.editedDelivery = null;
  }

  setGeocoderAdapter(adapter) {
    // *** FIX: Update type check ***
    this.geocoder = adapter instanceof GeocodeWithCacheController ? adapter : null;
    return this.geocoder;
  }

  async loadOrder(orderId) {
    this.loading = true;
    this.error = null;
    this.orderId = orderId;
    this.detail = null;
    this.editedPickup = null;
    this.editedDelivery = null;
    const res = await this.api.getOrderDetail(orderId);
    if (!res.ok) {
      this.loading = false;
      this.error = res.error.message;
      return Result.fail(res.error);
    }
    this.detail = res.value;
    this.editedPickup = new Address(
        this.detail.originalPickup.street,
        this.detail.originalPickup.houseNumber,
        this.detail.originalPickup.postalCode,
        this.detail.originalPickup.city,
        this.detail.originalPickup.country,
        this.detail.originalPickup.latitude,
        this.detail.originalPickup.longitude
    );
    this.editedDelivery = new Address(
        this.detail.originalDelivery.street,
        this.detail.originalDelivery.houseNumber,
        this.detail.originalDelivery.postalCode,
        this.detail.originalDelivery.city,
        this.detail.originalDelivery.country,
        this.detail.originalDelivery.latitude,
        this.detail.originalDelivery.longitude
    );
    this.loading = false;
    return Result.ok(this.detail);
  }

  async refreshSuggestions(side) {
    if (!this.orderId) return Result.fail(new Error("Order not loaded."));
    const s = side === "pickup" ? "pickup" : "delivery";
    const res = await this.api.refreshSuggestions(this.orderId, s);
    if (!res.ok) return Result.fail(res.error);
    if (s === "pickup") this.detail.suggestedPickup = res.value;
    if (s === "delivery") this.detail.suggestedDelivery = res.value;
    return Result.ok(res.value);
  }

  acceptSuggestion(side, index = 0) {
    if (!this.detail) return Result.fail(new Error("Order not loaded."));
    const list = side === "pickup" ? this.detail.suggestedPickup : this.detail.suggestedDelivery;
    if (!Array.isArray(list) || !list[index]) return Result.fail(new Error("Suggestion not found."));
    const s = list[index];
    const addr = new Address(
        s.street || "",
        s.houseNumber || null,
        s.postalCode || "",
        s.city || "",
        s.countryCode || this._defaultCountry(),
        s.latitude ?? null,
        s.longitude ?? null
    );
    if (side === "pickup") this.editedPickup = addr;
    if (side === "delivery") this.editedDelivery = addr;
    return Result.ok(addr);
  }

  useOriginal(side) {
    if (!this.detail) return Result.fail(new Error("Order not loaded."));
    if (side === "pickup") {
      const o = this.detail.originalPickup;
      this.editedPickup = new Address(o.street, o.houseNumber, o.postalCode, o.city, o.country, o.latitude, o.longitude);
      return Result.ok(this.editedPickup);
    }
    if (side === "delivery") {
      const o = this.detail.originalDelivery;
      this.editedDelivery = new Address(o.street, o.houseNumber, o.postalCode, o.city, o.country, o.latitude, o.longitude);
      return Result.ok(this.editedDelivery);
    }
    return Result.fail(new Error("Unknown side."));
  }

  setManualAddress(side, address) {
    if (!(address instanceof Address)) return Result.fail(new Error("Invalid Address."));
    if (side === "pickup") this.editedPickup = address;
    else if (side === "delivery") this.editedDelivery = address;
    else return Result.fail(new Error("Unknown side."));
    return Result.ok(address);
  }

  async geocodeEdited(side) {
    // *** FIX: Use GeocodeWithCacheController ***
    if (!this.geocoder) return Result.fail(new Error("No geocoder available."));
    const addr = side === "pickup" ? this.editedPickup : this.editedDelivery;
    if (!(addr instanceof Address)) return Result.fail(new Error("No edited address."));

    // Call the geocode method on GeocodeWithCacheController
    const r = await this.geocoder.geocode({
      street: addr.street,
      houseNumber: addr.houseNumber,
      postalCode: addr.postalCode,
      city: addr.city,
      country: addr.country,
    });

    if (!r) return Result.fail(new Error("Geocode not found."));

    // GeocodeWithCacheController returns the full normalized address object
    addr.latitude = r.latitude;
    addr.longitude = r.longitude;
    // Optionally update other fields if normalization is desired
    // addr.street = r.street;
    // addr.houseNumber = r.houseNumber;
    // addr.postalCode = r.postalCode;
    // addr.city = r.city;

    return Result.ok({ lat: r.latitude, lon: r.longitude });
  }

  async saveAcceptSuggestion(side) {
    if (!this.orderId) return Result.fail(new Error("Order not loaded."));
    const payload = {
      orderId: this.orderId,
      side: side === "both" ? "both" : side === "pickup" ? "pickup" : "delivery",
      correctedPickup: side === "pickup" || side === "both" ? this.editedPickup : null,
      correctedDelivery: side === "delivery" || side === "both" ? this.editedDelivery : null,
      resolution: "ACCEPT_SUGGESTION",
    };
    const res = await this.api.saveCorrection(payload);
    if (!res.ok) return Result.fail(res.error);
    return Result.ok(res.value);
  }

  async saveUseOriginal(side) {
    if (!this.orderId) return Result.fail(new Error("Order not loaded."));
    const payload = {
      orderId: this.orderId,
      side: side === "both" ? "both" : side === "pickup" ? "pickup" : "delivery",
      correctedPickup: side === "pickup" || side === "both" ? this.editedPickup : null,
      correctedDelivery: side === "delivery" || side === "both" ? this.editedDelivery : null,
      resolution: "USE_ORIGINAL",
    };
    const res = await this.api.saveCorrection(payload);
    if (!res.ok) return Result.fail(res.error);
    return Result.ok(res.value);
  }

  async saveManual(side) {
    if (!this.orderId) return Result.fail(new Error("Order not loaded."));
    const payload = {
      orderId: this.orderId,
      side: side === "both" ? "both" : side === "pickup" ? "pickup" : "delivery",
      correctedPickup: side === "pickup" || side === "both" ? this.editedPickup : null,
      correctedDelivery: side === "delivery" || side === "both" ? this.editedDelivery : null,
      resolution: "MANUAL_EDIT",
    };
    const res = await this.api.saveCorrection(payload);
    if (!res.ok) return Result.fail(res.error);
    return Result.ok(res.value);
  }

  async saveAndNext(side, worklistStore) {
    const saveRes = await this._saveBySideKind(side);
    if (!saveRes.ok) return saveRes;
    const nextIdRes = await worklistStore.getNextAndLoad(this.orderId);
    if (!nextIdRes.ok) return Result.fail(nextIdRes.error);
    const nextId = nextIdRes.value;
    if (!nextId) return Result.ok(null);
    const loadRes = await this.loadOrder(nextId);
    if (!loadRes.ok) return Result.fail(loadRes.error);
    return Result.ok(nextId);
  }

  snapshot() {
    return {
      orderId: this.orderId,
      detail: this.detail,
      editedPickup: this.editedPickup,
      editedDelivery: this.editedDelivery,
      loading: this.loading,
      error: this.error,
    };
  }

  _defaultCountry() {
    return "PL";
  }

  async _saveBySideKind(side) {
    if (side === "pickup") return this.saveManual("pickup");
    if (side === "delivery") return this.saveManual("delivery");
    if (side === "both") return this.saveManual("both");
    return Result.fail(new Error("Unknown side."));
  }
}


================================================================================
### PLIK: controllers/EditorAutosaveController.js
================================================================================

/**
 * ARCHITECTURE: EditorAutosaveController persists draft edits to session and restores on load.
 * It follows the manifesto by composing EditorStateSerializer with a timed save loop.
 * Responsibilities:
 * - Save edited pickup/delivery every N ms if changed; restore when opening the same orderId.
 */
import { EditorStateSerializer } from "@/services/EditorStateSerializer";
import { AddressEqualityService } from "@/services/AddressEqualityService";

export class EditorAutosaveController {
  constructor(editorFacade, serializer = new EditorStateSerializer(), eq = new AddressEqualityService(), intervalMs = 2000) {
    this.editor = editorFacade;
    this.serializer = serializer;
    this.eq = eq;
    this.intervalMs = intervalMs;
    this._timer = null;
    this._last = null;
    this._orderId = null;
  }

  async restore(orderId) {
    this._orderId = orderId;
    const saved = this.serializer.load(orderId);
    if (saved?.editedPickup) this.editor.setManualPickup(saved.editedPickup);
    if (saved?.editedDelivery) this.editor.setManualDelivery(saved.editedDelivery);
    this._last = this._take();
    return saved || null;
  }

  start() {
    if (this._timer) return false;
    this._timer = setInterval(() => this._tick(), this.intervalMs);
    return true;
  }

  stop() {
    if (!this._timer) return false;
    clearInterval(this._timer);
    this._timer = null;
    return true;
  }

  _tick() {
    if (!this._orderId) return;
    const now = this._take();
    if (!this._equalDrafts(this._last, now)) {
      this.serializer.save(this._orderId, now);
      this._last = now;
    }
  }

  _take() {
    const s = this.editor.snapshot();
    return { editedPickup: s?.editor?.editedPickup || null, editedDelivery: s?.editor?.editedDelivery || null };
  }

  _equalDrafts(a, b) {
    return this.eq.equals(a?.editedPickup || {}, b?.editedPickup || {}) && this.eq.equals(a?.editedDelivery || {}, b?.editedDelivery || {});
  }
}


================================================================================
### PLIK: controllers/EditorCommandBus.js
================================================================================

/**
 * ARCHITECTURE: EditorCommandBus centralizes high-level editor commands for buttons and hotkeys.
 * It follows the manifesto by exposing intent methods that orchestrate other controllers/facades.
 * Responsibilities:
 * - Provide accept/use-original/save/save&next commands for pickup, delivery, and both.
 * - Keep a single place to wire UI actions to EditorFacade and SaveFlowController.
 */
import { Result } from "@/domain/Result";

export class EditorCommandBus {
  constructor(editorFacade, saveFlowController) {
    this.editor = editorFacade;
    this.saveFlow = saveFlowController;
  }

  acceptPickup(i = 0) {
    const r = this.editor.acceptPickupSuggestion(i);
    return r.ok ? Result.ok(true) : r;
  }

  acceptDelivery(i = 0) {
    const r = this.editor.acceptDeliverySuggestion(i);
    return r.ok ? Result.ok(true) : r;
  }

  useOriginalPickup() {
    const r = this.editor.useOriginalPickup();
    return r.ok ? Result.ok(true) : r;
  }

  useOriginalDelivery() {
    const r = this.editor.useOriginalDelivery();
    return r.ok ? Result.ok(true) : r;
  }

  async savePickupThenNext() {
    return this.saveFlow.saveThenAwait("pickup");
  }

  async saveDeliveryThenNext() {
    return this.saveFlow.saveThenAwait("delivery");
  }

  async saveBothThenNext() {
    return this.saveFlow.saveThenAwait("both");
  }
}


================================================================================
### PLIK: controllers/EditorDiffController.js
================================================================================

/**
 * ARCHITECTURE: EditorDiffController computes and presents diffs for pickup and delivery addresses.
 * It follows the manifesto by composing DiffService and DiffPresenter behind a deterministic snapshot.
 * Responsibilities:
 * - Pull before/after from EditorFacade snapshot and compute UI-ready rows for both sides.
 */
import { DiffService } from "@/services/DiffService";
import { DiffPresenter } from "@/viewmodels/DiffPresenter";

export class EditorDiffController {
  constructor(editorFacade) {
    this.editor = editorFacade;
    this.diff = new DiffService();
    this.presenter = new DiffPresenter();
    this._snapshot = { pickup: { rows: [] }, delivery: { rows: [] } };
  }

  recompute() {
    const snap = this.editor.snapshot();
    const beforeP = snap.editor?.detail?.originalPickup || null;
    const afterP = snap.editor?.editedPickup || snap.editor?.editedPickup || snap.editor?.detail?.originalPickup || null;
    const beforeD = snap.editor?.detail?.originalDelivery || null;
    const afterD = snap.editor?.editedDelivery || snap.editor?.detail?.originalDelivery || null;

    const dp = this.presenter.present(this.diff.diff(beforeP, afterP));
    const dd = this.presenter.present(this.diff.diff(beforeD, afterD));

    this._snapshot = { pickup: dp, delivery: dd };
    return this._snapshot;
  }

  snapshot() {
    return JSON.parse(JSON.stringify(this._snapshot));
  }
}


================================================================================
### PLIK: controllers/EditorFacade.js
================================================================================

/**
 * ARCHITECTURE: EditorFacade wraps CorrectionEditorController and adds map preview conveniences.
 * It follows the manifesto by exposing intent methods used by the Editor view without leaking internals.
 * Responsibilities:
 * - Load order, set manual edits, accept suggestions, and compute snapshots for UI.
 * - Optionally preview on map when accepting/applying suggestions.
 */
import { Result } from "@/domain/Result";
import { SuggestionPreviewController } from "@/controllers/SuggestionPreviewController";

export class EditorFacade {
  constructor(editorController, mapController = null, _placesAdapter = null, queue = null) {
    this.ctrl = editorController;
    this.queue = queue || null;
    this.preview = mapController ? new SuggestionPreviewController(mapController) : null;
  }

  async load(orderId) {
    return await this.ctrl.loadOrder(orderId);
  }

  snapshot() {
    return { editor: this.ctrl.snapshot(), currentOrderId: this.ctrl?.detail?.orderId || null };
  }

  setManualPickup(addr) {
    return this.ctrl.setManualAddress("pickup", addr);
  }

  setManualDelivery(addr) {
    return this.ctrl.setManualAddress("delivery", addr);
  }

  setPickupSuggestions(list) {
    return this.ctrl.setSuggestions("pickup", list);
  }

  setDeliverySuggestions(list) {
    return this.ctrl.setSuggestions("delivery", list);
  }

  acceptPickupSuggestion(i = 0) {
    const r = this.ctrl.acceptSuggestion("pickup", i);
    if (this.preview && r.ok) this.preview.show(this.ctrl.snapshot().editedPickup);
    return r.ok ? Result.ok(true) : r;
  }

  acceptDeliverySuggestion(i = 0) {
    const r = this.ctrl.acceptSuggestion("delivery", i);
    if (this.preview && r.ok) this.preview.show(this.ctrl.snapshot().editedDelivery);
    return r.ok ? Result.ok(true) : r;
  }

  useOriginalPickup() {
    return this.ctrl.useOriginal("pickup");
  }

  useOriginalDelivery() {
    return this.ctrl.useOriginal("delivery");
  }
}


================================================================================
### PLIK: controllers/EditorFocusController.js
================================================================================

/**
 * ARCHITECTURE: EditorFocusController manages a deterministic focus order across address fields.
 * It follows the manifesto by isolating focus logic from the component and DOM details.
 * Responsibilities:
 * - Provide nextField() and prevField() given current key and an ordered schema.
 * - Return the target key for the view to focus without touching the DOM.
 */
export class EditorFocusController {
  constructor(order = ["street", "houseNumber", "postalCode", "city", "country"]) {
    this.order = order.slice();
    this.index = 0;
  }

  setCurrent(key) {
    const idx = this.order.indexOf(key);
    if (idx >= 0) this.index = idx;
    return this.current();
  }

  current() {
    return this.order[this.index] || null;
  }

  next() {
    this.index = Math.min(this.order.length - 1, this.index + 1);
    return this.current();
  }

  previous() {
    this.index = Math.max(0, this.index - 1);
    return this.current();
  }

  reset() {
    this.index = 0;
    return this.current();
  }
}


================================================================================
### PLIK: controllers/EditorHotkeysController.js
================================================================================

/**
 * ARCHITECTURE: EditorHotkeysController manages keyboard shortcuts for the Correction Editor.
 * It follows the manifesto by isolating DOM listeners and mapping keys to explicit callbacks.
 * Responsibilities:
 * - Attach/detach listeners and dispatch to provided handlers (save, save&next, accept, use original).
 * - Avoid collisions by scoping to a single active instance and ignoring repeated auto-fire.
 */
export class EditorHotkeysController {
  constructor(handlers = {}) {
    this.handlers = {
      onSave: handlers.onSave || null,
      onSaveNext: handlers.onSaveNext || null,
      onAccept: handlers.onAccept || null,
      onUseOriginal: handlers.onUseOriginal || null,
    };
    this._bound = (e) => this._onKey(e);
    this._attached = false;
  }

  attach() {
    if (this._attached) return false;
    window.addEventListener("keydown", this._bound, true);
    this._attached = true;
    return true;
  }

  detach() {
    if (!this._attached) return false;
    window.removeEventListener("keydown", this._bound, true);
    this._attached = false;
    return true;
  }

  _onKey(e) {
    if (e.repeat) return;
    const mod = e.ctrlKey || e.metaKey;
    if (mod && e.key.toLowerCase() === "s") {
      e.preventDefault();
      if (e.shiftKey && this.handlers.onSaveNext) return this.handlers.onSaveNext();
      if (this.handlers.onSave) return this.handlers.onSave();
    }
    if (mod && e.key.toLowerCase() === "enter") {
      e.preventDefault();
      if (this.handlers.onAccept) return this.handlers.onAccept();
    }
    if (mod && e.key.toLowerCase() === "backspace") {
      e.preventDefault();
      if (this.handlers.onUseOriginal) return this.handlers.onUseOriginal();
    }
  }
}


================================================================================
### PLIK: controllers/EditorInitController.js
================================================================================

/**
 * ARCHITECTURE: EditorInitController prepares the Correction Editor with autosave, undo, and recovery wiring.
 * It follows the manifesto by centralizing editor startup steps for a predictable, testable flow.
 * Responsibilities:
 * - Load order, restore drafts, start autosave, initialize undo snapshot, and prefetch next order.
 * - Provide a single init(orderId) returning a stabilized snapshot for the view.
 */
import { EditorAutosaveController } from "@/controllers/EditorAutosaveController";
import { EditorUndoController } from "@/controllers/EditorUndoController";
import { OrderDetailPrefetcher } from "@/services/OrderDetailPrefetcher";
import { Result } from "@/domain/Result";

export class EditorInitController {
  constructor(editorFacade, ordersQueue, autosave = null, undo = null, prefetcher = new OrderDetailPrefetcher()) {
    this.editor = editorFacade;
    this.queue = ordersQueue;
    this.autosave = autosave instanceof EditorAutosaveController ? autosave : new EditorAutosaveController(this.editor);
    this.undo = undo instanceof EditorUndoController ? undo : new EditorUndoController(this.editor);
    this.prefetcher = prefetcher;
  }

  async init(orderId) {
    const load = await this.editor.load(orderId);
    if (!load.ok) return load;
    await this.autosave.restore(orderId);
    this.autosave.start();
    this.undo.init();
    const nextId = this.queue.current() || this.queue.next();
    if (nextId) await this.prefetcher.prefetch(nextId);
    return Result.ok(this.editor.snapshot());
  }

  stop() {
    this.autosave.stop();
    return true;
  }
}


================================================================================
### PLIK: controllers/EditorNavigationController.js
================================================================================

/**
 * ARCHITECTURE: EditorNavigationController builds route URLs to the editor preserving context when needed.
 * It follows the manifesto by isolating URL composition away from views.
 * Responsibilities:
 * - toEditor(orderId, from, state): return path with optional query for back navigation.
 */
export class EditorNavigationController {
  toEditor(orderId, from = "worklist", state = null) {
    const q = new URLSearchParams();
    q.set("from", from);
    if (state && typeof state === "object") q.set("ctx", btoa(unescape(encodeURIComponent(JSON.stringify(state)))));
    return `/editor/${encodeURIComponent(orderId)}?${q.toString()}`;
  }
}


================================================================================
### PLIK: controllers/EditorRecoveryController.js
================================================================================

/**
 * ARCHITECTURE: EditorRecoveryController (Stub) would be responsible for
 * handling recovery from save failures or state inconsistencies in the editor,
 * potentially by retrying, resetting state, or alerting the user.
 * This is a placeholder implementation.
 */
import { Result } from "@/domain/Result";

export class EditorRecoveryController {
    constructor(editorFacade, saveFlowController) {
        this.editor = editorFacade;
        this.saveFlow = saveFlowController;
    }

    /**
     * Attempts to recover from a failed save state.
     * @param {object} lastKnownGoodState - The snapshot before the failed save.
     * @param {Error} error - The error that occurred.
     * @returns {Promise<Result<any, Error>>}
     */
    async attemptRecovery(lastKnownGoodState, error) {
        console.warn("[EditorRecoveryController] Recovery requested for error:", error, "Last state:", lastKnownGoodState);
        // Placeholder: Simple recovery might just be to inform the user.
        // A complex one might check error type and retry if retryable.
        return Result.fail(new Error("Automatic recovery not implemented. Please check your connection and try saving again."));
    }
}

================================================================================
### PLIK: controllers/EditorSavePolicyController.js
================================================================================

/**
 * ARCHITECTURE: EditorSavePolicyController decides when Save buttons should be enabled.
 * It follows the manifesto by isolating policy checks (diff, validation, geocode) from UI components.
 * Responsibilities:
 * - Evaluate readiness for pickup/delivery/both saves using diff flags and validation results.
 * - Provide explicit booleans and reasons for disabled states.
 */
export class EditorSavePolicyController {
  constructor() {
    this.requireGeocode = false;
  }

  setRequireGeocode(v) {
    this.requireGeocode = !!v;
    return this.requireGeocode;
  }

  canSavePickup(state) {
    return this._evaluate(state?.latestDiff?.pickup, state?.editor?.validation, state?.editor?.instant, "pickup");
  }

  canSaveDelivery(state) {
    return this._evaluate(state?.latestDiff?.delivery, state?.editor?.validation, state?.editor?.instant, "delivery");
  }

  canSaveBoth(state) {
    const p = this._evaluate(state?.latestDiff?.pickup, state?.editor?.validation, state?.editor?.instant, "pickup");
    const d = this._evaluate(state?.latestDiff?.delivery, state?.editor?.validation, state?.editor?.instant, "delivery");
    return { enabled: p.enabled && d.enabled, reason: p.enabled ? d.reason : p.reason };
  }

  _evaluate(diff, validation, instant, side) {
    if (!diff || !validation) return { enabled: false, reason: "No changes or validation state missing" };
    if (!diff.anyChanged) return { enabled: false, reason: "No changes detected" };
    if (!validation.valid) return { enabled: false, reason: "Invalid address fields" };
    if (this.requireGeocode && !instant) return { enabled: false, reason: "Geocode required" };
    return { enabled: true, reason: "OK" };
  }
}


================================================================================
### PLIK: controllers/EditorUndoController.js
================================================================================

/**
 * ARCHITECTURE: EditorUndoController wraps UndoStackService for pickup/delivery address edits.
 * It follows the manifesto by providing intent-driven methods without UI or storage coupling.
 * Responsibilities:
 * - Capture snapshots on change, and restore on undo/redo callbacks to the editor facade.
 * - Keep a tiny footprint: snapshot shape is {pickup,delivery}.
 */
import { UndoStackService } from "@/services/UndoStackService";

export class EditorUndoController {
  constructor(editorFacade, stack = new UndoStackService(100)) {
    this.editor = editorFacade;
    this.stack = stack;
  }

  init() {
    const snap = this._snapshot();
    this.stack.init(snap);
    return snap;
  }

  onChange() {
    return this.stack.push(this._snapshot());
  }

  undo() {
    const s = this.stack.undo();
    if (!s) return null;
    if (s.pickup) this.editor.setManualPickup(s.pickup);
    if (s.delivery) this.editor.setManualDelivery(s.delivery);
    return s;
  }

  redo() {
    const s = this.stack.redo();
    if (!s) return null;
    if (s.pickup) this.editor.setManualPickup(s.pickup);
    if (s.delivery) this.editor.setManualDelivery(s.delivery);
    return s;
  }

  _snapshot() {
    const st = this.editor.snapshot();
    return {
      pickup: st?.editor?.editedPickup || null,
      delivery: st?.editor?.editedDelivery || null,
    };
  }
}


================================================================================
### PLIK: controllers/EditorVerificationController.js
================================================================================

// FILE: src/controllers/EditorVerificationController.js
// UPDATED FILE (Remove Places dependency)
import { AddressNormalizer } from "@/services/AddressNormalizer";
import { ValidationService } from "@/services/ValidationService";
import { DebounceTimer } from "@/services/DebounceTimer";

/**
 * ARCHITECTURE: Coordinates live verification for the Correction Editor input fields.
 * REFACTORED: Removed Google Places adapter dependency. Relies on geocoder only.
 */
export class EditorVerificationController {
  constructor(
      geocoderAdapter, // e.g., NominatimGeocodingAdapter instance
      // Removed placesAdapter
      mapController,
      debounceMs = 400
  ) {
    this.normalizer = new AddressNormalizer();
    this.validator = new ValidationService(); // Assuming country PL default or configurable
    this.debouncer = new DebounceTimer(debounceMs);
    this.geocoder = geocoderAdapter || null;
    // this.places = null; // Removed
    this.map = mapController || null;
    this.input = { street: "", houseNumber: "", postalCode: "", city: "", country: "PL" };
    this.validation = { valid: false, errors: {} };
    this.instant = null; // Result from geocoder
    this.suggestions = []; // Now likely just [instant] or []
    this.loading = false;
    this.error = null;
  }

  setInputPatch(patch) {
    this.input = { ...this.input, ...(patch || {}) };
    return this.input;
  }

  async runVerification() {
    return this.debouncer.run(async () => {
      this.loading = true;
      this.error = null;
      this.instant = null; // Reset results
      this.suggestions = [];

      const normalized = this.normalizer.normalize(this.input);
      const check = this.validator.validate(normalized);
      this.validation = check;

      if (!check.valid) {
        log.debug("[EditorVerify] Input invalid, skipping geocode:", check.errors);
        this.loading = false;
        return this.snapshot();
      }

      let instantResult = null;
      if (this.geocoder) {
        try {
          instantResult = await this.geocoder.geocodeAddress(normalized);
          this.instant = instantResult; // Store the geocoded result
          if (instantResult) {
            this.suggestions = [this.mapGeoResultToSuggestion(instantResult, normalized)]; // Create suggestion from result
          }
        } catch (geoError) {
          log.error("[EditorVerify] Geocoder failed:", geoError);
          this.error = "Geocoding failed.";
          this.instant = null;
          this.suggestions = [];
        }
      } else {
        log.warn("[EditorVerify] No geocoder configured.");
      }

      // Update map marker if geocoding was successful and map exists
      if (instantResult && typeof instantResult.latitude === "number" && typeof instantResult.longitude === "number" && this.map) {
        try {
          await this.map.updateMarker(instantResult.latitude, instantResult.longitude, true); // Recenter map
        } catch (mapError) {
          log.error("[EditorVerify] Failed to update map marker:", mapError);
          // Non-critical error, continue
        }
      }

      this.loading = false;
      return this.snapshot();
    });
  }

  // Helper to map geocoder result to the suggestion format expected by downstream components
  mapGeoResultToSuggestion(geoResult, baseInput) {
    return {
      fullAddressLabel: geoResult._displayName || `${geoResult.street || ''} ${geoResult.houseNumber || ''}, ${geoResult.postalCode || ''} ${geoResult.city || ''}`.replace(/ ,|,$/,'').trim(),
      street: geoResult.street || null,
      houseNumber: geoResult.houseNumber || null,
      postalCode: geoResult.postalCode || null,
      city: geoResult.city || null,
      countryCode: geoResult.country || baseInput.country || "PL",
      countryName: null,
      latitude: geoResult.latitude ?? null,
      longitude: geoResult.longitude ?? null,
      matchScore: geoResult._confidence ?? 0.8,
      matchLevel: geoResult._osmType || "GEOCODER",
      providerSource: geoResult._provider || "GEOCODER_CLIENT",
    };
  }

  snapshot() {
    return {
      input: { ...this.input },
      validation: { ...this.validation },
      instant: this.instant ? { ...this.instant } : null,
      suggestions: this.suggestions.slice(),
      loading: this.loading,
      error: this.error,
    };
  }

  _composeFreeText(a) { // Keep for potential future use
    const line1 = a.houseNumber ? `${a.street || ''} ${a.houseNumber}` : a.street || "";
    return `${line1}, ${a.postalCode || ""} ${a.city || ""}`.trim();
  }
}

// Basic logger shim
const log = {
  debug: (...args) => console.debug(...args),
  warn: (...args) => console.warn(...args),
  error: (...args) => console.error(...args),
};

================================================================================
### PLIK: controllers/EndToEndVerifyAndSaveController.js
================================================================================

/**
 * ARCHITECTURE: EndToEndVerifyAndSaveController runs normalizeâ†’validateâ†’verifyâ†’save with telemetry.
 * It follows the manifesto by composing workflow, policy, and save flow into a single orchestrator.
 * Responsibilities:
 * - Verify pickup/delivery, apply best suggestion, and persist the result; then advance queue.
 * - Emit timing events via VerificationTelemetryController and return a concise outcome.
 */
import { AddressVerificationWorkflow } from "@/controllers/AddressVerificationWorkflow";
import { SuggestionSelectionController } from "@/controllers/SuggestionSelectionController";
import { SaveFlowController } from "@/controllers/SaveFlowController";
import { VerificationTelemetryController } from "@/controllers/VerificationTelemetryController";
import { Result } from "@/domain/Result";

export class EndToEndVerifyAndSaveController {
  constructor(googleApiKey, editorFacade, ordersQueue, saver) {
    this.workflow = new AddressVerificationWorkflow(googleApiKey);
    this.selector = new SuggestionSelectionController();
    this.saveFlow = new SaveFlowController(editorFacade, ordersQueue, saver);
    this.telemetry = new VerificationTelemetryController();
    this.editor = editorFacade;
  }

  async runForSide(side = "pickup") {
    const corr = this.telemetry.start(`e2e_${side}`);
    const addr = side === "pickup" ? this.editor.editor.editedPickup : this.editor.editor.editedDelivery;
    if (!addr) {
      this.telemetry.finish("no-input", { side });
      return Result.fail(new Error("No address to verify"));
    }
    this.telemetry.mark("verify-start", { side });
    const vr = await this.workflow.verify(addr);
    this.telemetry.mark("verify-finish", { valid: vr.success, side });
    if (!vr.success) {
      this.telemetry.finish("invalid", { side });
      return Result.fail(new Error("Validation failed"));
    }
    const best = this.selector.best(vr.normalized, vr.suggestions);
    if (best) {
      if (side === "pickup") this.editor.acceptPickupSuggestion(best.index);
      if (side === "delivery") this.editor.acceptDeliverySuggestion(best.index);
    }
    this.telemetry.mark("save-start", { side });
    const saved = await this.saveFlow.saveThenAwait(side);
    const status = saved.ok ? "ok" : "save-failed";
    this.telemetry.finish(status, { side, nextId: saved.ok ? saved.value?.nextId || null : null });
    return saved;
  }
}


================================================================================
### PLIK: controllers/erificationQueueController.js
================================================================================

/**
 * ARCHITECTURE: VerificationQueueController serializes geocode requests to respect provider quotas.
 * It follows the manifesto by isolating concurrency limits and exposing enqueue() with result promises.
 * Responsibilities:
 * - Maintain a FIFO queue, run up to N active tasks, and resolve/reject per item deterministically.
 * - Allow dynamic concurrency to adapt to UI load and throttle bursts from user typing.
 */
export class VerificationQueueController {
  constructor(concurrency = 2) {
    this.concurrency = Math.max(1, concurrency);
    this._active = 0;
    this._q = [];
  }

  setConcurrency(n) {
    this.concurrency = Math.max(1, n);
    this._drain();
    return this.concurrency;
  }

  enqueue(taskFn) {
    return new Promise((resolve, reject) => {
      this._q.push({ taskFn, resolve, reject });
      this._drain();
    });
  }

  _drain() {
    while (this._active < this.concurrency && this._q.length > 0) {
      const item = this._q.shift();
      this._run(item);
    }
  }

  async _run(item) {
    this._active++;
    try {
      const r = await item.taskFn();
      item.resolve(r);
    } catch (e) {
      item.reject(e);
    } finally {
      this._active--;
      this._drain();
    }
  }

  size() {
    return this._q.length + this._active;
  }
}


================================================================================
### PLIK: controllers/GeocodeWithCacheController.js
================================================================================

// FILE: src/controllers/GeocodeWithCacheController.js
// MODIFIED - Request adapter without specifying provider
import { AddressGeocodeCache } from "@/services/AddressGeocodeCache";
import { QuotaBackoffService } from "@/services/QuotaBackoffService";

/**
 * ARCHITECTURE: Composes cache, quota backoff for geocoding.
 * Uses injected GeoRuntime to get the configured geocoder adapter.
 */
export class GeocodeWithCacheController {
    constructor(
        geoRuntime,
        cache = new AddressGeocodeCache(),
        backoff = new QuotaBackoffService()
    ) {
        if (!geoRuntime) throw new Error("GeocodeWithCacheController requires GeoRuntime.");
        this.geoRuntime = geoRuntime;
        this.cache = cache;
        this.backoff = backoff;
        this._geocoderAdapter = null;
        // Lazy load
    }

    _getAdapter() {
        // *** FIX: Ensure GeoRuntime is initialized before requesting adapter ***
        // This relies on GeoRuntime.init() being called globally in main.js
        // or the router guard.
        if (!this._geocoderAdapter) {
            try {
                // Request the *configured* geocoding adapter
                this._geocoderAdapter = this.geoRuntime.geocodingAdapter();
                if(!this._geocoderAdapter) throw new Error("GeoRuntime returned null geocoding adapter.");
            } catch (e) {
                log.error("Failed to get configured geocoding adapter from GeoRuntime:", e);
                throw e; // Re-throw if no adapter available
            }
        }
        return this._geocoderAdapter;
    }


    async geocode(address) {
        const hit = this.cache.get(address);
        if (hit) {
            log.debug("[GeocodeCache] Cache hit for address:", address);
            return hit;
        }
        log.debug("[GeocodeCache] Cache miss for address:", address);

        // *** FIX: Ensure adapter is requested *before* task execution if not already loaded ***
        try {
            this._getAdapter();
        } catch (e) {
            log.error("[GeocodeCache] Cannot geocode, adapter unavailable:", e.message);
            return null;
        }
        // *** END FIX ***

        const task = async () => {
            const adapter = this._getAdapter();
            const run = () => adapter.geocodeAddress(address);
            const result = await this.backoff.execute(run);
            if (result && typeof result.latitude === 'number' && typeof result.longitude === 'number') {
                log.debug("[GeocodeCache] Geocode success, caching:", address, result);
                this.cache.put(address, result);
            } else {
                log.debug("[GeocodeCache] Geocode returned null/empty or invalid coordinates, not caching:", address);
            }
            return result;
        };

        return task();
    }
}

const log = {
    debug: (...args) => console.debug(...args),
    error: (...args) => console.error(...args),
};

================================================================================
### PLIK: controllers/HealthGateController.js
================================================================================

/**
 * ARCHITECTURE: HealthGateController returns a stable readiness object without external dependencies.
 * It follows the manifesto by short-circuiting health checks in dev so the shell can render immediately.
 * Responsibilities:
 * - Delegate to RuntimeHealthService (which is dev-bypassed) and forward the normalized result.
 */
import { RuntimeHealthService } from "@/services/RuntimeHealthService";

export class HealthGateController {
  constructor(runtime = new RuntimeHealthService()) {
    this.runtime = runtime;
  }

  async readiness(googleKey) {
    const r = await this.runtime.readiness(googleKey);
    return { ok: !!r.ready, backend: !!r.backend?.ok, provider: !!r.provider?.ok, google: !!r.google?.ok };
  }
}


================================================================================
### PLIK: controllers/IdempotentSaveController.js
================================================================================

// ============================================================================
// Frontend: Update IdempotentSaveController (Supersedes previous version)
// FILE: src/controllers/IdempotentSaveController.js
// REASON: Refactor save() to accept the new /approve payload.
// ============================================================================
// FILE: src/controllers/IdempotentSaveController.js (Supersedes previous version)

import { Result } from "@/domain/Result";
// Removed: import { AddressPersistenceMapper } from "@/services/AddressPersistenceMapper";
import { IdempotencyTokenService } from "@/services/IdempotencyTokenService";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

/**
 * ARCHITECTURE: Wraps AddressExceptionApi with idempotency token generation.
 * REFACTORED:
 * - No longer uses AddressPersistenceMapper.
 * - Accepts the payload required by AddressExceptionApi.saveCorrection
 * (i.e., { barcode, resolveCoordinatesIfNeeded, ...other token fields... })
 */
export class IdempotentSaveController {
  constructor(api = new AddressExceptionApi(), mapper = null, tokens = new IdempotencyTokenService()) {
    this.api = api;
    // this.mapper = mapper; // No longer used
    this.tokens = tokens;
  }

  async save(payload) {
    const orderId = payload?.orderId;
    const side = payload?.side || "both";
    const barcode = payload?.barcode;
    const resolveFlag = payload?.resolveCoordinatesIfNeeded || false;

    if (!barcode) {
      return Result.fail(new Error("IdempotentSaveController: Barcode is required in payload."));
    }

    // Create the body that AddressExceptionApi.saveCorrection expects
    const body = {
      barcode: barcode,
      resolveCoordinatesIfNeeded: resolveFlag
    };

    // Generate token based on orderId, side, and the *intended* changes
    // (We still use 'after' for token generation, even if not sent in 'body')
    const tokenPayload = {
      after: payload?.after || null,
      resolve: resolveFlag
    };
    const token = this.tokens.create(orderId, side, JSON.stringify(tokenPayload));

    // Call the API
    const res = await this.api.saveCorrection(body, token);
    return res.ok ? Result.ok(res.value) : Result.fail(res.error);
  }
}

================================================================================
### PLIK: controllers/IntegrationOrchestrator.js
================================================================================

// ============================================================================
// Frontend: Update IntegrationOrchestrator (Final Version)
// FILE: src/controllers/IntegrationOrchestrator.js
// REASON: Instantiate GeocodeWithCacheController correctly.
// ============================================================================
// FILE: src/controllers/IntegrationOrchestrator.js
import { OrdersQueueService } from "@/services/OrdersQueueService";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";
import { PollingService } from "@/services/PollingService";
import { WorklistFacade } from "@/controllers/WorklistFacade";
import { CorrectionEditorController } from "@/controllers/CorrectionEditorController";
import { EditorFacade } from "@/controllers/EditorFacade";
// Import GeocodeWithCacheController
import { GeocodeWithCacheController } from "@/controllers/GeocodeWithCacheController";

/**
 * ARCHITECTURE: Central factory/provider for core application controllers and services.
 * Injects dependencies like GeoRuntime and MapController to construct facades.
 * REFACTORED: Requests adapters from GeoRuntime without specifying provider type.
 * FIX: Instantiates GeocodeWithCacheController here to pass to EditorFacade.
 */
export class IntegrationOrchestrator {
  constructor(geoRuntime, mapController) { // mapController might be null initially
    if (!geoRuntime) throw new Error("IntegrationOrchestrator requires a GeoRuntime instance.");
    this._geoRuntime = geoRuntime;
    this._mapController = mapController || null; // MapController instance (using configured map adapter)

    this.queue = new OrdersQueueService();
    this.api = new AddressExceptionApi();
    this.polling = new PollingService();
    this._worklist = null;
    this._editor = null;

    // Instantiate shared GeocodeWithCacheController using the provided GeoRuntime
    // This assumes GeoRuntime.init() will be called before geocodeController.geocode() is needed.
    this._geocodeController = new GeocodeWithCacheController(this._geoRuntime);
  }

  getWorklist() {
    if (this._worklist) return this._worklist;
    // Instantiate WorklistFacade on demand
    this._worklist = new WorklistFacade(this.polling);
    return this._worklist;
  }

  getEditor(mapControllerInstance = null) { // Allow passing map controller if created later
    // If an editor instance already exists, return it
    if (this._editor) {
      // If a new map controller is provided (e.g., editor view re-created), update it
      if (mapControllerInstance && this._editor.preview) {
        this._editor.preview.map = mapControllerInstance; // Update the map controller in the preview helper
      }
      return this._editor;
    }

    // Use the mapController passed during creation or the one provided now
    const effectiveMapController = mapControllerInstance || this._mapController;

    let placesAdapter = null; // Places adapter might be null if config is 'none'

    try {
      // Attempt to get the *configured* places adapter from the runtime
      // Geocoder is handled by the injected _geocodeController
      placesAdapter = this._geoRuntime.placesAdapter(); // May return null
      if(placesAdapter) {
        console.info("[IntegrationOrchestrator] Places adapter obtained for EditorFacade.");
      } else {
        console.info("[IntegrationOrchestrator] Places adapter is null/unavailable. Editor hints disabled.");
      }
    } catch(e) {
      console.error("IntegrationOrchestrator: Failed to get configured places adapter from GeoRuntime:", e.message);
      // Continue with null adapter
    }

    // Instantiate CorrectionEditorController, passing the shared GeocodeWithCacheController
    const ctrl = new CorrectionEditorController(this.api, this._geocodeController);

    // Instantiate EditorFacade, passing the relevant components
    this._editor = new EditorFacade(
        ctrl,
        effectiveMapController, // Pass the map controller instance
        placesAdapter,          // Pass potentially null places adapter
        this.queue              // Pass the orders queue
    );
    return this._editor;
  }
}

================================================================================
### PLIK: controllers/LoginFormController.js
================================================================================


================================================================================
### PLIK: controllers/MapController.js
================================================================================

/**
 * ARCHITECTURE: MapController coordinates a map adapter to create a map, update its marker, and recenter.
 * REFACTORED: Now supports distinct pickup/delivery markers and route drawing.
 */
export class MapController {
  constructor(mapAdapter) {
    this.adapter = mapAdapter;
    this._container = null;
    this._center = { lat: 52.2297, lon: 21.0122, zoom: 6 };
    this._ready = false;
  }

  async init(container, options) {
    this._container = container;
    const opt = options || this._center;
    await this.adapter.create(container, { lat: opt.lat, lon: opt.lon, zoom: opt.zoom });
    this._center = { lat: opt.lat, lon: opt.lon, zoom: opt.zoom };
    this._ready = true;
    return true;
  }

  // *** MODIFIED: This legacy method now controls the PICKUP marker ***
  async updateMarker(lat, lon, recenter = false) {
    return this.updatePickupMarker(lat, lon, recenter);
  }

  // *** NEW METHODS ***
  async updatePickupMarker(lat, lon, zoomTo = false) {
    if (!this._ready) throw new Error("MapController: map not initialized.");
    await this.adapter.setPickupMarker(lat, lon, zoomTo);
    if(zoomTo) this._center = { ...this._center, lat, lon };
    return true;
  }

  async updateDeliveryMarker(lat, lon, zoomTo = false) {
    if (!this._ready) throw new Error("MapController: map not initialized.");
    await this.adapter.setDeliveryMarker(lat, lon, zoomTo);
    if(zoomTo) this._center = { ...this._center, lat, lon };
    return true;
  }

  async drawRouteAndFit(pickupPos, deliveryPos) {
    if (!this._ready) throw new Error("MapController: map not initialized.");
    if (!pickupPos || !deliveryPos) return false;

    const routeDrawn = await this.adapter.drawRoute(pickupPos, deliveryPos);
    const boundsFitted = await this.adapter.fitBounds(pickupPos, deliveryPos);

    return routeDrawn && boundsFitted;
  }
  // *** END NEW METHODS ***

  async recenter(zoom) {
    if (!this._ready) throw new Error("MapController: map not initialized.");
    const z = typeof zoom === "number" ? zoom : this._center.zoom;
    await this.adapter.setCenter(this._center.lat, this._center.lon, z);
    this._center.zoom = z;
    return true;
  }

  async destroy() {
    await this.adapter.destroy();
    this._ready = false;
    this._container = null;
    return true;
  }
}

================================================================================
### PLIK: controllers/MapViewportPolicyController.js
================================================================================

/**
 * ARCHITECTURE: MapViewportPolicyController centralizes how the editor focuses the map on addresses.
 * It follows the manifesto by hiding viewport decisions behind a minimal, deterministic API.
 * Responsibilities:
 * - Focus on instant geocode or suggestion; update marker and optionally recenter.
 */
export class MapViewportPolicyController {
  constructor(mapController) {
    this.map = mapController;
  }

  async focusInstant(model) {
    const lat = Number(model?.latitude);
    const lon = Number(model?.longitude);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) return false;
    await this.map.updateMarker(lat, lon, true);
    return true;
  }

  async focusSuggestion(suggestion) {
    const lat = Number(suggestion?.latitude);
    const lon = Number(suggestion?.longitude);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) return false;
    await this.map.updateMarker(lat, lon, true);
    return true;
  }

  async focusAddress(addr) {
    const lat = Number(addr?.latitude);
    const lon = Number(addr?.longitude);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) return false;
    await this.map.updateMarker(lat, lon, true);
    return true;
  }
}


================================================================================
### PLIK: controllers/PlacesHintController.js
================================================================================

/**
 * ARCHITECTURE: PlacesHintController coordinates Google Places type-ahead hints with session tokens and debouncing.
 * It follows the manifesto by isolating vendor semantics and timing concerns behind a single suggest() method.
 * Responsibilities:
 * - Use GooglePlacesSessionManager to reuse/renew AutocompleteSessionToken.
 * - Debounce keystrokes, query Places adapter, and return normalized suggestions.
 */
import { GooglePlacesSessionManager } from "@/adapters/GooglePlacesSessionManager";
import { DebounceTimer } from "@/services/DebounceTimer";
import { SuggestionNormalizer } from "@/services/SuggestionNormalizer";

export class PlacesHintController {
  constructor(googleObj, placesAdapter, debounceMs = 250) {
    this.google = googleObj;
    this.places = placesAdapter;
    this.session = new GooglePlacesSessionManager(this.google);
    this.debounce = new DebounceTimer(debounceMs);
    this.normalizer = new SuggestionNormalizer();
  }

  async suggest(freeText, country = "PL") {
    return this.debounce.run(async () => {
      if (!this.places || !freeText || !freeText.trim()) return [];
      const token = this.session.getToken();
      void token;
      const raw = await this.places.suggest(freeText, country);
      return this.normalizer.normalizeBatch(raw, "PLACES");
    });
  }

  renewSession() {
    this.session.renew();
    return true;
  }
}


================================================================================
### PLIK: controllers/ProviderFallbackController.js
================================================================================


================================================================================
### PLIK: controllers/ProviderGuard.js
================================================================================

/**
 * ARCHITECTURE: ProviderGuard enforces that TES address provider is GOOGLE before verification flows run.
 * It follows the manifesto by isolating cross-cutting preconditions and exposing a single guard method.
 * Responsibilities:
 * - Read current provider via DANXILS-API proxy; if not GOOGLE, request it be set to GOOGLE.
 * - Since the backend uses Kafka, this involves initiating requests and polling for completion status.
 * - Cache the result to avoid redundant network calls during the session.
 */
import apiClient from "@/services/api";
import { TesOperationPoller } from "@/services/TesOperationPoller";

export class ProviderGuard {
    constructor(poller = new TesOperationPoller()) {
        this._aligned = false;
        this._inFlight = null;
        this._poller = poller;
    }

    async ensureGoogle() {
        if (this._aligned) return true;
        if (this._inFlight) return this._inFlight;

        this._inFlight = (async () => {
            try {
                const getCurrentResponse = await apiClient.get("/api/admin/address-verification/providers/current");
                if (getCurrentResponse.status !== 202 || !getCurrentResponse.data?.correlationId) {
                    throw new Error("Failed to initiate get-current-provider request.");
                }
                const currentProviderResult = await this._poller.waitFor(getCurrentResponse.data.correlationId);
                if (currentProviderResult.status !== 'COMPLETED') {
                    throw new Error(`Polling for current provider failed: ${currentProviderResult.errorDetails || 'Unknown error'}`);
                }

                const currentProviderName = currentProviderResult.result;
                if (typeof currentProviderName === 'string' && currentProviderName.toUpperCase() === "GOOGLE") {
                    this._aligned = true;
                    return true;
                }

                console.warn(`TES Provider is '${currentProviderName}', attempting to set to GOOGLE.`);
                const setProviderResponse = await apiClient.post("/api/admin/address-verification/providers/current", "GOOGLE", {
                    headers: { "Content-Type": "text/plain" },
                });
                if (setProviderResponse.status !== 202 || !setProviderResponse.data?.correlationId) {
                    throw new Error("Failed to initiate set-current-provider request.");
                }
                const setProviderResult = await this._poller.waitFor(setProviderResponse.data.correlationId);
                if (setProviderResult.status !== 'COMPLETED') {
                    throw new Error(`Polling for set provider failed: ${setProviderResult.errorDetails || 'Unknown error'}`);
                }

                this._aligned = true;
                console.log("Successfully requested TES provider alignment to GOOGLE.");
                return true;
            } catch (error) {
                this._aligned = false;
                console.error("ProviderGuard alignment failed:", error);
                throw new Error(`Failed to ensure TES provider is GOOGLE: ${error.message}`);
            } finally {
                this._inFlight = null;
            }
        })();

        return this._inFlight;
    }
}


================================================================================
### PLIK: controllers/QuickAcceptController.js
================================================================================

/**
 * ARCHITECTURE: QuickAcceptController enables one-click "best suggestion" acceptance per side.
 * It follows the manifesto by composing SuggestionSelectionController and EditorFacade.
 * Responsibilities:
 * - Compute best suggestion for the current input and apply it; return the applied index or null.
 */
import { SuggestionSelectionController } from "@/controllers/SuggestionSelectionController";

export class QuickAcceptController {
  constructor() {
    this.selector = new SuggestionSelectionController();
  }

  applyBest(side, baseInput, suggestions, editorFacade) {
    const best = this.selector.best(baseInput, suggestions);
    if (!best) return null;
    if (side === "pickup") editorFacade.acceptPickupSuggestion(best.index);
    if (side === "delivery") editorFacade.acceptDeliverySuggestion(best.index);
    return best.index;
  }
}


================================================================================
### PLIK: controllers/RealtimeVerificationOrchestrator.js
================================================================================

// FILE: src/controllers/RealtimeVerificationOrchestrator.js
// MODIFIED - Handle potentially null places adapter
import { DebounceTimer } from "@/services/DebounceTimer";
import { AddressSuggestionRanker } from "@/services/AddressSuggestionRanker";
import { SuggestionNormalizer } from "@/services/SuggestionNormalizer";
/**
 * ARCHITECTURE: Coordinates debounced input, geocode-with-cache, and optional places hints.
 * REFACTORED: Gets configured adapters from GeoRuntime.
 * Handles null places adapter gracefully.
 * *** FIX: Corrected constructor to accept GeoRuntime and GeocodeController. ***
 */
export class RealtimeVerificationOrchestrator {
    constructor(
        geoRuntime, // Inject GeoRuntime
        geocodeController, // Inject GeocodeWithCacheController
        debounceMs = 350
    ) {
        if (!geoRuntime || !geocodeController) throw new Error("GeoRuntime and GeocodeController are required.");
        this.geoRuntime = geoRuntime;
        this.geocode = geocodeController;

        // Attempt to get the *configured* places adapter, may be null
        try {
            this.places = this.geoRuntime.placesAdapter();
            // Returns null if config is 'none'
            if(this.places) {
                log.info("[RealtimeVerify] Places adapter successfully obtained.");
            } else {
                log.info("[RealtimeVerify] Places provider configured as 'none' or unavailable. Hints disabled.");
            }
        } catch(e) {
            log.warn("Could not get places adapter during RealtimeVerificationOrchestrator init:", e.message);
            this.places = null; // Ensure it's null on error
        }

        this.debouncer = new DebounceTimer(debounceMs);
        this.ranker = new AddressSuggestionRanker();
        this.normalizer = new SuggestionNormalizer();
    }

    async verify(baseInput) {
        return this.debouncer.run(async () => {
            const t0 = performance.now ? performance.now() : Date.now();

            const geocodePromise = this.geocode.geocode(baseInput);
            // Only call places if the adapter is available
            const placesPromise = this.places
                ? this.places.suggest(this._freeText(baseInput), baseInput.country || "PL")
                : Promise.resolve([]); // Resolve empty if no places adapter

            const [geoResult, placeRaw] = await Promise.all([geocodePromise, placesPromise]);

            const instant = geoResult
                ? this.mapGeoResultToSuggestion(geoResult, baseInput) // Use helper
                : null;

            // Normalize places results (will be empty if this.places is null)
            const placesSuggestions = this.normalizer.normalizeBatch(placeRaw, "PLACES_DETAIL"); // Assume details if Places ran

            const merged = instant ? [instant, ...placesSuggestions] : [...placesSuggestions];
            const ranked = this.ranker.rank(baseInput, merged);
            const t1 = performance.now ? performance.now() : Date.now();
            return { instant, suggestions: ranked, elapsedMs: Math.round(t1 - t0) };
        });
    }

    mapGeoResultToSuggestion(geoResult, baseInput, providerSource = "GEOCODER_CLIENT") {
        if (!geoResult) return null;
        // Determine provider source based on adapter type if possible
        let source = providerSource;
        if (geoResult._provider === 'Google') source = 'GOOGLE_CLIENT';
        else if (geoResult._provider === 'Nominatim') source = 'NOMINATIM_CLIENT';
        return {
            fullAddressLabel: geoResult._displayName || `${geoResult.street ||
            ''} ${geoResult.houseNumber || ''}, ${geoResult.postalCode || ''} ${geoResult.city || ''}`.replace(/ ,|,$/,'').trim(),
            street: geoResult.street ||
                null,
            houseNumber: geoResult.houseNumber ||
                null,
            postalCode: geoResult.postalCode ||
                null,
            city: geoResult.city ||
                null,
            countryCode: geoResult.country || baseInput?.country ||
                "PL",
            countryName: null,
            latitude: geoResult.latitude ??
                null,
            longitude: geoResult.longitude ??
                null,
            matchScore: geoResult._confidence ??
                0.8,
            matchLevel: geoResult._locationType || geoResult._osmType ||
                "GEOCODER",
            providerSource: source,
        };
    }

    _freeText(a) {
        const line1 = a?.houseNumber ? `${a.street ||
        ''} ${a.houseNumber}` : a?.street || "";
        return `${line1}, ${a?.postalCode || ""} ${a?.city || ""}`.trim();
    }
}

const log = {
    info: (...args) => console.info(...args),
    debug: (...args) => console.debug(...args),
    warn: (...args) => console.warn(...args),
    error: (...args) => console.error(...args),
};

================================================================================
### PLIK: controllers/SafeSaveController.js
================================================================================

/**
 * ARCHITECTURE: SafeSaveController guards persistence with equality checks and idempotency keys.
 * It follows the manifesto by preventing duplicate saves and short-circuiting when nothing changed.
 * Responsibilities:
 * - Compute a change key using AddressEqualityService; skip save if unchanged.
 * - Generate an idempotency token to pass to backend headers when available.
 */
import { AddressEqualityService } from "@/services/AddressEqualityService";

export class SafeSaveController {
  constructor(saver, equality = new AddressEqualityService()) {
    this.saver = saver;
    this.eq = equality;
    this._lastKey = null;
  }

  async saveIfChanged(payload) {
    const before = payload?.before || {};
    const after = payload?.after || {};
    const key = this._keyOf(before, after, payload?.orderId, payload?.side, payload?.resolution);
    if (key === this._lastKey) return { skipped: true, reason: "Duplicate save call" };
    const changed =
      (after.pickup && !this.eq.equals(before.pickup || {}, after.pickup)) ||
      (after.delivery && !this.eq.equals(before.delivery || {}, after.delivery));
    if (!changed) return { skipped: true, reason: "No changes" };
    const res = await this.saver.save(payload);
    if (res?.ok) this._lastKey = key;
    return { skipped: false, result: res };
  }

  _keyOf(before, after, orderId, side, resolution) {
    const h = (a) => this.eq.hash(a || {});
    return [orderId || "", side || "", resolution || "", h(before?.pickup), h(before?.delivery), h(after?.pickup), h(after?.delivery)].join("#");
  }
}


================================================================================
### PLIK: controllers/SaveAndNextController.js
================================================================================

/**
 * ARCHITECTURE: SaveAndNextController coordinates saving an address correction and loading the next order.
 * It follows the manifesto by composing persistence, queue sequencing, and editor orchestration behind one method.
 * Responsibilities:
 * - Execute a provided save function, remove current id from queue on success, and resolve the next id.
 * - Short-circuit when the queue is empty and return null for end-of-queue conditions.
 */
import { Result } from "@/domain/Result";

export class SaveAndNextController {
  constructor(ordersQueue, editorController) {
    this.queue = ordersQueue;
    this.editor = editorController;
  }

  async saveThenNext(saveFn) {
    const currentId = this.queue.current();
    if (!currentId) return Result.ok(null);
    const res = await saveFn();
    if (!res || res.ok === false) {
      const err = res?.error || new Error("Save failed.");
      return Result.fail(err);
    }
    this.queue.remove(currentId);
    const nextId = this.queue.current() || this.queue.next();
    if (!nextId) return Result.ok(null);
    const load = await this.editor.loadOrder(nextId);
    if (!load.ok) return Result.fail(load.error);
    return Result.ok(nextId);
  }
}


================================================================================
### PLIK: controllers/SaveFlowController.js
================================================================================

// ============================================================================
// Frontend: Update SaveFlowController (Final Version)
// FILE: src/controllers/SaveFlowController.js
// REASON: Correctly builds payload for /approve endpoint and calls idempotent saver.
// ============================================================================
// FILE: src/controllers/SaveFlowController.js
import { Result } from "@/domain/Result";
import { AddressEqualityService } from "@/services/AddressEqualityService"; // For diff check

/**
 * ARCHITECTURE: SaveFlowController orchestrates saving pickup/delivery/both and computing next item.
 * REFACTORED:
 * - Constructs the payload for the /api/orders/{barcode}/approve endpoint.
 * - Determines 'resolveCoordinatesIfNeeded' based on mission logic.
 * - Calls the injected 'idempotentSaveController'.
 */
export class SaveFlowController {
  constructor(editorFacade, queueService, idempotentSaveController) {
    if (!editorFacade) throw new Error("SaveFlowController requires an EditorFacade.");
    if (!queueService) throw new Error("SaveFlowController requires a QueueService.");
    if (!idempotentSaveController) throw new Error("SaveFlowController requires an IdempotentSaveController.");

    this.editor = editorFacade;
    this.queue = queueService;
    this.saveController = idempotentSaveController; // This is an IdempotentSaveController
    this.eq = new AddressEqualityService(); // For diff checking
  }

  async saveThenAwait(side = "both") {
    const snap = this.editor.snapshot();
    // Get necessary data from the editor snapshot
    const orderId = snap.currentOrderId || snap.editor?.detail?.orderId || null;
    const barcode = snap.editor?.detail?.barcode || null;
    const sourceSystem = snap.editor?.detail?.sourceSystem || null; // Get source system

    if (!orderId || !barcode) {
      log.error("[SaveFlow] Cannot save: Missing orderId or barcode in editor state.");
      return Result.fail(new Error("SaveFlow: no order id or barcode found in editor state."));
    }

    // --- Logic for resolveCoordinatesIfNeeded ---
    const allowedSources = ["DANXILS_API", "AED_SFTP", "GW_SFTP", "WMS_PINQUARK", "DANXILS_API_MULTI"]; // Added MULTI
    const originalPickup = snap.editor?.detail?.originalPickup || null;
    const originalDelivery = snap.editor?.detail?.originalDelivery || null;
    // Stored address reflects the state *before* this correction attempt (from alias check)
    const storedPickup = snap.editor?.detail?.pickupStoredAddress || null;
    const storedDelivery = snap.editor?.detail?.deliveryStoredAddress || null;
    // Edited address is the user's current input/selection
    const editedPickup = snap.editor?.editedPickup || null;
    const editedDelivery = snap.editor?.editedDelivery || null;

    let resolveCoordinatesIfNeeded = false;

    if (allowedSources.includes(sourceSystem)) {
      let pickupIsNewAndChanged = false;
      let deliveryIsNewAndChanged = false;

      // Check pickup side if it's being saved
      if ((side === "pickup" || side === "both") && editedPickup) {
        // "Brand new" means no stored address existed (it was an ALIAS_NOT_FOUND result from TES)
        // AND the user has manually edited it or accepted a suggestion (it's not the same as the original)
        const pickupChangedFromOriginal = !this.eq.equals(originalPickup, editedPickup);
        if (storedPickup === null && pickupChangedFromOriginal) {
          pickupIsNewAndChanged = true;
        }
      }

      // Check delivery side if it's being saved
      if ((side === "delivery" || side === "both") && editedDelivery) {
        const deliveryChangedFromOriginal = !this.eq.equals(originalDelivery, editedDelivery);
        if (storedDelivery === null && deliveryChangedFromOriginal) {
          deliveryIsNewAndChanged = true;
        }
      }

      // Set flag if either side represents a new, modified address from an allowed source
      if (pickupIsNewAndChanged || deliveryIsNewAndChanged) {
        resolveCoordinatesIfNeeded = true;
      }
    }

    log.info(`[SaveFlow] For Barcode: ${barcode}, Source: ${sourceSystem}, ResolveCoords: ${resolveCoordinatesIfNeeded} (Save Side: ${side})`);
    // --- End Logic for resolveCoordinatesIfNeeded ---

    // Construct the payload expected by IdempotentSaveController's save method,
    // which in turn calls AddressExceptionApi.saveCorrection (the /approve endpoint)
    const payload = {
      barcode: barcode, // Required by the /approve endpoint
      resolveCoordinatesIfNeeded: resolveCoordinatesIfNeeded, // Flag for backend
      // Include fields needed for Idempotency Token generation within IdempotentSaveController
      orderId: orderId,
      side: side,
      // 'after' represents the state being saved
      after: {
        pickup: (side === "pickup" || side === "both") ? editedPickup : null,
        delivery: (side === "delivery" || side === "both") ? editedDelivery : null
      }
    };

    // Call the IdempotentSaveController which handles the actual API call
    const saveResult = await this.saveController.save(payload);

    // Check the result format from IdempotentSaveController
    // It returns { skipped: boolean, result: Result }
    if (saveResult?.skipped) {
      log.warn(`[SaveFlow] Save skipped for Barcode ${barcode}. Reason: ${saveResult.reason}`);
      // If skipped, it's not a failure, but we don't advance the queue
      // Or do we? If it's a duplicate save, we might want to advance.
      // For now, let's treat skipped as "not saved this time"
      return Result.ok({ success: true, skipped: true, nextOrderId: null }); // Indicate skipped
    }

    if (!saveResult || !saveResult.result || !saveResult.result.ok) {
      const error = saveResult?.result?.error || new Error("Save failed or invalid response from save controller.");
      log.error(`[SaveFlow] Save failed for Barcode ${barcode}.`, error);
      return Result.fail(error); // Return failure
    }

    // Save was successful
    const currentQueueId = this.queue.current();
    if (currentQueueId === orderId) { // Double check we are removing the correct item
      this.queue.remove(currentQueueId);
      log.info(`[SaveFlow] Removed Order ID ${currentQueueId} from queue after successful save.`);
    } else {
      log.warn(`[SaveFlow] Current queue ID '${currentQueueId}' does not match saved Order ID '${orderId}'. Queue state might be inconsistent.`);
    }

    const nextId = this.queue.current() || this.queue.next(); // Get next ID
    log.info(`[SaveFlow] Save successful for Barcode ${barcode}. Next Order ID in queue: ${nextId || 'None'}`);

    return Result.ok({ success: true, skipped: false, nextOrderId: nextId }); // Indicate success and provide next ID
  }
}

// Basic logger shim
const log = {
  info: (...args) => console.info(...args),
  warn: (...args) => console.warn(...args),
  error: (...args) => console.error(...args),
};

================================================================================
### PLIK: controllers/SuggestionListController.js
================================================================================

/**
 * ARCHITECTURE: SuggestionListController manages selection and application of ranked suggestions.
 * It follows the manifesto by isolating list state from UI and delegating application to EditorFacade.
 * Responsibilities:
 * - Hold a cursor over suggestions, navigate next/prev, and apply current suggestion to pickup or delivery.
 * - Coordinate map viewport focusing for visual confirmation.
 */
import { SuggestionSelectionController } from "@/controllers/SuggestionSelectionController";
import { MapViewportPolicyController } from "@/controllers/MapViewportPolicyController";

export class SuggestionListController {
  constructor(editorFacade, mapController) {
    this.editor = editorFacade;
    this.selector = new SuggestionSelectionController();
    this.viewport = new MapViewportPolicyController(mapController);
    this.items = [];
    this.index = -1;
  }

  load(list) {
    this.items = Array.isArray(list) ? list.slice() : [];
    this.index = this.items.length ? 0 : -1;
    return this.snapshot();
  }

  select(i) {
    if (typeof i !== "number" || i < 0 || i >= this.items.length) return this.snapshot();
    this.index = i;
    return this.snapshot();
  }

  next() {
    if (this.items.length === 0) return this.snapshot();
    this.index = Math.min(this.items.length - 1, this.index + 1);
    return this.snapshot();
  }

  prev() {
    if (this.items.length === 0) return this.snapshot();
    this.index = Math.max(0, this.index - 1);
    return this.snapshot();
  }

  async applyTo(side = "pickup") {
    if (this.index < 0 || this.index >= this.items.length) return false;
    const sel = { index: this.index, suggestion: this.items[this.index] };
    const ok = this.selector.accept(this.editor, side, sel);
    if (ok) await this.viewport.focusSuggestion(sel.suggestion);
    return ok;
  }

  snapshot() {
    return {
      items: this.items.slice(),
      index: this.index,
      current: this.index >= 0 ? this.items[this.index] : null,
    };
  }
}


================================================================================
### PLIK: controllers/SuggestionPreviewController.js
================================================================================

/**
 * ARCHITECTURE: SuggestionPreviewController coordinates map focusing for a chosen suggestion.
 * It follows the manifesto by isolating viewport behavior from editor and views.
 * Responsibilities:
 * - Show a suggestion on the map by updating marker and recentering using MapViewportPolicyController.
 */
import { MapViewportPolicyController } from "@/controllers/MapViewportPolicyController";

export class SuggestionPreviewController {
  constructor(mapController) {
    this.map = mapController;
    this.policy = new MapViewportPolicyController(mapController);
  }

  async show(suggestion) {
    if (!suggestion) return false;
    return await this.policy.focusSuggestion(suggestion);
  }
}


================================================================================
### PLIK: controllers/SuggestionSelectionController.js
================================================================================

/**
 * ARCHITECTURE: SuggestionSelectionController selects and applies suggestions deterministically.
 * It follows the manifesto by keeping scoring and application separate from UI and transport.
 * Responsibilities:
 * - Pick the best suggestion; apply a chosen index to the editor facade for a given side.
 */
export class SuggestionSelectionController {
  best(baseInput, suggestions) {
    const list = Array.isArray(suggestions) ? suggestions : [];
    if (!list.length) return null;
    let bestIndex = 0;
    let bestScore = -Infinity;
    for (let i = 0; i < list.length; i++) {
      const s = list[i] || {};
      const score = this._score(baseInput, s);
      if (score > bestScore) {
        bestScore = score;
        bestIndex = i;
      }
    }
    return { index: bestIndex, suggestion: list[bestIndex] };
  }

  accept(editorFacade, side, sel) {
    if (!sel || typeof sel.index !== "number") return false;
    if (side === "pickup") {
      const r = editorFacade.acceptPickupSuggestion(sel.index);
      return !!r?.ok;
    }
    if (side === "delivery") {
      const r = editorFacade.acceptDeliverySuggestion(sel.index);
      return !!r?.ok;
    }
    return false;
  }

  _score(base, sug) {
    let score = 0;
    if (typeof sug.matchScore === "number") score += sug.matchScore * 100;
    if (this._eq(base?.city, sug?.city)) score += 5;
    if (this._eq(base?.postalCode, sug?.postalCode)) score += 10;
    if (this._eq(base?.street, sug?.street)) score += 3;
    return score;
  }

  _eq(a, b) {
    return (a || "").toString().trim().toLowerCase() === (b || "").toString().trim().toLowerCase();
  }
}


================================================================================
### PLIK: controllers/TesSuggestionController.js
================================================================================

/**
 * ARCHITECTURE: TesSuggestionController starts TES suggest/search operations and collects results via poller.
 * It follows the manifesto by separating TES IO from UI and merging outputs through a stable contract.
 * Responsibilities:
 * - Trigger suggest-on-demand or search-by-name; poll until done; return normalized suggestions.
 * - Delegate normalization/merging to provided collaborators without leaking TES DTOs to callers.
 */
import apiClient from "@/services/api";
import { TesOperationPoller } from "@/services/TesOperationPoller";
import { SuggestionNormalizer } from "@/services/SuggestionNormalizer";
import { AddressSuggestionMerger } from "@/services/AddressSuggestionMerger";
import { AddressSuggestionRanker } from "@/services/AddressSuggestionRanker";

export class TesSuggestionController {
  constructor(poller = new TesOperationPoller(), normalizer = new SuggestionNormalizer(), merger = new AddressSuggestionMerger(), ranker = new AddressSuggestionRanker()) {
    this.poller = poller;
    this.normalizer = normalizer;
    this.merger = merger;
    this.ranker = ranker;
  }

  async suggestOnDemand(addressDto, baseInputForRanking = null) {
    const start = await apiClient.post("/api/admin/address-verification/suggest-on-demand", addressDto);
    const cid = start?.data?.correlationId;
    if (!cid) throw new Error("TesSuggestionController: missing correlationId.");
    const done = await this.poller.waitFor(cid);
    if (done.status !== "COMPLETED") return [];
    const raw = done.result?.suggestions || [];
    const normalized = this.normalizer.normalizeBatch(raw, "TES");
    const merged = this.merger.merge(baseInputForRanking || addressDto, [normalized]);
    return this.ranker.rank(baseInputForRanking || addressDto, merged);
  }

  async searchByName(query, baseInputForRanking = null) {
    const start = await apiClient.post("/api/admin/address-verification/search-by-name", query, { headers: { "Content-Type": "text/plain" } });
    const cid = start?.data?.correlationId;
    if (!cid) throw new Error("TesSuggestionController: missing correlationId.");
    const done = await this.poller.waitFor(cid);
    if (done.status !== "COMPLETED") return [];
    const raw = done.result?.suggestions || [];
    const normalized = this.normalizer.normalizeBatch(raw, "TES");
    const merged = this.merger.merge(baseInputForRanking || {}, [normalized]);
    return this.ranker.rank(baseInputForRanking || {}, merged);
  }
}


================================================================================
### PLIK: controllers/TriageDashboardController.js
================================================================================

// ============================================================================
// Frontend: Fix TriageDashboardController
// FILE: src/controllers/TriageDashboardController.js (Supersedes previous version)
// REASON: Remove call to non-existent 'getRecentBatches' method.
// ============================================================================
// FILE: src/controllers/TriageDashboardController.js
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";
import { PollingService } from "@/services/PollingService";

export class TriageDashboardController {
  constructor(api = new AddressExceptionApi(), polling = new PollingService()) {
    this.api = api;
    this.polling = polling;
    this.loading = false;
    this.error = null;
    this.kpis = null;
    this.recentBatches = [];
    this.pendingByErrorType = [];
    this._pollHandles = [];
  }

  async loadAll() {
    this.loading = true;
    this.error = null;

    // *** MODIFICATION: Removed getRecentBatches() call ***
    const [kpiRes, typeRes] = await Promise.all([
      this.api.getTriageKpis(),
      // this.api.getRecentBatches(), // <-- REMOVED THIS LINE
      this.api.getPendingByErrorType(),
    ]);
    // *** END MODIFICATION ***

    // Safety check for kpiRes (solves 'items' of undefined)
    if (!kpiRes.ok) return this._fail(kpiRes.error);
    if (!kpiRes.value) {
      console.warn("TriageDashboardController: getTriageKpis returned OK but value is null/undefined.");
      this.kpis = { pendingReviewCount: 0, automatedClearancePercent: 0, avgResolutionMinutes: null };
    } else {
      this.kpis = kpiRes.value;
    }

    // Safety check for batchRes (Set to empty array)
    this.recentBatches = [];

    // Safety check for typeRes
    if (!typeRes.ok) return this._fail(typeRes.error);
    this.pendingByErrorType = Array.isArray(typeRes.value) ? typeRes.value : [];

    this.loading = false;
    return Result.ok(this.snapshot());
  }

  startPolling(intervalMs = 10000) {
    this.stopPolling();
    const k = this.polling.start("kpis", intervalMs, async () => {
      const r = await this.api.getTriageKpis();
      if (r.ok && r.value) this.kpis = r.value;
    });
    // *** MODIFICATION: Removed polling for batches ***
    // const b = this.polling.start("batches", intervalMs, async () => {
    //   const r = await this.api.getRecentBatches();
    //   if (r.ok) this.recentBatches = Array.isArray(r.value) ? r.value : [];
    // }); [cite: 1089-1090]
    // *** END MODIFICATION ***
    const e = this.polling.start("errorsByType", intervalMs, async () => {
      const r = await this.api.getPendingByErrorType();
      if (r.ok) this.pendingByErrorType = Array.isArray(r.value) ? r.value : [];
    });
    this._pollHandles = [k, e]; // Removed 'b' from handles [cite: 1091]
    return this._pollHandles.slice();
  }

  stopPolling() {
    this.polling.stopAll();
    this._pollHandles = [];
  }

  snapshot() {
    return {
      loading: this.loading,
      error: this.error,
      kpis: this.kpis,
      recentBatches: this.recentBatches.slice(),
      pendingByErrorType: this.pendingByErrorType.slice(),
    };
  }

  _fail(err) {
    this.loading = false;
    this.error = err?.message || "Dashboard load failed.";
    return Result.fail(err);
  }
}

================================================================================
### PLIK: controllers/VerificationGuardController.js
================================================================================

/**
 * ARCHITECTURE: VerificationGuardController prevents unnecessary verification calls when input is incomplete.
 * It follows the manifesto by enforcing minimal field requirements before hitting providers.
 * Responsibilities:
 * - Check street, postal, and city presence; expose shouldVerify() with reason codes for UI hints.
 * - Reduce wasted quota and noise during live typing.
 */
export class VerificationGuardController {
  constructor() {
    this.required = ["street", "postalCode", "city"];
  }

  shouldVerify(input) {
    const missing = [];
    for (const f of this.required) {
      if (!input || !String(input[f] || "").trim()) missing.push(f);
    }
    if (missing.length) return { allow: false, reason: "MISSING_FIELDS", missing };
    return { allow: true, reason: "OK", missing: [] };
  }
}


================================================================================
### PLIK: controllers/VerificationPipelineController.js
================================================================================

/**
 * ARCHITECTURE: VerificationPipelineController composes timeout, merger, and ranking into a single step.
 * It follows the manifesto by hiding orchestration details behind a single run() method.
 * Responsibilities:
 * - Execute geocode + places + TES with budgets; merge and rank; return final suggestions list.
 */
import { VerificationTimeoutController } from "@/controllers/VerificationTimeoutController";
import { AddressSuggestionMerger } from "@/services/AddressSuggestionMerger";
import { AddressSuggestionRanker } from "@/services/AddressSuggestionRanker";

export class VerificationPipelineController {
  constructor(timeoutController, merger = new AddressSuggestionMerger(), ranker = new AddressSuggestionRanker()) {
    this.timeout = timeoutController;
    this.merger = merger;
    this.ranker = ranker;
  }

  async run(baseInput, ms = 1500) {
    const phased = await this.timeout.verifyWithin(baseInput, ms);
    const merged = this.merger.merge(baseInput, [phased.suggestions]);
    const ranked = this.ranker.rank(baseInput, merged);
    return { instant: phased.instant, suggestions: ranked, elapsed: phased.elapsed };
  }
}


================================================================================
### PLIK: controllers/VerificationTelemetryController.js
================================================================================

/**
 * ARCHITECTURE: VerificationTelemetryController (Stub) would be responsible for
 * emitting detailed, structured telemetry events specific to the address
 * verification lifecycle (e.g., timings, provider success/fail, user choices).
 * Composes the base TelemetryService.
 */
import { TelemetryService } from "@/services/TelemetryService"; // Assuming base service exists

export class VerificationTelemetryController {
    constructor(telemetryService = new TelemetryService()) {
        this.telemetry = telemetryService;
        this.currentCorrelation = null;
        this.startTime = 0;
    }

    /**
     * Starts a new verification telemetry trace.
     * @param {string} correlationId - A unique ID for this verification flow.
     * @returns {string} The correlation ID.
     */
    start(correlationId) {
        this.currentCorrelation = correlationId || `telemetry-${Date.now()}-${Math.random()}`;
        this.startTime = Date.now();
        this.telemetry.emit({
            category: "verification",
            name: "start",
            corr: this.currentCorrelation,
        });
        return this.currentCorrelation;
    }

    /**
     * Marks a specific milestone within the verification flow.
     * @param {string} name - Name of the milestone (e.g., "verify-start", "geocode-finish").
     * @param {object} data - Additional context data.
     */
    mark(name, data = {}) {
        this.telemetry.emit({
            category: "verification",
            name: name,
            data: {
                ...data,
                elapsedMs: Date.now() - this.startTime,
            },
            corr: this.currentCorrelation,
        });
    }

    /**
     * Finishes the verification telemetry trace with a final status.
     * @param {string} status - The final outcome (e.g., "ok", "save-failed", "invalid").
     * @param {object} data - Additional context data.
     */
    finish(status, data = {}) {
        this.telemetry.emit({
            category: "verification",
            name: "finish",
            data: {
                ...data,
                status,
                totalElapsedMs: Date.now() - this.startTime,
            },
            corr: this.currentCorrelation,
        });
        // Clear context for the next trace
        this.currentCorrelation = null;
        this.startTime = 0;
    }
}

================================================================================
### PLIK: controllers/VerificationTimeoutController.js
================================================================================

/**
 * ARCHITECTURE: VerificationTimeoutController applies latency budgets to geocode and suggestion steps.
 * It follows the manifesto by composing LatencyBudget with provider adapters to keep UI responsive.
 * Responsibilities:
 * - Run geocode and suggestions with independent timeouts; return partial results when needed.
 * - Provide verifyWithin() that yields {instant,suggestions,elapsed:{geo,suggest}}.
 */
import { LatencyBudget } from "@/services/LatencyBudget";

export class VerificationTimeoutController {
  constructor(geocodeController, placesAdapter, tesController, budget = new LatencyBudget()) {
    this.geocode = geocodeController;
    this.places = placesAdapter;
    this.tes = tesController;
    this.budget = budget;
  }

  async verifyWithin(baseInput, ms = 1200) {
    const geo = await this.budget.runWithTimeout(() => this.geocode.geocode(baseInput), ms, null);
    const places = await this.budget.runWithTimeout(
      () => (this.places ? this.places.suggest(this._freeText(baseInput), baseInput.country || "PL") : Promise.resolve([])),
      ms,
      []
    );
    const tes = await this.budget.runWithTimeout(() => this.tes.suggestOnDemand(baseInput, baseInput), ms * 2, []);
    return {
      instant: geo.value ? { latitude: geo.value.lat ?? null, longitude: geo.value.lon ?? null } : null,
      suggestions: ([]).concat(places.value || []).concat(tes.value || []),
      elapsed: { geocodeMs: geo.elapsedMs, placesMs: places.elapsedMs, tesMs: tes.elapsedMs },
    };
  }

  _freeText(a) {
    const line1 = a.houseNumber ? `${a.street} ${a.houseNumber}` : a.street || "";
    return `${line1}, ${a.postalCode || ""} ${a.city || ""}`.trim();
  }
}


================================================================================
### PLIK: controllers/WorklistExportController.js
================================================================================

/**
 * ARCHITECTURE: WorklistExportController generates CSV exports for selected/all rows from the worklist.
 * It follows the manifesto by isolating export formatting from views and transport concerns.
 * Responsibilities:
 * - exportSelected(items, ids): download CSV for selected IDs.
 * - exportAll(items): download CSV for all current rows.
 */
export class WorklistExportController {
  constructor() {
    this.headers = [
      "orderId",
      "customerName",
      "source",
      "errorType",
      "processingStatus",
      "updatedAt",
    ];
  }

  exportSelected(items, ids) {
    const set = new Set(Array.isArray(ids) ? ids : []);
    const rows = (Array.isArray(items) ? items : []).filter(r => set.has(r.orderId));
    if (!rows.length) return false;
    return this._download(rows, "worklist_selected.csv");
  }

  exportAll(items) {
    const rows = Array.isArray(items) ? items : [];
    if (!rows.length) return false;
    return this._download(rows, "worklist_all.csv");
  }

  _download(rows, filename) {
    const csv = this._toCsv(rows);
    const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.href = url;
    link.download = filename || "export.csv";
    link.style.display = "none";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    return true;
  }

  _toCsv(rows) {
    const head = this.headers.join(",");
    const lines = rows.map(r => this.headers.map(h => this._esc(r?.[h])).join(","));
    return [head, ...lines].join("\n");
  }

  _esc(v) {
    const s = (v == null ? "" : String(v));
    if (/[",\n]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
    return s;
  }
}


================================================================================
### PLIK: controllers/WorklistFacade.js
================================================================================

// FILE: src/controllers/WorklistFacade.js
import { useWorklistStore } from "@/stores/worklistStore";
import { PollingService } from "@/services/PollingService";
import { Result } from "@/domain/Result";

export class WorklistFacade {
    constructor(polling = new PollingService()) {
        this._store = useWorklistStore();
        this.poll = polling;
        this._pollHandle = null;
    }

    async initAndLoad(filters = {}) {
        if (Object.keys(filters).length > 0) {
            this._store.filter = this._store.filter.withPatch(filters);
            this._store.pagination.currentPage = 1;
        }
        const result = await this._store.loadWorklistPage();
        return result.ok ? Result.ok(this.snapshot()) : Result.fail(result.error);
    }

    startPolling(intervalMs = 15000) {
        if (this._pollHandle) {
            this.stopPolling();
        }
        this._pollHandle = this.poll.start("worklist", intervalMs, async () => {
            // CORRECTED: Use the correct store action name 'loadWorklistPage'
            await this._store.loadWorklistPage();
        });
        // Removed console.log for production readiness
        return true;
    }

    stopPolling() {
        if (this._pollHandle) {
            this.poll.stop("worklist");
            this._pollHandle = null;
            // Removed console.log for production readiness
            return true;
        }
        return false;
    }

    snapshot() {
        return {
            filter: { ...this._store.filter },
            items: [...this._store.items],
            pagination: { ...this._store.pagination },
            loading: this._store.loading,
            error: this._store.error,
            selection: [...this._store.selection],
        };
    }

    async applyFilterPatch(patch) {
        return await this._store.applyFilterPatch(patch);
    }

    async resetFilter() {
        return await this._store.resetFilter();
    }

    async goToPage(pageNumber) {
        return await this._store.goToPage(pageNumber);
    }

    async changePageSize(size) {
        return await this._store.changePageSize(size);
    }

    toggleSelection(orderId) {
        this._store.toggleSelection(orderId);
    }

    clearSelection() {
        this._store.clearSelection();
    }

    getSelection() {
        return [...this._store.selection];
    }
}

================================================================================
### PLIK: controllers/WorklistKpiController.js
================================================================================

/**
 * ARCHITECTURE: WorklistKpiController computes KPIs from the current worklist dataset.
 * It follows the manifesto by isolating KPI math from views and data transport.
 * Responsibilities:
 * - Compute pending review count, automated clearance percent, and average resolution minutes.
 * - Return a KpiViewModel ready to render in the dashboard.
 */
import { KpiViewModel } from "@/viewmodels/KpiViewModel";

export class WorklistKpiController {
  compute(items) {
    const arr = Array.isArray(items) ? items : [];

    const total = arr.length;
    const pending = arr.filter(x => (x?.processingStatus || "").toUpperCase() === "ADDRESS_NEEDS_REVIEW").length;
    const autoCleared = arr.filter(x => (x?.processingStatus || "").toUpperCase() === "ADDRESS_VALIDATED").length;

    const clearancePercent = total > 0 ? (autoCleared / total) * 100 : 0;

    const minutes = [];
    for (const r of arr) {
      const created = r?.createdAt ? new Date(r.createdAt).getTime() : null;
      const updated = r?.updatedAt ? new Date(r.updatedAt).getTime() : null;
      if (created && updated && updated >= created) {
        const diffMin = (updated - created) / 60000;
        if (Number.isFinite(diffMin)) minutes.push(diffMin);
      }
    }
    const avgMinutes = minutes.length ? minutes.reduce((a, b) => a + b, 0) / minutes.length : 0;

    return new KpiViewModel({
      pending,
      clearancePercent,
      avgMinutes,
    });
  }
}


================================================================================
### PLIK: controllers/WorklistSelectionController.js
================================================================================

/**
 * ARCHITECTURE: WorklistSelectionController manages single, multi, and range selections in the grid.
 * It follows the manifesto by isolating selection math from visual components.
 * Responsibilities:
 * - Toggle, select range with anchors, and expose a stable array of selected IDs.
 */
export class WorklistSelectionController {
  constructor() {
    this._selected = new Set();
    this._lastAnchorIndex = null;
  }

  toggle(id, index) {
    if (this._selected.has(id)) this._selected.delete(id);
    else this._selected.add(id);
    this._lastAnchorIndex = typeof index === "number" ? index : this._lastAnchorIndex;
    return this.ids();
  }

  set(ids) {
    this._selected = new Set(Array.isArray(ids) ? ids : []);
    return this.ids();
  }

  clear() {
    this._selected.clear();
    this._lastAnchorIndex = null;
    return [];
  }

  range(allIds, toIndex) {
    if (!Array.isArray(allIds) || typeof this._lastAnchorIndex !== "number" || typeof toIndex !== "number") return this.ids();
    const [a, b] = [this._lastAnchorIndex, toIndex].sort((x, y) => x - y);
    for (let i = a; i <= b; i++) this._selected.add(allIds[i]);
    return this.ids();
  }

  ids() {
    return Array.from(this._selected.values());
  }
}


================================================================================
### PLIK: assets/main.css
================================================================================

/* ARCHITECTURE: Base styles kept tiny and neutral. */
:root { color-scheme: light; }
body { background:#fff; color:#111; }

================================================================================
### PLIK: assets/theme.css
================================================================================

/* ARCHITECTURE: Base theme variables and minimal global styles */
:root {
    --color-primary: #005A9C; /* A solid blue */
    --color-secondary: #FFC107; /* A bright yellow */
    --color-background: #FFFFFF; /* White background */
    --color-text: #333333; /* Dark gray text */
    --color-text-light: #666666; /* Lighter gray text */
    --color-border: #E0E0E0; /* Light gray border */
    --color-success: #28a745;
    --color-warning: #ffc107; /* Using secondary yellow for warning */
    --color-danger: #dc3545;
    --color-info: #17a2b8;
    --color-neutral: #6c757d;

    --font-family-sans: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    --spacing-unit: 8px; /* Base unit for margins/paddings */
}

/* Minimal body reset */
body {
    margin: 0;
    padding: 0;
    font-family: var(--font-family-sans);
    background-color: var(--color-background);
    color: var(--color-text);
    line-height: 1.6;
}

/* Basic link styling */
a {
    color: var(--color-primary);
    text-decoration: none;
}
a:hover {
    text-decoration: underline;
}

/* Basic container */
.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: calc(var(--spacing-unit) * 2);
}

/* Basic headings */
h1, h2, h3, h4 {
    color: var(--color-primary);
    margin-bottom: var(--spacing-unit);
}

/* Utility class for primary text color */
.text-primary {
    color: var(--color-primary);
}

/* Utility class for secondary text color */
.text-secondary {
    color: var(--color-secondary);
}

/* Simple button style */
.button {
    display: inline-block;
    padding: calc(var(--spacing-unit) * 1.5) calc(var(--spacing-unit) * 3);
    background-color: var(--color-primary);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    text-align: center;
    transition: background-color 0.2s ease;
}
.button:hover {
    background-color: #004477; /* Darker blue */
}
.button.secondary {
    background-color: var(--color-secondary);
    color: var(--color-text);
}
.button.secondary:hover {
    background-color: #e0a800; /* Darker yellow */
}

/* Basic card style */
.card {
    border: 1px solid var(--color-border);
    border-radius: 4px;
    padding: calc(var(--spacing-unit) * 2);
    margin-bottom: calc(var(--spacing-unit) * 2);
    background-color: #fff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

================================================================================
### PLIK: domain/BulkEditPlan.js
================================================================================

/**
 * ARCHITEKTURA: Deklaratywna definicja operacji masowej korekty adresÃ³w z podglÄ…dem i zastosowaniem.
 * Zaprojektowana do walidacji po stronie serwera oraz ponownej weryfikacji partii.
 */
export class BulkEditPlan {
  constructor(orderIds, field, mode, findPattern, replaceWith) {
    this.orderIds = Array.isArray(orderIds) ? orderIds : [];
    this.field = field;
    this.mode = mode;
    this.findPattern = findPattern;
    this.replaceWith = replaceWith;
  }

  static findReplace(orderIds, field, findPattern, replaceWith) {
    return new BulkEditPlan(orderIds, field, "FIND_REPLACE", findPattern, replaceWith);
  }

  static append(orderIds, field, suffix) {
    return new BulkEditPlan(orderIds, field, "APPEND", null, suffix);
  }

  static prepend(orderIds, field, prefix) {
    return new BulkEditPlan(orderIds, field, "PREPEND", null, prefix);
  }
}


================================================================================
### PLIK: domain/Result.js
================================================================================

/**
 * ARCHITEKTURA: Uniwersalny noÅ›nik wyniku operacji (sukces/poraÅ¼ka) bez nulli i wyjÄ…tkÃ³w sterujÄ…cych przepÅ‚ywem.
 * Zapewnia spÃ³jny kontrakt dla wywoÅ‚aÅ„ usÅ‚ug oraz uÅ‚atwia kompozycjÄ™ wynikÃ³w.
 */
export class Result {
  constructor(ok, value, error) {
    this.ok = ok;
    this._value = value;
    this._error = error;
  }

  static ok(value) {
    return new Result(true, value, undefined);
  }

  static fail(error) {
    return new Result(false, undefined, error instanceof Error ? error : new Error(String(error)));
  }

  get value() {
    if (!this.ok) throw new Error("Attempt to get value from failed Result.");
    return this._value;
    }

  get error() {
    if (this.ok) throw new Error("Attempt to get error from successful Result.");
    return this._error;
  }

  map(fn) {
    return this.ok ? Result.ok(fn(this._value)) : Result.fail(this._error);
  }

  asyncMap(fn) {
    if (!this.ok) return Promise.resolve(Result.fail(this._error));
    return fn(this._value).then(Result.ok).catch(err => Result.fail(err));
  }
}


================================================================================
### PLIK: domain/WorkbenchModels.js
================================================================================

/**
 * ARCHITECTURE: WorkbenchModels define immutable value objects used by the editor and worklist.
 * It follows the manifesto by centralizing simple data models away from transport and views.
 * Responsibilities:
 * - Provide Address with factory helpers to ensure safe defaults and cloning.
 * - Offer toPlain() for persistence mapping without leaking internal structure.
 */
export class Address {
  constructor({ street = "", houseNumber = null, postalCode = "", city = "", country = "PL", latitude = null, longitude = null } = {}) {
    this.street = street || "";
    this.houseNumber = houseNumber || null;
    this.postalCode = postalCode || "";
    this.city = city || "";
    this.country = country || "PL";
    this.latitude = typeof latitude === "number" ? latitude : null;
    this.longitude = typeof longitude === "number" ? longitude : null;
  }

  static from(obj) {
    if (!obj || typeof obj !== "object") return new Address();
    return new Address({
      street: obj.street,
      houseNumber: obj.houseNumber,
      postalCode: obj.postalCode,
      city: obj.city,
      country: obj.country,
      latitude: obj.latitude,
      longitude: obj.longitude,
    });
  }

  clone() {
    return new Address(this);
  }

  toPlain() {
    return {
      street: this.street,
      houseNumber: this.houseNumber,
      postalCode: this.postalCode,
      city: this.city,
      country: this.country,
      latitude: this.latitude,
      longitude: this.longitude,
    };
  }
}


================================================================================
### PLIK: domain/WorklistFilter.js
================================================================================

// ============================================================================
// Frontend: Update WorklistFilter Domain (Supersedes previous version)
// FILE: src/domain/WorklistFilter.js
// REASON: Align default status with canonical mission state 'PENDING_VERIFICATION'.
// ============================================================================
// FILE: src/domain/WorklistFilter.js (Supersedes previous version)

/**
 * ARCHITEKTURA: Niemutowalny obiekt zapytania do listy roboczej.
 * Odpowiada za serializacjÄ™ filtrÃ³w do parametrÃ³w URL.
 * Separuje szczegÃ³Å‚y filtrowania od komponentÃ³w UI oraz usÅ‚ug sieciowych.
 * ENHANCED: Added status, barcode, customerId, dateFrom, dateTo fields.
 * UPDATED: Changed default status to PENDING_VERIFICATION.
 */
export class WorklistFilter {
  // *** MODIFIED: Added constructor parameters and properties ***
  constructor({ status = 'PENDING_VERIFICATION', barcode = '', customerId = '', dateFrom = '', dateTo = '' } = {}) {
    this.status = status || 'PENDING_VERIFICATION'; // Default status aligned
    this.barcode = barcode || '';
    this.customerId = customerId || '';
    this.dateFrom = dateFrom || ''; // Expect YYYY-MM-DD
    this.dateTo = dateTo || '';     // Expect YYYY-MM-DD
  }
  // *** END MODIFIED ***

  withPatch(patch) {
    // *** MODIFIED: Update patch logic for new fields ***
    return new WorklistFilter({
      status: patch.status ?? this.status,
      barcode: patch.barcode ?? this.barcode,
      customerId: patch.customerId ?? this.customerId,
      dateFrom: patch.dateFrom ?? this.dateFrom,
      dateTo: patch.dateTo ?? this.dateTo,
    });
    // *** END MODIFIED ***
  }

  toQueryRecord() {
    // *** MODIFIED: Serialize all filter fields ***
    const q = {};
    if (this.status) q.status = this.status;
    if (this.barcode) q.barcode = this.barcode;
    if (this.customerId) q.customerId = this.customerId;
    if (this.dateFrom) q.dateFrom = this.dateFrom;
    if (this.dateTo) q.dateTo = this.dateTo;
    // page and size are added by the store action
    return q;
    // *** END MODIFIED ***
  }

  // Helper to return plain object state, useful for binding v-model in components
  toPlainObject() {
    return {
      status: this.status,
      barcode: this.barcode,
      customerId: this.customerId,
      dateFrom: this.dateFrom,
      dateTo: this.dateTo,
    };
  }
}

================================================================================
### PLIK: services/AddressAuditTrailService.js
================================================================================

/**
 * ARCHITECTURE: AddressAuditTrailService maintains an in-memory audit stream for user actions.
 * It follows the manifesto by isolating audit appends and allowing later persistence without UI impact.
 * Responsibilities:
 * - Append entries and read them by orderId; provide a clear method for testability.
 */
export class AddressAuditTrailService {
  constructor() {
    this._byOrder = new Map();
  }

  append(entry) {
    const id = entry?.orderId || "unknown";
    const list = this._byOrder.get(id) || [];
    list.push({ ...entry, at: new Date().toISOString() });
    this._byOrder.set(id, list);
    return true;
  }

  list(orderId) {
    return (this._byOrder.get(orderId) || []).slice();
  }

  clear(orderId) {
    if (!orderId) return false;
    this._byOrder.delete(orderId);
    return true;
  }
}


================================================================================
### PLIK: services/AddressClipboardService.js
================================================================================

/**
 * ARCHITECTURE: AddressClipboardService copies formatted addresses to clipboard for quick customer contact.
 * It follows the manifesto by isolating browser clipboard usage and formatting concerns.
 * Responsibilities:
 * - Build single-line and multi-line strings and write to navigator.clipboard if available.
 * - Provide deterministic return values indicating success or failure without throwing.
 */
export class AddressClipboardService {
  constructor() {
    this.available = typeof navigator !== "undefined" && !!navigator.clipboard;
  }

  async copyOneLine(a) {
    const str = this._oneLine(a);
    return this._copy(str);
  }

  async copyTwoLines(a) {
    const str = this._twoLines(a);
    return this._copy(str);
  }

  async _copy(str) {
    if (!this.available) return { ok: false, reason: "Clipboard unavailable" };
    try {
      await navigator.clipboard.writeText(str);
      return { ok: true };
    } catch (_) {
      return { ok: false, reason: "Clipboard write failed" };
    }
  }

  _oneLine(a) {
    const p1 = [a?.street, a?.houseNumber].filter(Boolean).join(" ");
    const p2 = [a?.postalCode, a?.city].filter(Boolean).join(" ");
    const p3 = a?.country || "PL";
    return [p1, p2, p3].filter(Boolean).join(", ");
  }

  _twoLines(a) {
    const p1 = [a?.street, a?.houseNumber].filter(Boolean).join(" ");
    const p2 = [a?.postalCode, a?.city, a?.country || "PL"].filter(Boolean).join(", ");
    return `${p1}\n${p2}`;
  }
}


================================================================================
### PLIK: services/AddressCorrectionService.js
================================================================================

/**
 * ARCHITECTURE: AddressCorrectionService persists address fixes to the backend and records an audit entry.
 * It follows the manifesto by isolating persistence and audit concerns behind one explicit contract.
 * Responsibilities:
 * - Save corrections via AddressExceptionApi with explicit resolution mode.
 * - Append audit entries using AddressAuditTrailService and provide a deterministic Result object.
 */
import { Result } from "@/domain/Result";
import { AddressAuditTrailService } from "@/services/AddressAuditTrailService";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

export class AddressCorrectionService {
  constructor(api = new AddressExceptionApi(), audit = new AddressAuditTrailService()) {
    this.api = api;
    this.audit = audit;
  }

  async save({ orderId, side, before, after, resolution }) {
    const res = await this.api.saveCorrection({
      orderId,
      side,
      correctedPickup: side === "pickup" || side === "both" ? after?.pickup || null : null,
      correctedDelivery: side === "delivery" || side === "both" ? after?.delivery || null : null,
      resolution: resolution || "MANUAL_EDIT",
    });
    if (!res.ok) return Result.fail(res.error);
    this.audit.append({
      orderId,
      side,
      action: resolution || "MANUAL_EDIT",
      before,
      after,
      diff: null,
    });
    return Result.ok(res.value);
  }
}


================================================================================
### PLIK: services/AddressEqualityService.js
================================================================================

/**
 * ARCHITECTURE: AddressEqualityService computes structural equality and a stable hash for Address DTOs.
 * It follows the manifesto by providing deterministic comparisons without UI or transport concerns.
 * Responsibilities:
 * - Compare two addresses field-by-field with normalization of whitespace and case.
 * - Produce a hash string for use in caches, audit, or deduplication logic.
 */
export class AddressEqualityService {
  constructor() {
    this._fields = ["street", "houseNumber", "postalCode", "city", "country", "latitude", "longitude"];
  }

  equals(a, b) {
    if (!a || !b) return false;
    for (const f of this._fields) {
      if (!this._eq(a[f], b[f])) return false;
    }
    return true;
  }

  hash(a) {
    const s = (x) => (x == null ? "" : String(x).trim().toLowerCase());
    const n = (x) => (typeof x === "number" ? x.toFixed(6) : "");
    const parts = [
      s(a?.street),
      s(a?.houseNumber),
      s(a?.postalCode),
      s(a?.city),
      s(a?.country),
      n(a?.latitude),
      n(a?.longitude),
    ];
    return this._simpleHash(parts.join("|"));
  }

  _eq(a, b) {
    if (typeof a === "number" || typeof b === "number") {
      return Number(a || 0).toFixed(6) === Number(b || 0).toFixed(6);
    }
    return (a || "").toString().trim().toLowerCase() === (b || "").toString().trim().toLowerCase();
  }

  _simpleHash(str) {
    let h = 0;
    for (let i = 0; i < str.length; i++) {
      h = (h << 5) - h + str.charCodeAt(i);
      h |= 0;
    }
    return `h${(h >>> 0).toString(16)}`;
  }
}


================================================================================
### PLIK: services/AddressExceptionApi.js
================================================================================

// ============================================================================
// Frontend: Update AddressExceptionApi (Supersedes previous version)
// FILE: src/services/AddressExceptionApi.js
// REASON: Align saveCorrection to call /api/orders/{barcode}/approve endpoint.
// ============================================================================
// FILE: src/services/AddressExceptionApi.js (Supersedes previous version)
import api from "@/services/api";
import { Result } from "@/domain/Result";
import { Address } from "@/domain/WorkbenchModels";

/**
 * ARCHITECTURE: API client for address-related operations.
 * REFACTORED:
 * - `getWorklist` filters by `status=PENDING_VERIFICATION` by default.
 * - `getOrderDetail` maps `sourceSystem`.
 * - `saveCorrection` method calls the new `/api/orders/{barcode}/approve` endpoint.
 */
export class AddressExceptionApi {
    constructor() {
        this.client = api;
    }

    async getWorklist(filter = { page: 0, size: 25, status: 'PENDING_VERIFICATION' }) {
        try {
            const q = new URLSearchParams();
            q.set("page", String(filter.page >= 0 ? filter.page : 0));
            q.set("size", String(filter.size || 25));
            q.set("status", filter.status || 'PENDING_VERIFICATION'); // Default to PENDING_VERIFICATION
            if (filter.barcode) q.set("barcode", filter.barcode);
            if (filter.sort) q.set("sort", filter.sort);
            if (filter.customerId) q.set("customerId", filter.customerId);
            if (filter.dateFrom) q.set("dateFrom", filter.dateFrom);
            if (filter.dateTo) q.set("dateTo", filter.dateTo);

            const res = await this.client.get(`/api/orders?${q.toString()}`);
            const data = res.data || {};
            return Result.ok({
                items: Array.isArray(data.content) ? data.content : [],
                total: Number(data.totalElements || 0),
            });
        } catch (e) {
            console.error("Error fetching worklist:", e);
            const errorMessage = e.response?.data?.error || e.message || "Failed to fetch worklist.";
            return Result.fail(new Error(errorMessage));
        }
    }

    async getOrderDetail(orderId) {
        if (!orderId) {
            return Result.fail(new Error("Order ID is required."));
        }
        try {
            // Use orderId (UUID) to fetch, not barcode
            const res = await this.client.get(`/api/orders/${encodeURIComponent(orderId)}`);
            const backendDto = res.data;
            if (!backendDto || !backendDto.id) {
                return Result.fail(new Error(`Order details not found or invalid response for ID: ${orderId}`));
            }

            const originalPickup = backendDto.pickupAddress ? Address.from(backendDto.pickupAddress) : new Address();
            const originalDelivery = backendDto.deliveryAddress ? Address.from(backendDto.deliveryAddress) : new Address();
            const pickupStoredDisplay = backendDto.pickupStoredAddress ? Address.from(backendDto.pickupStoredAddress) : null;
            const deliveryStoredDisplay = backendDto.deliveryStoredAddress ? Address.from(backendDto.deliveryStoredAddress) : null;

            const pickupStoredLabel = this._getStoredAddressLabel(backendDto.pickupReasonCode, 'Pickup');
            const deliveryStoredLabel = this._getStoredAddressLabel(backendDto.deliveryReasonCode, 'Delivery');

            const frontendDetail = {
                orderId: backendDto.id,
                barcode: backendDto.barcode,
                requestId: backendDto.requestId,
                customerId: backendDto.customerId,
                sourceSystem: backendDto.sourceSystem, // *** ADDED MAPPING ***
                processingStatus: backendDto.processingStatus,
                createdAt: backendDto.createdAt,
                updatedAt: backendDto.updatedAt,
                pickupAlias: backendDto.pickupAlias || null,
                deliveryAlias: backendDto.deliveryAlias || null,
                originalPickup: originalPickup,
                originalDelivery: originalDelivery,
                pickupReasonCode: backendDto.pickupReasonCode || null,
                deliveryReasonCode: backendDto.deliveryReasonCode || null,
                pickupStoredAddress: pickupStoredDisplay,
                deliveryStoredAddress: deliveryStoredDisplay,
                pickupStoredLabel: pickupStoredLabel,
                deliveryStoredLabel: deliveryStoredLabel,
                suggestedPickup: Array.isArray(backendDto.suggestedPickup) ? backendDto.suggestedPickup : [],
                suggestedDelivery: Array.isArray(backendDto.suggestedDelivery) ? backendDto.suggestedDelivery : [],
                relatedError: backendDto.relatedError || null
            };
            return Result.ok(frontendDetail);
        } catch (e) {
            console.error(`Error fetching order detail for ${orderId}:`, e);
            const status = e.response?.status;
            const errorMessage = e.response?.data?.error || e.message || `Failed to fetch order details for ID: ${orderId}.`;
            if (status === 404) {
                return Result.fail(new Error(`Order not found: ${orderId}`));
            }
            return Result.fail(new Error(errorMessage));
        }
    }

    /**
     * Replaces the old /corrections endpoint call.
     * Now calls the centralized /api/orders/{barcode}/approve endpoint.
     *
     * @param {object} body - Must contain { barcode, resolveCoordinatesIfNeeded }
     * @param {string} idempotencyToken - The idempotency key.
     */
    async saveCorrection(body, idempotencyToken = null) {
        const barcode = body?.barcode;
        if (!barcode) {
            return Result.fail(new Error("Barcode is required to approve the correction."));
        }

        // Build the payload required by POST /api/orders/{barcode}/approve
        const approvePayload = {
            resolveCoordinatesIfNeeded: body?.resolveCoordinatesIfNeeded || false
        };

        try {
            const headers = idempotencyToken ? { "Idempotency-Key": idempotencyToken } : {};

            // Call the correct endpoint using the barcode
            const res = await this.client.post(`/api/orders/${encodeURIComponent(barcode)}/approve`, approvePayload, { headers });
            return Result.ok(res.data || true);
        } catch (e) {
            console.error(`Error saving/approving correction for barcode ${barcode}:`, e);
            const errorMessage = e.response?.data?.error || e.message || "Failed to save/approve correction.";
            return Result.fail(new Error(errorMessage));
        }
    }

    // (Kept other methods: getTriageKpis, sendClientLogs, admin operations, etc.)

    async getTriageKpis() {
        try {
            const res = await this.client.get(`/api/dashboard/kpis`);
            const data = res.data || { pendingReviewCount: 0, automatedClearancePercent: 0, avgResolutionMinutes: null };
            return Result.ok(data);
        } catch (e) {
            console.error("Error fetching triage KPIs:", e);
            const errorMessage = e.response?.data?.error || e.message || "Failed to fetch KPIs.";
            return Result.fail(new Error(errorMessage));
        }
    }

    async sendClientLogs(logEntries) {
        if (!Array.isArray(logEntries) || logEntries.length === 0) {
            return Promise.resolve();
        }
        return this.client.post(`/api/log/client`, logEntries);
    }

    async requestGetAvailableProviders() { return this.client.get(`/api/admin/address-verification/providers/available`); }
    async requestGetCurrentProvider() { return this.client.get(`/api/admin/address-verification/providers/current`); }
    async requestSetProvider(providerName) { return this.client.post(`/api/admin/address-verification/providers/current`, providerName, { headers: { 'Content-Type': 'text/plain' } }); }
    async getOperationStatus(correlationId) { return this.client.get(`/api/admin/address-verification/operations/${correlationId}`); }

    _getStoredAddressLabel(reasonCode, side) {
        if (reasonCode === 'ALIAS_MATCH_CONFIRMED') return `Stored (TrackIT - Matched)`;
        if (reasonCode === 'ALIAS_MISMATCH') return `Stored (TrackIT - Mismatch)`;
        if (reasonCode === 'ALIAS_NOT_FOUND') return `Original ${side}`;
        return `Stored (TrackIT - if mismatched)`;
    }
}

================================================================================
### PLIK: services/AddressFieldGuard.js
================================================================================

/**
 * ARCHITECTURE: AddressFieldGuard enforces form field enable/disable rules per country and workflow state.
 * It follows the manifesto by isolating editability policies from components and controllers.
 * Responsibilities:
 * - Decide if a field is editable based on country rules, verification status, and role flags.
 * - Provide a stateless canEdit(field, context) API returning a boolean.
 */
export class AddressFieldGuard {
  constructor() {
    this._rules = new Map();
    this._rules.set("PL", {
      postalCode: () => true,
      street: () => true,
      houseNumber: () => true,
      city: () => true,
      country: () => false,
    });
  }

  register(country, rules) {
    this._rules.set((country || "PL").toUpperCase(), rules);
    return true;
  }

  canEdit(field, context) {
    const c = (context?.country || "PL").toUpperCase();
    const rules = this._rules.get(c) || this._rules.get("PL");
    if (typeof rules[field] === "function") return !!rules[field](context);
    return true;
  }
}


================================================================================
### PLIK: services/AddressFormatterService.js
================================================================================

/**
 * ARCHITECTURE: AddressFormatterService produces consistent, locale-aware display strings for addresses.
 * It follows the manifesto by separating presentation formatting from data models and controllers.
 * Responsibilities:
 * - Format single-line and multi-line address strings with optional fallbacks.
 * - Handle missing fields gracefully and avoid mutating inputs.
 */
export class AddressFormatterService {
  constructor(defaultCountry = "PL") {
    this.defaultCountry = defaultCountry;
  }

  oneLine(a) {
    if (!a) return "";
    const parts = [];
    const line1 = [a.street, a.houseNumber].filter(Boolean).join(" ").trim();
    if (line1) parts.push(line1);
    const line2 = [a.postalCode, a.city].filter(Boolean).join(" ").trim();
    if (line2) parts.push(line2);
    const c = a.country || this.defaultCountry;
    if (c) parts.push(c);
    return parts.join(", ");
  }

  twoLines(a) {
    if (!a) return { line1: "", line2: "" };
    const line1 = [a.street, a.houseNumber].filter(Boolean).join(" ").trim();
    const line2 = [[a.postalCode, a.city].filter(Boolean).join(" ").trim(), a.country || this.defaultCountry].filter(Boolean).join(", ");
    return { line1, line2 };
  }
}


================================================================================
### PLIK: services/AddressGeocodeCache.js
================================================================================

import { AddressEqualityService } from "@/services/AddressEqualityService";

/**
 * ARCHITECTURE: AddressGeocodeCache provides an in-memory, session-scoped cache
 * for geocoding results to reduce API calls.
 * It uses AddressEqualityService to create stable keys from address objects.
 */
export class AddressGeocodeCache {
    constructor(equalityService = new AddressEqualityService()) {
        this.cache = new Map();
        this.eq = equalityService;
    }

    _key(address) {
        // Use the hash function from the equality service for a stable key
        return this.eq.hash(address);
    }

    get(address) {
        const key = this._key(address);
        const result = this.cache.get(key) || null;
        if (result) {
            console.debug(`[GeocodeCache] Cache HIT for key: ${key}`);
        }
        return result;
    }

    put(address, result) {
        const key = this._key(address);
        console.debug(`[GeocodeCache] Cache SET for key: ${key}`);
        this.cache.set(key, result);
    }

    clear() {
        this.cache.clear();
    }
}


================================================================================
### PLIK: services/AddressHistoryService.js
================================================================================

/**
 * ARCHITECTURE: AddressHistoryService records a per-order timeline of edits and applied suggestions.
 * It follows the manifesto by providing an append-only log consumable by the audit or session history.
 * Responsibilities:
 * - Append events with before/after snapshots and provider info; read back per orderId.
 */
export class AddressHistoryService {
  constructor() {
    this._byOrder = new Map();
  }

  append(orderId, payload) {
    if (!orderId) return false;
    const list = this._byOrder.get(orderId) || [];
    list.push({
      at: new Date().toISOString(),
      type: payload?.type || "EDIT",
      side: payload?.side || "both",
      provider: payload?.provider || null,
      before: payload?.before || null,
      after: payload?.after || null,
    });
    this._byOrder.set(orderId, list);
    return true;
  }

  list(orderId) {
    return (this._byOrder.get(orderId) || []).slice();
  }

  clear(orderId) {
    if (!orderId) return false;
    this._byOrder.delete(orderId);
    return true;
  }
}


================================================================================
### PLIK: services/AddressInputMaskService.js
================================================================================

/**
 * ARCHITECTURE: AddressInputMaskService (Stub) would provide input masking
 * logic for address fields, specific to country rules (e.g., postal codes).
 * This is a placeholder returning the value as-is.
 */
export class AddressInputMaskService {
    constructor(countryCode = "PL") {
        this.countryCode = countryCode.toUpperCase();
    }

    /**
     * Masks a postal code value (stub).
     * @param {string} value - The input value.
     * @param {string} country - The country context.
     * @returns {string} The masked/formatted value.
     */
    maskPostal(value, country) {
        // TODO: Implement actual postal code masking (e.g., PL: '00123' -> '00-123')
        return value;
    }

    /**
     * Masks a street value (stub).
     * @param {string} value - The input value.
     * @returns {string} The masked/formatted value.
     */
    maskStreet(value) {
        // TODO: Implement street name masking/formatting (e.g., capitalization)
        return value;
    }

    /**
     * Masks a city value (stub).
     * @param {string} value - The input value.
     * @returns {string} The masked/formatted value.
     */
    maskCity(value) {
        // TODO: Implement city name masking/formatting
        return value;
    }

    /**
     * Masks a house number value (stub).
     * @param {string} value - The input value.
     * @returns {string} The masked/formatted value.
     */
    maskHouseNo(value) {
        // TODO: Implement house number masking/formatting
        return value;
    }
}

================================================================================
### PLIK: services/AddressNormalizer.js
================================================================================

/**
 * ARCHITECTURE: AddressNormalizer sanitizes raw address input into a consistent DTO used by verification.
 * It follows the manifesto by providing pure, deterministic transformations without UI or transport coupling.
 * Responsibilities:
 * - Trim whitespace, stabilize casing, and normalize postal code for PL (e.g., "00123" â†’ "00-123").
 * - Guarantee presence of all expected fields with safe defaults.
 *
 * FIX: Removed erroneous circular self-import statement.
 */

export class AddressNormalizer {
  constructor(defaultCountry = "PL") {
    this.defaultCountry = defaultCountry.toUpperCase();
  }

  normalize(a) {
    const street = this._sp(a?.street);
    const houseNumber = this._hn(a?.houseNumber);
    const city = this._cap(this._sp(a?.city));
    const country = this._cc(a?.country);
    const postalCode = this._postal(a?.postalCode, country);
    const latitude = this._num(a?.latitude);
    const longitude = this._num(a?.longitude);
    return { street, houseNumber, postalCode, city, country, latitude, longitude };
  }

  _sp(v) {
    return (v || "").toString().replace(/\s+/g, " ").trim();
  }

  _hn(v) {
    const s = (v == null ? "" : String(v)).replace(/\s+/g, "").trim();
    return s.length ? s : null;
  }

  _cap(v) {
    if (!v) return "";
    return v.charAt(0).toUpperCase() + v.slice(1);
  }

  _cc(v) {
    const s = (v || this.defaultCountry).toString().trim().toUpperCase();
    return s || this.defaultCountry;
  }

  _postal(v, country) {
    const raw = (v || "").replace(/\s|-/g, "");
    if ((country || "").toUpperCase() === "PL") {
      if (raw.length < 5) return raw;
      return `${raw.slice(0, 2)}-${raw.slice(2, 5)}`;
    }
    return v || "";
  }

  _num(v) {
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  }
}


================================================================================
### PLIK: services/AddressPersistenceMapper.js
================================================================================

// ============================================================================
// Frontend: Mark AddressPersistenceMapper as Deprecated
// FILE: src/services/AddressPersistenceMapper.js
// REASON: This mapper is bypassed by the new save flow.
// ============================================================================
// FILE: src/services/AddressPersistenceMapper.js (Supersedes previous version)

/**
 * ARCHITECTURE: AddressPersistenceMapper shapes editor state into backend save payloads.
 * DEPRECATED: This mapper creates a payload for the old /corrections endpoint.
 * The flow is now handled by SaveFlowController -> IdempotentSaveController
 * which build a payload for the /api/orders/{barcode}/approve endpoint.
 * @deprecated
 */
export class AddressPersistenceMapper {
  toSavePayload(orderId, side, before, after, resolution) {
    console.warn("DEPRECATED: AddressPersistenceMapper.toSavePayload called. This logic is obsolete.");
    const s = (side || "both").toLowerCase();
    const body = {
      orderId: orderId,
      side: s === "pickup" || s === "delivery" ? s : "both",
      resolution: resolution || "MANUAL_EDIT",
      correctedPickup: s === "delivery" ? null : (after?.pickup || after?.correctedPickup || after?.editedPickup || after || null),
      correctedDelivery: s === "pickup" ? null : (after?.delivery || after?.correctedDelivery || after?.editedDelivery || after || null),
      beforePickup: s === "delivery" ? null : (before?.pickup || before?.originalPickup || before || null),
      beforeDelivery: s === "pickup" ? null : (before?.delivery || before?.originalDelivery || before || null),
    };
    return body;
  }
}

================================================================================
### PLIK: services/AddressRulesService.js
================================================================================

/**
 * ARCHITECTURE: AddressRulesService centralizes country-specific rules for required fields and masks.
 * It follows the manifesto by separating rule data from controllers and adapters.
 * Responsibilities:
 * - Provide requiredFields(country) and postalRegex(country) for validation and hints.
 */
export class AddressRulesService {
  constructor() {
    this._req = new Map();
    this._req.set("PL", ["street", "postalCode", "city", "country"]);
    this._postal = new Map();
    this._postal.set("PL", /^(\d{2}-\d{3}|\d{5})$/);
  }

  requiredFields(country = "PL") {
    return this._req.get((country || "PL").toUpperCase()) || this._req.get("PL");
  }

  postalRegex(country = "PL") {
    return this._postal.get((country || "PL").toUpperCase()) || /.*/;
  }
}


================================================================================
### PLIK: services/AddressSuggestionMerger.js
================================================================================

/**
 * ARCHITECTURE: AddressSuggestionMerger combines suggestion lists from multiple sources
 * (e.g., client-side geocoding, Places API, TES backend) into a single list,
 * potentially removing duplicates based on address content equality. Adheres to SRP.
 * This is a basic stub implementation assuming simple concatenation.
 */
import { AddressEqualityService } from "@/services/AddressEqualityService"; // Assuming this exists

export class AddressSuggestionMerger {
    constructor(equalityService = new AddressEqualityService()) {
        this.eq = equalityService;
    }

    /**
     * Merges multiple lists of suggestions, attempting basic deduplication.
     * @param {object} baseInput - The original input address (used for context, not currently in stub).
     * @param {Array<Array<object>>} suggestionLists - An array of suggestion lists from different sources.
     * @returns {Array<object>} A single, merged list of suggestions.
     */
    merge(baseInput, suggestionLists) {
        const merged = [];
        const seenHashes = new Set();

        if (!Array.isArray(suggestionLists)) {
            return merged;
        }

        for (const list of suggestionLists) {
            if (!Array.isArray(list)) continue;

            for (const suggestion of list) {
                if (!suggestion) continue;

                // Simple deduplication based on normalized address hash (requires AddressEqualityService)
                const addressPart = {
                    street: suggestion.street,
                    houseNumber: suggestion.houseNumber,
                    postalCode: suggestion.postalCode,
                    city: suggestion.city,
                    country: suggestion.countryCode,
                    // Note: Lat/Lon usually excluded from equality hash for address matching
                };
                const hash = this.eq.hash(addressPart);

                if (!seenHashes.has(hash)) {
                    merged.push(suggestion);
                    seenHashes.add(hash);
                }
            }
        }
        // Further sorting/ranking is typically done by AddressSuggestionRanker
        return merged;
    }
}

================================================================================
### PLIK: services/AddressSuggestionRanker.js
================================================================================

/**
 * ARCHITECTURE: AddressSuggestionRanker orders suggestions by confidence and locality relevance.
 * It follows the manifesto by keeping ranking policy separate from UI and transport details.
 * Responsibilities:
 * - Sort by matchScore desc, then city/postal match with the base input, then provider priority.
 */
export class AddressSuggestionRanker {
  rank(baseInput, list) {
    const arr = Array.isArray(list) ? list.slice() : [];
    const prio = (p) => (p === "GOOGLE_CLIENT" ? 3 : p === "GOOGLE_PLACES" ? 2 : p === "TES" ? 1 : 0);
    const eq = (a, b) => (a || "").toString().trim().toLowerCase() === (b || "").toString().trim().toLowerCase();
    arr.sort((a, b) => {
      const sa = typeof a.matchScore === "number" ? a.matchScore : 0;
      const sb = typeof b.matchScore === "number" ? b.matchScore : 0;
      if (sb !== sa) return sb - sa;
      const ca = eq(a.city, baseInput?.city) ? 1 : 0;
      const cb = eq(b.city, baseInput?.city) ? 1 : 0;
      if (cb !== ca) return cb - ca;
      const pa = eq(a.postalCode, baseInput?.postalCode) ? 1 : 0;
      const pb = eq(b.postalCode, baseInput?.postalCode) ? 1 : 0;
      if (pb !== pa) return pb - pa;
      return prio(b.providerSource) - prio(a.providerSource);
    });
    return arr;
  }
}


================================================================================
### PLIK: services/api.js
================================================================================

/**
 * ARCHITECTURE: Axios singleton configured to cooperate with the Vite proxy in development.
 * Responsibilities:
 * - Use baseURL from env; when set to "/" (recommended for dev), requests are same-origin and get proxied.
 */
import axios from "axios";

function resolveBaseUrl() {
  const w = typeof window !== "undefined" ? window : {};
  const winBase = (w.__API_BASE_URL__ || "").trim();
  const viteBase = (import.meta?.env?.VITE_API_BASE_URL || "").trim();
  const base = (winBase || viteBase);
  if (!base) return "/";          // default to same-origin â†’ dev proxy handles cross-origin
  if (base === "/") return "/";   // explicit proxy mode
  return base.replace(/\/+$/, "");
}

const api = axios.create({
  baseURL: resolveBaseUrl(),
  withCredentials: true,
  headers: {
    "Accept": "application/json",
    "Content-Type": "application/json",
  },
});

api.interceptors.response.use(
  (res) => res,
  (err) => {
    err.message = err?.response?.data?.message || err.message || "Request failed";
    return Promise.reject(err);
  }
);

export default api;


================================================================================
### PLIK: services/ApiAuthBinder.js
================================================================================

/**
 * ARCHITECTURE: ApiAuthBinder binds/unbinds the Authorization header on the shared ApiHttpClient singleton.
 * Responsibilities:
 * - Apply "Authorization: <type> <token>" to axios defaults; remove it on logout.
 */
import apiClient from "@/services/api";

export class ApiAuthBinder {
  constructor() {
    this.headerName = "Authorization";
  }

  bind(accessToken, tokenType = "Bearer") {
    if (!accessToken) return false;
    const scheme = String(tokenType || "Bearer").trim() || "Bearer";
    if (!apiClient.defaults.headers) apiClient.defaults.headers = {};
    if (!apiClient.defaults.headers.common) apiClient.defaults.headers.common = {};
    apiClient.defaults.headers.common[this.headerName] = `${scheme} ${accessToken}`;
    return true;
  }

  unbind() {
    if (apiClient?.defaults?.headers?.common && this.headerName in apiClient.defaults.headers.common) {
      delete apiClient.defaults.headers.common[this.headerName];
      return true;
    }
    return false;
  }
}


================================================================================
### PLIK: services/ApiErrorMapper.js
================================================================================

/**
 * ARCHITECTURE: ApiErrorMapper (Stub) translates backend HTTP error responses
 * into user-facing, domain-specific error messages or error objects.
 * This isolates HTTP error structure from controllers.
 */
import { Result } from "@/domain/Result";

export class ApiErrorMapper {
    constructor() {
        // Map of known backend error codes/messages to frontend-friendly text
        this.errorMap = {
            "validation_failed": "The data provided was invalid. Please check the fields.",
            "duplicate_barcode": "This barcode already exists in the system.",
            "auth_invalid_credentials": "Invalid username or password.",
        };
    }

    /**
     * Maps an Axios error object to a frontend-friendly Error object.
     * @param {Error} axiosError - The error object from an Axios request.
     * @returns {Error} A new Error object with a user-friendly message.
     */
    map(axiosError) {
        if (!axiosError) {
            return new Error("An unknown error occurred.");
        }

        const responseData = axiosError.response?.data;
        const status = axiosError.response?.status;

        if (status === 401) {
            return new Error("Authentication failed. Please log in again.");
        }

        if (status === 403) {
            return new Error("You do not have permission to perform this action.");
        }

        // Check for specific backend error code
        const backendErrorCode = responseData?.errorCode; // Assuming backend sends { "errorCode": "...", ... }
        if (backendErrorCode && this.errorMap[backendErrorCode]) {
            return new Error(this.errorMap[backendErrorCode]);
        }

        // Check for Spring Boot validation errors
        if (status === 422 && Array.isArray(responseData?.details)) {
            return new Error(`Validation failed: ${responseData.details.join(', ')}`);
        }

        // Fallback to message from backend payload or default
        const message = responseData?.error || responseData?.message || axiosError.message || "An unknown server error occurred.";
        return new Error(message);
    }

    /**
     * Wraps an API call (a function returning a Promise) with error mapping.
     * @param {Function} apiCallFn - An async function (e.g., () => apiClient.get('/...')).
     * @returns {Promise<Result<any, Error>>} A Result object.
     */
    async wrap(apiCallFn) {
        try {
            const response = await apiCallFn();
            return Result.ok(response.data); // Assumes success is response.data
        } catch (error) {
            return Result.fail(this.map(error));
        }
    }
}

================================================================================
### PLIK: services/AuthApi.js
================================================================================

/**
 * ARCHITECTURE: AuthApi encapsulates authentication HTTP calls against the backend auth service.
 * It follows the manifesto by isolating transport details and returning deterministic Result objects.
 * Responsibilities:
 * - POST credentials to /auth/login and return a normalized session object on success.
 * - Keep transport client injectable for testing; default to the shared Axios instance.
 */
import api from "@/services/api";
import { Result } from "@/domain/Result";

export class AuthApi {
  constructor(httpClient = api) {
    this.http = httpClient;
  }

  async login(username, password) {
    try {
      const res = await this.http.post("/auth/login", { username, password });
      const data = res?.data || {};
      const session = {
        accessToken: data.accessToken || null,
        refreshToken: data.refreshToken || null,
        tokenType: data.tokenType || "Bearer",
        username: data.username || username || null,
        roles: Array.isArray(data.roles) ? data.roles : [],
      };
      if (!session.accessToken) return Result.fail(new Error("AuthApi: accessToken missing in response."));
      return Result.ok(session);
    } catch (e) {
      return Result.fail(e instanceof Error ? e : new Error("AuthApi: login failed"));
    }
  }
}


================================================================================
### PLIK: services/AuthApi.spec.js
================================================================================

// src/services/AuthApi.spec.js
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { AuthApi } from '@/services/AuthApi';
import { Result } from '@/domain/Result';

// Mock the underlying HTTP client (e.g., axios instance)
const mockHttpClient = {
    post: vi.fn(),
};

describe('AuthApi', () => {
    let authApi;

    beforeEach(() => {
        // Reset mocks before each test
        vi.resetAllMocks();
        // Create a new instance with the mock client for each test
        authApi = new AuthApi(mockHttpClient);
    });

    it('should call login endpoint and return Ok Result on success', async () => {
        // Arrange
        const mockUsername = 'testuser';
        const mockPassword = 'password';
        const mockApiResponse = {
            data: {
                accessToken: 'mockAccessToken',
                refreshToken: 'mockRefreshToken',
                tokenType: 'Bearer',
                username: mockUsername,
                roles: ['USER', 'ADMIN'],
            }
        };
        mockHttpClient.post.mockResolvedValue(mockApiResponse);

        // Act
        const result = await authApi.login(mockUsername, mockPassword);

        // Assert
        expect(mockHttpClient.post).toHaveBeenCalledTimes(1);
        expect(mockHttpClient.post).toHaveBeenCalledWith('/auth/login', { username: mockUsername, password: mockPassword });

        expect(result).toBeInstanceOf(Result);
        expect(result.ok).toBe(true);
        expect(result.value).toEqual({
            accessToken: 'mockAccessToken',
            refreshToken: 'mockRefreshToken',
            tokenType: 'Bearer',
            username: mockUsername,
            roles: ['USER', 'ADMIN'],
        });
    });

    it('should return Fail Result if API call fails', async () => {
        // Arrange
        const mockUsername = 'testuser';
        const mockPassword = 'password';
        const mockError = new Error('Network Error');
        mockHttpClient.post.mockRejectedValue(mockError);

        // Act
        const result = await authApi.login(mockUsername, mockPassword);

        // Assert
        expect(mockHttpClient.post).toHaveBeenCalledTimes(1);
        expect(mockHttpClient.post).toHaveBeenCalledWith('/auth/login', { username: mockUsername, password: mockPassword });

        expect(result).toBeInstanceOf(Result);
        expect(result.ok).toBe(false);
        expect(result.error).toBe(mockError);
    });

    it('should return Fail Result if API response is missing accessToken', async () => {
        // Arrange
        const mockUsername = 'testuser';
        const mockPassword = 'password';
        const mockApiResponse = {
            data: { /* accessToken is missing */ }
        };
        mockHttpClient.post.mockResolvedValue(mockApiResponse);

        // Act
        const result = await authApi.login(mockUsername, mockPassword);

        // Assert
        expect(result).toBeInstanceOf(Result);
        expect(result.ok).toBe(false);
        expect(result.error).toBeInstanceOf(Error);
        expect(result.error.message).toContain('accessToken missing');
    });
});

================================================================================
### PLIK: services/AuthSessionService.js
================================================================================

/**
 * ARCHITECTURE: AuthSessionService persists auth tokens and user profile and exposes accessors.
 * It follows the manifesto by isolating storage mechanics and providing deterministic getters/setters.
 * Responsibilities:
 * - Save/load/remove session in localStorage with a namespaced key.
 * - Expose isAuthenticated(), getAccessToken(), getTokenType(), getUser(), hasRole().
 */
export class AuthSessionService {
  constructor(namespace = "danxils_auth") {
    this.ns = namespace;
    this.store = typeof window !== "undefined" ? window.localStorage : null;
  }

  save(session) {
    if (!this.store) return false;
    const payload = {
      accessToken: session?.accessToken || null,
      refreshToken: session?.refreshToken || null,
      tokenType: session?.tokenType || "Bearer",
      username: session?.username || null,
      roles: Array.isArray(session?.roles) ? session.roles : [],
      at: Date.now(),
    };
    this.store.setItem(this.ns, JSON.stringify(payload));
    return true;
  }

  load() {
    if (!this.store) return null;
    const raw = this.store.getItem(this.ns);
    if (!raw) return null;
    try { return JSON.parse(raw); } catch { return null; }
  }

  clear() {
    if (!this.store) return false;
    this.store.removeItem(this.ns);
    return true;
  }

  isAuthenticated() {
    const s = this.load();
    return !!(s && s.accessToken);
  }

  getAccessToken() {
    const s = this.load();
    return s?.accessToken || null;
  }

  getTokenType() {
    const s = this.load();
    return s?.tokenType || "Bearer";
  }

  getUser() {
    const s = this.load();
    return { username: s?.username || null, roles: Array.isArray(s?.roles) ? s.roles : [] };
  }

  hasRole(role) {
    const s = this.load();
    const roles = Array.isArray(s?.roles) ? s.roles : [];
    return roles.includes(role);
  }
}


================================================================================
### PLIK: services/CsvBuilder.js
================================================================================

/**
 * ARCHITECTURE: CsvBuilder builds CSV text from arrays of objects without UI or transport coupling.
 * It follows the manifesto by providing a pure data-to-text transformation with stable escaping.
 * Responsibilities:
 * - Accept columns definition and rows; output RFC-4180-compliant CSV with quotes/escaping.
 * - Return a string for download or clipboard without side effects.
 */
export class CsvBuilder {
  constructor(columns) {
    if (!Array.isArray(columns) || columns.length === 0) throw new Error("CsvBuilder: columns are required.");
    this.columns = columns; // [{key:'orderId', title:'Order ID'}, ...]
  }

  build(rows) {
    const head = this.columns.map(c => this._q(c.title || c.key)).join(",");
    const body = (Array.isArray(rows) ? rows : []).map(r => this.columns.map(c => this._q(r[c.key])).join(",")).join("\n");
    return [head, body].filter(Boolean).join("\n");
  }

  _q(v) {
    const s = v == null ? "" : String(v);
    if (/[",\n]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
    return s;
  }
}


================================================================================
### PLIK: services/DebounceTimer.js
================================================================================

/**
 * ARCHITECTURE: DebounceTimer provides deterministic debouncing for keystroke-driven verification.
 * It follows the manifesto by encapsulating timing concerns and exposing a minimal, testable contract.
 * Responsibilities:
 * - Debounce a single async task, cancelling the previous one if a new call arrives within the interval.
 * - Prevent overlapping executions by using a monotonically increasing token.
 */
export class DebounceTimer {
  constructor(delayMs = 400) {
    this.delayMs = delayMs;
    this._timer = null;
    this._token = 0;
  }

  run(asyncFn) {
    return new Promise((resolve, reject) => {
      const current = ++this._token;
      if (this._timer) clearTimeout(this._timer);
      this._timer = setTimeout(async () => {
        try {
          if (current !== this._token) return resolve(null);
          const r = await asyncFn();
          if (current !== this._token) return resolve(null);
          resolve(r);
        } catch (e) {
          reject(e);
        }
      }, this.delayMs);
    });
  }

  cancel() {
    if (this._timer) clearTimeout(this._timer);
    this._timer = null;
    this._token++;
  }
}


================================================================================
### PLIK: services/DiffService.js
================================================================================

/**
 * ARCHITECTURE: DiffService computes before/after differences for Address DTO fields.
 * It follows the manifesto by isolating comparison logic from viewmodels and controllers.
 * Responsibilities:
 * - Compare two objects field-by-field; return {entries[], anyChanged}.
 */
export class DiffService {
  constructor(fields = ["street", "houseNumber", "postalCode", "city", "country", "latitude", "longitude"]) {
    this.fields = fields.slice();
  }

  diff(before, after) {
    const entries = this.fields.map(f => {
      const b = this._val(before, f);
      const a = this._val(after, f);
      const changed = !this._eq(b, a);
      return { field: f, before: b, after: a, changed };
    });
    const anyChanged = entries.some(e => e.changed);
    return { entries, anyChanged };
  }

  _val(obj, field) {
    if (!obj) return null;
    return obj[field] ?? null;
  }

  _eq(a, b) {
    if (typeof a === "number" || typeof b === "number") return Number(a || 0).toFixed(6) === Number(b || 0).toFixed(6);
    return (a || "").toString().trim().toLowerCase() === (b || "").toString().trim().toLowerCase();
  }
}


================================================================================
### PLIK: services/EditorStateSerializer.js
================================================================================

/**
 * ARCHITECTURE: EditorStateSerializer persists and restores editor state across reloads in session storage.
 * It follows the manifesto by isolating serialization concerns and avoiding component-level side effects.
 * Responsibilities:
 * - Save minimal editor payload keyed by orderId; restore and clear on demand.
 * - Handle safe JSON parse/stringify and namespace keys to avoid collisions.
 */
export class EditorStateSerializer {
  constructor(namespace = "editor") {
    this.ns = namespace;
    this._store = typeof window !== "undefined" ? window.sessionStorage : null;
  }

  save(orderId, state) {
    if (!this._store || !orderId) return false;
    const key = this._key(orderId);
    const payload = {
      at: Date.now(),
      editedPickup: state?.editedPickup || null,
      editedDelivery: state?.editedDelivery || null,
    };
    this._store.setItem(key, JSON.stringify(payload));
    return true;
  }

  load(orderId) {
    if (!this._store || !orderId) return null;
    const raw = this._store.getItem(this._key(orderId));
    if (!raw) return null;
    try {
      return JSON.parse(raw);
    } catch {
      return null;
    }
  }

  clear(orderId) {
    if (!this._store || !orderId) return false;
    this._store.removeItem(this._key(orderId));
    return true;
  }

  _key(orderId) {
    return `${this.ns}:${orderId}`;
  }
}


================================================================================
### PLIK: services/EnvironmentConfigService.js
================================================================================

/**
 * ARCHITECTURE: EnvironmentConfigService centralizes runtime configuration discovery for the frontend.
 * It follows the manifesto by isolating environment concerns and producing a deterministic config object.
 * Responsibilities:
 * - Load API base URL and flags from environment variables or window-injected globals.
 * - Expose get(key) and typed helpers; set window.__API_BASE_URL__ for ApiHttpClient consumers.
 */
export class EnvironmentConfigService {
  constructor() {
    this._loaded = false;
    this._cfg = {
      API_BASE_URL: "",
      GOOGLE_MAPS_API_KEY: "",
      APP_ENV: "development",
    };
  }

  async load() {
    if (this._loaded) return this._cfg;
    const w = typeof window !== "undefined" ? window : {};
    const env = w.__APP_ENV__ || {};
    const apiFromWindow = (w.__API_BASE_URL__ || "").trim();
    const apiFromEnv = (import.meta && import.meta.env && import.meta.env.VITE_API_BASE_URL) || "";
    const keyFromWindow = (w.__GOOGLE_MAPS_API_KEY__ || "").trim();
    const keyFromEnv = (import.meta && import.meta.env && import.meta.env.VITE_GOOGLE_MAPS_API_KEY) || "";
    const appEnv = (import.meta && import.meta.env && import.meta.env.MODE) || env.MODE || "development";
    this._cfg = {
      API_BASE_URL: apiFromWindow || apiFromEnv || "",
      GOOGLE_MAPS_API_KEY: keyFromWindow || keyFromEnv || "",
      APP_ENV: appEnv,
    };
    if (typeof window !== "undefined") {
      window.__API_BASE_URL__ = this._cfg.API_BASE_URL;
    }
    this._loaded = true;
    return this._cfg;
  }

  get(key, fallback = null) {
    return Object.prototype.hasOwnProperty.call(this._cfg, key) ? this._cfg[key] : fallback;
  }

  apiBase() {
    return this.get("API_BASE_URL", "");
  }

  googleKey() {
    return this.get("GOOGLE_MAPS_API_KEY", "");
  }

  appEnv() {
    return this.get("APP_ENV", "development");
  }
}


================================================================================
### PLIK: services/ErrorTypeDictionary.js
================================================================================

/**
 * ARCHITECTURE: ErrorTypeDictionary maps backend error codes to user-facing labels and severities.
 * It follows the manifesto by isolating presentation-neutral taxonomy from API DTOs.
 * Responsibilities:
 * - Provide stable lookups for label, severity, and suggested actions per error type.
 * - Allow extension via register() without changing existing mappings.
 */
export class ErrorTypeDictionary {
  constructor() {
    this._map = new Map();
    this._map.set("INVALID_POSTAL_CODE", { label: "Invalid ZIP/Postal Code", severity: "critical", actions: ["verify", "fix-postal"] });
    this._map.set("AMBIGUOUS_STREET", { label: "Ambiguous Street (Apt/Suite missing)", severity: "warning", actions: ["add-apartment", "verify"] });
    this._map.set("NON_STANDARDIZED", { label: "Non-standardized Address", severity: "info", actions: ["normalize", "verify"] });
  }

  get(code) {
    return this._map.get(code) || { label: code || "Unknown Error", severity: "info", actions: [] };
  }

  register(code, entry) {
    if (!code || typeof entry !== "object") throw new Error("ErrorTypeDictionary: invalid registration.");
    this._map.set(code, entry);
    return true;
  }
}


================================================================================
### PLIK: services/FeatureFlagService.js
================================================================================

/**
 * ARCHITECTURE: FeatureFlagService loads and caches runtime feature flags that guide UX policies.
 * It follows the manifesto by centralizing flag access behind explicit getters with session caching.
 * Responsibilities:
 * - Fetch flags from backend once; expose booleans for critical flows (requireGeocode, bulkEdit).
 * - Allow local overrides for testing without changing backend state.
 */
import apiClient from "@/services/api";

export class FeatureFlagService {
  constructor(endpoint = "/status/feature-flags") {
    this.endpoint = endpoint;
    this._flags = null;
    this._inFlight = null;
    this._overrides = {};
  }

  async load() {
    if (this._flags) return this._flags;
    if (this._inFlight) return this._inFlight;
    this._inFlight = apiClient.get(this.endpoint).then(r => {
      this._flags = r?.data || {};
      return this._flags;
    }).finally(() => (this._inFlight = null));
    return this._inFlight;
  }

  setOverride(key, value) {
    this._overrides[key] = value;
    return true;
  }

  get(key, fallback = false) {
    const base = this._flags && Object.prototype.hasOwnProperty.call(this._flags, key) ? this._flags[key] : fallback;
    return Object.prototype.hasOwnProperty.call(this._overrides, key) ? this._overrides[key] : base;
  }

  requireGeocode() {
    return !!this.get("REQUIRE_GEOCODE", false);
  }

  allowBulkEdit() {
    return !!this.get("ALLOW_BULK_EDIT", true);
  }
}


================================================================================
### PLIK: services/GoogleErrorTranslator.js
================================================================================

/**
 * ARCHITECTURE: GoogleErrorTranslator maps Google Maps/Places status messages to stable application errors.
 * It follows the manifesto by isolating third-party semantics from business logic and controllers.
 * Responsibilities:
 * - Translate known status/error strings to canonical codes and user-friendly messages.
 * - Provide a simple translate(err) that returns {code,message,retryable}.
 */
export class GoogleErrorTranslator {
  constructor() {
    this._map = new Map();
    this._map.set("OVER_QUERY_LIMIT", { code: "RATE_LIMIT", message: "Google quota exceeded", retryable: true });
    this._map.set("ZERO_RESULTS", { code: "NO_RESULTS", message: "No results found", retryable: false });
    this._map.set("REQUEST_DENIED", { code: "DENIED", message: "Request denied by Google", retryable: false });
    this._map.set("INVALID_REQUEST", { code: "INVALID", message: "Invalid geocoding request", retryable: false });
    this._map.set("UNKNOWN_ERROR", { code: "UNKNOWN", message: "Temporary Google error", retryable: true });
  }

  translate(error) {
    const msg = (error?.message || "").toUpperCase();
    for (const [k, v] of this._map.entries()) {
      if (msg.includes(k)) return v;
    }
    const status = error?.status || error?.response?.status || null;
    if (status === 429) return { code: "RATE_LIMIT", message: "Rate limit reached", retryable: true };
    if (status === 503) return { code: "UNAVAILABLE", message: "Service unavailable", retryable: true };
    return { code: "GENERIC", message: error?.message || "Unexpected Google error", retryable: false };
  }
}


================================================================================
### PLIK: services/GoogleKeyProvider.js
================================================================================

/**
 * ARCHITECTURE: GoogleKeyProvider offers a minimal, cached accessor for the Google Maps API key.
 * Responsibilities:
 * - Resolve the key from EnvironmentConfigService once and memoize it.
 */
import { EnvironmentConfigService } from "@/services/EnvironmentConfigService";

export class GoogleKeyProvider {
  constructor(configService = new EnvironmentConfigService()) {
    this.config = configService;
    this._key = null;
    this._inFlight = null;
  }

  async getKey() {
    if (this._key) return this._key;
    if (this._inFlight) return this._inFlight;
    this._inFlight = this.config.load().then(() => {
      this._key = this.config.googleKey();
      if (!this._key) throw new Error("GoogleKeyProvider: GOOGLE_MAPS_JS_API_KEY missing.");
      return this._key;
    }).finally(() => {
      this._inFlight = null;
    });
    return this._inFlight;
  }
}


================================================================================
### PLIK: services/IdempotencyTokenService.js
================================================================================

/**
 * ARCHITECTURE: IdempotencyTokenService creates deterministic tokens for save requests.
 * It follows the manifesto by isolating token generation from controllers and transport layers.
 * Responsibilities:
 * - Produce a stable hash-like token from orderId, side, and payload string.
 */
export class IdempotencyTokenService {
  create(orderId, side, payloadString) {
    const base = `${orderId || ""}|${side || "both"}|${payloadString || ""}`;
    // Simple Fowlerâ€“Nollâ€“Vo (FNV-1a) 32-bit hash for deterministic tokens
    let h = 0x811c9dc5;
    for (let i = 0; i < base.length; i++) {
      h ^= base.charCodeAt(i);
      h = (h + ((h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24))) >>> 0;
    }
    return `idem-${h.toString(16)}`;
  }
}


================================================================================
### PLIK: services/LatencyBudget.js
================================================================================

/**
 * ARCHITECTURE: LatencyBudget enforces per-step execution budgets for snappy UX under load.
 * It follows the manifesto by isolating timing limits and providing a race-with-timeout helper.
 * Responsibilities:
 * - Wrap a promise with a timeout; resolve fallback when exceeded; report elapsed for telemetry.
 */
export class LatencyBudget {
  constructor(defaultMs = 1200) {
    this.defaultMs = Math.max(100, defaultMs);
  }

  async runWithTimeout(promiseFactory, timeoutMs = this.defaultMs, fallback = null) {
    const start = Date.now();
    const to = new Promise(resolve => setTimeout(() => resolve({ timeout: true, value: fallback }), Math.max(50, timeoutMs)));
    const op = Promise.resolve().then(() => promiseFactory()).then(v => ({ timeout: false, value: v }));
    const res = await Promise.race([to, op]);
    const elapsedMs = Date.now() - start;
    return { ...res, elapsedMs };
  }
}


================================================================================
### PLIK: services/LoadingBarrier.js
================================================================================

/**
 * ARCHITECTURE: LoadingBarrier serializes concurrent loads by key and ensures latest-wins semantics.
 * It follows the manifesto by centralizing anti-race logic for order detail fetches and suggestion refreshes.
 * Responsibilities:
 * - Track an incrementing ticket per key; resolve only if the ticket is still current when the promise returns.
 * - Provide a simple run(key, fn) API that callers wrap around their async loads.
 */
export class LoadingBarrier {
  constructor() {
    this._tickets = new Map();
  }

  async run(key, fn) {
    if (!key || typeof fn !== "function") throw new Error("LoadingBarrier: invalid arguments.");
    const next = (this._tickets.get(key) || 0) + 1;
    this._tickets.set(key, next);
    const myTicket = next;
    const result = await fn();
    if (this._tickets.get(key) !== myTicket) return null;
    return result;
  }

  invalidate(key) {
    const next = (this._tickets.get(key) || 0) + 1;
    this._tickets.set(key, next);
    return next;
  }
}


================================================================================
### PLIK: services/OrderDetailPrefetcher.js
================================================================================

/**
 * ARCHITECTURE: OrderDetailPrefetcher warms the cache by fetching the next order detail proactively.
 * It follows the manifesto by separating performance optimizations from core controllers.
 * Responsibilities:
 * - Prefetch via AddressExceptionApi and hold a single-item cache keyed by orderId.
 * - Provide getOrFetch(id) to serve from cache or network.
 */
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

export class OrderDetailPrefetcher {
  constructor(api = new AddressExceptionApi()) {
    this.api = api;
    this._cachedId = null;
    this._cached = null;
  }

  async prefetch(nextOrderId) {
    if (!nextOrderId) return false;
    const r = await this.api.getOrderDetail(nextOrderId);
    if (r.ok) {
      this._cachedId = nextOrderId;
      this._cached = r.value;
      return true;
    }
    return false;
  }

  async getOrFetch(orderId) {
    if (this._cachedId === orderId && this._cached) return this._cached;
    const r = await this.api.getOrderDetail(orderId);
    if (r.ok) {
      this._cachedId = orderId;
      this._cached = r.value;
      return r.value;
    }
    throw r.error;
  }

  clear() {
    this._cachedId = null;
    this._cached = null;
    return true;
  }
}


================================================================================
### PLIK: services/OrdersKpiEstimator.js
================================================================================

/**
 * ARCHITECTURE: OrdersKpiEstimator (Stub) would be responsible for calculating
 * client-side KPIs or estimates based on a list of order data.
 * This is a placeholder implementation.
 */
export class OrdersKpiEstimator {
    constructor() {
        // Configuration for KPI calculation
    }

    /**
     * Calculates KPIs from a list of worklist items.
     * @param {Array<object>} items - The list of order summary DTOs.
     * @returns {object} An object containing calculated KPIs (e.g., { pending, avgAgeMs }).
     */
    calculate(items = []) {
        const pending = items.filter(item => item.processingStatus === 'ADDRESS_NEEDS_REVIEW').length;
        const now = Date.now();
        const ages = items
            .filter(item => item.processingStatus === 'ADDRESS_NEEDS_REVIEW' && item.createdAt)
            .map(item => now - new Date(item.createdAt).getTime());

        const avgAgeMs = ages.length > 0
            ? ages.reduce((a, b) => a + b, 0) / ages.length
            : 0;

        return {
            pending: pending,
            avgAgeMs: avgAgeMs,
        };
    }
}

================================================================================
### PLIK: services/OrdersQueueService.js
================================================================================

/**
 * ARCHITECTURE: OrdersQueueService maintains a FIFO queue of orderIds for Save & Next workflows.
 * It follows the manifesto by isolating queue mechanics from components and views.
 * Responsibilities:
 * - Load from a list, advance to next, remove current, inspect current/size/ids.
 */
export class OrdersQueueService {
  constructor() {
    this._ids = [];
    this._index = 0;
  }

  loadFromItems(items) {
    this._ids = (Array.isArray(items) ? items : []).map(x => x.orderId).filter(Boolean);
    this._index = 0;
    return this.ids();
  }

  ids() {
    return this._ids.slice();
  }

  size() {
    return Math.max(0, this._ids.length - this._index);
  }

  current() {
    return this._ids[this._index] || null;
  }

  next() {
    if (this._index + 1 >= this._ids.length) return null;
    this._index++;
    return this.current();
  }

  remove(orderId) {
    const pos = this._ids.indexOf(orderId);
    if (pos === -1) return false;
    this._ids.splice(pos, 1);
    if (this._index > pos) this._index--;
    return true;
  }

  reset() {
    this._ids = [];
    this._index = 0;
    return true;
  }
}


================================================================================
### PLIK: services/OrderStatusWatcher.js
================================================================================

/**
 * ARCHITECTURE: OrderStatusWatcher polls backend for a single order until a target status is reached.
 * It follows the manifesto by isolating polling semantics from views and controllers with a clear contract.
 * Responsibilities:
 * - Poll /orders/{id} at a fixed interval and resolve when status âˆˆ target set or when max time elapses.
 * - Expose start(), cancel(), and onTick hooks for progress indicators without leaking transport details.
 */
import apiClient from "@/services/api";

export class OrderStatusWatcher {
  constructor(intervalMs = 2000, timeoutMs = 60000) {
    this.intervalMs = Math.max(250, intervalMs);
    this.timeoutMs = Math.max(this.intervalMs, timeoutMs);
    this._timer = null;
    this._startedAt = 0;
    this._active = false;
    this._onTick = null;
  }

  onTick(fn) {
    this._onTick = typeof fn === "function" ? fn : null;
    return this;
  }

  start(orderId, targetStatuses = ["ADDRESS_VALIDATED", "MANUALLY_CORRECTED"]) {
    if (!orderId) throw new Error("OrderStatusWatcher: orderId required.");
    this.cancel();
    this._active = true;
    this._startedAt = Date.now();
    return new Promise((resolve, reject) => {
      const tick = async () => {
        if (!this._active) return;
        try {
          const r = await apiClient.get(`/orders/${encodeURIComponent(orderId)}`);
          const status = r?.data?.processingStatus || null;
          if (this._onTick) this._onTick({ status, elapsedMs: Date.now() - this._startedAt });
          if (status && targetStatuses.includes(status)) {
            this.cancel();
            return resolve({ status, elapsedMs: Date.now() - this._startedAt });
          }
        } catch (e) {
          this.cancel();
          return reject(e);
        }
        if (Date.now() - this._startedAt > this.timeoutMs) {
          this.cancel();
          return resolve({ status: null, elapsedMs: this.timeoutMs, timeout: true });
        }
        this._timer = setTimeout(tick, this.intervalMs);
      };
      this._timer = setTimeout(tick, this.intervalMs);
    });
  }

  cancel() {
    this._active = false;
    if (this._timer) clearTimeout(this._timer);
    this._timer = null;
    return true;
  }
}


================================================================================
### PLIK: services/PollingService.js
================================================================================

/**
 * ARCHITECTURE: PollingService centralizes controlled, single-instance polling loops per key.
 * It follows the manifesto by isolating timing concerns and exposing explicit start/stop contracts.
 * Responsibilities:
 * - Start a debounced timer for an async function and prevent duplicate loops for the same key.
 * - Provide deterministic cancellation via handles and bulk stop-All capability.
 */
export class PollingService {
  constructor() {
    this._timers = new Map();
  }

  start(key, intervalMs, asyncFn) {
    if (!key || typeof asyncFn !== "function" || typeof intervalMs !== "number" || intervalMs <= 0) {
      throw new Error("PollingService.start: invalid arguments.");
    }
    this.stop(key);
    let active = true;
    const tick = async () => {
      if (!active) return;
      try {
        await asyncFn();
      } catch (_) {
        // Errors are handled upstream; polling continues unless explicitly stopped.
      }
      if (active) {
        this._timers.set(key, setTimeout(tick, intervalMs));
      }
    };
    this._timers.set(key, setTimeout(tick, intervalMs));
    return { key, stop: () => this.stop(key) };
  }

  stop(key) {
    const t = this._timers.get(key);
    if (t) {
      clearTimeout(t);
      this._timers.delete(key);
    }
  }

  stopAll() {
    for (const key of this._timers.keys()) {
      this.stop(key);
    }
  }
}


================================================================================
### PLIK: services/QuotaBackoffService.js
================================================================================

/**
 * ARCHITECTURE: QuotaBackoffService (Stub) would manage client-side rate limiting
 * or backoff strategies when interacting with external APIs (like Google)
 * that enforce quotas. This is a placeholder.
 */
import { RetryPolicy } from "@/services/RetryPolicy"; // Assumes RetryPolicy exists

export class QuotaBackoffService {
    constructor() {
        // Configure retry policy specifically for quota errors
        this.retryPolicy = new RetryPolicy(
            3, // Max 3 attempts
            500, // Base delay 500ms
            200, // Jitter 200ms
            (error) => {
                // Only retry on specific quota-related error messages or status codes
                const msg = (error?.message || "").toLowerCase();
                const status = error?.response?.status;
                return msg.includes("quota") || msg.includes("rate limit") || status === 429 || status === 503;
            }
        );
    }

    /**
     * Executes a function wrapped in the backoff/retry policy.
     * @param {Function} asyncFn - The async function to execute (e.g., () => geocoder.geocode(...)).
     * @returns {Promise<any>} The result of the async function.
     */
    async execute(asyncFn) {
        try {
            return await this.retryPolicy.execute(asyncFn);
        } catch (error) {
            console.warn("[QuotaBackoffService] Execution failed after retries:", error);
            throw error; // Re-throw the final error
        }
    }
}

================================================================================
### PLIK: services/RetryPolicy.js
================================================================================

/**
 * ARCHITECTURE: RetryPolicy executes async operations with bounded retries and jittered backoff.
 * It follows the manifesto by centralizing resilience concerns away from controllers and adapters.
 * Responsibilities:
 * - Execute a provided async function up to maxAttempts with exponential backoff and random jitter.
 * - Allow fast-fail on non-retryable errors via predicate.
 */
export class RetryPolicy {
  constructor(maxAttempts = 5, baseDelayMs = 300, jitterMs = 150, isRetryable = () => true) {
    this.maxAttempts = Math.max(1, maxAttempts);
    this.baseDelayMs = Math.max(0, baseDelayMs);
    this.jitterMs = Math.max(0, jitterMs);
    this.isRetryable = isRetryable;
  }

  async execute(fn) {
    let attempt = 0;
    let lastError = null;
    while (attempt < this.maxAttempts) {
      try {
        return await fn();
      } catch (e) {
        lastError = e;
        attempt++;
        if (attempt >= this.maxAttempts || !this.isRetryable(e)) break;
        const backoff = this.baseDelayMs * Math.pow(2, attempt - 1);
        const jitter = Math.floor(Math.random() * this.jitterMs);
        await new Promise((r) => setTimeout(r, backoff + jitter));
      }
    }
    throw lastError || new Error("RetryPolicy: execution failed.");
  }
}


================================================================================
### PLIK: services/RuntimeHealthService.js
================================================================================

/**
 * ARCHITECTURE: RuntimeHealthService is a tolerant, dev-first health probe that never blocks the UI.
 * It follows the manifesto by eliminating non-essential cross-origin calls that cause startup noise.
 * Responsibilities:
 * - Always return a "ready" structure without performing any network requests in development.
 * - Preserve the method signature so other controllers remain decoupled from transport concerns.
 */
export class RuntimeHealthService {
  constructor() {
    this.devBypass = true; // development-first: suppress all /status calls to avoid 403/5xx noise
  }

  async readiness(googleKey) {
    return {
      ready: true,
      backend: { ok: true, code: 200 },
      provider: { ok: true, code: 200 },
      google: { ok: !!googleKey },
    };
  }
}


================================================================================
### PLIK: services/SessionStorageService.js
================================================================================

/**
 * ARCHITECTURE: SessionStorageService persists small JSON blobs across reloads within the session.
 * It follows the manifesto by isolating storage read/write and providing safe JSON handling.
 * Responsibilities:
 * - Save and load values by key with automatic JSON serialization and prefixing to avoid collisions.
 * - Provide remove and clearNamespace utilities without affecting unrelated storage.
 */
export class SessionStorageService {
  constructor(namespace = "wb") {
    this.ns = namespace;
    this._prefix = `${this.ns}:`;
    this._store = typeof window !== "undefined" ? window.sessionStorage : null;
  }

  save(key, value) {
    if (!this._store) return false;
    this._store.setItem(this._prefix + key, JSON.stringify(value == null ? null : value));
    return true;
  }

  load(key, fallback = null) {
    if (!this._store) return fallback;
    const raw = this._store.getItem(this._prefix + key);
    if (raw == null) return fallback;
    try {
      return JSON.parse(raw);
    } catch {
      return fallback;
    }
  }

  remove(key) {
    if (!this._store) return false;
    this._store.removeItem(this._prefix + key);
    return true;
  }

  clearNamespace() {
    if (!this._store) return 0;
    const keys = [];
    for (let i = 0; i < this._store.length; i++) {
      const k = this._store.key(i);
      if (k && k.startsWith(this._prefix)) keys.push(k);
    }
    keys.forEach(k => this._store.removeItem(k));
    return keys.length;
  }
}


================================================================================
### PLIK: services/SuggestionConflictDetector.js
================================================================================

/**
 * ARCHITECTURE: SuggestionConflictDetector (Stub) would be responsible for
 * analyzing a list of suggestions and flagging potential conflicts
 * (e.g., same street/city but different postal codes).
 * This is a placeholder implementation.
 */
export class SuggestionConflictDetector {
    constructor() {
        // Configuration for conflict detection
    }

    /**
     * Analyzes a list of suggestions and returns conflict metadata.
     * @param {Array<object>} suggestions - List of normalized suggestions.
     * @returns {object} An object describing conflicts (e.g., { hasPostalConflict: true }).
     */
    analyze(suggestions = []) {
        if (suggestions.length < 2) {
            return { hasPostalConflict: false, hasCityConflict: false };
        }

        // Example: Check for postal code conflicts (same street/city, different postal)
        const postalCodes = new Set();
        let hasPostalConflict = false;
        const firstStreet = suggestions[0].street?.toLowerCase();
        const firstCity = suggestions[0].city?.toLowerCase();

        for (const s of suggestions) {
            if (s.postalCode) {
                // Check if this suggestion has same street/city but different postal code
                if (s.street?.toLowerCase() === firstStreet && s.city?.toLowerCase() === firstCity) {
                    postalCodes.add(s.postalCode);
                    if (postalCodes.size > 1) {
                        hasPostalConflict = true;
                        break;
                    }
                }
            }
        }

        return {
            hasPostalConflict: hasPostalConflict,
            hasCityConflict: false, // TODO: Implement city conflict logic
        };
    }
}

================================================================================
### PLIK: services/SuggestionNormalizer.js
================================================================================

// FILE: src/services/SuggestionNormalizer.js
/**
 * ARCHITECTURE: SuggestionNormalizer converts heterogeneous provider responses into a unified Suggestion DTO.
 * It follows the manifesto by isolating mapping/normalization concerns and avoiding provider leakage into UI.
 * Responsibilities:
 * - Accept raw Google Geocoder/Places or TES suggestion objects and output a normalized shape.
 * - Provide batch normalization and safe defaults for missing fields.
 *
 * FIX: Removed erroneous circular self-import statement.
 */
// REMOVED: import { SuggestionNormalizer } from "@/services/SuggestionNormalizer";

export class SuggestionNormalizer {
  constructor(defaultCountry = "PL") {
    this.defaultCountry = defaultCountry;
  }

  fromGoogleGeocoder(geo) {
    if (!geo) return null;
    const comp = this._indexComponents(geo.address_components || []);
    return {
      fullAddressLabel: geo.formatted_address || null,
      street: comp.route ||
          null,
      houseNumber: comp.street_number || null,
      postalCode: comp.postal_code ||
          null,
      city: comp.locality || comp.postal_town || comp.administrative_area_level_2 ||
          null,
      countryCode: comp.country_code || this.defaultCountry,
      countryName: comp.country ||
          null,
      latitude: geo.geometry?.location?.lat?.() ?? null,
      longitude: geo.geometry?.location?.lng?.() ??
          null,
      matchScore: 0.95,
      matchLevel: "GEOCODER",
      providerSource: "GOOGLE_CLIENT",
    };
  }

  fromGooglePlaces(place) {
    if (!place) return null;
    const comp = this._indexComponents(place.address_components || []);
    return {
      fullAddressLabel: null,
      street: comp.route ||
          null,
      houseNumber: comp.street_number || null,
      postalCode: comp.postal_code ||
          null,
      city: comp.locality || comp.postal_town || comp.administrative_area_level_2 ||
          null,
      countryCode: comp.country_code || this.defaultCountry,
      countryName: comp.country ||
          null,
      latitude: place.geometry?.location?.lat?.() ?? null,
      longitude: place.geometry?.location?.lng?.() ??
          null,
      matchScore: 0.9,
      matchLevel: "PLACES",
      providerSource: "GOOGLE_PLACES",
    };
  }

  fromTes(item) {
    if (!item) return null;
    return {
      fullAddressLabel: item.label || null,
      street: item.street ||
          null,
      houseNumber: item.houseNumber || null,
      postalCode: item.postalCode ||
          null,
      city: item.city || null,
      countryCode: item.countryCode ||
          this.defaultCountry,
      countryName: item.country || null,
      latitude: typeof item.latitude === "number" ?
          item.latitude : null,
      longitude: typeof item.longitude === "number" ?
          item.longitude : null,
      matchScore: typeof item.score === "number" ?
          item.score : 0.7,
      matchLevel: item.level ||
          "TES",
      providerSource: "TES",
    };
  }

  normalizeBatch(list, origin) {
    if (!Array.isArray(list)) return [];
    if (origin === "GEOCODER") return list.map(x => this.fromGoogleGeocoder(x)).filter(Boolean);
    if (origin === "PLACES") return list.map(x => this.fromGooglePlaces(x)).filter(Boolean);
    if (origin === "TES") return list.map(x => this.fromTes(x)).filter(Boolean);
    return [];
  }

  _indexComponents(parts) {
    const map = {};
    for (const c of parts) {
      for (const t of c.types) {
        if (t === "country") {
          map.country = c.long_name;
          map.country_code = c.short_name;
        } else if (t === "locality") {
          map.locality = c.long_name;
        } else if (t === "postal_town") {
          map.postal_town = c.long_name;
        } else if (t === "administrative_area_level_2") {
          map.administrative_area_level_2 = c.long_name;
        } else if (t === "route") {
          map.route = c.long_name;
        } else if (t === "street_number") {
          map.street_number = c.long_name;
        } else if (t === "postal_code") {
          map.postal_code = c.long_name;
        }
      }
    }
    return map;
  }
}

================================================================================
### PLIK: services/SuggestionPreviewService.js
================================================================================

/**
 * ARCHITECTURE: SuggestionPreviewService creates a non-destructive preview Address object from a suggestion.
 * It follows the manifesto by isolating conversion rules away from editor state and components.
 * Responsibilities:
 * - Convert a suggestion DTO to an Address-like object the map can display without committing changes.
 */
export class SuggestionPreviewService {
  toAddressLike(s) {
    if (!s) return null;
    return {
      street: s.street || "",
      houseNumber: s.houseNumber || null,
      postalCode: s.postalCode || "",
      city: s.city || "",
      country: s.countryCode || s.country || "PL",
      latitude: typeof s.latitude === "number" ? s.latitude : null,
      longitude: typeof s.longitude === "number" ? s.longitude : null,
    };
  }
}


================================================================================
### PLIK: services/TelemetryService.js
================================================================================

// FILE: src/services/TelemetryService.js
// ENHANCED FILE
import { AddressExceptionApi } from '@/services/AddressExceptionApi'; // For sending logs
import { AuthController } from '@/controllers/AuthController'; // To potentially check auth state
import { ref } from 'vue';

const MAX_BUFFER_SIZE = 50;
const SEND_INTERVAL_MS = 15000; // Send logs every 15 seconds

/**
 * ARCHITECTURE: Simple telemetry for capturing key UI events and errors.
 * ENHANCED: Captures console logs, buffers them, and sends them periodically to the backend.
 */
export class TelemetryService {
    constructor(api = new AddressExceptionApi(), auth = new AuthController()) {
        this.api = api; // Use API service to send logs
        this.auth = auth; // To check if logged in
        this._logBuffer = ref([]); // Use ref for potential reactivity if needed later
        this._originalConsole = {};
        this._sendTimeoutId = null;
        this._isSending = false; // Prevent concurrent sends

        this._wrapConsole();
        this._startSendingInterval();
    }

    _wrapConsole() {
        const levels = ['log', 'info', 'warn', 'error', 'debug'];
        levels.forEach(level => {
            this._originalConsole[level] = console[level];
            console[level] = (...args) => {
                // Call original console method
                this._originalConsole[level]?.apply(console, args);
                // Capture and buffer the log
                this._captureLog(level, args);
            };
        });
        // Capture unhandled errors/rejections
        window.addEventListener('error', (event) => this._captureErrorEvent(event));
        window.addEventListener('unhandledrejection', (event) => this._captureUnhandledRejection(event));
    }

    _captureLog(level, args) {
        if (this._logBuffer.value.length >= MAX_BUFFER_SIZE) {
            // Optionally drop oldest log or stop buffering
            // console.warn("[Telemetry] Log buffer full, dropping oldest entry.");
            // this._logBuffer.value.shift();
            return; // Stop buffering if full for now
        }
        try {
            const message = args.map(arg => this._formatArg(arg)).join(' ');
            const logEntry = {
                timestamp: new Date().toISOString(),
                level: level.toUpperCase(),
                message: message,
                // Add context if needed: location: window.location.pathname, userAgent: navigator.userAgent
            };
            this._logBuffer.value.push(logEntry);
        } catch(e) {
            this._originalConsole.error?.("[Telemetry] Error capturing log:", e);
        }
    }

    _captureErrorEvent(event) {
        // event: ErrorEvent
        const entry = {
            timestamp: new Date().toISOString(),
            level: 'ERROR',
            message: event.message,
            source: 'window.onerror',
            filename: event.filename,
            lineno: event.lineno,
            colno: event.colno,
            error: event.error ? this._formatArg(event.error) : null
        };
        this._logBuffer.value.push(entry);
    }

    _captureUnhandledRejection(event) {
        // event: PromiseRejectionEvent
        const entry = {
            timestamp: new Date().toISOString(),
            level: 'ERROR',
            message: 'Unhandled promise rejection',
            source: 'window.onunhandledrejection',
            reason: event.reason ? this._formatArg(event.reason) : null
        };
        this._logBuffer.value.push(entry);
    }

    _formatArg(arg) {
        if (arg instanceof Error) {
            return `${arg.name}: ${arg.message}\n${arg.stack}`;
        }
        if (typeof arg === 'object' && arg !== null) {
            try {
                // Basic object serialization, limit depth/size if needed
                return JSON.stringify(arg);
            } catch {
                return '[Unserializable Object]';
            }
        }
        return String(arg);
    }

    _startSendingInterval() {
        if (this._sendTimeoutId) clearTimeout(this._sendTimeoutId);
        this._sendTimeoutId = setInterval(() => {
            this._sendBufferedLogs();
        }, SEND_INTERVAL_MS);
    }

    async _sendBufferedLogs() {
        // Check if user is authenticated before sending
        if (!this.auth.isAuthenticatedRef.value || this._isSending) {
            return;
        }
        if (this._logBuffer.value.length === 0) {
            return;
        }

        // Important: Swap buffer immediately to avoid race conditions
        const logsToSend = this._logBuffer.value;
        this._logBuffer.value = [];
        this._isSending = true;

        try {
            this._originalConsole.debug?.(`[Telemetry] Sending ${logsToSend.length} log entries...`);
            // Use the API client method (to be created in AddressExceptionApi)
            await this.api.sendClientLogs(logsToSend);
            // Logs sent successfully
        } catch (error) {
            this._originalConsole.error?.("[Telemetry] Failed to send client logs:", error);
            // Failed: Put logs back into buffer (potentially merging with new ones)
            // Be careful about buffer size limit
            const currentBuffer = this._logBuffer.value;
            this._logBuffer.value = [...logsToSend, ...currentBuffer].slice(0, MAX_BUFFER_SIZE);
            if (this._logBuffer.value.length >= MAX_BUFFER_SIZE) {
                this._originalConsole.warn?.("[Telemetry] Log buffer full after send failure.");
            }
        } finally {
            this._isSending = false;
        }
    }

    // Method to manually trigger send (e.g., on beforeunload)
    flushLogs() {
        if (this._sendTimeoutId) clearTimeout(this._sendTimeoutId);
        this._sendTimeoutId = null; // Stop interval
        // Send any remaining logs synchronously if possible, or async
        this._sendBufferedLogs(); // Fire and forget async send
    }

    // Call this when app unloads
    destroy() {
        this.flushLogs();
        // Restore original console methods
        Object.keys(this._originalConsole).forEach(level => {
            if (console[level] === this._originalConsole[level]) return; // Already restored or never wrapped
            console[level] = this._originalConsole[level];
        });
        window.removeEventListener('error', this._captureErrorEvent);
        window.removeEventListener('unhandledrejection', this._captureUnhandledRejection);
    }

    // Existing methods (can remain or be removed if only log capture is needed)
    event(name, data = {}) {
        // console.log("[Telemetry Event]", name, data);
        this._captureLog('info', [`[Telemetry Event] ${name}`, data]);
    }
    error(err, context = {}) {
        // console.error("[Telemetry Error]", err, context);
        this._captureLog('error', ["[Telemetry Error]", err, context]);
    }
}

================================================================================
### PLIK: services/TesOperationPoller.js
================================================================================

/**
 * ARCHITECTURE: TesOperationPoller handles polling the DANXILS-API status endpoint
 * for asynchronous operations initiated via Kafka proxies.
 * Responsibilities:
 * - Poll a given status URL until the operation status is COMPLETED or FAILED.
 * - Implement configurable retry limits and polling intervals.
 * - Return the final operation status and result/error.
 */
import apiClient from '@/services/api';

export class TesOperationPoller {
    constructor(defaultIntervalMs = 2000, defaultMaxRetries = 15) {
        this.intervalMs = defaultIntervalMs;
        this.maxRetries = defaultMaxRetries;
    }

    async waitFor(correlationId, intervalMs = this.intervalMs, maxRetries = this.maxRetries) {
        if (!correlationId) {
            throw new Error("TesOperationPoller: correlationId is required.");
        }

        const statusUrl = `/api/admin/address-verification/operations/${correlationId}`;
        console.debug(`Polling status for ${correlationId} at ${statusUrl}...`);

        for (let i = 0; i < maxRetries; i++) {
            try {
                if (i > 0) {
                    await new Promise(resolve => setTimeout(resolve, intervalMs));
                }

                const statusResponse = await apiClient.get(statusUrl);
                const operation = statusResponse.data;

                if (!operation || !operation.status) {
                    console.warn(`Polling for ${correlationId}: Received unexpected response. Retrying...`);
                    continue;
                }

                console.debug(`Polling for ${correlationId}: Attempt ${i+1}/${maxRetries}, Status: ${operation.status}`);

                if (operation.status === 'COMPLETED') {
                    let parsedResult = operation.responsePayloadJson;
                    if (parsedResult && typeof parsedResult === 'string') {
                        try {
                            parsedResult = JSON.parse(parsedResult);
                        } catch (parseError) {
                            console.warn(`Polling for ${correlationId}: Completed, but failed to parse responsePayloadJson`, parseError);
                        }
                    }
                    return { ...operation, result: parsedResult };
                }

                if (operation.status === 'FAILED') {
                    return { ...operation, errorDetails: operation.errorMessage };
                }

            } catch (error) {
                if (error.response?.status === 404) {
                    console.warn(`Polling for ${correlationId}: Received 404. Retrying (attempt ${i+1}/${maxRetries})...`);
                } else {
                    console.error(`Polling for ${correlationId}: Error during attempt ${i+1}:`, error);
                }
            }
        }

        throw new Error(`Polling for operation ${correlationId} timed out after ${maxRetries} attempts.`);
    }
}


================================================================================
### PLIK: services/UndoStackService.js
================================================================================

// FILE: services/UndoStackService.js
/**
 * ARCHITECTURE: UndoStackService provides bounded undo/redo stacks for immutable editor state snapshots.
 * It follows the manifesto by isolating time-travel mechanics with a deterministic, dependency-free API.
 * Responsibilities:
 * - Push snapshots, undo, redo, and limit memory with a maximum capacity.
 * - Expose current() without mutating returned objects.
 * REFACTORED: Added canUndo() and canRedo() methods.
 */
export class UndoStackService {
  constructor(capacity = 50) {
    this.capacity = Math.max(1, capacity);
    this._past = [];
    this._future = [];
    this._current = null;
  }

  init(snapshot) {
    this._past = [];
    this._future = [];
    this._current = snapshot ? JSON.parse(JSON.stringify(snapshot)) : null;
    return this.current();
  }

  push(snapshot) {
    if (this._current != null) {
      this._past.push(this._current);
      if (this._past.length > this.capacity) this._past.shift();
    }
    this._current = snapshot ? JSON.parse(JSON.stringify(snapshot)) : null;
    this._future = [];
    return this.current();
  }

  undo() {
    if (!this._past.length) return this.current();
    this._future.unshift(this._current);
    this._current = this._past.pop();
    return this.current();
  }

  redo() {
    if (!this._future.length) return this.current();
    this._past.push(this._current);
    this._current = this._future.shift();
    return this.current();
  }

  clear() {
    this._past = [];
    this._future = [];
    return true;
  }

  current() {
    return this._current ? JSON.parse(JSON.stringify(this._current)) : null;
  }

  // --- ADDED METHODS ---
  /** Checks if an undo operation is possible. */
  canUndo() {
    return this._past.length > 0;
  }

  /** Checks if a redo operation is possible. */
  canRedo() {
    return this._future.length > 0;
  }
  // --- END ADDED METHODS ---
}

================================================================================
### PLIK: services/ValidationService.js
================================================================================

/**
 * ARCHITECTURE: ValidationService provides basic, potentially country-specific,
 * validation rules for address fields. Adheres to SRP by isolating validation logic.
 * This is a basic stub implementation; enhance with actual rules as needed.
 */
export class ValidationService {
    constructor(countryCode = "PL") {
        this.countryCode = countryCode.toUpperCase();
        // Basic required fields for PL example
        this.requiredFields = ["street", "postalCode", "city", "country"];
        // Basic regex for PL postal code example
        this.postalRegex = /^\d{2}-\d{3}$/;
    }

    /**
     * Validates an address object based on configured rules.
     * @param {object} address - The address object to validate (e.g., { street, postalCode, city, country }).
     * @returns {{valid: boolean, errors: object}} - Validation result.
     */
    validate(address) {
        const errors = {};
        let valid = true;

        if (!address) {
            return { valid: false, errors: { general: "Address object is missing." } };
        }

        // Check required fields
        for (const field of this.requiredFields) {
            if (!address[field] || String(address[field]).trim() === "") {
                errors[field] = `${field} is required.`;
                valid = false;
            }
        }

        // Check postal code format (example for PL)
        if (this.countryCode === "PL" && address.postalCode && !this.postalRegex.test(String(address.postalCode).trim())) {
            errors.postalCode = "Invalid postal code format (expected XX-XXX).";
            valid = false;
        }

        // Add more specific validation rules here (length, character sets, etc.)

        return { valid, errors };
    }
}

================================================================================
### PLIK: debug/StartupProbe.js
================================================================================

/**
 * ARCHITECTURE: StartupProbe emits deterministic breadcrumbs during app boot and first render.
 * It follows the manifesto by isolating debug side effects from core logic.
 * Responsibilities:
 * - Log lifecycle milestones; stamp <html data-app-boot="..."> for visual confirmation.
 */
export class StartupProbe {
    constructor() {
        this.marks = [];
    }

    mark(label) {
        const ts = new Date().toISOString();
        const entry = `${ts} :: ${label}`;
        this.marks.push(entry);
        if (typeof console !== "undefined" && console.log) console.log("[startup]", entry);
        try {
            const html = document.documentElement;
            html.setAttribute("data-app-boot", label);
        } catch (_) { /* ignore */ }
        return entry;
    }

    dump() {
        if (typeof console !== "undefined" && console.table) console.table(this.marks.map((m, i) => ({ i, m })));
        return this.marks.slice();
    }
}

================================================================================
### PLIK: router/AuthGuard.js
================================================================================

/**
 * ARCHITECTURE: AuthGuard protects routes by requiring an authenticated session.
 * It follows the manifesto by isolating navigation policy and tolerating a minimal localStorage token.
 * Responsibilities:
 * - Allow /login always.
 * - Accept session from AuthSessionService; if absent, fall back to localStorage.accessToken and bind header.
 */
import { AuthSessionService } from "@/services/AuthSessionService";
import { ApiAuthBinder } from "@/services/ApiAuthBinder";

export class AuthGuard {
    constructor(session = new AuthSessionService(), binder = new ApiAuthBinder()) {
        this.session = session;
        this.binder = binder;
    }

    async canEnter(to) {
        const path = String(to?.path || "");
        if (path.startsWith("/login")) return true;

        // Primary: full session saved by AuthController
        if (this.session.isAuthenticated()) {
            const tok = this.session.getAccessToken();
            const typ = this.session.getTokenType();
            if (tok) this.binder.bind(tok, typ);
            return true;
        }

        // Tolerant fallback: plain token in localStorage (e.g., from earlier minimal form)
        if (typeof window !== "undefined") {
            const raw = window.localStorage?.getItem("accessToken");
            if (raw && raw.length > 10) {
                this.binder.bind(raw, "Bearer");
                return true;
            }
        }

        throw new Error("AuthGuard: unauthenticated.");
    }
}


================================================================================
### PLIK: router/EditorRouteGuard.js
================================================================================

// FILE: src/router/EditorRouteGuard.js
/**
 * ARCHITECTURE: Ensures GeoRuntime is initialized and required providers are ready.
 * Supports Leaflet/Nominatim or Google stacks via configuration.
 */
export class EditorRouteGuard {
  constructor(geoRuntime) {
    if (!geoRuntime) throw new Error("EditorRouteGuard requires GeoRuntime.");
    this._geoRuntime = geoRuntime;
  }

  async canEnter(to) {
    const orderId = to?.params?.id || to?.query?.orderId || null;
    if (!orderId) throw new Error("EditorRouteGuard: orderId is required.");

    // Ensure providers are initialized before checking readiness.
    await this._geoRuntime.init();

    const cfg = this._geoRuntime._config;
    const mustBeReady = [
      ["map", cfg.map],
      ["geocode", cfg.geocode],
      ...(cfg.places && cfg.places !== "none" ? [["places", cfg.places]] : [])
    ];

    for (const [type, provider] of mustBeReady) {
      if (!this._geoRuntime.isProviderReady(type, provider)) {
        throw new Error(`EditorRouteGuard: ${type} provider '${provider}' not available.`);
      }
    }

    return true;
  }
}


================================================================================
### PLIK: router/index.js
================================================================================

// ============================================================================
// Frontend âžœ router/index.js (Final Version)
// REASON: Ensure GeoRuntime is passed, guards are correctly instantiated and used.
// ============================================================================
// FILE: src/router/index.js

import { createRouter as vueCreateRouter, createWebHistory } from "vue-router";
import LoginView from "@/views/LoginView.vue";
import WorklistView from "@/views/WorklistView.vue";
import TriageDashboard from "@/views/TriageDashboard.vue";
import CorrectionEditorView from "@/views/CorrectionEditorView.vue";
import LogDashboardView from "@/views/LogDashboardView.vue";
import AedAdminView from "@/views/AedAdminView.vue";
// *** ADDED IMPORTS FOR NEW ADMIN VIEWS ***
import HubRulesView from "@/views/HubRulesView.vue";
import AddressUploadView from "@/views/AddressUploadView.vue";

import { AuthGuard } from "@/router/AuthGuard";
import { EditorRouteGuard } from "@/router/EditorRouteGuard";
import { AuthSessionService } from "@/services/AuthSessionService";

/**
 * ARCHITECTURE: Creates the Vue Router with guards for authentication and editor prerequisites.
 * REFACTORED: Added routes for Hub Rules, Address Upload, AED SFTP Admin. Corrected admin role check.
 */
export function createRouter(geoRuntime) { // GeoRuntime must be passed from main.js
  if (!geoRuntime) throw new Error("createRouter requires a GeoRuntime instance.");

  const editorGuard = new EditorRouteGuard(geoRuntime);
  const authGuard = new AuthGuard();
  const authSession = new AuthSessionService(); // For role checking

  const routes = [
    { path: "/", redirect: "/login" },
    { path: "/login", name: "login", component: LoginView },

    // Protected routes
    { path: "/dashboard", name: "dashboard", component: TriageDashboard, meta: { requiresAuth: true } },
    { path: "/worklist", name: "worklist", component: WorklistView, meta: { requiresAuth: true } },
    {
      path: "/editor/:id",
      name: "editor",
      component: CorrectionEditorView,
      meta: { requiresAuth: true }, // Editor requires auth
      beforeEnter: async (to, _from, next) => {
        try {
          // Check if geo providers are ready *before* allowing entry
          await editorGuard.canEnter(to);
          next(); // Proceed if guard passes
        } catch (guardError) {
          console.error("EditorRouteGuard failed:", guardError?.message || guardError);
          // Redirect back to worklist with an error query param
          next({ path: "/worklist", query: { error: 'editor_unavailable', reason: guardError?.message || 'Unknown' }});
        }
      },
    },
    // Admin routes grouped under /admin
    {
      path: "/admin/logs",
      name: "log-dashboard",
      component: LogDashboardView,
      meta: { requiresAuth: true, requiresAdmin: true } // Requires admin
    },
    {
      path: "/admin/hub-rules", // New route for Hub Rules
      name: "hub-rules",
      component: HubRulesView,
      meta: { requiresAuth: true, requiresAdmin: true }
    },
    {
      path: "/admin/address-upload", // New route for Address Upload
      name: "address-upload",
      component: AddressUploadView,
      meta: { requiresAuth: true, requiresAdmin: true }
    },
    {
      path: "/admin/aed-sftp", // New route for AED SFTP Admin
      name: "aed-admin",
      component: AedAdminView,
      meta: { requiresAuth: true, requiresAdmin: true }
    },

    // Catch-all redirect (redirects unauthenticated to login, authenticated to dashboard)
    {
      path: "/:pathMatch(.*)*",
      redirect: to => {
        // Use session service to check current auth state without async call
        return authSession.isAuthenticated() ? '/dashboard' : '/login';
      }
    },
  ];

  const router = vueCreateRouter({
    history: createWebHistory(import.meta.env.BASE_URL),
    routes
  });

  // Global Navigation Guard
  router.beforeEach(async (to, from, next) => {
    // 1. Skip auth checks for the login page itself
    if (to.path === '/login') {
      // If already authenticated, redirect away from login to dashboard
      if (authSession.isAuthenticated()) {
        next('/dashboard');
      } else {
        next(); // Allow access to login if not authenticated
      }
      return;
    }

    // 2. Check if the route requires authentication
    if (to.meta.requiresAuth || to.meta.requiresAdmin) {
      try {
        // Verify authentication using the AuthGuard
        await authGuard.canEnter(to); // This throws if not authenticated

        // 3. Check for Admin role if required
        if (to.meta.requiresAdmin && !authSession.hasRole('ADMIN')) {
          console.warn("AuthGuard: Admin role required for", to.path, ". User roles:", authSession.getUser()?.roles, "Redirecting to dashboard.");
          next("/dashboard"); // Redirect non-admins trying to access admin pages
          return;
        }

        // Authentication and Authorization passed
        next();

      } catch (authError) {
        // AuthGuard failed (not authenticated or token invalid)
        console.warn("AuthGuard failed:", authError?.message || authError, "Redirecting to login.");
        // Redirect to login, preserving the intended destination
        next({ path: "/login", query: { redirect: to.fullPath } });
      }
    } else {
      // Route does not require authentication
      next();
    }
  });

  return router;
}
