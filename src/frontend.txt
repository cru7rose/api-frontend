
================================================================================
### PLIK: main.js
================================================================================

/**
 * ARCHITECTURE: main.js mounts App.vue, installs Pinia + Router, and provides DI singletons.
 * Responsibilities:
 * - Create AuthController and provide it under the 'auth' key so views (LoginView) can call auth.login().
 * - Bootstrap environment (orchestrator, googleKey, health) and provide them as well.
 */
import { createApp } from "vue";
import { createPinia } from "pinia";
import App from "@/App.vue";
import { createRouterWithKey } from "@/router/index";
import { AppBootstrapController } from "@/controllers/AppBootstrapController";
import { AuthController } from "@/controllers/AuthController";

// Use an async IIFE to allow top-level await for bootstrap
(async () => {
    const pinia = createPinia();

    // Initialize authentication controller and load any existing session
    const auth = new AuthController();
    auth.hydrateFromStorage();

    // Bootstrap application configuration and health checks
    const bootstrap = new AppBootstrapController();
    const boot = await bootstrap.bootstrap();

    // Create router instance, potentially passing config like Google API key
    const router = createRouterWithKey(boot.googleKey);

    // Create the main Vue application instance
    const app = createApp(App);

    // Global Vue error handler
    app.config.errorHandler = (err, instance, info) => {
        // eslint-disable-next-line no-console
        console.error("[vue-error]", err, info, instance);
    };
    // Global window error handler for unhandled promise rejections etc.
    window.addEventListener("error", (e) => {
        // eslint-disable-next-line
        console.error("[window-error]", e?.error || e?.message || e);
    });
    window.addEventListener("unhandledrejection", (e) => {
        // eslint-disable-next-line no-console
        console.error("[unhandled-rejection]", e?.reason || e);
    });


    // Install plugins
    app.use(pinia);
    app.use(router);

    // Dependency Injection: Provide shared instances to components
    app.provide("auth", auth); // Make AuthController available
    app.provide("orchestrator", boot.orchestrator); // Make main orchestrator available
    app.provide("googleKey", boot.googleKey); // Provide Google API Key
    app.provide("health", boot.health); // Provide health status

    // Mount the application to the DOM
    app.mount("#app");
})();

================================================================================
### PLIK: adapters\GoogleGeocodingAdapter.js
================================================================================

/**
 * ARCHITECTURE: GoogleGeocodingAdapter wraps the Maps JS Geocoder into a provider-agnostic API.
 * It follows the manifesto by providing a single responsibility: address → {lat,lon,normalizedFields}.
 * Responsibilities:
 * - Accept Address-like input and call google.maps.Geocoder.
 * - Normalize results into a plain object usable by the Editor (street, houseNumber, postalCode, city, country, lat, lon).
 */
export class GoogleGeocodingAdapter {
  constructor(googleObj) {
    this.google = googleObj;
    this.geocoder = new this.google.maps.Geocoder();
  }

  async geocodeAddress(address) {
    if (!address || !address.street || !address.postalCode || !address.city) {
      return null;
    }
    const line1 = address.houseNumber ? `${address.street} ${address.houseNumber}` : address.street;
    const country = address.country || "PL";
    const query = `${line1}, ${address.postalCode} ${address.city}, ${country}`;
    const res = await this.geocoder.geocode({ address: query });
    if (!res || !Array.isArray(res.results) || res.results.length === 0) {
      return null;
    }
    const best = res.results[0];
    const components = this._indexComponents(best.address_components || []);
    const normalized = {
      street: components.route || address.street,
      houseNumber: components.street_number || address.houseNumber || null,
      postalCode: components.postal_code || address.postalCode,
      city: components.locality || components.postal_town || components.administrative_area_level_2 || address.city,
      country: components.country_code || country,
      latitude: best.geometry?.location?.lat?.() ?? null,
      longitude: best.geometry?.location?.lng?.() ?? null,
    };
    return normalized;
  }

  _indexComponents(parts) {
    const map = {};
    for (const c of parts) {
      for (const t of c.types) {
        if (t === "country") {
          map.country = c.long_name;
          map.country_code = c.short_name;
        } else if (t === "locality") {
          map.locality = c.long_name;
        } else if (t === "postal_town") {
          map.postal_town = c.long_name;
        } else if (t === "administrative_area_level_2") {
          map.administrative_area_level_2 = c.long_name;
        } else if (t === "route") {
          map.route = c.long_name;
        } else if (t === "street_number") {
          map.street_number = c.long_name;
        } else if (t === "postal_code") {
          map.postal_code = c.long_name;
        }
      }
    }
    return map;
  }
}


================================================================================
### PLIK: adapters\GoogleMapAdapter.js
================================================================================

/**
 * ARCHITECTURE: GoogleMapAdapter provides a concrete map implementation for MapController using Google Maps JS API.
 * It follows the manifesto by encapsulating all vendor-specific map calls behind a small, explicit interface.
 * Responsibilities:
 * - Create/destroy a map instance, set center/zoom, and manage a single primary marker.
 * - Avoid leaking Google objects to callers; expose only success/failure via resolved promises.
 */
export class GoogleMapAdapter {
  constructor(googleObj) {
    if (!googleObj || !googleObj.maps) throw new Error("GoogleMapAdapter: google maps object required.");
    this.google = googleObj;
    this._map = null;
    this._marker = null;
  }

  async create(container, options) {
    if (!container) throw new Error("GoogleMapAdapter.create: container is required.");
    const center = { lat: options?.lat ?? 52.2297, lng: options?.lon ?? 21.0122 };
    const zoom = options?.zoom ?? 12;
    this._map = new this.google.maps.Map(container, { center, zoom, mapTypeControl: false, streetViewControl: false });
    this._marker = new this.google.maps.Marker({ position: center, map: this._map });
    return true;
  }

  async setCenter(lat, lon, zoom) {
    if (!this._map) throw new Error("GoogleMapAdapter.setCenter: map not created.");
    const center = { lat, lng: lon };
    this._map.setCenter(center);
    if (typeof zoom === "number") this._map.setZoom(zoom);
    return true;
  }

  async setMarker(lat, lon) {
    if (!this._map || !this._marker) throw new Error("GoogleMapAdapter.setMarker: map not created.");
    const pos = { lat, lng: lon };
    this._marker.setPosition(pos);
    return true;
  }

  async fit(lat, lon) {
    if (!this._map) throw new Error("GoogleMapAdapter.fit: map not created.");
    const bounds = new this.google.maps.LatLngBounds();
    bounds.extend(new this.google.maps.LatLng(lat, lon));
    this._map.fitBounds(bounds, 64);
    return true;
  }

  async destroy() {
    if (this._marker) {
      this._marker.setMap(null);
      this._marker = null;
    }
    if (this._map) {
      this._map = null;
    }
    return true;
  }
}


================================================================================
### PLIK: adapters\GoogleMapsScriptLoader.js
================================================================================

/**
 * ARCHITECTURE: GoogleMapsScriptLoader ensures exactly-once loading of the Google Maps JS API.
 * It follows the manifesto by isolating third-party script lifecycle and exposing a minimal contract.
 * Responsibilities:
 * - Load the script with an API key and optional libraries only once per app session.
 * - Resolve when window.google is available; reject on network or auth errors.
 */
export class GoogleMapsScriptLoader {
  constructor() {
    this._promise = null;
    this._loadedKey = null;
    this._loadedLibsKey = null;
  }

  load(apiKey, libraries = []) {
    if (!apiKey || typeof apiKey !== "string") {
      return Promise.reject(new Error("GoogleMapsScriptLoader: missing apiKey."));
    }
    const libs = Array.isArray(libraries) ? libraries.slice().sort() : [];
    const libsKey = libs.join(",");
    if (this._promise && this._loadedKey === apiKey && this._loadedLibsKey === libsKey) {
      return this._promise;
    }
    if (typeof window !== "undefined" && window.google && window.google.maps) {
      this._promise = Promise.resolve(window.google);
      this._loadedKey = apiKey;
      this._loadedLibsKey = libsKey;
      return this._promise;
    }
    const src = new URL("https://maps.googleapis.com/maps/api/js");
    src.searchParams.set("key", apiKey);
    if (libs.length) src.searchParams.set("libraries", libsKey);
    src.searchParams.set("v", "weekly");
    this._promise = new Promise((resolve, reject) => {
      const s = document.createElement("script");
      s.src = src.toString();
      s.async = true;
      s.defer = true;
      s.onerror = () => reject(new Error("Google Maps script failed to load."));
      s.onload = () => {
        if (window.google && window.google.maps) {
          this._loadedKey = apiKey;
          this._loadedLibsKey = libsKey;
          resolve(window.google);
        } else {
          reject(new Error("Google Maps script loaded but window.google is undefined."));
        }
      };
      document.head.appendChild(s);
    });
    return this._promise;
  }
}


================================================================================
### PLIK: adapters\GooglePlacesAutocompleteAdapter.js
================================================================================

/**
 * ARCHITECTURE: GooglePlacesAutocompleteAdapter wraps Places Autocomplete for type-ahead address hints.
 * It follows the manifesto by isolating vendor-specific API calls and returning normalized suggestion DTOs.
 * Responsibilities:
 * - Create and reuse a session token, query AutocompleteService, and detail lookup for precise fields.
 * - Normalize results into street, houseNumber, postalCode, city, country, latitude, longitude.
 */
export class GooglePlacesAutocompleteAdapter {
  constructor(googleObj) {
    if (!googleObj || !googleObj.maps) throw new Error("GooglePlacesAutocompleteAdapter: google maps object required.");
    this.google = googleObj;
    this.service = new this.google.maps.places.AutocompleteService();
    this.details = new this.google.maps.places.PlacesService(document.createElement("div"));
    this.sessionToken = new this.google.maps.places.AutocompleteSessionToken();
  }

  async suggest(text, country = "PL") {
    if (!text || !text.trim()) return [];
    const r = await this._getPredictions(text, country);
    const picks = Array.isArray(r) ? r.slice(0, 5) : [];
    const enriched = [];
    for (const p of picks) {
      const d = await this._getDetails(p.place_id);
      if (d) {
        enriched.push(d);
      }
    }
    return enriched;
  }

  async _getPredictions(input, country) {
    return new Promise((resolve, reject) => {
      this.service.getPlacePredictions(
        { input, sessionToken: this.sessionToken, componentRestrictions: { country } },
        (predictions, status) => {
          if (status !== this.google.maps.places.PlacesServiceStatus.OK || !predictions) return resolve([]);
          resolve(predictions);
        }
      );
    });
  }

  async _getDetails(placeId) {
    return new Promise((resolve) => {
      this.details.getDetails({ placeId, sessionToken: this.sessionToken, fields: ["address_components", "geometry"] }, (place, status) => {
        if (status !== this.google.maps.places.PlacesServiceStatus.OK || !place) return resolve(null);
        const comps = this._indexComponents(place.address_components || []);
        resolve({
          fullAddressLabel: null,
          street: comps.route || null,
          houseNumber: comps.street_number || null,
          postalCode: comps.postal_code || null,
          city: comps.locality || comps.postal_town || comps.administrative_area_level_2 || null,
          countryCode: comps.country_code || null,
          countryName: comps.country || null,
          latitude: place.geometry?.location?.lat?.() ?? null,
          longitude: place.geometry?.location?.lng?.() ?? null,
          matchScore: 0.9,
          matchLevel: "PLACES",
          providerSource: "GOOGLE_PLACES",
        });
      });
    });
  }

  _indexComponents(parts) {
    const map = {};
    for (const c of parts) {
      for (const t of c.types) {
        if (t === "country") {
          map.country = c.long_name;
          map.country_code = c.short_name;
        } else if (t === "locality") {
          map.locality = c.long_name;
        } else if (t === "postal_town") {
          map.postal_town = c.long_name;
        } else if (t === "administrative_area_level_2") {
          map.administrative_area_level_2 = c.long_name;
        } else if (t === "route") {
          map.route = c.long_name;
        } else if (t === "street_number") {
          map.street_number = c.long_name;
        } else if (t === "postal_code") {
          map.postal_code = c.long_name;
        }
      }
    }
    return map;
  }
}


================================================================================
### PLIK: adapters\GooglePlacesSessionManager.js
================================================================================

/**
 * ARCHITECTURE: GooglePlacesSessionManager encapsulates the creation, retrieval,
 * and renewal of Google Places AutocompleteSessionToken objects.
 * This is crucial for managing billing correctly with the Places API.
 * This is a stub implementation as the 'google' object is not available here directly.
 */
export class GooglePlacesSessionManager {
    constructor(googleMapsInstance) {
        if (!googleMapsInstance || !googleMapsInstance.maps || !googleMapsInstance.maps.places) {
            console.warn("[GooglePlacesSessionManager] Google Maps Places library not found. Session management will be non-functional.");
            this._googlePlaces = null;
        } else {
            this._googlePlaces = googleMapsInstance.maps.places;
        }
        this._token = null;
        this._renewToken(); // Initialize first token
    }

    /**
     * Retrieves the current session token.
     * @returns {google.maps.places.AutocompleteSessionToken | null} The current token.
     */
    getToken() {
        if (!this._token) {
            // Attempt to create one if it was missed, though it should be initialized.
            this._renewToken();
        }
        return this._token;
    }

    /**
     * Renews the session token. This should be called after a successful
     * 'getDetails' call, invalidating the previous token.
     */
    renew() {
        this._renewToken();
    }

    /**
     * Internal helper to create a new token.
     */
    _renewToken() {
        if (this._googlePlaces) {
            try {
                this._token = new this._googlePlaces.AutocompleteSessionToken();
            } catch (e) {
                console.error("[GooglePlacesSessionManager] Failed to create new AutocompleteSessionToken:", e);
                this._token = null;
            }
        } else {
            this._token = null;
        }
    }
}

================================================================================
### PLIK: adapters\GoogleRuntime.js
================================================================================

/**
 * ARCHITECTURE: GoogleRuntime caches a single Google Maps JS instance and constructs common adapters on demand.
 * It follows the manifesto by preventing duplicate script loads and centralizing third-party object reuse.
 * Responsibilities:
 * - Load and memoize window.google, expose factories for Map, Geocoder, and Places adapters.
 * - Guard callers against uninitialized usage with explicit init().
 */
import { GoogleMapsScriptLoader } from "@/adapters/GoogleMapsScriptLoader";
import { GoogleMapAdapter } from "@/adapters/GoogleMapAdapter";
import { GoogleGeocodingAdapter } from "@/adapters/GoogleGeocodingAdapter";
import { GooglePlacesAutocompleteAdapter } from "@/adapters/GooglePlacesAutocompleteAdapter";

export class GoogleRuntime {
  constructor() {
    this._loader = new GoogleMapsScriptLoader();
    this._google = null;
  }

  async init(apiKey, libraries = ["places"]) {
    if (this._google) return this._google;
    this._google = await this._loader.load(apiKey, libraries);
    return this._google;
  }

  mapAdapter() {
    if (!this._google) throw new Error("GoogleRuntime: not initialized.");
    return new GoogleMapAdapter(this._google);
  }

  geocodingAdapter() {
    if (!this._google) throw new Error("GoogleRuntime: not initialized.");
    return new GoogleGeocodingAdapter(this._google);
  }

  placesAdapter() {
    if (!this._google) throw new Error("GoogleRuntime: not initialized.");
    return new GooglePlacesAutocompleteAdapter(this._google);
  }
}


================================================================================
### PLIK: adapters\MapGeocoderAdapter.js
================================================================================

/**
 * ARCHITECTURE: MapGeocoderAdapter abstracts a geocoding function behind a stable contract.
 * It follows the manifesto by isolating vendor-specific logic and exposing a single responsibility.
 * Responsibilities:
 * - Accept an Address-like DTO and delegate to an injected geocode function.
 * - Return a normalized { lat, lon } object or null without leaking provider details.
 */
export class MapGeocoderAdapter {
  constructor(geocodeFn) {
    if (typeof geocodeFn !== "function") throw new Error("MapGeocoderAdapter: geocode function required.");
    this.geocodeFn = geocodeFn;
  }

  async geocodeAddress(address) {
    if (!address || typeof address !== "object") return null;
    const r = await this.geocodeFn({
      street: address.street,
      houseNumber: address.houseNumber ?? null,
      postalCode: address.postalCode,
      city: address.city,
      country: address.country || "PL",
    });
    if (!r || typeof r.lat !== "number" || typeof r.lon !== "number") return null;
    return { lat: r.lat, lon: r.lon };
  }
}


================================================================================
### PLIK: assets\main.css
================================================================================

/* ARCHITECTURE: Base styles kept tiny and neutral. */
:root { color-scheme: light; }
body { background:#fff; color:#111; }

================================================================================
### PLIK: bootstrap\GoogleAddressVerificationBootstrap.js
================================================================================

/**
 * ARCHITECTURE: GoogleAddressVerificationBootstrap initializes Google runtime, map, and adapters for the editor.
 * It follows the manifesto by centralizing third-party setup and returning ready-to-use controllers/adapters.
 * Responsibilities:
 * - Load Google script, create MapController with GoogleMapAdapter, and provide geocoder + places adapters.
 */
import { GoogleMapsScriptLoader } from "@/adapters/GoogleMapsScriptLoader";
import { GoogleMapAdapter } from "@/adapters/GoogleMapAdapter";
import { GoogleGeocodingAdapter } from "@/adapters/GoogleGeocodingAdapter";
import { GooglePlacesAutocompleteAdapter } from "@/adapters/GooglePlacesAutocompleteAdapter";
import { MapController } from "@/controllers/MapController";

export class GoogleAddressVerificationBootstrap {
  constructor(loader = new GoogleMapsScriptLoader()) {
    this.loader = loader;
    this.google = null;
    this.mapController = null;
    this.geocoderAdapter = null;
    this.placesAdapter = null;
  }

  async init(mapContainerEl, apiKey) {
    this.google = await this.loader.load(apiKey, ["places"]);
    const mapAdapter = new GoogleMapAdapter(this.google);
    this.mapController = new MapController(mapAdapter);
    await this.mapController.init(mapContainerEl, { lat: 52.2297, lon: 21.0122, zoom: 12 });
    this.geocoderAdapter = new GoogleGeocodingAdapter(this.google);
    this.placesAdapter = new GooglePlacesAutocompleteAdapter(this.google);
    return {
      google: this.google,
      mapController: this.mapController,
      geocoderAdapter: this.geocoderAdapter,
      placesAdapter: this.placesAdapter,
    };
  }
}


================================================================================
### PLIK: controllers\AddressFormController.js
================================================================================

/**
 * ARCHITECTURE: AddressFormController coordinates field masking, editability rules, guard checks, and realtime verification.
 * It follows the manifesto by isolating input lifecycle from components and wiring existing services behind one API.
 * Responsibilities:
 * - Apply masks on change, consult AddressFieldGuard for editability, and gate verification with VerificationGuardController.
 * - Invoke RealtimeVerificationOrchestrator and MapViewportPolicyController to produce instant geocode + ranked hints.
 * - Expose a stable snapshot with input, validation, instant, suggestions, and busy flags for the view.
 */
import { AddressInputMaskService } from "@/services/AddressInputMaskService";
import { AddressFieldGuard } from "@/services/AddressFieldGuard";
import { VerificationGuardController } from "@/controllers/VerificationGuardController";
import { RealtimeVerificationOrchestrator } from "@/controllers/RealtimeVerificationOrchestrator";
import { MapViewportPolicyController } from "@/controllers/MapViewportPolicyController";
import { ValidationService } from "@/services/ValidationService";
import { AddressNormalizer } from "@/services/AddressNormalizer";

export class AddressFormController {
  constructor(geocodeWithCacheController, placesAdapter, mapController) {
    this.mask = new AddressInputMaskService("PL");
    this.guard = new AddressFieldGuard();
    this.verifyGuard = new VerificationGuardController();
    this.realtime = new RealtimeVerificationOrchestrator(geocodeWithCacheController, placesAdapter, 300);
    this.viewport = new MapViewportPolicyController(mapController);
    this.validator = new ValidationService("PL");
    this.normalizer = new AddressNormalizer();
    this.input = { street: "", houseNumber: "", postalCode: "", city: "", country: "PL" };
    this.validation = { valid: false, errors: {} };
    this.instant = null;
    this.suggestions = [];
    this.loading = false;
    this.error = null;
  }

  setField(field, value) {
    if (!this.guard.canEdit(field, { country: this.input.country })) return this.snapshot();
    if (field === "postalCode") this.input.postalCode = this.mask.maskPostal(value, this.input.country);
    else if (field === "street") this.input.street = this.mask.maskStreet(value);
    else if (field === "city") this.input.city = this.mask.maskCity(value);
    else if (field === "houseNumber") this.input.houseNumber = this.mask.maskHouseNo(value);
    else if (field === "country") this.input.country = String(value || "PL").toUpperCase();
    else this.input[field] = value;
    return this.snapshot();
  }

  async verifyIfReady() {
    const gate = this.verifyGuard.shouldVerify(this.input);
    if (!gate.allow) {
      this.loading = false;
      this.error = null;
      this.instant = null;
      this.suggestions = [];
      this.validation = this.validator.validate(this.normalizer.normalize(this.input));
      return this.snapshot();
    }
    this.loading = true;
    this.error = null;
    const res = await this.realtime.verify(this.input);
    this.loading = false;
    this.instant = res.instant || null;
    this.suggestions = Array.isArray(res.suggestions) ? res.suggestions : [];
    if (this.instant) await this.viewport.focusInstant({ ...this.instant, matchLevel: "GEOCODER" });
    this.validation = this.validator.validate(this.normalizer.normalize(this.input));
    return this.snapshot();
  }

  snapshot() {
    return {
      input: { ...this.input },
      validation: { ...this.validation },
      instant: this.instant ? { ...this.instant } : null,
      suggestions: this.suggestions.slice(),
      loading: this.loading,
      error: this.error,
    };
  }
}


================================================================================
### PLIK: controllers\AddressVerificationController.js
================================================================================

/**
 * ARCHITECTURE: AddressVerificationController orchestrates Google-first verification and TES-backed suggestions.
 * It follows the manifesto by isolating IO, retries, and provider alignment (set GOOGLE) behind simple methods.
 * Responsibilities:
 * - Ensure TES provider is set to GOOGLE via admin API proxy (asynchronously).
 * - Trigger on-demand suggestions and search-by-name via DANXILS-API proxy (Kafka-based flow) and poll operation status.
 * - Perform instant client-side geocode with Google for live map feedback.
 * - Merge and return a unified suggestion list and a normalized best candidate for the Editor.
 */
import apiClient from "@/services/api";
import { GoogleMapsScriptLoader } from "@/adapters/GoogleMapsScriptLoader";
import { GoogleGeocodingAdapter } from "@/adapters/GoogleGeocodingAdapter";
import { TesOperationPoller } from "@/services/TesOperationPoller";
import { ProviderGuard } from "@/controllers/ProviderGuard";

export class AddressVerificationController {
    constructor(poller = new TesOperationPoller(), providerGuard = new ProviderGuard(poller)) {
        this._google = null;
        this._mapsLoader = new GoogleMapsScriptLoader();
        this._geocoder = null;
        this._poller = poller;
        this._providerGuard = providerGuard;
        this.loading = false;
        this.error = null;
    }

    /** @deprecated Provider alignment is now handled asynchronously by ProviderGuard.ensureGoogle(). */
    async alignProviderToGoogle() {
        console.warn("AddressVerificationController.alignProviderToGoogle is deprecated. Use ProviderGuard.ensureGoogle().");
        try {
            await this._providerGuard.ensureGoogle();
            return true;
        } catch (e) {
            this.error = e.message;
            return false;
        }
    }

    async initGoogle(apiKey, libraries = ["geocoding"]) {
        if (this._google) return true;
        try {
            this._google = await this._mapsLoader.load(apiKey, libraries);
            this._geocoder = new GoogleGeocodingAdapter(this._google);
            return true;
        } catch (e) {
            this.error = `Failed to initialize Google Maps: ${e.message}`;
            console.error(this.error, e);
            throw e;
        }
    }

    async geocodeInstant(addressDto) {
        if (!this._geocoder) throw new Error("Google geocoder not initialized.");
        try {
            return await this._geocoder.geocodeAddress(addressDto);
        } catch (e) {
            console.error("Instant geocoding failed:", e);
            return null;
        }
    }

    async suggestOnDemand(addressQuery) {
        if (!addressQuery || Object.values(addressQuery).every(v => !v)) return [];
        this.loading = true;
        this.error = null;
        try {
            const startResponse = await apiClient.post("/api/admin/address-verification/suggest-on-demand", addressQuery);
            const correlationId = startResponse?.data?.correlationId;
            if (!correlationId) throw new Error("Missing correlationId from suggest-on-demand initiation.");

            const operationResult = await this._poller.waitFor(correlationId);

            if (operationResult.status === "COMPLETED") {
                const resultPayload = operationResult.result || {};
                return resultPayload.suggestions || [];
            } else {
                throw new Error(operationResult.errorDetails || "Suggestion operation failed.");
            }
        } catch (e) {
            console.error("Suggest-on-demand flow failed:", e);
            this.error = e.message;
            return [];
        } finally {
            this.loading = false;
        }
    }

    async searchByName(query) {
        if (!query || !query.trim()) return [];
        this.loading = true;
        this.error = null;
        try {
            const startResponse = await apiClient.post("/api/admin/address-verification/search-by-name", query.trim(), {
                headers: { "Content-Type": "text/plain" },
            });
            const correlationId = startResponse?.data?.correlationId;
            if (!correlationId) throw new Error("Missing correlationId from search-by-name initiation.");

            const operationResult = await this._poller.waitFor(correlationId);

            if (operationResult.status === "COMPLETED") {
                const resultPayload = operationResult.result || {};
                return resultPayload.suggestions || [];
            } else {
                throw new Error(operationResult.errorDetails || "Search-by-name operation failed.");
            }
        } catch (e) {
            console.error("Search-by-name flow failed:", e);
            this.error = e.message;
            return [];
        } finally {
            this.loading = false;
        }
    }

    async verifyAddressFlow(googleApiKey, addressDto) {
        this.loading = true;
        this.error = null;
        try {
            await this._providerGuard.ensureGoogle();
            await this.initGoogle(googleApiKey, ["geocoding", "places"]);
            const instantResult = await this.geocodeInstant(addressDto);
            const backendSuggestions = await this.suggestOnDemand({
                street: addressDto.street || "",
                houseNumber: addressDto.houseNumber || "",
                postalCode: addressDto.postalCode || "",
                city: addressDto.city || "",
                country: addressDto.country || "PL",
            });
            const mergedSuggestions = this._mergeSuggestions(instantResult, backendSuggestions);
            return { instant: instantResult, suggestions: mergedSuggestions };
        } catch (e) {
            this.error = e?.message || "Verification flow failed.";
            console.error("verifyAddressFlow failed:", e);
            throw e;
        } finally {
            this.loading = false;
        }
    }

    _mergeSuggestions(instant, backendList) {
        const list = Array.isArray(backendList) ? [...backendList] : [];
        const fromInstant = instant ? {
            fullAddressLabel: `${instant.street || ""} ${instant.houseNumber || ""}, ${instant.postalCode || ""} ${instant.city || ""}`.replace(/ ,|,$/,'').trim(),
            street: instant.street || null,
            houseNumber: instant.houseNumber || null,
            postalCode: instant.postalCode || null,
            city: instant.city || null,
            countryCode: instant.country || null,
            latitude: instant.latitude ?? null,
            longitude: instant.longitude ?? null,
            matchScore: 1.0,
            matchLevel: "GEOCODER",
            providerSource: "GOOGLE_CLIENT",
        } : null;

        if (fromInstant) {
            list.unshift(fromInstant);
        }
        return list;
    }
}


================================================================================
### PLIK: controllers\AddressVerificationFacade.js
================================================================================

/**
 * ARCHITECTURE: AddressVerificationFacade provides a minimal API to run Google-first verification end-to-end.
 * It follows the manifesto by composing workflow, merger, ranker, and TES suggestions behind a single call.
 * Responsibilities:
 * - Accept an Address-like DTO; return {normalized, validation, instant, suggestions} ready for the editor.
 * - Optionally enrich with TES suggestions and merge/rank them alongside Google-derived candidates.
 */
import { AddressVerificationWorkflow } from "@/controllers/AddressVerificationWorkflow";
import { TesSuggestionController } from "@/controllers/TesSuggestionController";
import { AddressSuggestionMerger } from "@/services/AddressSuggestionMerger";
import { AddressSuggestionRanker } from "@/services/AddressSuggestionRanker";

export class AddressVerificationFacade {
  constructor(googleApiKey, tes = new TesSuggestionController(), merger = new AddressSuggestionMerger(), ranker = new AddressSuggestionRanker()) {
    this.workflow = new AddressVerificationWorkflow(googleApiKey);
    this.tes = tes;
    this.merger = merger;
    this.ranker = ranker;
  }

  async verify(address) {
    const base = await this.workflow.verify(address);
    if (!base.success) return base;
    const tes = await this.tes.suggestOnDemand(base.normalized, base.normalized);
    const merged = this.merger.merge(base.normalized, [base.suggestions, tes]);
    const ranked = this.ranker.rank(base.normalized, merged);
    return { ...base, suggestions: ranked };
  }
}


================================================================================
### PLIK: controllers\AddressVerificationWorkflow.js
================================================================================

/**
 * ARCHITECTURE: AddressVerificationWorkflow runs normalize→validate→(optional)geocode to build a result model.
 * It follows the manifesto by keeping verification orchestration independent from UI and transport details.
 * Responsibilities:
 * - Normalize and validate input; if geocoder is injected, resolve coordinates as an "instant" candidate.
 * - Return {success, normalized, validation, instant, suggestions[]} without throwing on user errors.
 */
import { AddressNormalizer } from "@/services/AddressNormalizer";
import { ValidationService } from "@/services/ValidationService";

export class AddressVerificationWorkflow {
  constructor(googleApiKey = null, geocoderAdapter = null) {
    void googleApiKey;
    this.normalizer = new AddressNormalizer();
    this.validator = new ValidationService("PL");
    this.geocoder = geocoderAdapter || null;
  }

  async verify(address) {
    const normalized = this.normalizer.normalize(address);
    const validation = this.validator.validate(normalized);
    if (!validation.valid) {
      return {
        success: false,
        normalized,
        validation,
        instant: null,
        suggestions: [],
      };
    }
    let instant = null;
    if (this.geocoder && typeof this.geocoder.geocodeAddress === "function") {
      try {
        const r = await this.geocoder.geocodeAddress(normalized);
        if (r && typeof r.lat === "number" && typeof r.lon === "number") {
          instant = { latitude: r.lat, longitude: r.lon, providerSource: "GOOGLE_CLIENT", matchLevel: "GEOCODER", matchScore: 1.0 };
        }
      } catch (_) {
        instant = null;
      }
    }
    return {
      success: true,
      normalized,
      validation,
      instant,
      suggestions: [],
    };
  }
}


================================================================================
### PLIK: controllers\AppBootstrapController.js
================================================================================

/**
 * ARCHITECTURE: AppBootstrapController wires config + health + orchestrator for the app shell.
 * Responsibilities:
 * - Load env config and Google key
 * - Run health gate
 * - Build IntegrationOrchestrator stub (can be extended later with Google runtime)
 * - Return { googleKey, orchestrator, health }
 */
import { EnvironmentConfigService } from "@/services/EnvironmentConfigService";
import { HealthGateController } from "@/controllers/HealthGateController";
import { IntegrationOrchestrator } from "@/controllers/IntegrationOrchestrator";

export class AppBootstrapController {
  constructor(cfg = new EnvironmentConfigService(), health = new HealthGateController()) {
    this.cfg = cfg;
    this.healthCtrl = health;
  }

  async bootstrap() {
    await this.cfg.load();
    const googleKey = this.cfg.googleKey();
    const health = await this.healthCtrl.readiness(googleKey);
    const orchestrator = new IntegrationOrchestrator(null, null);
    return { googleKey, orchestrator, health };
  }
}


================================================================================
### PLIK: controllers\AuthController.js
================================================================================

/**
 * ARCHITECTURE: AuthController coordinates login/logout by composing AuthApi, AuthSessionService, and ApiAuthBinder.
 * It follows the manifesto by exposing intent-driven methods and returning Result objects for views/guards.
 * Responsibilities:
 * - login(username,password): call AuthApi, persist session, bind Authorization header.
 * - logout(): clear session and unbind header.
 * - hydrateFromStorage(): reapply header on app start.
 * - snapshot(): expose {isAuthenticated,user}.
 */
import { Result } from "@/domain/Result";
import { AuthApi } from "@/services/AuthApi";
import { AuthSessionService } from "@/services/AuthSessionService";
import { ApiAuthBinder } from "@/services/ApiAuthBinder";

export class AuthController {
  constructor(api = new AuthApi(), session = new AuthSessionService(), binder = new ApiAuthBinder()) {
    this.api = api;
    this.session = session;
    this.binder = binder;
  }

  async login(username, password) {
    const r = await this.api.login(username, password);
    if (!r.ok) return Result.fail(r.error);
    this.session.save(r.value);
    this.binder.bind(r.value.accessToken, r.value.tokenType);
    return Result.ok(this.snapshot());
  }

  async logout() {
    this.session.clear();
    this.binder.unbind();
    return Result.ok(true);
  }

  hydrateFromStorage() {
    const token = this.session.getAccessToken();
    const type = this.session.getTokenType();
    if (token) this.binder.bind(token, type);
    return this.snapshot();
  }

  snapshot() {
    return {
      isAuthenticated: this.session.isAuthenticated(),
      user: this.session.getUser(),
      tokenPresent: !!this.session.getAccessToken(),
    };
  }
}


================================================================================
### PLIK: controllers\AuthController.spec.js
================================================================================

// src/controllers/AuthController.spec.js
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { AuthController } from '@/controllers/AuthController';
import { Result } from '@/domain/Result';

// Mock the dependencies (AuthApi, AuthSessionService, ApiAuthBinder)
const mockAuthApi = {
    login: vi.fn(),
};
const mockSessionService = {
    save: vi.fn(),
    clear: vi.fn(),
    isAuthenticated: vi.fn(),
    getUser: vi.fn(),
    getAccessToken: vi.fn(),
    getTokenType: vi.fn(),
};
const mockApiBinder = {
    bind: vi.fn(),
    unbind: vi.fn(),
};

describe('AuthController', () => {
    let authController;

    beforeEach(() => {
        vi.resetAllMocks();
        authController = new AuthController(mockAuthApi, mockSessionService, mockApiBinder);
    });

    describe('login', () => {
        it('should call AuthApi, save session, bind token, and return Ok Result on success', async () => {
            // Arrange
            const username = 'test';
            const password = 'pw';
            const mockSessionData = {
                accessToken: 'atoken',
                refreshToken: 'rtoken',
                tokenType: 'Bearer',
                username: username,
                roles: ['USER'],
            };
            const mockSnapshot = { isAuthenticated: true, user: { username: username, roles: ['USER'] } };
            mockAuthApi.login.mockResolvedValue(Result.ok(mockSessionData));
            // Mock snapshot call within the controller's login method
            vi.spyOn(authController, 'snapshot').mockReturnValue(mockSnapshot);

            // Act
            const result = await authController.login(username, password);

            // Assert
            expect(mockAuthApi.login).toHaveBeenCalledWith(username, password);
            expect(mockSessionService.save).toHaveBeenCalledWith(mockSessionData);
            expect(mockApiBinder.bind).toHaveBeenCalledWith(mockSessionData.accessToken, mockSessionData.tokenType);
            expect(result.ok).toBe(true);
            expect(result.value).toEqual(mockSnapshot); // Login returns the snapshot
        });

        it('should return Fail Result if AuthApi.login fails', async () => {
            // Arrange
            const username = 'test';
            const password = 'pw';
            const mockError = new Error('Invalid credentials');
            mockAuthApi.login.mockResolvedValue(Result.fail(mockError));

            // Act
            const result = await authController.login(username, password);

            // Assert
            expect(mockAuthApi.login).toHaveBeenCalledWith(username, password);
            expect(mockSessionService.save).not.toHaveBeenCalled();
            expect(mockApiBinder.bind).not.toHaveBeenCalled();
            expect(result.ok).toBe(false);
            expect(result.error).toBe(mockError);
        });
    });

    describe('logout', () => {
        it('should clear session and unbind token', async () => {
            // Act
            const result = await authController.logout();

            // Assert
            expect(mockSessionService.clear).toHaveBeenCalledTimes(1);
            expect(mockApiBinder.unbind).toHaveBeenCalledTimes(1);
            expect(result.ok).toBe(true);
        });
    });

    describe('hydrateFromStorage', () => {
        it('should bind token if found in session', () => {
            // Arrange
            mockSessionService.getAccessToken.mockReturnValue('storedToken');
            mockSessionService.getTokenType.mockReturnValue('Bearer');

            // Act
            authController.hydrateFromStorage();

            // Assert
            expect(mockApiBinder.bind).toHaveBeenCalledWith('storedToken', 'Bearer');
        });

        it('should not bind token if not found in session', () => {
            // Arrange
            mockSessionService.getAccessToken.mockReturnValue(null);

            // Act
            authController.hydrateFromStorage();

            // Assert
            expect(mockApiBinder.bind).not.toHaveBeenCalled();
        });
    });

    describe('snapshot', () => {
        it('should return current auth state from session service', () => {
            // Arrange
            mockSessionService.isAuthenticated.mockReturnValue(true);
            mockSessionService.getUser.mockReturnValue({ username: 'snapUser', roles: ['TEST']});
            mockSessionService.getAccessToken.mockReturnValue('snapToken');

            // Act
            const snapshot = authController.snapshot();

            // Assert
            expect(snapshot).toEqual({
                isAuthenticated: true,
                user: { username: 'snapUser', roles: ['TEST']},
                tokenPresent: true
            });
        });
    });
});

================================================================================
### PLIK: controllers\BulkEditController.js
================================================================================

/**
 * ARCHITECTURE: BulkEditController previews and applies batch text transforms across selected orders.
 * It follows the manifesto by isolating batch logic and delegating transport to AddressExceptionApi.
 * Responsibilities:
 * - Preview client-side transformations for confidence; apply changes via backend endpoint.
 * - Accept BulkEditPlan JSON and return Result objects for both preview and apply.
 */
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

export class BulkEditController {
  constructor(storeOrApi = null) {
    this.api = storeOrApi instanceof AddressExceptionApi ? storeOrApi : new AddressExceptionApi();
  }

  async preview(plan) {
    try {
      const { data } = await this._post("/bulk/preview", plan);
      return Result.ok(Array.isArray(data?.items) ? data.items : []);
    } catch (e) {
      return Result.fail(e);
    }
  }

  async apply(plan) {
    try {
      const { data } = await this._post("/bulk/apply", plan);
      return Result.ok(data || true);
    } catch (e) {
      return Result.fail(e);
    }
  }

  async _post(path, plan) {
    const url = `/api/address-exceptions${path}`;
    return await (await import("@/services/api")).default.post(url, plan.toJSON ? plan.toJSON() : plan);
  }
}


================================================================================
### PLIK: controllers\CorrectionEditorController.js
================================================================================

/**
 * ARCHITECTURE: CorrectionEditorController orchestrates the "side-by-side diff" editor.
 * It follows the manifesto by isolating all IO and decision logic away from the component tree.
 * Responsibilities:
 * - Loads OrderDetail and related suggestions for pickup/delivery.
 * - Maintains editable copies of addresses, integrates optional geocoder.
 * - Applies Accept Suggestion, Use Original, Manual Edit, Save, and Save & Next.
 * - Shields UI from API details via AddressExceptionApi and from map choice via MapGeocoderAdapter.
 */
import { Address } from "@/domain/WorkbenchModels";
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";
import { MapGeocoderAdapter } from "@/adapters/MapGeocoderAdapter";

export class CorrectionEditorController {
  constructor(api = new AddressExceptionApi(), geocoder = null) {
    this.api = api;
    this.geocoder = geocoder instanceof MapGeocoderAdapter ? geocoder : null;
    this.orderId = null;
    this.detail = null;
    this.loading = false;
    this.error = null;
    this.editedPickup = null;
    this.editedDelivery = null;
  }

  setGeocoderAdapter(adapter) {
    this.geocoder = adapter instanceof MapGeocoderAdapter ? adapter : null;
    return this.geocoder;
  }

  async loadOrder(orderId) {
    this.loading = true;
    this.error = null;
    this.orderId = orderId;
    this.detail = null;
    this.editedPickup = null;
    this.editedDelivery = null;
    const res = await this.api.getOrderDetail(orderId);
    if (!res.ok) {
      this.loading = false;
      this.error = res.error.message;
      return Result.fail(res.error);
    }
    this.detail = res.value;
    this.editedPickup = new Address(
      this.detail.originalPickup.street,
      this.detail.originalPickup.houseNumber,
      this.detail.originalPickup.postalCode,
      this.detail.originalPickup.city,
      this.detail.originalPickup.country,
      this.detail.originalPickup.latitude,
      this.detail.originalPickup.longitude
    );
    this.editedDelivery = new Address(
      this.detail.originalDelivery.street,
      this.detail.originalDelivery.houseNumber,
      this.detail.originalDelivery.postalCode,
      this.detail.originalDelivery.city,
      this.detail.originalDelivery.country,
      this.detail.originalDelivery.latitude,
      this.detail.originalDelivery.longitude
    );
    this.loading = false;
    return Result.ok(this.detail);
  }

  async refreshSuggestions(side) {
    if (!this.orderId) return Result.fail(new Error("Order not loaded."));
    const s = side === "pickup" ? "pickup" : "delivery";
    const res = await this.api.refreshSuggestions(this.orderId, s);
    if (!res.ok) return Result.fail(res.error);
    if (s === "pickup") this.detail.suggestedPickup = res.value;
    if (s === "delivery") this.detail.suggestedDelivery = res.value;
    return Result.ok(res.value);
  }

  acceptSuggestion(side, index = 0) {
    if (!this.detail) return Result.fail(new Error("Order not loaded."));
    const list = side === "pickup" ? this.detail.suggestedPickup : this.detail.suggestedDelivery;
    if (!Array.isArray(list) || !list[index]) return Result.fail(new Error("Suggestion not found."));
    const s = list[index];
    const addr = new Address(
      s.street || "",
      s.houseNumber || null,
      s.postalCode || "",
      s.city || "",
      s.countryCode || this._defaultCountry(),
      s.latitude ?? null,
      s.longitude ?? null
    );
    if (side === "pickup") this.editedPickup = addr;
    if (side === "delivery") this.editedDelivery = addr;
    return Result.ok(addr);
  }

  useOriginal(side) {
    if (!this.detail) return Result.fail(new Error("Order not loaded."));
    if (side === "pickup") {
      const o = this.detail.originalPickup;
      this.editedPickup = new Address(o.street, o.houseNumber, o.postalCode, o.city, o.country, o.latitude, o.longitude);
      return Result.ok(this.editedPickup);
    }
    if (side === "delivery") {
      const o = this.detail.originalDelivery;
      this.editedDelivery = new Address(o.street, o.houseNumber, o.postalCode, o.city, o.country, o.latitude, o.longitude);
      return Result.ok(this.editedDelivery);
    }
    return Result.fail(new Error("Unknown side."));
  }

  setManualAddress(side, address) {
    if (!(address instanceof Address)) return Result.fail(new Error("Invalid Address."));
    if (side === "pickup") this.editedPickup = address;
    else if (side === "delivery") this.editedDelivery = address;
    else return Result.fail(new Error("Unknown side."));
    return Result.ok(address);
  }

  async geocodeEdited(side) {
    if (!this.geocoder) return Result.fail(new Error("No geocoder."));
    const addr = side === "pickup" ? this.editedPickup : this.editedDelivery;
    if (!(addr instanceof Address)) return Result.fail(new Error("No edited address."));
    const r = await this.geocoder.geocodeAddress({
      street: addr.street,
      houseNumber: addr.houseNumber,
      postalCode: addr.postalCode,
      city: addr.city,
      country: addr.country,
    });
    if (!r) return Result.fail(new Error("Geocode not found."));
    addr.latitude = r.lat;
    addr.longitude = r.lon;
    return Result.ok({ lat: r.lat, lon: r.lon });
  }

  async saveAcceptSuggestion(side) {
    if (!this.orderId) return Result.fail(new Error("Order not loaded."));
    const payload = {
      orderId: this.orderId,
      side: side === "both" ? "both" : side === "pickup" ? "pickup" : "delivery",
      correctedPickup: side === "pickup" || side === "both" ? this.editedPickup : null,
      correctedDelivery: side === "delivery" || side === "both" ? this.editedDelivery : null,
      resolution: "ACCEPT_SUGGESTION",
    };
    const res = await this.api.saveCorrection(payload);
    if (!res.ok) return Result.fail(res.error);
    return Result.ok(res.value);
  }

  async saveUseOriginal(side) {
    if (!this.orderId) return Result.fail(new Error("Order not loaded."));
    const payload = {
      orderId: this.orderId,
      side: side === "both" ? "both" : side === "pickup" ? "pickup" : "delivery",
      correctedPickup: side === "pickup" || side === "both" ? this.editedPickup : null,
      correctedDelivery: side === "delivery" || side === "both" ? this.editedDelivery : null,
      resolution: "USE_ORIGINAL",
    };
    const res = await this.api.saveCorrection(payload);
    if (!res.ok) return Result.fail(res.error);
    return Result.ok(res.value);
  }

  async saveManual(side) {
    if (!this.orderId) return Result.fail(new Error("Order not loaded."));
    const payload = {
      orderId: this.orderId,
      side: side === "both" ? "both" : side === "pickup" ? "pickup" : "delivery",
      correctedPickup: side === "pickup" || side === "both" ? this.editedPickup : null,
      correctedDelivery: side === "delivery" || side === "both" ? this.editedDelivery : null,
      resolution: "MANUAL_EDIT",
    };
    const res = await this.api.saveCorrection(payload);
    if (!res.ok) return Result.fail(res.error);
    return Result.ok(res.value);
  }

  async saveAndNext(side, worklistStore) {
    const saveRes = await this._saveBySideKind(side);
    if (!saveRes.ok) return saveRes;
    const nextIdRes = await worklistStore.getNextAndLoad(this.orderId);
    if (!nextIdRes.ok) return Result.fail(nextIdRes.error);
    const nextId = nextIdRes.value;
    if (!nextId) return Result.ok(null);
    const loadRes = await this.loadOrder(nextId);
    if (!loadRes.ok) return Result.fail(loadRes.error);
    return Result.ok(nextId);
  }

  snapshot() {
    return {
      orderId: this.orderId,
      detail: this.detail,
      editedPickup: this.editedPickup,
      editedDelivery: this.editedDelivery,
      loading: this.loading,
      error: this.error,
    };
  }

  _defaultCountry() {
    return "PL";
  }

  async _saveBySideKind(side) {
    if (side === "pickup") return this.saveManual("pickup");
    if (side === "delivery") return this.saveManual("delivery");
    if (side === "both") return this.saveManual("both");
    return Result.fail(new Error("Unknown side."));
  }
}


================================================================================
### PLIK: controllers\EditorAutosaveController.js
================================================================================

/**
 * ARCHITECTURE: EditorAutosaveController persists draft edits to session and restores on load.
 * It follows the manifesto by composing EditorStateSerializer with a timed save loop.
 * Responsibilities:
 * - Save edited pickup/delivery every N ms if changed; restore when opening the same orderId.
 */
import { EditorStateSerializer } from "@/services/EditorStateSerializer";
import { AddressEqualityService } from "@/services/AddressEqualityService";

export class EditorAutosaveController {
  constructor(editorFacade, serializer = new EditorStateSerializer(), eq = new AddressEqualityService(), intervalMs = 2000) {
    this.editor = editorFacade;
    this.serializer = serializer;
    this.eq = eq;
    this.intervalMs = intervalMs;
    this._timer = null;
    this._last = null;
    this._orderId = null;
  }

  async restore(orderId) {
    this._orderId = orderId;
    const saved = this.serializer.load(orderId);
    if (saved?.editedPickup) this.editor.setManualPickup(saved.editedPickup);
    if (saved?.editedDelivery) this.editor.setManualDelivery(saved.editedDelivery);
    this._last = this._take();
    return saved || null;
  }

  start() {
    if (this._timer) return false;
    this._timer = setInterval(() => this._tick(), this.intervalMs);
    return true;
  }

  stop() {
    if (!this._timer) return false;
    clearInterval(this._timer);
    this._timer = null;
    return true;
  }

  _tick() {
    if (!this._orderId) return;
    const now = this._take();
    if (!this._equalDrafts(this._last, now)) {
      this.serializer.save(this._orderId, now);
      this._last = now;
    }
  }

  _take() {
    const s = this.editor.snapshot();
    return { editedPickup: s?.editor?.editedPickup || null, editedDelivery: s?.editor?.editedDelivery || null };
  }

  _equalDrafts(a, b) {
    return this.eq.equals(a?.editedPickup || {}, b?.editedPickup || {}) && this.eq.equals(a?.editedDelivery || {}, b?.editedDelivery || {});
  }
}


================================================================================
### PLIK: controllers\EditorCommandBus.js
================================================================================

/**
 * ARCHITECTURE: EditorCommandBus centralizes high-level editor commands for buttons and hotkeys.
 * It follows the manifesto by exposing intent methods that orchestrate other controllers/facades.
 * Responsibilities:
 * - Provide accept/use-original/save/save&next commands for pickup, delivery, and both.
 * - Keep a single place to wire UI actions to EditorFacade and SaveFlowController.
 */
import { Result } from "@/domain/Result";

export class EditorCommandBus {
  constructor(editorFacade, saveFlowController) {
    this.editor = editorFacade;
    this.saveFlow = saveFlowController;
  }

  acceptPickup(i = 0) {
    const r = this.editor.acceptPickupSuggestion(i);
    return r.ok ? Result.ok(true) : r;
  }

  acceptDelivery(i = 0) {
    const r = this.editor.acceptDeliverySuggestion(i);
    return r.ok ? Result.ok(true) : r;
  }

  useOriginalPickup() {
    const r = this.editor.useOriginalPickup();
    return r.ok ? Result.ok(true) : r;
  }

  useOriginalDelivery() {
    const r = this.editor.useOriginalDelivery();
    return r.ok ? Result.ok(true) : r;
  }

  async savePickupThenNext() {
    return this.saveFlow.saveThenAwait("pickup");
  }

  async saveDeliveryThenNext() {
    return this.saveFlow.saveThenAwait("delivery");
  }

  async saveBothThenNext() {
    return this.saveFlow.saveThenAwait("both");
  }
}


================================================================================
### PLIK: controllers\EditorDiffController.js
================================================================================

/**
 * ARCHITECTURE: EditorDiffController computes and presents diffs for pickup and delivery addresses.
 * It follows the manifesto by composing DiffService and DiffPresenter behind a deterministic snapshot.
 * Responsibilities:
 * - Pull before/after from EditorFacade snapshot and compute UI-ready rows for both sides.
 */
import { DiffService } from "@/services/DiffService";
import { DiffPresenter } from "@/viewmodels/DiffPresenter";

export class EditorDiffController {
  constructor(editorFacade) {
    this.editor = editorFacade;
    this.diff = new DiffService();
    this.presenter = new DiffPresenter();
    this._snapshot = { pickup: { rows: [] }, delivery: { rows: [] } };
  }

  recompute() {
    const snap = this.editor.snapshot();
    const beforeP = snap.editor?.detail?.originalPickup || null;
    const afterP = snap.editor?.editedPickup || snap.editor?.editedPickup || snap.editor?.detail?.originalPickup || null;
    const beforeD = snap.editor?.detail?.originalDelivery || null;
    const afterD = snap.editor?.editedDelivery || snap.editor?.detail?.originalDelivery || null;

    const dp = this.presenter.present(this.diff.diff(beforeP, afterP));
    const dd = this.presenter.present(this.diff.diff(beforeD, afterD));

    this._snapshot = { pickup: dp, delivery: dd };
    return this._snapshot;
  }

  snapshot() {
    return JSON.parse(JSON.stringify(this._snapshot));
  }
}


================================================================================
### PLIK: controllers\EditorFacade.js
================================================================================

/**
 * ARCHITECTURE: EditorFacade wraps CorrectionEditorController and adds map preview conveniences.
 * It follows the manifesto by exposing intent methods used by the Editor view without leaking internals.
 * Responsibilities:
 * - Load order, set manual edits, accept suggestions, and compute snapshots for UI.
 * - Optionally preview on map when accepting/applying suggestions.
 */
import { Result } from "@/domain/Result";
import { SuggestionPreviewController } from "@/controllers/SuggestionPreviewController";

export class EditorFacade {
  constructor(editorController, mapController = null, _placesAdapter = null, queue = null) {
    this.ctrl = editorController;
    this.queue = queue || null;
    this.preview = mapController ? new SuggestionPreviewController(mapController) : null;
  }

  async load(orderId) {
    return await this.ctrl.loadOrder(orderId);
  }

  snapshot() {
    return { editor: this.ctrl.snapshot(), currentOrderId: this.ctrl?.detail?.orderId || null };
  }

  setManualPickup(addr) {
    return this.ctrl.setManualAddress("pickup", addr);
  }

  setManualDelivery(addr) {
    return this.ctrl.setManualAddress("delivery", addr);
  }

  setPickupSuggestions(list) {
    return this.ctrl.setSuggestions("pickup", list);
  }

  setDeliverySuggestions(list) {
    return this.ctrl.setSuggestions("delivery", list);
  }

  acceptPickupSuggestion(i = 0) {
    const r = this.ctrl.acceptSuggestion("pickup", i);
    if (this.preview && r.ok) this.preview.show(this.ctrl.snapshot().editedPickup);
    return r.ok ? Result.ok(true) : r;
  }

  acceptDeliverySuggestion(i = 0) {
    const r = this.ctrl.acceptSuggestion("delivery", i);
    if (this.preview && r.ok) this.preview.show(this.ctrl.snapshot().editedDelivery);
    return r.ok ? Result.ok(true) : r;
  }

  useOriginalPickup() {
    return this.ctrl.useOriginal("pickup");
  }

  useOriginalDelivery() {
    return this.ctrl.useOriginal("delivery");
  }
}


================================================================================
### PLIK: controllers\EditorFocusController.js
================================================================================

/**
 * ARCHITECTURE: EditorFocusController manages a deterministic focus order across address fields.
 * It follows the manifesto by isolating focus logic from the component and DOM details.
 * Responsibilities:
 * - Provide nextField() and prevField() given current key and an ordered schema.
 * - Return the target key for the view to focus without touching the DOM.
 */
export class EditorFocusController {
  constructor(order = ["street", "houseNumber", "postalCode", "city", "country"]) {
    this.order = order.slice();
    this.index = 0;
  }

  setCurrent(key) {
    const idx = this.order.indexOf(key);
    if (idx >= 0) this.index = idx;
    return this.current();
  }

  current() {
    return this.order[this.index] || null;
  }

  next() {
    this.index = Math.min(this.order.length - 1, this.index + 1);
    return this.current();
  }

  previous() {
    this.index = Math.max(0, this.index - 1);
    return this.current();
  }

  reset() {
    this.index = 0;
    return this.current();
  }
}


================================================================================
### PLIK: controllers\EditorHotkeysController.js
================================================================================

/**
 * ARCHITECTURE: EditorHotkeysController manages keyboard shortcuts for the Correction Editor.
 * It follows the manifesto by isolating DOM listeners and mapping keys to explicit callbacks.
 * Responsibilities:
 * - Attach/detach listeners and dispatch to provided handlers (save, save&next, accept, use original).
 * - Avoid collisions by scoping to a single active instance and ignoring repeated auto-fire.
 */
export class EditorHotkeysController {
  constructor(handlers = {}) {
    this.handlers = {
      onSave: handlers.onSave || null,
      onSaveNext: handlers.onSaveNext || null,
      onAccept: handlers.onAccept || null,
      onUseOriginal: handlers.onUseOriginal || null,
    };
    this._bound = (e) => this._onKey(e);
    this._attached = false;
  }

  attach() {
    if (this._attached) return false;
    window.addEventListener("keydown", this._bound, true);
    this._attached = true;
    return true;
  }

  detach() {
    if (!this._attached) return false;
    window.removeEventListener("keydown", this._bound, true);
    this._attached = false;
    return true;
  }

  _onKey(e) {
    if (e.repeat) return;
    const mod = e.ctrlKey || e.metaKey;
    if (mod && e.key.toLowerCase() === "s") {
      e.preventDefault();
      if (e.shiftKey && this.handlers.onSaveNext) return this.handlers.onSaveNext();
      if (this.handlers.onSave) return this.handlers.onSave();
    }
    if (mod && e.key.toLowerCase() === "enter") {
      e.preventDefault();
      if (this.handlers.onAccept) return this.handlers.onAccept();
    }
    if (mod && e.key.toLowerCase() === "backspace") {
      e.preventDefault();
      if (this.handlers.onUseOriginal) return this.handlers.onUseOriginal();
    }
  }
}


================================================================================
### PLIK: controllers\EditorInitController.js
================================================================================

/**
 * ARCHITECTURE: EditorInitController prepares the Correction Editor with autosave, undo, and recovery wiring.
 * It follows the manifesto by centralizing editor startup steps for a predictable, testable flow.
 * Responsibilities:
 * - Load order, restore drafts, start autosave, initialize undo snapshot, and prefetch next order.
 * - Provide a single init(orderId) returning a stabilized snapshot for the view.
 */
import { EditorAutosaveController } from "@/controllers/EditorAutosaveController";
import { EditorUndoController } from "@/controllers/EditorUndoController";
import { OrderDetailPrefetcher } from "@/services/OrderDetailPrefetcher";
import { Result } from "@/domain/Result";

export class EditorInitController {
  constructor(editorFacade, ordersQueue, autosave = null, undo = null, prefetcher = new OrderDetailPrefetcher()) {
    this.editor = editorFacade;
    this.queue = ordersQueue;
    this.autosave = autosave instanceof EditorAutosaveController ? autosave : new EditorAutosaveController(this.editor);
    this.undo = undo instanceof EditorUndoController ? undo : new EditorUndoController(this.editor);
    this.prefetcher = prefetcher;
  }

  async init(orderId) {
    const load = await this.editor.load(orderId);
    if (!load.ok) return load;
    await this.autosave.restore(orderId);
    this.autosave.start();
    this.undo.init();
    const nextId = this.queue.current() || this.queue.next();
    if (nextId) await this.prefetcher.prefetch(nextId);
    return Result.ok(this.editor.snapshot());
  }

  stop() {
    this.autosave.stop();
    return true;
  }
}


================================================================================
### PLIK: controllers\EditorNavigationController.js
================================================================================

/**
 * ARCHITECTURE: EditorNavigationController builds route URLs to the editor preserving context when needed.
 * It follows the manifesto by isolating URL composition away from views.
 * Responsibilities:
 * - toEditor(orderId, from, state): return path with optional query for back navigation.
 */
export class EditorNavigationController {
  toEditor(orderId, from = "worklist", state = null) {
    const q = new URLSearchParams();
    q.set("from", from);
    if (state && typeof state === "object") q.set("ctx", btoa(unescape(encodeURIComponent(JSON.stringify(state)))));
    return `/editor/${encodeURIComponent(orderId)}?${q.toString()}`;
  }
}


================================================================================
### PLIK: controllers\EditorRecoveryController.js
================================================================================

/**
 * ARCHITECTURE: EditorRecoveryController (Stub) would be responsible for
 * handling recovery from save failures or state inconsistencies in the editor,
 * potentially by retrying, resetting state, or alerting the user.
 * This is a placeholder implementation.
 */
import { Result } from "@/domain/Result";

export class EditorRecoveryController {
    constructor(editorFacade, saveFlowController) {
        this.editor = editorFacade;
        this.saveFlow = saveFlowController;
    }

    /**
     * Attempts to recover from a failed save state.
     * @param {object} lastKnownGoodState - The snapshot before the failed save.
     * @param {Error} error - The error that occurred.
     * @returns {Promise<Result<any, Error>>}
     */
    async attemptRecovery(lastKnownGoodState, error) {
        console.warn("[EditorRecoveryController] Recovery requested for error:", error, "Last state:", lastKnownGoodState);
        // Placeholder: Simple recovery might just be to inform the user.
        // A complex one might check error type and retry if retryable.
        return Result.fail(new Error("Automatic recovery not implemented. Please check your connection and try saving again."));
    }
}

================================================================================
### PLIK: controllers\EditorSavePolicyController.js
================================================================================

/**
 * ARCHITECTURE: EditorSavePolicyController decides when Save buttons should be enabled.
 * It follows the manifesto by isolating policy checks (diff, validation, geocode) from UI components.
 * Responsibilities:
 * - Evaluate readiness for pickup/delivery/both saves using diff flags and validation results.
 * - Provide explicit booleans and reasons for disabled states.
 */
export class EditorSavePolicyController {
  constructor() {
    this.requireGeocode = false;
  }

  setRequireGeocode(v) {
    this.requireGeocode = !!v;
    return this.requireGeocode;
  }

  canSavePickup(state) {
    return this._evaluate(state?.latestDiff?.pickup, state?.editor?.validation, state?.editor?.instant, "pickup");
  }

  canSaveDelivery(state) {
    return this._evaluate(state?.latestDiff?.delivery, state?.editor?.validation, state?.editor?.instant, "delivery");
  }

  canSaveBoth(state) {
    const p = this._evaluate(state?.latestDiff?.pickup, state?.editor?.validation, state?.editor?.instant, "pickup");
    const d = this._evaluate(state?.latestDiff?.delivery, state?.editor?.validation, state?.editor?.instant, "delivery");
    return { enabled: p.enabled && d.enabled, reason: p.enabled ? d.reason : p.reason };
  }

  _evaluate(diff, validation, instant, side) {
    if (!diff || !validation) return { enabled: false, reason: "No changes or validation state missing" };
    if (!diff.anyChanged) return { enabled: false, reason: "No changes detected" };
    if (!validation.valid) return { enabled: false, reason: "Invalid address fields" };
    if (this.requireGeocode && !instant) return { enabled: false, reason: "Geocode required" };
    return { enabled: true, reason: "OK" };
  }
}


================================================================================
### PLIK: controllers\EditorUndoController.js
================================================================================

/**
 * ARCHITECTURE: EditorUndoController wraps UndoStackService for pickup/delivery address edits.
 * It follows the manifesto by providing intent-driven methods without UI or storage coupling.
 * Responsibilities:
 * - Capture snapshots on change, and restore on undo/redo callbacks to the editor facade.
 * - Keep a tiny footprint: snapshot shape is {pickup,delivery}.
 */
import { UndoStackService } from "@/services/UndoStackService";

export class EditorUndoController {
  constructor(editorFacade, stack = new UndoStackService(100)) {
    this.editor = editorFacade;
    this.stack = stack;
  }

  init() {
    const snap = this._snapshot();
    this.stack.init(snap);
    return snap;
  }

  onChange() {
    return this.stack.push(this._snapshot());
  }

  undo() {
    const s = this.stack.undo();
    if (!s) return null;
    if (s.pickup) this.editor.setManualPickup(s.pickup);
    if (s.delivery) this.editor.setManualDelivery(s.delivery);
    return s;
  }

  redo() {
    const s = this.stack.redo();
    if (!s) return null;
    if (s.pickup) this.editor.setManualPickup(s.pickup);
    if (s.delivery) this.editor.setManualDelivery(s.delivery);
    return s;
  }

  _snapshot() {
    const st = this.editor.snapshot();
    return {
      pickup: st?.editor?.editedPickup || null,
      delivery: st?.editor?.editedDelivery || null,
    };
  }
}


================================================================================
### PLIK: controllers\EditorVerificationController.js
================================================================================

/**
 * ARCHITECTURE: EditorVerificationController coordinates live verification for the Correction Editor input fields.
 * It follows the manifesto by composing debounce, normalization, validation, Google geocode, and Places hints.
 * Responsibilities:
 * - Debounce user input; on settle, normalize+validate; if valid, geocode and suggest via Places.
 * - Update a MapController through an injected adapter to visualize the current candidate.
 * - Provide a snapshot for the component to render without exposing third-party APIs.
 */
import { AddressNormalizer } from "@/services/AddressNormalizer";
import { ValidationService } from "@/services/ValidationService";
import { DebounceTimer } from "@/services/DebounceTimer";

export class EditorVerificationController {
  constructor(geocoderAdapter, placesAdapter, mapController, debounceMs = 400) {
    this.normalizer = new AddressNormalizer();
    this.validator = new ValidationService();
    this.debouncer = new DebounceTimer(debounceMs);
    this.geocoder = geocoderAdapter || null;
    this.places = placesAdapter || null;
    this.map = mapController || null;
    this.input = { street: "", houseNumber: "", postalCode: "", city: "", country: "PL" };
    this.validation = { valid: false, errors: {} };
    this.instant = null;
    this.suggestions = [];
    this.loading = false;
    this.error = null;
  }

  setInputPatch(patch) {
    this.input = { ...this.input, ...(patch || {}) };
    return this.input;
  }

  async runVerification() {
    return this.debouncer.run(async () => {
      this.loading = true;
      this.error = null;
      const normalized = this.normalizer.normalize(this.input);
      const check = this.validator.validate(normalized);
      this.validation = check;
      if (!check.valid) {
        this.instant = null;
        this.suggestions = [];
        this.loading = false;
        return this.snapshot();
      }
      const instant = this.geocoder ? await this.geocoder.geocodeAddress(normalized) : null;
      if (instant && typeof instant.latitude === "number" && typeof instant.longitude === "number" && this.map) {
        await this.map.updateMarker(instant.latitude, instant.longitude, true);
      }
      const hints = this.places ? await this.places.suggest(this._composeFreeText(normalized), normalized.country) : [];
      this.instant = instant;
      this.suggestions = Array.isArray(hints) ? hints : [];
      this.loading = false;
      return this.snapshot();
    });
  }

  snapshot() {
    return {
      input: { ...this.input },
      validation: { ...this.validation },
      instant: this.instant ? { ...this.instant } : null,
      suggestions: this.suggestions.slice(),
      loading: this.loading,
      error: this.error,
    };
  }

  _composeFreeText(a) {
    const line1 = a.houseNumber ? `${a.street} ${a.houseNumber}` : a.street;
    return `${line1}, ${a.postalCode} ${a.city}`;
  }
}


================================================================================
### PLIK: controllers\EndToEndVerifyAndSaveController.js
================================================================================

/**
 * ARCHITECTURE: EndToEndVerifyAndSaveController runs normalize→validate→verify→save with telemetry.
 * It follows the manifesto by composing workflow, policy, and save flow into a single orchestrator.
 * Responsibilities:
 * - Verify pickup/delivery, apply best suggestion, and persist the result; then advance queue.
 * - Emit timing events via VerificationTelemetryController and return a concise outcome.
 */
import { AddressVerificationWorkflow } from "@/controllers/AddressVerificationWorkflow";
import { SuggestionSelectionController } from "@/controllers/SuggestionSelectionController";
import { SaveFlowController } from "@/controllers/SaveFlowController";
import { VerificationTelemetryController } from "@/controllers/VerificationTelemetryController";
import { Result } from "@/domain/Result";

export class EndToEndVerifyAndSaveController {
  constructor(googleApiKey, editorFacade, ordersQueue, saver) {
    this.workflow = new AddressVerificationWorkflow(googleApiKey);
    this.selector = new SuggestionSelectionController();
    this.saveFlow = new SaveFlowController(editorFacade, ordersQueue, saver);
    this.telemetry = new VerificationTelemetryController();
    this.editor = editorFacade;
  }

  async runForSide(side = "pickup") {
    const corr = this.telemetry.start(`e2e_${side}`);
    const addr = side === "pickup" ? this.editor.editor.editedPickup : this.editor.editor.editedDelivery;
    if (!addr) {
      this.telemetry.finish("no-input", { side });
      return Result.fail(new Error("No address to verify"));
    }
    this.telemetry.mark("verify-start", { side });
    const vr = await this.workflow.verify(addr);
    this.telemetry.mark("verify-finish", { valid: vr.success, side });
    if (!vr.success) {
      this.telemetry.finish("invalid", { side });
      return Result.fail(new Error("Validation failed"));
    }
    const best = this.selector.best(vr.normalized, vr.suggestions);
    if (best) {
      if (side === "pickup") this.editor.acceptPickupSuggestion(best.index);
      if (side === "delivery") this.editor.acceptDeliverySuggestion(best.index);
    }
    this.telemetry.mark("save-start", { side });
    const saved = await this.saveFlow.saveThenAwait(side);
    const status = saved.ok ? "ok" : "save-failed";
    this.telemetry.finish(status, { side, nextId: saved.ok ? saved.value?.nextId || null : null });
    return saved;
  }
}


================================================================================
### PLIK: controllers\erificationQueueController.js
================================================================================

/**
 * ARCHITECTURE: VerificationQueueController serializes geocode requests to respect provider quotas.
 * It follows the manifesto by isolating concurrency limits and exposing enqueue() with result promises.
 * Responsibilities:
 * - Maintain a FIFO queue, run up to N active tasks, and resolve/reject per item deterministically.
 * - Allow dynamic concurrency to adapt to UI load and throttle bursts from user typing.
 */
export class VerificationQueueController {
  constructor(concurrency = 2) {
    this.concurrency = Math.max(1, concurrency);
    this._active = 0;
    this._q = [];
  }

  setConcurrency(n) {
    this.concurrency = Math.max(1, n);
    this._drain();
    return this.concurrency;
  }

  enqueue(taskFn) {
    return new Promise((resolve, reject) => {
      this._q.push({ taskFn, resolve, reject });
      this._drain();
    });
  }

  _drain() {
    while (this._active < this.concurrency && this._q.length > 0) {
      const item = this._q.shift();
      this._run(item);
    }
  }

  async _run(item) {
    this._active++;
    try {
      const r = await item.taskFn();
      item.resolve(r);
    } catch (e) {
      item.reject(e);
    } finally {
      this._active--;
      this._drain();
    }
  }

  size() {
    return this._q.length + this._active;
  }
}


================================================================================
### PLIK: controllers\GeocodeWithCacheController.js
================================================================================

// FILE: controllers/GeocodeWithCacheController.js
/**
 * ARCHITECTURE: GeocodeWithCacheController composes cache, quota backoff for geocoding.
 * It follows the manifesto by isolating resilience and performance concerns behind a single geocode() method.
 * Responsibilities:
 * - Check in-memory cache, call the provider, and apply quota backoff on retryable errors.
 * - Store successful results back to cache with TTL.
 * REFACTORED: Removed VerificationQueueController dependency as it's being removed. Direct calls are now made.
 */
import { AddressGeocodeCache } from "@/services/AddressGeocodeCache";
import { QuotaBackoffService } from "@/services/QuotaBackoffService";
// REMOVED: import { VerificationQueueController } from "@/controllers/VerificationQueueController";

export class GeocodeWithCacheController {
    constructor(
        geocoderAdapter,
        cache = new AddressGeocodeCache(),
        backoff = new QuotaBackoffService()
        // REMOVED: queue dependency
    ) {
        this.geocoder = geocoderAdapter;
        this.cache = cache;
        this.backoff = backoff;
        // REMOVED: this.queue = queue;
    }

    async geocode(address) {
        const hit = this.cache.get(address);
        if (hit) {
            // console.debug("Geocode cache hit:", address);
            return hit;
        }
        // console.debug("Geocode cache miss:", address);

        // Directly execute the task with backoff, removing the queue layer
        const task = async () => {
            const run = () => this.geocoder.geocodeAddress(address);
            const result = await this.backoff.execute(run);
            if (result) {
                // console.debug("Geocode success, caching:", address, result);
                this.cache.put(address, result);
            } else {
                // console.debug("Geocode returned null/empty, not caching:", address);
            }
            return result;
        };

        // Replace queue enqueue with direct execution
        return task();
        // REMOVED: return this.queue.enqueue(task);
    }
}

================================================================================
### PLIK: controllers\HealthGateController.js
================================================================================

/**
 * ARCHITECTURE: HealthGateController returns a stable readiness object without external dependencies.
 * It follows the manifesto by short-circuiting health checks in dev so the shell can render immediately.
 * Responsibilities:
 * - Delegate to RuntimeHealthService (which is dev-bypassed) and forward the normalized result.
 */
import { RuntimeHealthService } from "@/services/RuntimeHealthService";

export class HealthGateController {
  constructor(runtime = new RuntimeHealthService()) {
    this.runtime = runtime;
  }

  async readiness(googleKey) {
    const r = await this.runtime.readiness(googleKey);
    return { ok: !!r.ready, backend: !!r.backend?.ok, provider: !!r.provider?.ok, google: !!r.google?.ok };
  }
}


================================================================================
### PLIK: controllers\IdempotentSaveController.js
================================================================================

/**
 * ARCHITECTURE: IdempotentSaveController wraps AddressCorrectionService with idempotency token generation.
 * It follows the manifesto by isolating token creation and persistence concerns behind one save() method.
 * Responsibilities:
 * - Generate a deterministic token per payload and pass it down to AddressExceptionApi.
 * - Return Result objects and protect against accidental duplicate submissions.
 */
import { Result } from "@/domain/Result";
import { AddressPersistenceMapper } from "@/services/AddressPersistenceMapper";
import { IdempotencyTokenService } from "@/services/IdempotencyTokenService";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

export class IdempotentSaveController {
  constructor(api = new AddressExceptionApi(), mapper = new AddressPersistenceMapper(), tokens = new IdempotencyTokenService()) {
    this.api = api;
    this.mapper = mapper;
    this.tokens = tokens;
  }

  async save(payload) {
    const orderId = payload?.orderId;
    const side = payload?.side || "both";
    const body = this.mapper.toSavePayload(orderId, side, payload?.before || null, payload?.after || null, payload?.resolution || "MANUAL_EDIT");
    const token = this.tokens.create(orderId, side, JSON.stringify(body));
    const res = await this.api.saveCorrection(body, token);
    return res.ok ? Result.ok(res.value) : Result.fail(res.error);
  }
}


================================================================================
### PLIK: controllers\IntegrationOrchestrator.js
================================================================================

/**
 * ARCHITECTURE: IntegrationOrchestrator wires shared controllers/services and exposes factories for views.
 * It follows the manifesto by centralizing cross-cutting instances (queue, polling, api) behind a stable API.
 * Responsibilities:
 * - Hold shared OrdersQueueService, AddressExceptionApi, and factories for WorklistFacade and EditorFacade.
 * - Provide getWorklist() and getEditor() used by views; keep instances memoized per app session.
 */
import { OrdersQueueService } from "@/services/OrdersQueueService";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";
import { WorklistFacade } from "@/controllers/WorklistFacade";
import { CorrectionEditorController } from "@/controllers/CorrectionEditorController";
import { EditorFacade } from "@/controllers/EditorFacade";
import { GoogleGeocodingAdapter } from "@/adapters/GoogleGeocodingAdapter";
import { GooglePlacesAutocompleteAdapter } from "@/adapters/GooglePlacesAutocompleteAdapter";

export class IntegrationOrchestrator {
  constructor(google, mapController) {
    this.google = google || null;
    this.mapController = mapController || null;
    this.queue = new OrdersQueueService();
    this.api = new AddressExceptionApi();
    this._worklist = null;
    this._editor = null;
  }

  getWorklist() {
    if (this._worklist) return this._worklist;
    this._worklist = new WorklistFacade(this.api, this.queue);
    return this._worklist;
  }

  getEditor() {
    if (this._editor) return this._editor;
    const geocoder = this.google ? new GoogleGeocodingAdapter(this.google) : null;
    const places = this.google ? new GooglePlacesAutocompleteAdapter(this.google) : null;
    const ctrl = new CorrectionEditorController(this.api, geocoder);
    this._editor = new EditorFacade(ctrl, this.mapController, places, this.queue);
    return this._editor;
  }
}


================================================================================
### PLIK: controllers\LoginFormController.js
================================================================================


================================================================================
### PLIK: controllers\MapController.js
================================================================================

/**
 * ARCHITECTURE: MapController coordinates a map adapter to create a map, update its marker, and recenter.
 * It follows the manifesto by hiding vendor API behind a minimal surface tailored to the editor workflow.
 * Responsibilities:
 * - Initialize the map, move the marker to a coordinate, and recenter with optional zoom changes.
 * - Provide idempotent destroy() to free resources on route leave.
 */
export class MapController {
  constructor(mapAdapter) {
    this.adapter = mapAdapter;
    this._container = null;
    this._center = { lat: 52.2297, lon: 21.0122, zoom: 12 };
    this._ready = false;
  }

  async init(container, options) {
    this._container = container;
    const opt = options || this._center;
    await this.adapter.create(container, { lat: opt.lat, lon: opt.lon, zoom: opt.zoom });
    this._center = { lat: opt.lat, lon: opt.lon, zoom: opt.zoom };
    this._ready = true;
    return true;
  }

  async updateMarker(lat, lon, recenter = false) {
    if (!this._ready) throw new Error("MapController: map not initialized.");
    await this.adapter.setMarker(lat, lon);
    if (recenter) {
      await this.adapter.setCenter(lat, lon, this._center.zoom);
      this._center = { ...this._center, lat, lon };
    }
    return true;
  }

  async recenter(zoom) {
    if (!this._ready) throw new Error("MapController: map not initialized.");
    const z = typeof zoom === "number" ? zoom : this._center.zoom;
    await this.adapter.setCenter(this._center.lat, this._center.lon, z);
    this._center.zoom = z;
    return true;
  }

  async destroy() {
    await this.adapter.destroy();
    this._ready = false;
    this._container = null;
    return true;
  }
}


================================================================================
### PLIK: controllers\MapViewportPolicyController.js
================================================================================

/**
 * ARCHITECTURE: MapViewportPolicyController centralizes how the editor focuses the map on addresses.
 * It follows the manifesto by hiding viewport decisions behind a minimal, deterministic API.
 * Responsibilities:
 * - Focus on instant geocode or suggestion; update marker and optionally recenter.
 */
export class MapViewportPolicyController {
  constructor(mapController) {
    this.map = mapController;
  }

  async focusInstant(model) {
    const lat = Number(model?.latitude);
    const lon = Number(model?.longitude);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) return false;
    await this.map.updateMarker(lat, lon, true);
    return true;
  }

  async focusSuggestion(suggestion) {
    const lat = Number(suggestion?.latitude);
    const lon = Number(suggestion?.longitude);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) return false;
    await this.map.updateMarker(lat, lon, true);
    return true;
  }

  async focusAddress(addr) {
    const lat = Number(addr?.latitude);
    const lon = Number(addr?.longitude);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) return false;
    await this.map.updateMarker(lat, lon, true);
    return true;
  }
}


================================================================================
### PLIK: controllers\PlacesHintController.js
================================================================================

/**
 * ARCHITECTURE: PlacesHintController coordinates Google Places type-ahead hints with session tokens and debouncing.
 * It follows the manifesto by isolating vendor semantics and timing concerns behind a single suggest() method.
 * Responsibilities:
 * - Use GooglePlacesSessionManager to reuse/renew AutocompleteSessionToken.
 * - Debounce keystrokes, query Places adapter, and return normalized suggestions.
 */
import { GooglePlacesSessionManager } from "@/adapters/GooglePlacesSessionManager";
import { DebounceTimer } from "@/services/DebounceTimer";
import { SuggestionNormalizer } from "@/services/SuggestionNormalizer";

export class PlacesHintController {
  constructor(googleObj, placesAdapter, debounceMs = 250) {
    this.google = googleObj;
    this.places = placesAdapter;
    this.session = new GooglePlacesSessionManager(this.google);
    this.debounce = new DebounceTimer(debounceMs);
    this.normalizer = new SuggestionNormalizer();
  }

  async suggest(freeText, country = "PL") {
    return this.debounce.run(async () => {
      if (!this.places || !freeText || !freeText.trim()) return [];
      const token = this.session.getToken();
      void token;
      const raw = await this.places.suggest(freeText, country);
      return this.normalizer.normalizeBatch(raw, "PLACES");
    });
  }

  renewSession() {
    this.session.renew();
    return true;
  }
}


================================================================================
### PLIK: controllers\ProviderFallbackController.js
================================================================================


================================================================================
### PLIK: controllers\ProviderGuard.js
================================================================================

/**
 * ARCHITECTURE: ProviderGuard enforces that TES address provider is GOOGLE before verification flows run.
 * It follows the manifesto by isolating cross-cutting preconditions and exposing a single guard method.
 * Responsibilities:
 * - Read current provider via DANXILS-API proxy; if not GOOGLE, request it be set to GOOGLE.
 * - Since the backend uses Kafka, this involves initiating requests and polling for completion status.
 * - Cache the result to avoid redundant network calls during the session.
 */
import apiClient from "@/services/api";
import { TesOperationPoller } from "@/services/TesOperationPoller";

export class ProviderGuard {
    constructor(poller = new TesOperationPoller()) {
        this._aligned = false;
        this._inFlight = null;
        this._poller = poller;
    }

    async ensureGoogle() {
        if (this._aligned) return true;
        if (this._inFlight) return this._inFlight;

        this._inFlight = (async () => {
            try {
                const getCurrentResponse = await apiClient.get("/api/admin/address-verification/providers/current");
                if (getCurrentResponse.status !== 202 || !getCurrentResponse.data?.correlationId) {
                    throw new Error("Failed to initiate get-current-provider request.");
                }
                const currentProviderResult = await this._poller.waitFor(getCurrentResponse.data.correlationId);
                if (currentProviderResult.status !== 'COMPLETED') {
                    throw new Error(`Polling for current provider failed: ${currentProviderResult.errorDetails || 'Unknown error'}`);
                }

                const currentProviderName = currentProviderResult.result;
                if (typeof currentProviderName === 'string' && currentProviderName.toUpperCase() === "GOOGLE") {
                    this._aligned = true;
                    return true;
                }

                console.warn(`TES Provider is '${currentProviderName}', attempting to set to GOOGLE.`);
                const setProviderResponse = await apiClient.post("/api/admin/address-verification/providers/current", "GOOGLE", {
                    headers: { "Content-Type": "text/plain" },
                });
                if (setProviderResponse.status !== 202 || !setProviderResponse.data?.correlationId) {
                    throw new Error("Failed to initiate set-current-provider request.");
                }
                const setProviderResult = await this._poller.waitFor(setProviderResponse.data.correlationId);
                if (setProviderResult.status !== 'COMPLETED') {
                    throw new Error(`Polling for set provider failed: ${setProviderResult.errorDetails || 'Unknown error'}`);
                }

                this._aligned = true;
                console.log("Successfully requested TES provider alignment to GOOGLE.");
                return true;
            } catch (error) {
                this._aligned = false;
                console.error("ProviderGuard alignment failed:", error);
                throw new Error(`Failed to ensure TES provider is GOOGLE: ${error.message}`);
            } finally {
                this._inFlight = null;
            }
        })();

        return this._inFlight;
    }
}


================================================================================
### PLIK: controllers\QuickAcceptController.js
================================================================================

/**
 * ARCHITECTURE: QuickAcceptController enables one-click "best suggestion" acceptance per side.
 * It follows the manifesto by composing SuggestionSelectionController and EditorFacade.
 * Responsibilities:
 * - Compute best suggestion for the current input and apply it; return the applied index or null.
 */
import { SuggestionSelectionController } from "@/controllers/SuggestionSelectionController";

export class QuickAcceptController {
  constructor() {
    this.selector = new SuggestionSelectionController();
  }

  applyBest(side, baseInput, suggestions, editorFacade) {
    const best = this.selector.best(baseInput, suggestions);
    if (!best) return null;
    if (side === "pickup") editorFacade.acceptPickupSuggestion(best.index);
    if (side === "delivery") editorFacade.acceptDeliverySuggestion(best.index);
    return best.index;
  }
}


================================================================================
### PLIK: controllers\RealtimeVerificationOrchestrator.js
================================================================================

/**
 * ARCHITECTURE: RealtimeVerificationOrchestrator coordinates debounced input, geocode-with-cache, and places hints.
 * It follows the manifesto by composing small services to provide a single verify() for live user typing.
 * Responsibilities:
 * - Debounce the input, validate and normalize externally, then call geocode and places in parallel.
 * - Return a deterministic structure with instant geocode, ranked suggestions, and timing info.
 */
import { DebounceTimer } from "@/services/DebounceTimer";
import { AddressSuggestionRanker } from "@/services/AddressSuggestionRanker";
import { SuggestionNormalizer } from "@/services/SuggestionNormalizer";

export class RealtimeVerificationOrchestrator {
  constructor(geocodeController, placesAdapter, debounceMs = 350) {
    this.geocode = geocodeController;
    this.places = placesAdapter;
    this.debouncer = new DebounceTimer(debounceMs);
    this.ranker = new AddressSuggestionRanker();
    this.normalizer = new SuggestionNormalizer();
  }

  async verify(baseInput) {
    return this.debouncer.run(async () => {
      const t0 = performance.now ? performance.now() : Date.now();
      const [geo, placeRaw] = await Promise.all([
        this.geocode.geocode(baseInput),
        this.places ? this.places.suggest(this._freeText(baseInput), baseInput.country || "PL") : Promise.resolve([]),
      ]);
      const instant = geo
        ? {
            fullAddressLabel: null,
            street: baseInput.street || null,
            houseNumber: baseInput.houseNumber || null,
            postalCode: baseInput.postalCode || null,
            city: baseInput.city || null,
            countryCode: baseInput.country || "PL",
            countryName: null,
            latitude: geo.lat ?? null,
            longitude: geo.lon ?? null,
            matchScore: 1.0,
            matchLevel: "GEOCODER",
            providerSource: "GOOGLE_CLIENT",
          }
        : null;
      const places = this.normalizer.normalizeBatch(placeRaw, "PLACES");
      const merged = instant ? [instant, ...places] : places.slice();
      const ranked = this.ranker.rank(baseInput, merged);
      const t1 = performance.now ? performance.now() : Date.now();
      return { instant, suggestions: ranked, elapsedMs: Math.round(t1 - t0) };
    });
  }

  _freeText(a) {
    const line1 = a.houseNumber ? `${a.street} ${a.houseNumber}` : a.street || "";
    return `${line1}, ${a.postalCode || ""} ${a.city || ""}`.trim();
  }
}


================================================================================
### PLIK: controllers\SafeSaveController.js
================================================================================

/**
 * ARCHITECTURE: SafeSaveController guards persistence with equality checks and idempotency keys.
 * It follows the manifesto by preventing duplicate saves and short-circuiting when nothing changed.
 * Responsibilities:
 * - Compute a change key using AddressEqualityService; skip save if unchanged.
 * - Generate an idempotency token to pass to backend headers when available.
 */
import { AddressEqualityService } from "@/services/AddressEqualityService";

export class SafeSaveController {
  constructor(saver, equality = new AddressEqualityService()) {
    this.saver = saver;
    this.eq = equality;
    this._lastKey = null;
  }

  async saveIfChanged(payload) {
    const before = payload?.before || {};
    const after = payload?.after || {};
    const key = this._keyOf(before, after, payload?.orderId, payload?.side, payload?.resolution);
    if (key === this._lastKey) return { skipped: true, reason: "Duplicate save call" };
    const changed =
      (after.pickup && !this.eq.equals(before.pickup || {}, after.pickup)) ||
      (after.delivery && !this.eq.equals(before.delivery || {}, after.delivery));
    if (!changed) return { skipped: true, reason: "No changes" };
    const res = await this.saver.save(payload);
    if (res?.ok) this._lastKey = key;
    return { skipped: false, result: res };
  }

  _keyOf(before, after, orderId, side, resolution) {
    const h = (a) => this.eq.hash(a || {});
    return [orderId || "", side || "", resolution || "", h(before?.pickup), h(before?.delivery), h(after?.pickup), h(after?.delivery)].join("#");
  }
}


================================================================================
### PLIK: controllers\SaveAndNextController.js
================================================================================

/**
 * ARCHITECTURE: SaveAndNextController coordinates saving an address correction and loading the next order.
 * It follows the manifesto by composing persistence, queue sequencing, and editor orchestration behind one method.
 * Responsibilities:
 * - Execute a provided save function, remove current id from queue on success, and resolve the next id.
 * - Short-circuit when the queue is empty and return null for end-of-queue conditions.
 */
import { Result } from "@/domain/Result";

export class SaveAndNextController {
  constructor(ordersQueue, editorController) {
    this.queue = ordersQueue;
    this.editor = editorController;
  }

  async saveThenNext(saveFn) {
    const currentId = this.queue.current();
    if (!currentId) return Result.ok(null);
    const res = await saveFn();
    if (!res || res.ok === false) {
      const err = res?.error || new Error("Save failed.");
      return Result.fail(err);
    }
    this.queue.remove(currentId);
    const nextId = this.queue.current() || this.queue.next();
    if (!nextId) return Result.ok(null);
    const load = await this.editor.loadOrder(nextId);
    if (!load.ok) return Result.fail(load.error);
    return Result.ok(nextId);
  }
}


================================================================================
### PLIK: controllers\SaveFlowController.js
================================================================================

/**
 * ARCHITECTURE: SaveFlowController orchestrates saving pickup/delivery/both and computing next item.
 * It follows the manifesto by isolating save intent and queue stepping away from views.
 * Responsibilities:
 * - Save via IdempotentSaveController; on success, pop next id from OrdersQueueService for Save & Next.
 */
import { Result } from "@/domain/Result";

export class SaveFlowController {
  constructor(editorFacade, queueService, idempotentSaveController) {
    this.editor = editorFacade;
    this.queue = queueService || { current: () => null, next: () => null };
    this.saveController = idempotentSaveController;
  }

  async saveThenAwait(side = "both") {
    const snap = this.editor.snapshot();
    const orderId = snap.currentOrderId || snap.editor?.detail?.orderId || null;
    if (!orderId) return Result.fail(new Error("SaveFlow: no order id."));

    const before = {
      pickup: snap.editor?.detail?.originalPickup || null,
      delivery: snap.editor?.detail?.originalDelivery || null,
    };
    const after = {
      pickup: snap.editor?.editedPickup || null,
      delivery: snap.editor?.editedDelivery || null,
    };

    const payload = { orderId, side, before, after, resolution: "MANUAL_EDIT" };
    const r = await this.saveController.save(payload);
    if (!r.ok) return r;

    const nextId = this.queue.next();
    return Result.ok({ ok: true, nextId });
  }
}


================================================================================
### PLIK: controllers\SuggestionListController.js
================================================================================

/**
 * ARCHITECTURE: SuggestionListController manages selection and application of ranked suggestions.
 * It follows the manifesto by isolating list state from UI and delegating application to EditorFacade.
 * Responsibilities:
 * - Hold a cursor over suggestions, navigate next/prev, and apply current suggestion to pickup or delivery.
 * - Coordinate map viewport focusing for visual confirmation.
 */
import { SuggestionSelectionController } from "@/controllers/SuggestionSelectionController";
import { MapViewportPolicyController } from "@/controllers/MapViewportPolicyController";

export class SuggestionListController {
  constructor(editorFacade, mapController) {
    this.editor = editorFacade;
    this.selector = new SuggestionSelectionController();
    this.viewport = new MapViewportPolicyController(mapController);
    this.items = [];
    this.index = -1;
  }

  load(list) {
    this.items = Array.isArray(list) ? list.slice() : [];
    this.index = this.items.length ? 0 : -1;
    return this.snapshot();
  }

  select(i) {
    if (typeof i !== "number" || i < 0 || i >= this.items.length) return this.snapshot();
    this.index = i;
    return this.snapshot();
  }

  next() {
    if (this.items.length === 0) return this.snapshot();
    this.index = Math.min(this.items.length - 1, this.index + 1);
    return this.snapshot();
  }

  prev() {
    if (this.items.length === 0) return this.snapshot();
    this.index = Math.max(0, this.index - 1);
    return this.snapshot();
  }

  async applyTo(side = "pickup") {
    if (this.index < 0 || this.index >= this.items.length) return false;
    const sel = { index: this.index, suggestion: this.items[this.index] };
    const ok = this.selector.accept(this.editor, side, sel);
    if (ok) await this.viewport.focusSuggestion(sel.suggestion);
    return ok;
  }

  snapshot() {
    return {
      items: this.items.slice(),
      index: this.index,
      current: this.index >= 0 ? this.items[this.index] : null,
    };
  }
}


================================================================================
### PLIK: controllers\SuggestionPreviewController.js
================================================================================

/**
 * ARCHITECTURE: SuggestionPreviewController coordinates map focusing for a chosen suggestion.
 * It follows the manifesto by isolating viewport behavior from editor and views.
 * Responsibilities:
 * - Show a suggestion on the map by updating marker and recentering using MapViewportPolicyController.
 */
import { MapViewportPolicyController } from "@/controllers/MapViewportPolicyController";

export class SuggestionPreviewController {
  constructor(mapController) {
    this.map = mapController;
    this.policy = new MapViewportPolicyController(mapController);
  }

  async show(suggestion) {
    if (!suggestion) return false;
    return await this.policy.focusSuggestion(suggestion);
  }
}


================================================================================
### PLIK: controllers\SuggestionSelectionController.js
================================================================================

/**
 * ARCHITECTURE: SuggestionSelectionController selects and applies suggestions deterministically.
 * It follows the manifesto by keeping scoring and application separate from UI and transport.
 * Responsibilities:
 * - Pick the best suggestion; apply a chosen index to the editor facade for a given side.
 */
export class SuggestionSelectionController {
  best(baseInput, suggestions) {
    const list = Array.isArray(suggestions) ? suggestions : [];
    if (!list.length) return null;
    let bestIndex = 0;
    let bestScore = -Infinity;
    for (let i = 0; i < list.length; i++) {
      const s = list[i] || {};
      const score = this._score(baseInput, s);
      if (score > bestScore) {
        bestScore = score;
        bestIndex = i;
      }
    }
    return { index: bestIndex, suggestion: list[bestIndex] };
  }

  accept(editorFacade, side, sel) {
    if (!sel || typeof sel.index !== "number") return false;
    if (side === "pickup") {
      const r = editorFacade.acceptPickupSuggestion(sel.index);
      return !!r?.ok;
    }
    if (side === "delivery") {
      const r = editorFacade.acceptDeliverySuggestion(sel.index);
      return !!r?.ok;
    }
    return false;
  }

  _score(base, sug) {
    let score = 0;
    if (typeof sug.matchScore === "number") score += sug.matchScore * 100;
    if (this._eq(base?.city, sug?.city)) score += 5;
    if (this._eq(base?.postalCode, sug?.postalCode)) score += 10;
    if (this._eq(base?.street, sug?.street)) score += 3;
    return score;
  }

  _eq(a, b) {
    return (a || "").toString().trim().toLowerCase() === (b || "").toString().trim().toLowerCase();
  }
}


================================================================================
### PLIK: controllers\TesSuggestionController.js
================================================================================

/**
 * ARCHITECTURE: TesSuggestionController starts TES suggest/search operations and collects results via poller.
 * It follows the manifesto by separating TES IO from UI and merging outputs through a stable contract.
 * Responsibilities:
 * - Trigger suggest-on-demand or search-by-name; poll until done; return normalized suggestions.
 * - Delegate normalization/merging to provided collaborators without leaking TES DTOs to callers.
 */
import apiClient from "@/services/api";
import { TesOperationPoller } from "@/services/TesOperationPoller";
import { SuggestionNormalizer } from "@/services/SuggestionNormalizer";
import { AddressSuggestionMerger } from "@/services/AddressSuggestionMerger";
import { AddressSuggestionRanker } from "@/services/AddressSuggestionRanker";

export class TesSuggestionController {
  constructor(poller = new TesOperationPoller(), normalizer = new SuggestionNormalizer(), merger = new AddressSuggestionMerger(), ranker = new AddressSuggestionRanker()) {
    this.poller = poller;
    this.normalizer = normalizer;
    this.merger = merger;
    this.ranker = ranker;
  }

  async suggestOnDemand(addressDto, baseInputForRanking = null) {
    const start = await apiClient.post("/api/admin/address-verification/suggest-on-demand", addressDto);
    const cid = start?.data?.correlationId;
    if (!cid) throw new Error("TesSuggestionController: missing correlationId.");
    const done = await this.poller.waitFor(cid);
    if (done.status !== "COMPLETED") return [];
    const raw = done.result?.suggestions || [];
    const normalized = this.normalizer.normalizeBatch(raw, "TES");
    const merged = this.merger.merge(baseInputForRanking || addressDto, [normalized]);
    return this.ranker.rank(baseInputForRanking || addressDto, merged);
  }

  async searchByName(query, baseInputForRanking = null) {
    const start = await apiClient.post("/api/admin/address-verification/search-by-name", query, { headers: { "Content-Type": "text/plain" } });
    const cid = start?.data?.correlationId;
    if (!cid) throw new Error("TesSuggestionController: missing correlationId.");
    const done = await this.poller.waitFor(cid);
    if (done.status !== "COMPLETED") return [];
    const raw = done.result?.suggestions || [];
    const normalized = this.normalizer.normalizeBatch(raw, "TES");
    const merged = this.merger.merge(baseInputForRanking || {}, [normalized]);
    return this.ranker.rank(baseInputForRanking || {}, merged);
  }
}


================================================================================
### PLIK: controllers\TriageDashboardController.js
================================================================================

/**
 * ARCHITECTURE: TriageDashboardController orchestrates KPI tiles, batch/source lists, and error-type groupings.
 * It follows the manifesto by separating read-model orchestration from UI and router glue.
 * Responsibilities:
 * - Load KPIs, recent batches, and pending-by-error-type using AddressExceptionApi.
 * - Expose immutable snapshots for rendering.
 * - Integrate PollingService to keep the dashboard fresh without duplicating timers.
 */
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";
import { PollingService } from "@/services/PollingService";

export class TriageDashboardController {
  constructor(api = new AddressExceptionApi(), polling = new PollingService()) {
    this.api = api;
    this.polling = polling;
    this.loading = false;
    this.error = null;
    this.kpis = null;
    this.recentBatches = [];
    this.pendingByErrorType = [];
    this._pollHandles = [];
  }

  async loadAll() {
    this.loading = true;
    this.error = null;
    const [kpiRes, batchRes, typeRes] = await Promise.all([
      this.api.getTriageKpis(),
      this.api.getRecentBatches(),
      this.api.getPendingByErrorType(),
    ]);
    if (!kpiRes.ok) return this._fail(kpiRes.error);
    if (!batchRes.ok) return this._fail(batchRes.error);
    if (!typeRes.ok) return this._fail(typeRes.error);
    this.kpis = kpiRes.value;
    this.recentBatches = Array.isArray(batchRes.value) ? batchRes.value : [];
    this.pendingByErrorType = Array.isArray(typeRes.value) ? typeRes.value : [];
    this.loading = false;
    return Result.ok(this.snapshot());
  }

  startPolling(intervalMs = 10000) {
    this.stopPolling();
    const k = this.polling.start("kpis", intervalMs, async () => {
      const r = await this.api.getTriageKpis();
      if (r.ok) this.kpis = r.value;
    });
    const b = this.polling.start("batches", intervalMs, async () => {
      const r = await this.api.getRecentBatches();
      if (r.ok) this.recentBatches = Array.isArray(r.value) ? r.value : [];
    });
    const e = this.polling.start("errorsByType", intervalMs, async () => {
      const r = await this.api.getPendingByErrorType();
      if (r.ok) this.pendingByErrorType = Array.isArray(r.value) ? r.value : [];
    });
    this._pollHandles = [k, b, e];
    return this._pollHandles.slice();
  }

  stopPolling() {
    this.polling.stopAll();
    this._pollHandles = [];
  }

  snapshot() {
    return {
      loading: this.loading,
      error: this.error,
      kpis: this.kpis,
      recentBatches: this.recentBatches.slice(),
      pendingByErrorType: this.pendingByErrorType.slice(),
    };
  }

  _fail(err) {
    this.loading = false;
    this.error = err?.message || "Dashboard load failed.";
    return Result.fail(err);
  }
}


================================================================================
### PLIK: controllers\VerificationGuardController.js
================================================================================

/**
 * ARCHITECTURE: VerificationGuardController prevents unnecessary verification calls when input is incomplete.
 * It follows the manifesto by enforcing minimal field requirements before hitting providers.
 * Responsibilities:
 * - Check street, postal, and city presence; expose shouldVerify() with reason codes for UI hints.
 * - Reduce wasted quota and noise during live typing.
 */
export class VerificationGuardController {
  constructor() {
    this.required = ["street", "postalCode", "city"];
  }

  shouldVerify(input) {
    const missing = [];
    for (const f of this.required) {
      if (!input || !String(input[f] || "").trim()) missing.push(f);
    }
    if (missing.length) return { allow: false, reason: "MISSING_FIELDS", missing };
    return { allow: true, reason: "OK", missing: [] };
  }
}


================================================================================
### PLIK: controllers\VerificationPipelineController.js
================================================================================

/**
 * ARCHITECTURE: VerificationPipelineController composes timeout, merger, and ranking into a single step.
 * It follows the manifesto by hiding orchestration details behind a single run() method.
 * Responsibilities:
 * - Execute geocode + places + TES with budgets; merge and rank; return final suggestions list.
 */
import { VerificationTimeoutController } from "@/controllers/VerificationTimeoutController";
import { AddressSuggestionMerger } from "@/services/AddressSuggestionMerger";
import { AddressSuggestionRanker } from "@/services/AddressSuggestionRanker";

export class VerificationPipelineController {
  constructor(timeoutController, merger = new AddressSuggestionMerger(), ranker = new AddressSuggestionRanker()) {
    this.timeout = timeoutController;
    this.merger = merger;
    this.ranker = ranker;
  }

  async run(baseInput, ms = 1500) {
    const phased = await this.timeout.verifyWithin(baseInput, ms);
    const merged = this.merger.merge(baseInput, [phased.suggestions]);
    const ranked = this.ranker.rank(baseInput, merged);
    return { instant: phased.instant, suggestions: ranked, elapsed: phased.elapsed };
  }
}


================================================================================
### PLIK: controllers\VerificationTelemetryController.js
================================================================================

/**
 * ARCHITECTURE: VerificationTelemetryController (Stub) would be responsible for
 * emitting detailed, structured telemetry events specific to the address
 * verification lifecycle (e.g., timings, provider success/fail, user choices).
 * Composes the base TelemetryService.
 */
import { TelemetryService } from "@/services/TelemetryService"; // Assuming base service exists

export class VerificationTelemetryController {
    constructor(telemetryService = new TelemetryService()) {
        this.telemetry = telemetryService;
        this.currentCorrelation = null;
        this.startTime = 0;
    }

    /**
     * Starts a new verification telemetry trace.
     * @param {string} correlationId - A unique ID for this verification flow.
     * @returns {string} The correlation ID.
     */
    start(correlationId) {
        this.currentCorrelation = correlationId || `telemetry-${Date.now()}-${Math.random()}`;
        this.startTime = Date.now();
        this.telemetry.emit({
            category: "verification",
            name: "start",
            corr: this.currentCorrelation,
        });
        return this.currentCorrelation;
    }

    /**
     * Marks a specific milestone within the verification flow.
     * @param {string} name - Name of the milestone (e.g., "verify-start", "geocode-finish").
     * @param {object} data - Additional context data.
     */
    mark(name, data = {}) {
        this.telemetry.emit({
            category: "verification",
            name: name,
            data: {
                ...data,
                elapsedMs: Date.now() - this.startTime,
            },
            corr: this.currentCorrelation,
        });
    }

    /**
     * Finishes the verification telemetry trace with a final status.
     * @param {string} status - The final outcome (e.g., "ok", "save-failed", "invalid").
     * @param {object} data - Additional context data.
     */
    finish(status, data = {}) {
        this.telemetry.emit({
            category: "verification",
            name: "finish",
            data: {
                ...data,
                status,
                totalElapsedMs: Date.now() - this.startTime,
            },
            corr: this.currentCorrelation,
        });
        // Clear context for the next trace
        this.currentCorrelation = null;
        this.startTime = 0;
    }
}

================================================================================
### PLIK: controllers\VerificationTimeoutController.js
================================================================================

/**
 * ARCHITECTURE: VerificationTimeoutController applies latency budgets to geocode and suggestion steps.
 * It follows the manifesto by composing LatencyBudget with provider adapters to keep UI responsive.
 * Responsibilities:
 * - Run geocode and suggestions with independent timeouts; return partial results when needed.
 * - Provide verifyWithin() that yields {instant,suggestions,elapsed:{geo,suggest}}.
 */
import { LatencyBudget } from "@/services/LatencyBudget";

export class VerificationTimeoutController {
  constructor(geocodeController, placesAdapter, tesController, budget = new LatencyBudget()) {
    this.geocode = geocodeController;
    this.places = placesAdapter;
    this.tes = tesController;
    this.budget = budget;
  }

  async verifyWithin(baseInput, ms = 1200) {
    const geo = await this.budget.runWithTimeout(() => this.geocode.geocode(baseInput), ms, null);
    const places = await this.budget.runWithTimeout(
      () => (this.places ? this.places.suggest(this._freeText(baseInput), baseInput.country || "PL") : Promise.resolve([])),
      ms,
      []
    );
    const tes = await this.budget.runWithTimeout(() => this.tes.suggestOnDemand(baseInput, baseInput), ms * 2, []);
    return {
      instant: geo.value ? { latitude: geo.value.lat ?? null, longitude: geo.value.lon ?? null } : null,
      suggestions: ([]).concat(places.value || []).concat(tes.value || []),
      elapsed: { geocodeMs: geo.elapsedMs, placesMs: places.elapsedMs, tesMs: tes.elapsedMs },
    };
  }

  _freeText(a) {
    const line1 = a.houseNumber ? `${a.street} ${a.houseNumber}` : a.street || "";
    return `${line1}, ${a.postalCode || ""} ${a.city || ""}`.trim();
  }
}


================================================================================
### PLIK: controllers\WorklistExportController.js
================================================================================

/**
 * ARCHITECTURE: WorklistExportController generates CSV exports for selected/all rows from the worklist.
 * It follows the manifesto by isolating export formatting from views and transport concerns.
 * Responsibilities:
 * - exportSelected(items, ids): download CSV for selected IDs.
 * - exportAll(items): download CSV for all current rows.
 */
export class WorklistExportController {
  constructor() {
    this.headers = [
      "orderId",
      "customerName",
      "source",
      "errorType",
      "processingStatus",
      "updatedAt",
    ];
  }

  exportSelected(items, ids) {
    const set = new Set(Array.isArray(ids) ? ids : []);
    const rows = (Array.isArray(items) ? items : []).filter(r => set.has(r.orderId));
    if (!rows.length) return false;
    return this._download(rows, "worklist_selected.csv");
  }

  exportAll(items) {
    const rows = Array.isArray(items) ? items : [];
    if (!rows.length) return false;
    return this._download(rows, "worklist_all.csv");
  }

  _download(rows, filename) {
    const csv = this._toCsv(rows);
    const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.href = url;
    link.download = filename || "export.csv";
    link.style.display = "none";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    return true;
  }

  _toCsv(rows) {
    const head = this.headers.join(",");
    const lines = rows.map(r => this.headers.map(h => this._esc(r?.[h])).join(","));
    return [head, ...lines].join("\n");
  }

  _esc(v) {
    const s = (v == null ? "" : String(v));
    if (/[",\n]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
    return s;
  }
}


================================================================================
### PLIK: controllers\WorklistFacade.js
================================================================================

/**
 * ARCHITECTURE: WorklistFacade provides a simplified interface for initializing
 * and controlling the polling of the worklist, interacting with the Pinia store.
 * It's primarily used for bootstrapping and managing background updates.
 * Direct state access and most actions should be done via `useWorklistStore` in components.
 */
import { useWorklistStore } from "@/stores/worklistStore";
import { PollingService } from "@/services/PollingService";
import { Result } from "@/domain/Result";

export class WorklistFacade {
    constructor(polling = new PollingService()) {
        // Get the store instance - assumes Pinia is initialized.
        this._store = useWorklistStore();
        this.poll = polling;
        this._pollHandle = null;
    }

    /**
     * Initializes the store by loading the first page based on optional filters.
     * @param {object} filters - Initial filter settings.
     * @returns {Promise<Result<object, Error>>} Result with initial snapshot or error.
     */
    async initAndLoad(filters = {}) {
        // Apply initial filters directly via store action if needed
        if (Object.keys(filters).length > 0) {
            this._store.filter = this._store.filter.withPatch(filters);
            this._store.pagination.currentPage = 1;
        }
        const result = await this._store.loadPage();
        // Return snapshot or error based on the load result
        return result.ok ? Result.ok(this.snapshot()) : Result.fail(result.error);
    }

    /**
     * Starts polling the worklist store's loadPage action.
     * @param {number} intervalMs - Polling interval in milliseconds.
     * @returns {boolean} True if polling was started.
     */
    startPolling(intervalMs = 15000) {
        if (this._pollHandle) {
            this.stopPolling();
        }
        this._pollHandle = this.poll.start("worklist", intervalMs, async () => {
            // Poll by calling the store's action
            await this._store.loadPage();
        });
        console.log(`[WorklistFacade] Started polling worklist every ${intervalMs}ms.`);
        return true;
    }

    /**
     * Stops the worklist polling loop.
     * @returns {boolean} True if polling was stopped.
     */
    stopPolling() {
        if (this._pollHandle) {
            this.poll.stop("worklist");
            this._pollHandle = null;
            console.log("[WorklistFacade] Stopped polling worklist.");
            return true;
        }
        return false;
    }

    /**
     * Provides a snapshot of the current worklist state from the Pinia store.
     * Primarily for non-Vue contexts; components should use the store directly.
     * @returns {object} Snapshot of store state.
     */
    snapshot() {
        // Create a snapshot directly from store state
        return {
            filter: { ...this._store.filter },
            items: [...this._store.items],
            pagination: { ...this._store.pagination },
            loading: this._store.loading,
            error: this._store.error,
            selection: [...this._store.selection],
        };
    }

    // Facade actions delegate directly to the store actions for convenience
    // Consumers can also call store actions directly via useWorklistStore().

    /** Apply filter patch and reload */
    async applyFilterPatch(patch) {
        return await this._store.applyFilterPatch(patch);
    }
    /** Reset filters and reload */
    async resetFilter() {
        return await this._store.resetFilter();
    }
    /** Go to a specific page */
    async goToPage(pageNumber) {
        return await this._store.goToPage(pageNumber);
    }
    /** Change items per page */
    async changePageSize(size) {
        return await this._store.changePageSize(size);
    }
    /** Toggle item selection */
    toggleSelection(orderId) {
        this._store.toggleSelection(orderId);
    }
    /** Clear selection */
    clearSelection() {
        this._store.clearSelection();
    }
    /** Get selected IDs */
    getSelection() {
        // Return a copy to prevent mutation outside store
        return [...this._store.selection];
    }
}

================================================================================
### PLIK: controllers\WorklistKpiController.js
================================================================================

/**
 * ARCHITECTURE: WorklistKpiController computes KPIs from the current worklist dataset.
 * It follows the manifesto by isolating KPI math from views and data transport.
 * Responsibilities:
 * - Compute pending review count, automated clearance percent, and average resolution minutes.
 * - Return a KpiViewModel ready to render in the dashboard.
 */
import { KpiViewModel } from "@/viewmodels/KpiViewModel";

export class WorklistKpiController {
  compute(items) {
    const arr = Array.isArray(items) ? items : [];

    const total = arr.length;
    const pending = arr.filter(x => (x?.processingStatus || "").toUpperCase() === "ADDRESS_NEEDS_REVIEW").length;
    const autoCleared = arr.filter(x => (x?.processingStatus || "").toUpperCase() === "ADDRESS_VALIDATED").length;

    const clearancePercent = total > 0 ? (autoCleared / total) * 100 : 0;

    const minutes = [];
    for (const r of arr) {
      const created = r?.createdAt ? new Date(r.createdAt).getTime() : null;
      const updated = r?.updatedAt ? new Date(r.updatedAt).getTime() : null;
      if (created && updated && updated >= created) {
        const diffMin = (updated - created) / 60000;
        if (Number.isFinite(diffMin)) minutes.push(diffMin);
      }
    }
    const avgMinutes = minutes.length ? minutes.reduce((a, b) => a + b, 0) / minutes.length : 0;

    return new KpiViewModel({
      pending,
      clearancePercent,
      avgMinutes,
    });
  }
}


================================================================================
### PLIK: controllers\WorklistSelectionController.js
================================================================================

/**
 * ARCHITECTURE: WorklistSelectionController manages single, multi, and range selections in the grid.
 * It follows the manifesto by isolating selection math from visual components.
 * Responsibilities:
 * - Toggle, select range with anchors, and expose a stable array of selected IDs.
 */
export class WorklistSelectionController {
  constructor() {
    this._selected = new Set();
    this._lastAnchorIndex = null;
  }

  toggle(id, index) {
    if (this._selected.has(id)) this._selected.delete(id);
    else this._selected.add(id);
    this._lastAnchorIndex = typeof index === "number" ? index : this._lastAnchorIndex;
    return this.ids();
  }

  set(ids) {
    this._selected = new Set(Array.isArray(ids) ? ids : []);
    return this.ids();
  }

  clear() {
    this._selected.clear();
    this._lastAnchorIndex = null;
    return [];
  }

  range(allIds, toIndex) {
    if (!Array.isArray(allIds) || typeof this._lastAnchorIndex !== "number" || typeof toIndex !== "number") return this.ids();
    const [a, b] = [this._lastAnchorIndex, toIndex].sort((x, y) => x - y);
    for (let i = a; i <= b; i++) this._selected.add(allIds[i]);
    return this.ids();
  }

  ids() {
    return Array.from(this._selected.values());
  }
}


================================================================================
### PLIK: debug\StartupProbe.js
================================================================================

/**
 * ARCHITECTURE: StartupProbe emits deterministic breadcrumbs during app boot and first render.
 * It follows the manifesto by isolating debug side effects from core logic.
 * Responsibilities:
 * - Log lifecycle milestones; stamp <html data-app-boot="..."> for visual confirmation.
 */
export class StartupProbe {
    constructor() {
        this.marks = [];
    }

    mark(label) {
        const ts = new Date().toISOString();
        const entry = `${ts} :: ${label}`;
        this.marks.push(entry);
        if (typeof console !== "undefined" && console.log) console.log("[startup]", entry);
        try {
            const html = document.documentElement;
            html.setAttribute("data-app-boot", label);
        } catch (_) { /* ignore */ }
        return entry;
    }

    dump() {
        if (typeof console !== "undefined" && console.table) console.table(this.marks.map((m, i) => ({ i, m })));
        return this.marks.slice();
    }
}

================================================================================
### PLIK: domain\BulkEditPlan.js
================================================================================

/**
 * ARCHITEKTURA: Deklaratywna definicja operacji masowej korekty adresów z podglądem i zastosowaniem.
 * Zaprojektowana do walidacji po stronie serwera oraz ponownej weryfikacji partii.
 */
export class BulkEditPlan {
  constructor(orderIds, field, mode, findPattern, replaceWith) {
    this.orderIds = Array.isArray(orderIds) ? orderIds : [];
    this.field = field;
    this.mode = mode;
    this.findPattern = findPattern;
    this.replaceWith = replaceWith;
  }

  static findReplace(orderIds, field, findPattern, replaceWith) {
    return new BulkEditPlan(orderIds, field, "FIND_REPLACE", findPattern, replaceWith);
  }

  static append(orderIds, field, suffix) {
    return new BulkEditPlan(orderIds, field, "APPEND", null, suffix);
  }

  static prepend(orderIds, field, prefix) {
    return new BulkEditPlan(orderIds, field, "PREPEND", null, prefix);
  }
}


================================================================================
### PLIK: domain\Result.js
================================================================================

/**
 * ARCHITEKTURA: Uniwersalny nośnik wyniku operacji (sukces/porażka) bez nulli i wyjątków sterujących przepływem.
 * Zapewnia spójny kontrakt dla wywołań usług oraz ułatwia kompozycję wyników.
 */
export class Result {
  constructor(ok, value, error) {
    this.ok = ok;
    this._value = value;
    this._error = error;
  }

  static ok(value) {
    return new Result(true, value, undefined);
  }

  static fail(error) {
    return new Result(false, undefined, error instanceof Error ? error : new Error(String(error)));
  }

  get value() {
    if (!this.ok) throw new Error("Attempt to get value from failed Result.");
    return this._value;
    }

  get error() {
    if (this.ok) throw new Error("Attempt to get error from successful Result.");
    return this._error;
  }

  map(fn) {
    return this.ok ? Result.ok(fn(this._value)) : Result.fail(this._error);
  }

  asyncMap(fn) {
    if (!this.ok) return Promise.resolve(Result.fail(this._error));
    return fn(this._value).then(Result.ok).catch(err => Result.fail(err));
  }
}


================================================================================
### PLIK: domain\WorkbenchModels.js
================================================================================

/**
 * ARCHITECTURE: WorkbenchModels define immutable value objects used by the editor and worklist.
 * It follows the manifesto by centralizing simple data models away from transport and views.
 * Responsibilities:
 * - Provide Address with factory helpers to ensure safe defaults and cloning.
 * - Offer toPlain() for persistence mapping without leaking internal structure.
 */
export class Address {
  constructor({ street = "", houseNumber = null, postalCode = "", city = "", country = "PL", latitude = null, longitude = null } = {}) {
    this.street = street || "";
    this.houseNumber = houseNumber || null;
    this.postalCode = postalCode || "";
    this.city = city || "";
    this.country = country || "PL";
    this.latitude = typeof latitude === "number" ? latitude : null;
    this.longitude = typeof longitude === "number" ? longitude : null;
  }

  static from(obj) {
    if (!obj || typeof obj !== "object") return new Address();
    return new Address({
      street: obj.street,
      houseNumber: obj.houseNumber,
      postalCode: obj.postalCode,
      city: obj.city,
      country: obj.country,
      latitude: obj.latitude,
      longitude: obj.longitude,
    });
  }

  clone() {
    return new Address(this);
  }

  toPlain() {
    return {
      street: this.street,
      houseNumber: this.houseNumber,
      postalCode: this.postalCode,
      city: this.city,
      country: this.country,
      latitude: this.latitude,
      longitude: this.longitude,
    };
  }
}


================================================================================
### PLIK: domain\WorklistFilter.js
================================================================================

/**
 * ARCHITEKTURA: Niemutowalny obiekt zapytania do listy roboczej. Odpowiada za serializację filtrów do parametrów URL.
 * Separuje szczegóły filtrowania od komponentów UI oraz usług sieciowych.
 */
export class WorklistFilter {
  constructor(search = null, source = null, errorTypes = [], minConfidence = null, maxConfidence = null, page = 1, pageSize = 50) {
    this.search = search;
    this.source = source;
    this.errorTypes = Array.isArray(errorTypes) ? errorTypes : [];
    this.minConfidence = minConfidence;
    this.maxConfidence = maxConfidence;
    this.page = page;
    this.pageSize = pageSize;
  }

  withPatch(patch) {
    return new WorklistFilter(
      patch.search ?? this.search,
      patch.source ?? this.source,
      patch.errorTypes ?? this.errorTypes.slice(),
      patch.minConfidence ?? this.minConfidence,
      patch.maxConfidence ?? this.maxConfidence,
      patch.page ?? this.page,
      patch.pageSize ?? this.pageSize
    );
  }

  toQueryRecord() {
    const q = {};
    if (this.search) q.q = this.search;
    if (this.source) q.source = this.source;
    if (this.errorTypes.length) q.errorTypes = this.errorTypes.join(",");
    if (this.minConfidence != null) q.minConfidence = String(this.minConfidence);
    if (this.maxConfidence != null) q.maxConfidence = String(this.maxConfidence);
    q.page = String(this.page);
    q.pageSize = String(this.pageSize);
    return q;
  }
}


================================================================================
### PLIK: router\AuthGuard.js
================================================================================

/**
 * ARCHITECTURE: AuthGuard protects routes by requiring an authenticated session.
 * It follows the manifesto by isolating navigation policy and tolerating a minimal localStorage token.
 * Responsibilities:
 * - Allow /login always.
 * - Accept session from AuthSessionService; if absent, fall back to localStorage.accessToken and bind header.
 */
import { AuthSessionService } from "@/services/AuthSessionService";
import { ApiAuthBinder } from "@/services/ApiAuthBinder";

export class AuthGuard {
    constructor(session = new AuthSessionService(), binder = new ApiAuthBinder()) {
        this.session = session;
        this.binder = binder;
    }

    async canEnter(to) {
        const path = String(to?.path || "");
        if (path.startsWith("/login")) return true;

        // Primary: full session saved by AuthController
        if (this.session.isAuthenticated()) {
            const tok = this.session.getAccessToken();
            const typ = this.session.getTokenType();
            if (tok) this.binder.bind(tok, typ);
            return true;
        }

        // Tolerant fallback: plain token in localStorage (e.g., from earlier minimal form)
        if (typeof window !== "undefined") {
            const raw = window.localStorage?.getItem("accessToken");
            if (raw && raw.length > 10) {
                this.binder.bind(raw, "Bearer");
                return true;
            }
        }

        throw new Error("AuthGuard: unauthenticated.");
    }
}


================================================================================
### PLIK: router\EditorRouteGuard.js
================================================================================

/**
 * ARCHITECTURE: EditorRouteGuard ensures prerequisites are met before entering the Correction Editor route.
 * It follows the manifesto by isolating cross-cutting navigation checks behind a simple guard class.
 * Responsibilities:
 * - Verify that TES provider is GOOGLE and that Google Maps JS can be loaded.
 * - Optionally validate presence of an orderId param to prevent broken editor sessions.
 */
import { ProviderGuard } from "@/controllers/ProviderGuard";
import { GoogleMapsScriptLoader } from "@/adapters/GoogleMapsScriptLoader";

export class EditorRouteGuard {
  constructor(googleApiKey) {
    this.googleApiKey = googleApiKey;
    this._provider = new ProviderGuard();
    this._loader = new GoogleMapsScriptLoader();
  }

  async canEnter(to) {
    const orderId = to?.params?.id || to?.query?.orderId || null;
    if (!orderId) throw new Error("EditorRouteGuard: orderId is required.");
    await this._provider.ensureGoogle();
    await this._loader.load(this.googleApiKey, ["places"]);
    return true;
  }
}


================================================================================
### PLIK: router\index.js
================================================================================

/**
 * ARCHITECTURE: router/index defines minimal, safe routes so the shell always renders something.
 * It follows the manifesto by isolating guards and keeping route table deterministic.
 * Responsibilities:
 * - Provide /login, /worklist, /dashboard, /editor/:id; redirect / → /login to make the test obvious.
 */
import { createRouter, createWebHistory } from "vue-router";
import LoginView from "@/views/LoginView.vue";
import WorklistView from "@/views/WorklistView.vue";
import TriageDashboard from "@/views/TriageDashboard.vue";
import CorrectionEditorView from "@/views/CorrectionEditorView.vue";
import { AuthGuard } from "@/router/AuthGuard";
import { EditorRouteGuard } from "@/router/EditorRouteGuard";

export function createRouterWithKey(googleApiKey) {
  const editorGuard = new EditorRouteGuard(googleApiKey);
  const authGuard = new AuthGuard();

  const routes = [
    { path: "/", redirect: "/login" },
    { path: "/login", name: "login", component: LoginView },
    { path: "/worklist", name: "worklist", component: WorklistView },
    { path: "/dashboard", name: "dashboard", component: TriageDashboard },
    {
      path: "/editor/:id",
      name: "editor",
      component: CorrectionEditorView,
      beforeEnter: async (to, _from, next) => {
        try { await editorGuard.canEnter(to); next(); } catch { next("/worklist"); }
      },
    },
    { path: "/:pathMatch(.*)*", redirect: "/login" },
  ];

  const router = createRouter({ history: createWebHistory(), routes });

  router.beforeEach(async (to, _from, next) => {
    try { await authGuard.canEnter(to); next(); }
    catch { next({ path: "/login", query: { r: to.fullPath } }); }
  });

  return router;
}

================================================================================
### PLIK: services\AddressAuditTrailService.js
================================================================================

/**
 * ARCHITECTURE: AddressAuditTrailService maintains an in-memory audit stream for user actions.
 * It follows the manifesto by isolating audit appends and allowing later persistence without UI impact.
 * Responsibilities:
 * - Append entries and read them by orderId; provide a clear method for testability.
 */
export class AddressAuditTrailService {
  constructor() {
    this._byOrder = new Map();
  }

  append(entry) {
    const id = entry?.orderId || "unknown";
    const list = this._byOrder.get(id) || [];
    list.push({ ...entry, at: new Date().toISOString() });
    this._byOrder.set(id, list);
    return true;
  }

  list(orderId) {
    return (this._byOrder.get(orderId) || []).slice();
  }

  clear(orderId) {
    if (!orderId) return false;
    this._byOrder.delete(orderId);
    return true;
  }
}


================================================================================
### PLIK: services\AddressClipboardService.js
================================================================================

/**
 * ARCHITECTURE: AddressClipboardService copies formatted addresses to clipboard for quick customer contact.
 * It follows the manifesto by isolating browser clipboard usage and formatting concerns.
 * Responsibilities:
 * - Build single-line and multi-line strings and write to navigator.clipboard if available.
 * - Provide deterministic return values indicating success or failure without throwing.
 */
export class AddressClipboardService {
  constructor() {
    this.available = typeof navigator !== "undefined" && !!navigator.clipboard;
  }

  async copyOneLine(a) {
    const str = this._oneLine(a);
    return this._copy(str);
  }

  async copyTwoLines(a) {
    const str = this._twoLines(a);
    return this._copy(str);
  }

  async _copy(str) {
    if (!this.available) return { ok: false, reason: "Clipboard unavailable" };
    try {
      await navigator.clipboard.writeText(str);
      return { ok: true };
    } catch (_) {
      return { ok: false, reason: "Clipboard write failed" };
    }
  }

  _oneLine(a) {
    const p1 = [a?.street, a?.houseNumber].filter(Boolean).join(" ");
    const p2 = [a?.postalCode, a?.city].filter(Boolean).join(" ");
    const p3 = a?.country || "PL";
    return [p1, p2, p3].filter(Boolean).join(", ");
  }

  _twoLines(a) {
    const p1 = [a?.street, a?.houseNumber].filter(Boolean).join(" ");
    const p2 = [a?.postalCode, a?.city, a?.country || "PL"].filter(Boolean).join(", ");
    return `${p1}\n${p2}`;
  }
}


================================================================================
### PLIK: services\AddressCorrectionService.js
================================================================================

/**
 * ARCHITECTURE: AddressCorrectionService persists address fixes to the backend and records an audit entry.
 * It follows the manifesto by isolating persistence and audit concerns behind one explicit contract.
 * Responsibilities:
 * - Save corrections via AddressExceptionApi with explicit resolution mode.
 * - Append audit entries using AddressAuditTrailService and provide a deterministic Result object.
 */
import { Result } from "@/domain/Result";
import { AddressAuditTrailService } from "@/services/AddressAuditTrailService";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

export class AddressCorrectionService {
  constructor(api = new AddressExceptionApi(), audit = new AddressAuditTrailService()) {
    this.api = api;
    this.audit = audit;
  }

  async save({ orderId, side, before, after, resolution }) {
    const res = await this.api.saveCorrection({
      orderId,
      side,
      correctedPickup: side === "pickup" || side === "both" ? after?.pickup || null : null,
      correctedDelivery: side === "delivery" || side === "both" ? after?.delivery || null : null,
      resolution: resolution || "MANUAL_EDIT",
    });
    if (!res.ok) return Result.fail(res.error);
    this.audit.append({
      orderId,
      side,
      action: resolution || "MANUAL_EDIT",
      before,
      after,
      diff: null,
    });
    return Result.ok(res.value);
  }
}


================================================================================
### PLIK: services\AddressEqualityService.js
================================================================================

/**
 * ARCHITECTURE: AddressEqualityService computes structural equality and a stable hash for Address DTOs.
 * It follows the manifesto by providing deterministic comparisons without UI or transport concerns.
 * Responsibilities:
 * - Compare two addresses field-by-field with normalization of whitespace and case.
 * - Produce a hash string for use in caches, audit, or deduplication logic.
 */
export class AddressEqualityService {
  constructor() {
    this._fields = ["street", "houseNumber", "postalCode", "city", "country", "latitude", "longitude"];
  }

  equals(a, b) {
    if (!a || !b) return false;
    for (const f of this._fields) {
      if (!this._eq(a[f], b[f])) return false;
    }
    return true;
  }

  hash(a) {
    const s = (x) => (x == null ? "" : String(x).trim().toLowerCase());
    const n = (x) => (typeof x === "number" ? x.toFixed(6) : "");
    const parts = [
      s(a?.street),
      s(a?.houseNumber),
      s(a?.postalCode),
      s(a?.city),
      s(a?.country),
      n(a?.latitude),
      n(a?.longitude),
    ];
    return this._simpleHash(parts.join("|"));
  }

  _eq(a, b) {
    if (typeof a === "number" || typeof b === "number") {
      return Number(a || 0).toFixed(6) === Number(b || 0).toFixed(6);
    }
    return (a || "").toString().trim().toLowerCase() === (b || "").toString().trim().toLowerCase();
  }

  _simpleHash(str) {
    let h = 0;
    for (let i = 0; i < str.length; i++) {
      h = (h << 5) - h + str.charCodeAt(i);
      h |= 0;
    }
    return `h${(h >>> 0).toString(16)}`;
  }
}


================================================================================
### PLIK: services\AddressExceptionApi.js
================================================================================

// src/services/AddressExceptionApi.js
/**
 * ARCHITECTURE: AddressExceptionApi encapsulates backend endpoints for worklist and editor operations.
 * It follows the manifesto by isolating transport, shaping payloads, and returning Result objects.
 * REFACTORED: Updated getOrderDetail to correctly map the backend OrderDetailDTO structure
 * (assuming fields like id, barcode, pickupAddress, deliveryAddress)
 * to the structure expected by the frontend CorrectionEditorController.
 */
import api from "@/services/api";
import { Result } from "@/domain/Result";
import { Address } from "@/domain/WorkbenchModels"; // Import frontend Address model

export class AddressExceptionApi {
    constructor() {
        // Base paths handled directly in endpoint calls
    }

    /**
     * Fetches a paginated list of orders needing review.
     * Maps backend Page<OrderSummaryDTO> to { items, total }.
     * @param {object} filter - Contains filter criteria (page, size, status, barcode, etc.)
     * @returns {Promise<Result<{items: Array, total: number}, Error>>}
     */
    async getWorklist(filter = { page: 1, size: 25, status: 'ADDRESS_NEEDS_REVIEW' }) {
        try {
            const q = new URLSearchParams();
            q.set("page", String(filter.page > 0 ? filter.page - 1 : 0)); // Spring Pageable is 0-indexed
            q.set("size", String(filter.size || 25));
            q.set("status", filter.status || 'ADDRESS_NEEDS_REVIEW'); // Default or specified status
            if (filter.barcode) q.set("barcode", filter.barcode);
            // Add other filters/sorting as needed based on backend capabilities
            // q.set("sort", `${filter.sortBy || 'createdAt'},${filter.sortDir || 'DESC'}`);

            const res = await api.get(`/api/orders?${q.toString()}`);
            const data = res.data || {};
            // Map Spring Page<OrderSummaryDTO> response
            return Result.ok({
                items: Array.isArray(data.content) ? data.content : [],
                total: Number(data.totalElements || 0),
            });
        } catch (e) {
            console.error("Error fetching worklist:", e);
            const errorMessage = e.response?.data?.error || e.message || "Failed to fetch worklist.";
            return Result.fail(new Error(errorMessage));
        }
    }

    /**
     * Fetches the full details of a specific order by its UUID.
     * Assumes backend now returns OrderDetailDTO. Maps this DTO to the structure
     * expected by CorrectionEditorController (using frontend Address model).
     * @param {string} orderId - The UUID of the order.
     * @returns {Promise<Result<object, Error>>} Frontend OrderDetail structure.
     */
    async getOrderDetail(orderId) {
        if (!orderId) {
            return Result.fail(new Error("Order ID is required."));
        }
        try {
            const res = await api.get(`/api/orders/${encodeURIComponent(orderId)}`);
            const backendDto = res.data; // Assuming this is OrderDetailDTO

            if (!backendDto || !backendDto.id) {
                return Result.fail(new Error(`Order details not found or invalid response for ID: ${orderId}`));
            }

            // Map backend OrderDetailDTO to the frontend structure expected by CorrectionEditorController
            const frontendDetail = {
                orderId: backendDto.id, // Use 'id' from response
                barcode: backendDto.barcode,
                requestId: backendDto.requestId,
                customerId: backendDto.customerId,
                processingStatus: backendDto.processingStatus,
                createdAt: backendDto.createdAt,
                updatedAt: backendDto.updatedAt,
                // Map nested backend AddressDto to frontend Address model
                originalPickup: backendDto.pickupAddress ? Address.from(backendDto.pickupAddress) : new Address(),
                originalDelivery: backendDto.deliveryAddress ? Address.from(backendDto.deliveryAddress) : new Address(),
                // Assume suggestions are still fetched separately or now included in DTO
                suggestedPickup: Array.isArray(backendDto.suggestedPickup) ? backendDto.suggestedPickup : [],
                suggestedDelivery: Array.isArray(backendDto.suggestedDelivery) ? backendDto.suggestedDelivery : [],
                relatedError: backendDto.relatedError || null // Pass through if present
            };
            return Result.ok(frontendDetail);
        } catch (e) {
            console.error(`Error fetching order detail for ${orderId}:`, e);
            const status = e.response?.status;
            const errorMessage = e.response?.data?.error || e.message || `Failed to fetch order details for ID: ${orderId}.`;
            if (status === 404) {
                return Result.fail(new Error(`Order not found: ${orderId}`));
            }
            return Result.fail(new Error(errorMessage));
        }
    }

    /**
     * Saves the corrected address details back to the backend.
     * @param {object} body - The CorrectionRequest payload (orderId, side, correctedPickup?, correctedDelivery?, resolution).
     * @param {string|null} idempotencyToken - Optional token for preventing duplicate saves.
     * @returns {Promise<Result<any, Error>>} Backend response data or true on success.
     */
    async saveCorrection(body, idempotencyToken = null) {
        try {
            const orderId = body?.orderId;
            if (!orderId) {
                return Result.fail(new Error("Missing orderId in saveCorrection payload"));
            }
            // Ensure address objects are plain objects if needed by backend
            const payload = {
                ...body,
                correctedPickup: body.correctedPickup?.toPlain ? body.correctedPickup.toPlain() : body.correctedPickup,
                correctedDelivery: body.correctedDelivery?.toPlain ? body.correctedDelivery.toPlain() : body.correctedDelivery
            };

            const headers = idempotencyToken ? { "Idempotency-Key": idempotencyToken } : {};
            const res = await api.post(`/api/orders/${encodeURIComponent(orderId)}/corrections`, payload, { headers });
            return Result.ok(res.data || true); // Return response data or true
        } catch (e) {
            console.error(`Error saving correction for order ${body?.orderId}:`, e);
            const errorMessage = e.response?.data?.error || e.message || "Failed to save correction.";
            return Result.fail(new Error(errorMessage));
        }
    }

    // --- Other methods (e.g., bulk, getNextOrderId, kpis) remain as placeholders or need specific backend confirmation ---
    // async refreshSuggestions(orderId, side) { /* ... likely handled by error store/service ... */ }
    // async bulkPreview(plan) { /* ... needs backend endpoint confirmation ... */ }
    // async bulkApply(plan) { /* ... needs backend endpoint confirmation ... */ }
    // async getNextOrderId(currentId, filter) { /* ... likely handled by queue service + getWorklist ... */ }
    // async getTriageKpis() { /* ... needs backend endpoint confirmation ... */ }
    // async getRecentBatches() { /* ... needs backend endpoint confirmation ... */ }
    // async getPendingByErrorType() { /* ... needs backend endpoint confirmation ... */ }
}

================================================================================
### PLIK: services\AddressFieldGuard.js
================================================================================

/**
 * ARCHITECTURE: AddressFieldGuard enforces form field enable/disable rules per country and workflow state.
 * It follows the manifesto by isolating editability policies from components and controllers.
 * Responsibilities:
 * - Decide if a field is editable based on country rules, verification status, and role flags.
 * - Provide a stateless canEdit(field, context) API returning a boolean.
 */
export class AddressFieldGuard {
  constructor() {
    this._rules = new Map();
    this._rules.set("PL", {
      postalCode: () => true,
      street: () => true,
      houseNumber: () => true,
      city: () => true,
      country: () => false,
    });
  }

  register(country, rules) {
    this._rules.set((country || "PL").toUpperCase(), rules);
    return true;
  }

  canEdit(field, context) {
    const c = (context?.country || "PL").toUpperCase();
    const rules = this._rules.get(c) || this._rules.get("PL");
    if (typeof rules[field] === "function") return !!rules[field](context);
    return true;
  }
}


================================================================================
### PLIK: services\AddressFormatterService.js
================================================================================

/**
 * ARCHITECTURE: AddressFormatterService produces consistent, locale-aware display strings for addresses.
 * It follows the manifesto by separating presentation formatting from data models and controllers.
 * Responsibilities:
 * - Format single-line and multi-line address strings with optional fallbacks.
 * - Handle missing fields gracefully and avoid mutating inputs.
 */
export class AddressFormatterService {
  constructor(defaultCountry = "PL") {
    this.defaultCountry = defaultCountry;
  }

  oneLine(a) {
    if (!a) return "";
    const parts = [];
    const line1 = [a.street, a.houseNumber].filter(Boolean).join(" ").trim();
    if (line1) parts.push(line1);
    const line2 = [a.postalCode, a.city].filter(Boolean).join(" ").trim();
    if (line2) parts.push(line2);
    const c = a.country || this.defaultCountry;
    if (c) parts.push(c);
    return parts.join(", ");
  }

  twoLines(a) {
    if (!a) return { line1: "", line2: "" };
    const line1 = [a.street, a.houseNumber].filter(Boolean).join(" ").trim();
    const line2 = [[a.postalCode, a.city].filter(Boolean).join(" ").trim(), a.country || this.defaultCountry].filter(Boolean).join(", ");
    return { line1, line2 };
  }
}


================================================================================
### PLIK: services\AddressGeocodeCache.js
================================================================================


================================================================================
### PLIK: services\AddressHistoryService.js
================================================================================

/**
 * ARCHITECTURE: AddressHistoryService records a per-order timeline of edits and applied suggestions.
 * It follows the manifesto by providing an append-only log consumable by the audit or session history.
 * Responsibilities:
 * - Append events with before/after snapshots and provider info; read back per orderId.
 */
export class AddressHistoryService {
  constructor() {
    this._byOrder = new Map();
  }

  append(orderId, payload) {
    if (!orderId) return false;
    const list = this._byOrder.get(orderId) || [];
    list.push({
      at: new Date().toISOString(),
      type: payload?.type || "EDIT",
      side: payload?.side || "both",
      provider: payload?.provider || null,
      before: payload?.before || null,
      after: payload?.after || null,
    });
    this._byOrder.set(orderId, list);
    return true;
  }

  list(orderId) {
    return (this._byOrder.get(orderId) || []).slice();
  }

  clear(orderId) {
    if (!orderId) return false;
    this._byOrder.delete(orderId);
    return true;
  }
}


================================================================================
### PLIK: services\AddressInputMaskService.js
================================================================================

/**
 * ARCHITECTURE: AddressInputMaskService (Stub) would provide input masking
 * logic for address fields, specific to country rules (e.g., postal codes).
 * This is a placeholder returning the value as-is.
 */
export class AddressInputMaskService {
    constructor(countryCode = "PL") {
        this.countryCode = countryCode.toUpperCase();
    }

    /**
     * Masks a postal code value (stub).
     * @param {string} value - The input value.
     * @param {string} country - The country context.
     * @returns {string} The masked/formatted value.
     */
    maskPostal(value, country) {
        // TODO: Implement actual postal code masking (e.g., PL: '00123' -> '00-123')
        return value;
    }

    /**
     * Masks a street value (stub).
     * @param {string} value - The input value.
     * @returns {string} The masked/formatted value.
     */
    maskStreet(value) {
        // TODO: Implement street name masking/formatting (e.g., capitalization)
        return value;
    }

    /**
     * Masks a city value (stub).
     * @param {string} value - The input value.
     * @returns {string} The masked/formatted value.
     */
    maskCity(value) {
        // TODO: Implement city name masking/formatting
        return value;
    }

    /**
     * Masks a house number value (stub).
     * @param {string} value - The input value.
     * @returns {string} The masked/formatted value.
     */
    maskHouseNo(value) {
        // TODO: Implement house number masking/formatting
        return value;
    }
}

================================================================================
### PLIK: services\AddressNormalizer.js
================================================================================

/**
 * ARCHITECTURE: AddressNormalizer sanitizes raw address input into a consistent DTO used by verification.
 * It follows the manifesto by providing pure, deterministic transformations without UI or transport coupling.
 * Responsibilities:
 * - Trim whitespace, stabilize casing, and normalize postal code for PL (e.g., "00123" → "00-123").
 * - Guarantee presence of all expected fields with safe defaults.
 */
export class AddressNormalizer {
  constructor(defaultCountry = "PL") {
    this.defaultCountry = defaultCountry.toUpperCase();
  }

  normalize(a) {
    const street = this._sp(a?.street);
    const houseNumber = this._hn(a?.houseNumber);
    const city = this._cap(this._sp(a?.city));
    const country = this._cc(a?.country);
    const postalCode = this._postal(a?.postalCode, country);
    const latitude = this._num(a?.latitude);
    const longitude = this._num(a?.longitude);
    return { street, houseNumber, postalCode, city, country, latitude, longitude };
  }

  _sp(v) {
    return (v || "").toString().replace(/\s+/g, " ").trim();
  }

  _hn(v) {
    const s = (v == null ? "" : String(v)).replace(/\s+/g, "").trim();
    return s.length ? s : null;
  }

  _cap(v) {
    if (!v) return "";
    return v.charAt(0).toUpperCase() + v.slice(1);
  }

  _cc(v) {
    const s = (v || this.defaultCountry).toString().trim().toUpperCase();
    return s || this.defaultCountry;
  }

  _postal(v, country) {
    const raw = (v || "").replace(/\s|-/g, "");
    if ((country || "").toUpperCase() === "PL") {
      if (raw.length < 5) return raw;
      return `${raw.slice(0, 2)}-${raw.slice(2, 5)}`;
    }
    return v || "";
  }

  _num(v) {
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  }
}


================================================================================
### PLIK: services\AddressPersistenceMapper.js
================================================================================

/**
 * ARCHITECTURE: AddressPersistenceMapper shapes editor state into backend save payloads.
 * It follows the manifesto by isolating transport DTO mapping away from controllers and views.
 * Responsibilities:
 * - Map orderId, side, before/after models and resolution into /corrections payload.
 */
export class AddressPersistenceMapper {
  toSavePayload(orderId, side, before, after, resolution) {
    const s = (side || "both").toLowerCase();
    const body = {
      orderId: orderId,
      side: s === "pickup" || s === "delivery" ? s : "both",
      resolution: resolution || "MANUAL_EDIT",
      correctedPickup: s === "delivery" ? null : (after?.pickup || after?.correctedPickup || after?.editedPickup || after || null),
      correctedDelivery: s === "pickup" ? null : (after?.delivery || after?.correctedDelivery || after?.editedDelivery || after || null),
      beforePickup: s === "delivery" ? null : (before?.pickup || before?.originalPickup || before || null),
      beforeDelivery: s === "pickup" ? null : (before?.delivery || before?.originalDelivery || before || null),
    };
    return body;
  }
}


================================================================================
### PLIK: services\AddressRulesService.js
================================================================================

/**
 * ARCHITECTURE: AddressRulesService centralizes country-specific rules for required fields and masks.
 * It follows the manifesto by separating rule data from controllers and adapters.
 * Responsibilities:
 * - Provide requiredFields(country) and postalRegex(country) for validation and hints.
 */
export class AddressRulesService {
  constructor() {
    this._req = new Map();
    this._req.set("PL", ["street", "postalCode", "city", "country"]);
    this._postal = new Map();
    this._postal.set("PL", /^(\d{2}-\d{3}|\d{5})$/);
  }

  requiredFields(country = "PL") {
    return this._req.get((country || "PL").toUpperCase()) || this._req.get("PL");
  }

  postalRegex(country = "PL") {
    return this._postal.get((country || "PL").toUpperCase()) || /.*/;
  }
}


================================================================================
### PLIK: services\AddressSuggestionMerger.js
================================================================================

/**
 * ARCHITECTURE: AddressSuggestionMerger combines suggestion lists from multiple sources
 * (e.g., client-side geocoding, Places API, TES backend) into a single list,
 * potentially removing duplicates based on address content equality. Adheres to SRP.
 * This is a basic stub implementation assuming simple concatenation.
 */
import { AddressEqualityService } from "@/services/AddressEqualityService"; // Assuming this exists

export class AddressSuggestionMerger {
    constructor(equalityService = new AddressEqualityService()) {
        this.eq = equalityService;
    }

    /**
     * Merges multiple lists of suggestions, attempting basic deduplication.
     * @param {object} baseInput - The original input address (used for context, not currently in stub).
     * @param {Array<Array<object>>} suggestionLists - An array of suggestion lists from different sources.
     * @returns {Array<object>} A single, merged list of suggestions.
     */
    merge(baseInput, suggestionLists) {
        const merged = [];
        const seenHashes = new Set();

        if (!Array.isArray(suggestionLists)) {
            return merged;
        }

        for (const list of suggestionLists) {
            if (!Array.isArray(list)) continue;

            for (const suggestion of list) {
                if (!suggestion) continue;

                // Simple deduplication based on normalized address hash (requires AddressEqualityService)
                const addressPart = {
                    street: suggestion.street,
                    houseNumber: suggestion.houseNumber,
                    postalCode: suggestion.postalCode,
                    city: suggestion.city,
                    country: suggestion.countryCode,
                    // Note: Lat/Lon usually excluded from equality hash for address matching
                };
                const hash = this.eq.hash(addressPart);

                if (!seenHashes.has(hash)) {
                    merged.push(suggestion);
                    seenHashes.add(hash);
                }
            }
        }
        // Further sorting/ranking is typically done by AddressSuggestionRanker
        return merged;
    }
}

================================================================================
### PLIK: services\AddressSuggestionRanker.js
================================================================================

/**
 * ARCHITECTURE: AddressSuggestionRanker orders suggestions by confidence and locality relevance.
 * It follows the manifesto by keeping ranking policy separate from UI and transport details.
 * Responsibilities:
 * - Sort by matchScore desc, then city/postal match with the base input, then provider priority.
 */
export class AddressSuggestionRanker {
  rank(baseInput, list) {
    const arr = Array.isArray(list) ? list.slice() : [];
    const prio = (p) => (p === "GOOGLE_CLIENT" ? 3 : p === "GOOGLE_PLACES" ? 2 : p === "TES" ? 1 : 0);
    const eq = (a, b) => (a || "").toString().trim().toLowerCase() === (b || "").toString().trim().toLowerCase();
    arr.sort((a, b) => {
      const sa = typeof a.matchScore === "number" ? a.matchScore : 0;
      const sb = typeof b.matchScore === "number" ? b.matchScore : 0;
      if (sb !== sa) return sb - sa;
      const ca = eq(a.city, baseInput?.city) ? 1 : 0;
      const cb = eq(b.city, baseInput?.city) ? 1 : 0;
      if (cb !== ca) return cb - ca;
      const pa = eq(a.postalCode, baseInput?.postalCode) ? 1 : 0;
      const pb = eq(b.postalCode, baseInput?.postalCode) ? 1 : 0;
      if (pb !== pa) return pb - pa;
      return prio(b.providerSource) - prio(a.providerSource);
    });
    return arr;
  }
}


================================================================================
### PLIK: services\api.js
================================================================================

/**
 * ARCHITECTURE: Axios singleton configured to cooperate with the Vite proxy in development.
 * Responsibilities:
 * - Use baseURL from env; when set to "/" (recommended for dev), requests are same-origin and get proxied.
 */
import axios from "axios";

function resolveBaseUrl() {
  const w = typeof window !== "undefined" ? window : {};
  const winBase = (w.__API_BASE_URL__ || "").trim();
  const viteBase = (import.meta?.env?.VITE_API_BASE_URL || "").trim();
  const base = (winBase || viteBase);
  if (!base) return "/";          // default to same-origin → dev proxy handles cross-origin
  if (base === "/") return "/";   // explicit proxy mode
  return base.replace(/\/+$/, "");
}

const api = axios.create({
  baseURL: resolveBaseUrl(),
  withCredentials: true,
  headers: {
    "Accept": "application/json",
    "Content-Type": "application/json",
  },
});

api.interceptors.response.use(
  (res) => res,
  (err) => {
    err.message = err?.response?.data?.message || err.message || "Request failed";
    return Promise.reject(err);
  }
);

export default api;


================================================================================
### PLIK: services\ApiAuthBinder.js
================================================================================

/**
 * ARCHITECTURE: ApiAuthBinder binds/unbinds the Authorization header on the shared ApiHttpClient singleton.
 * Responsibilities:
 * - Apply "Authorization: <type> <token>" to axios defaults; remove it on logout.
 */
import apiClient from "@/services/api";

export class ApiAuthBinder {
  constructor() {
    this.headerName = "Authorization";
  }

  bind(accessToken, tokenType = "Bearer") {
    if (!accessToken) return false;
    const scheme = String(tokenType || "Bearer").trim() || "Bearer";
    if (!apiClient.defaults.headers) apiClient.defaults.headers = {};
    if (!apiClient.defaults.headers.common) apiClient.defaults.headers.common = {};
    apiClient.defaults.headers.common[this.headerName] = `${scheme} ${accessToken}`;
    return true;
  }

  unbind() {
    if (apiClient?.defaults?.headers?.common && this.headerName in apiClient.defaults.headers.common) {
      delete apiClient.defaults.headers.common[this.headerName];
      return true;
    }
    return false;
  }
}


================================================================================
### PLIK: services\ApiErrorMapper.js
================================================================================

/**
 * ARCHITECTURE: ApiErrorMapper (Stub) translates backend HTTP error responses
 * into user-facing, domain-specific error messages or error objects.
 * This isolates HTTP error structure from controllers.
 */
import { Result } from "@/domain/Result";

export class ApiErrorMapper {
    constructor() {
        // Map of known backend error codes/messages to frontend-friendly text
        this.errorMap = {
            "validation_failed": "The data provided was invalid. Please check the fields.",
            "duplicate_barcode": "This barcode already exists in the system.",
            "auth_invalid_credentials": "Invalid username or password.",
        };
    }

    /**
     * Maps an Axios error object to a frontend-friendly Error object.
     * @param {Error} axiosError - The error object from an Axios request.
     * @returns {Error} A new Error object with a user-friendly message.
     */
    map(axiosError) {
        if (!axiosError) {
            return new Error("An unknown error occurred.");
        }

        const responseData = axiosError.response?.data;
        const status = axiosError.response?.status;

        if (status === 401) {
            return new Error("Authentication failed. Please log in again.");
        }

        if (status === 403) {
            return new Error("You do not have permission to perform this action.");
        }

        // Check for specific backend error code
        const backendErrorCode = responseData?.errorCode; // Assuming backend sends { "errorCode": "...", ... }
        if (backendErrorCode && this.errorMap[backendErrorCode]) {
            return new Error(this.errorMap[backendErrorCode]);
        }

        // Check for Spring Boot validation errors
        if (status === 422 && Array.isArray(responseData?.details)) {
            return new Error(`Validation failed: ${responseData.details.join(', ')}`);
        }

        // Fallback to message from backend payload or default
        const message = responseData?.error || responseData?.message || axiosError.message || "An unknown server error occurred.";
        return new Error(message);
    }

    /**
     * Wraps an API call (a function returning a Promise) with error mapping.
     * @param {Function} apiCallFn - An async function (e.g., () => apiClient.get('/...')).
     * @returns {Promise<Result<any, Error>>} A Result object.
     */
    async wrap(apiCallFn) {
        try {
            const response = await apiCallFn();
            return Result.ok(response.data); // Assumes success is response.data
        } catch (error) {
            return Result.fail(this.map(error));
        }
    }
}

================================================================================
### PLIK: services\AuthApi.js
================================================================================

/**
 * ARCHITECTURE: AuthApi encapsulates authentication HTTP calls against the backend auth service.
 * It follows the manifesto by isolating transport details and returning deterministic Result objects.
 * Responsibilities:
 * - POST credentials to /auth/login and return a normalized session object on success.
 * - Keep transport client injectable for testing; default to the shared Axios instance.
 */
import api from "@/services/api";
import { Result } from "@/domain/Result";

export class AuthApi {
  constructor(httpClient = api) {
    this.http = httpClient;
  }

  async login(username, password) {
    try {
      const res = await this.http.post("/auth/login", { username, password });
      const data = res?.data || {};
      const session = {
        accessToken: data.accessToken || null,
        refreshToken: data.refreshToken || null,
        tokenType: data.tokenType || "Bearer",
        username: data.username || username || null,
        roles: Array.isArray(data.roles) ? data.roles : [],
      };
      if (!session.accessToken) return Result.fail(new Error("AuthApi: accessToken missing in response."));
      return Result.ok(session);
    } catch (e) {
      return Result.fail(e instanceof Error ? e : new Error("AuthApi: login failed"));
    }
  }
}


================================================================================
### PLIK: services\AuthApi.spec.js
================================================================================

// src/services/AuthApi.spec.js
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { AuthApi } from '@/services/AuthApi';
import { Result } from '@/domain/Result';

// Mock the underlying HTTP client (e.g., axios instance)
const mockHttpClient = {
    post: vi.fn(),
};

describe('AuthApi', () => {
    let authApi;

    beforeEach(() => {
        // Reset mocks before each test
        vi.resetAllMocks();
        // Create a new instance with the mock client for each test
        authApi = new AuthApi(mockHttpClient);
    });

    it('should call login endpoint and return Ok Result on success', async () => {
        // Arrange
        const mockUsername = 'testuser';
        const mockPassword = 'password';
        const mockApiResponse = {
            data: {
                accessToken: 'mockAccessToken',
                refreshToken: 'mockRefreshToken',
                tokenType: 'Bearer',
                username: mockUsername,
                roles: ['USER', 'ADMIN'],
            }
        };
        mockHttpClient.post.mockResolvedValue(mockApiResponse);

        // Act
        const result = await authApi.login(mockUsername, mockPassword);

        // Assert
        expect(mockHttpClient.post).toHaveBeenCalledTimes(1);
        expect(mockHttpClient.post).toHaveBeenCalledWith('/auth/login', { username: mockUsername, password: mockPassword });

        expect(result).toBeInstanceOf(Result);
        expect(result.ok).toBe(true);
        expect(result.value).toEqual({
            accessToken: 'mockAccessToken',
            refreshToken: 'mockRefreshToken',
            tokenType: 'Bearer',
            username: mockUsername,
            roles: ['USER', 'ADMIN'],
        });
    });

    it('should return Fail Result if API call fails', async () => {
        // Arrange
        const mockUsername = 'testuser';
        const mockPassword = 'password';
        const mockError = new Error('Network Error');
        mockHttpClient.post.mockRejectedValue(mockError);

        // Act
        const result = await authApi.login(mockUsername, mockPassword);

        // Assert
        expect(mockHttpClient.post).toHaveBeenCalledTimes(1);
        expect(mockHttpClient.post).toHaveBeenCalledWith('/auth/login', { username: mockUsername, password: mockPassword });

        expect(result).toBeInstanceOf(Result);
        expect(result.ok).toBe(false);
        expect(result.error).toBe(mockError);
    });

    it('should return Fail Result if API response is missing accessToken', async () => {
        // Arrange
        const mockUsername = 'testuser';
        const mockPassword = 'password';
        const mockApiResponse = {
            data: { /* accessToken is missing */ }
        };
        mockHttpClient.post.mockResolvedValue(mockApiResponse);

        // Act
        const result = await authApi.login(mockUsername, mockPassword);

        // Assert
        expect(result).toBeInstanceOf(Result);
        expect(result.ok).toBe(false);
        expect(result.error).toBeInstanceOf(Error);
        expect(result.error.message).toContain('accessToken missing');
    });
});

================================================================================
### PLIK: services\AuthSessionService.js
================================================================================

/**
 * ARCHITECTURE: AuthSessionService persists auth tokens and user profile and exposes accessors.
 * It follows the manifesto by isolating storage mechanics and providing deterministic getters/setters.
 * Responsibilities:
 * - Save/load/remove session in localStorage with a namespaced key.
 * - Expose isAuthenticated(), getAccessToken(), getTokenType(), getUser(), hasRole().
 */
export class AuthSessionService {
  constructor(namespace = "danxils_auth") {
    this.ns = namespace;
    this.store = typeof window !== "undefined" ? window.localStorage : null;
  }

  save(session) {
    if (!this.store) return false;
    const payload = {
      accessToken: session?.accessToken || null,
      refreshToken: session?.refreshToken || null,
      tokenType: session?.tokenType || "Bearer",
      username: session?.username || null,
      roles: Array.isArray(session?.roles) ? session.roles : [],
      at: Date.now(),
    };
    this.store.setItem(this.ns, JSON.stringify(payload));
    return true;
  }

  load() {
    if (!this.store) return null;
    const raw = this.store.getItem(this.ns);
    if (!raw) return null;
    try { return JSON.parse(raw); } catch { return null; }
  }

  clear() {
    if (!this.store) return false;
    this.store.removeItem(this.ns);
    return true;
  }

  isAuthenticated() {
    const s = this.load();
    return !!(s && s.accessToken);
  }

  getAccessToken() {
    const s = this.load();
    return s?.accessToken || null;
  }

  getTokenType() {
    const s = this.load();
    return s?.tokenType || "Bearer";
  }

  getUser() {
    const s = this.load();
    return { username: s?.username || null, roles: Array.isArray(s?.roles) ? s.roles : [] };
  }

  hasRole(role) {
    const s = this.load();
    const roles = Array.isArray(s?.roles) ? s.roles : [];
    return roles.includes(role);
  }
}


================================================================================
### PLIK: services\CsvBuilder.js
================================================================================

/**
 * ARCHITECTURE: CsvBuilder builds CSV text from arrays of objects without UI or transport coupling.
 * It follows the manifesto by providing a pure data-to-text transformation with stable escaping.
 * Responsibilities:
 * - Accept columns definition and rows; output RFC-4180-compliant CSV with quotes/escaping.
 * - Return a string for download or clipboard without side effects.
 */
export class CsvBuilder {
  constructor(columns) {
    if (!Array.isArray(columns) || columns.length === 0) throw new Error("CsvBuilder: columns are required.");
    this.columns = columns; // [{key:'orderId', title:'Order ID'}, ...]
  }

  build(rows) {
    const head = this.columns.map(c => this._q(c.title || c.key)).join(",");
    const body = (Array.isArray(rows) ? rows : []).map(r => this.columns.map(c => this._q(r[c.key])).join(",")).join("\n");
    return [head, body].filter(Boolean).join("\n");
  }

  _q(v) {
    const s = v == null ? "" : String(v);
    if (/[",\n]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
    return s;
  }
}


================================================================================
### PLIK: services\DebounceTimer.js
================================================================================

/**
 * ARCHITECTURE: DebounceTimer provides deterministic debouncing for keystroke-driven verification.
 * It follows the manifesto by encapsulating timing concerns and exposing a minimal, testable contract.
 * Responsibilities:
 * - Debounce a single async task, cancelling the previous one if a new call arrives within the interval.
 * - Prevent overlapping executions by using a monotonically increasing token.
 */
export class DebounceTimer {
  constructor(delayMs = 400) {
    this.delayMs = delayMs;
    this._timer = null;
    this._token = 0;
  }

  run(asyncFn) {
    return new Promise((resolve, reject) => {
      const current = ++this._token;
      if (this._timer) clearTimeout(this._timer);
      this._timer = setTimeout(async () => {
        try {
          if (current !== this._token) return resolve(null);
          const r = await asyncFn();
          if (current !== this._token) return resolve(null);
          resolve(r);
        } catch (e) {
          reject(e);
        }
      }, this.delayMs);
    });
  }

  cancel() {
    if (this._timer) clearTimeout(this._timer);
    this._timer = null;
    this._token++;
  }
}


================================================================================
### PLIK: services\DiffService.js
================================================================================

/**
 * ARCHITECTURE: DiffService computes before/after differences for Address DTO fields.
 * It follows the manifesto by isolating comparison logic from viewmodels and controllers.
 * Responsibilities:
 * - Compare two objects field-by-field; return {entries[], anyChanged}.
 */
export class DiffService {
  constructor(fields = ["street", "houseNumber", "postalCode", "city", "country", "latitude", "longitude"]) {
    this.fields = fields.slice();
  }

  diff(before, after) {
    const entries = this.fields.map(f => {
      const b = this._val(before, f);
      const a = this._val(after, f);
      const changed = !this._eq(b, a);
      return { field: f, before: b, after: a, changed };
    });
    const anyChanged = entries.some(e => e.changed);
    return { entries, anyChanged };
  }

  _val(obj, field) {
    if (!obj) return null;
    return obj[field] ?? null;
  }

  _eq(a, b) {
    if (typeof a === "number" || typeof b === "number") return Number(a || 0).toFixed(6) === Number(b || 0).toFixed(6);
    return (a || "").toString().trim().toLowerCase() === (b || "").toString().trim().toLowerCase();
  }
}


================================================================================
### PLIK: services\EditorStateSerializer.js
================================================================================

/**
 * ARCHITECTURE: EditorStateSerializer persists and restores editor state across reloads in session storage.
 * It follows the manifesto by isolating serialization concerns and avoiding component-level side effects.
 * Responsibilities:
 * - Save minimal editor payload keyed by orderId; restore and clear on demand.
 * - Handle safe JSON parse/stringify and namespace keys to avoid collisions.
 */
export class EditorStateSerializer {
  constructor(namespace = "editor") {
    this.ns = namespace;
    this._store = typeof window !== "undefined" ? window.sessionStorage : null;
  }

  save(orderId, state) {
    if (!this._store || !orderId) return false;
    const key = this._key(orderId);
    const payload = {
      at: Date.now(),
      editedPickup: state?.editedPickup || null,
      editedDelivery: state?.editedDelivery || null,
    };
    this._store.setItem(key, JSON.stringify(payload));
    return true;
  }

  load(orderId) {
    if (!this._store || !orderId) return null;
    const raw = this._store.getItem(this._key(orderId));
    if (!raw) return null;
    try {
      return JSON.parse(raw);
    } catch {
      return null;
    }
  }

  clear(orderId) {
    if (!this._store || !orderId) return false;
    this._store.removeItem(this._key(orderId));
    return true;
  }

  _key(orderId) {
    return `${this.ns}:${orderId}`;
  }
}


================================================================================
### PLIK: services\EnvironmentConfigService.js
================================================================================

/**
 * ARCHITECTURE: EnvironmentConfigService centralizes runtime configuration discovery for the frontend.
 * It follows the manifesto by isolating environment concerns and producing a deterministic config object.
 * Responsibilities:
 * - Load API base URL and flags from environment variables or window-injected globals.
 * - Expose get(key) and typed helpers; set window.__API_BASE_URL__ for ApiHttpClient consumers.
 */
export class EnvironmentConfigService {
  constructor() {
    this._loaded = false;
    this._cfg = {
      API_BASE_URL: "",
      GOOGLE_MAPS_API_KEY: "",
      APP_ENV: "development",
    };
  }

  async load() {
    if (this._loaded) return this._cfg;
    const w = typeof window !== "undefined" ? window : {};
    const env = w.__APP_ENV__ || {};
    const apiFromWindow = (w.__API_BASE_URL__ || "").trim();
    const apiFromEnv = (import.meta && import.meta.env && import.meta.env.VITE_API_BASE_URL) || "";
    const keyFromWindow = (w.__GOOGLE_MAPS_API_KEY__ || "").trim();
    const keyFromEnv = (import.meta && import.meta.env && import.meta.env.VITE_GOOGLE_MAPS_API_KEY) || "";
    const appEnv = (import.meta && import.meta.env && import.meta.env.MODE) || env.MODE || "development";
    this._cfg = {
      API_BASE_URL: apiFromWindow || apiFromEnv || "",
      GOOGLE_MAPS_API_KEY: keyFromWindow || keyFromEnv || "",
      APP_ENV: appEnv,
    };
    if (typeof window !== "undefined") {
      window.__API_BASE_URL__ = this._cfg.API_BASE_URL;
    }
    this._loaded = true;
    return this._cfg;
  }

  get(key, fallback = null) {
    return Object.prototype.hasOwnProperty.call(this._cfg, key) ? this._cfg[key] : fallback;
  }

  apiBase() {
    return this.get("API_BASE_URL", "");
  }

  googleKey() {
    return this.get("GOOGLE_MAPS_API_KEY", "");
  }

  appEnv() {
    return this.get("APP_ENV", "development");
  }
}


================================================================================
### PLIK: services\ErrorTypeDictionary.js
================================================================================

/**
 * ARCHITECTURE: ErrorTypeDictionary maps backend error codes to user-facing labels and severities.
 * It follows the manifesto by isolating presentation-neutral taxonomy from API DTOs.
 * Responsibilities:
 * - Provide stable lookups for label, severity, and suggested actions per error type.
 * - Allow extension via register() without changing existing mappings.
 */
export class ErrorTypeDictionary {
  constructor() {
    this._map = new Map();
    this._map.set("INVALID_POSTAL_CODE", { label: "Invalid ZIP/Postal Code", severity: "critical", actions: ["verify", "fix-postal"] });
    this._map.set("AMBIGUOUS_STREET", { label: "Ambiguous Street (Apt/Suite missing)", severity: "warning", actions: ["add-apartment", "verify"] });
    this._map.set("NON_STANDARDIZED", { label: "Non-standardized Address", severity: "info", actions: ["normalize", "verify"] });
  }

  get(code) {
    return this._map.get(code) || { label: code || "Unknown Error", severity: "info", actions: [] };
  }

  register(code, entry) {
    if (!code || typeof entry !== "object") throw new Error("ErrorTypeDictionary: invalid registration.");
    this._map.set(code, entry);
    return true;
  }
}


================================================================================
### PLIK: services\FeatureFlagService.js
================================================================================

/**
 * ARCHITECTURE: FeatureFlagService loads and caches runtime feature flags that guide UX policies.
 * It follows the manifesto by centralizing flag access behind explicit getters with session caching.
 * Responsibilities:
 * - Fetch flags from backend once; expose booleans for critical flows (requireGeocode, bulkEdit).
 * - Allow local overrides for testing without changing backend state.
 */
import apiClient from "@/services/api";

export class FeatureFlagService {
  constructor(endpoint = "/status/feature-flags") {
    this.endpoint = endpoint;
    this._flags = null;
    this._inFlight = null;
    this._overrides = {};
  }

  async load() {
    if (this._flags) return this._flags;
    if (this._inFlight) return this._inFlight;
    this._inFlight = apiClient.get(this.endpoint).then(r => {
      this._flags = r?.data || {};
      return this._flags;
    }).finally(() => (this._inFlight = null));
    return this._inFlight;
  }

  setOverride(key, value) {
    this._overrides[key] = value;
    return true;
  }

  get(key, fallback = false) {
    const base = this._flags && Object.prototype.hasOwnProperty.call(this._flags, key) ? this._flags[key] : fallback;
    return Object.prototype.hasOwnProperty.call(this._overrides, key) ? this._overrides[key] : base;
  }

  requireGeocode() {
    return !!this.get("REQUIRE_GEOCODE", false);
  }

  allowBulkEdit() {
    return !!this.get("ALLOW_BULK_EDIT", true);
  }
}


================================================================================
### PLIK: services\GoogleErrorTranslator.js
================================================================================

/**
 * ARCHITECTURE: GoogleErrorTranslator maps Google Maps/Places status messages to stable application errors.
 * It follows the manifesto by isolating third-party semantics from business logic and controllers.
 * Responsibilities:
 * - Translate known status/error strings to canonical codes and user-friendly messages.
 * - Provide a simple translate(err) that returns {code,message,retryable}.
 */
export class GoogleErrorTranslator {
  constructor() {
    this._map = new Map();
    this._map.set("OVER_QUERY_LIMIT", { code: "RATE_LIMIT", message: "Google quota exceeded", retryable: true });
    this._map.set("ZERO_RESULTS", { code: "NO_RESULTS", message: "No results found", retryable: false });
    this._map.set("REQUEST_DENIED", { code: "DENIED", message: "Request denied by Google", retryable: false });
    this._map.set("INVALID_REQUEST", { code: "INVALID", message: "Invalid geocoding request", retryable: false });
    this._map.set("UNKNOWN_ERROR", { code: "UNKNOWN", message: "Temporary Google error", retryable: true });
  }

  translate(error) {
    const msg = (error?.message || "").toUpperCase();
    for (const [k, v] of this._map.entries()) {
      if (msg.includes(k)) return v;
    }
    const status = error?.status || error?.response?.status || null;
    if (status === 429) return { code: "RATE_LIMIT", message: "Rate limit reached", retryable: true };
    if (status === 503) return { code: "UNAVAILABLE", message: "Service unavailable", retryable: true };
    return { code: "GENERIC", message: error?.message || "Unexpected Google error", retryable: false };
  }
}


================================================================================
### PLIK: services\GoogleKeyProvider.js
================================================================================

/**
 * ARCHITECTURE: GoogleKeyProvider offers a minimal, cached accessor for the Google Maps API key.
 * Responsibilities:
 * - Resolve the key from EnvironmentConfigService once and memoize it.
 */
import { EnvironmentConfigService } from "@/services/EnvironmentConfigService";

export class GoogleKeyProvider {
  constructor(configService = new EnvironmentConfigService()) {
    this.config = configService;
    this._key = null;
    this._inFlight = null;
  }

  async getKey() {
    if (this._key) return this._key;
    if (this._inFlight) return this._inFlight;
    this._inFlight = this.config.load().then(() => {
      this._key = this.config.googleKey();
      if (!this._key) throw new Error("GoogleKeyProvider: GOOGLE_MAPS_JS_API_KEY missing.");
      return this._key;
    }).finally(() => {
      this._inFlight = null;
    });
    return this._inFlight;
  }
}


================================================================================
### PLIK: services\IdempotencyTokenService.js
================================================================================

/**
 * ARCHITECTURE: IdempotencyTokenService creates deterministic tokens for save requests.
 * It follows the manifesto by isolating token generation from controllers and transport layers.
 * Responsibilities:
 * - Produce a stable hash-like token from orderId, side, and payload string.
 */
export class IdempotencyTokenService {
  create(orderId, side, payloadString) {
    const base = `${orderId || ""}|${side || "both"}|${payloadString || ""}`;
    // Simple Fowler–Noll–Vo (FNV-1a) 32-bit hash for deterministic tokens
    let h = 0x811c9dc5;
    for (let i = 0; i < base.length; i++) {
      h ^= base.charCodeAt(i);
      h = (h + ((h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24))) >>> 0;
    }
    return `idem-${h.toString(16)}`;
  }
}


================================================================================
### PLIK: services\LatencyBudget.js
================================================================================

/**
 * ARCHITECTURE: LatencyBudget enforces per-step execution budgets for snappy UX under load.
 * It follows the manifesto by isolating timing limits and providing a race-with-timeout helper.
 * Responsibilities:
 * - Wrap a promise with a timeout; resolve fallback when exceeded; report elapsed for telemetry.
 */
export class LatencyBudget {
  constructor(defaultMs = 1200) {
    this.defaultMs = Math.max(100, defaultMs);
  }

  async runWithTimeout(promiseFactory, timeoutMs = this.defaultMs, fallback = null) {
    const start = Date.now();
    const to = new Promise(resolve => setTimeout(() => resolve({ timeout: true, value: fallback }), Math.max(50, timeoutMs)));
    const op = Promise.resolve().then(() => promiseFactory()).then(v => ({ timeout: false, value: v }));
    const res = await Promise.race([to, op]);
    const elapsedMs = Date.now() - start;
    return { ...res, elapsedMs };
  }
}


================================================================================
### PLIK: services\LoadingBarrier.js
================================================================================

/**
 * ARCHITECTURE: LoadingBarrier serializes concurrent loads by key and ensures latest-wins semantics.
 * It follows the manifesto by centralizing anti-race logic for order detail fetches and suggestion refreshes.
 * Responsibilities:
 * - Track an incrementing ticket per key; resolve only if the ticket is still current when the promise returns.
 * - Provide a simple run(key, fn) API that callers wrap around their async loads.
 */
export class LoadingBarrier {
  constructor() {
    this._tickets = new Map();
  }

  async run(key, fn) {
    if (!key || typeof fn !== "function") throw new Error("LoadingBarrier: invalid arguments.");
    const next = (this._tickets.get(key) || 0) + 1;
    this._tickets.set(key, next);
    const myTicket = next;
    const result = await fn();
    if (this._tickets.get(key) !== myTicket) return null;
    return result;
  }

  invalidate(key) {
    const next = (this._tickets.get(key) || 0) + 1;
    this._tickets.set(key, next);
    return next;
  }
}


================================================================================
### PLIK: services\OrderDetailPrefetcher.js
================================================================================

/**
 * ARCHITECTURE: OrderDetailPrefetcher warms the cache by fetching the next order detail proactively.
 * It follows the manifesto by separating performance optimizations from core controllers.
 * Responsibilities:
 * - Prefetch via AddressExceptionApi and hold a single-item cache keyed by orderId.
 * - Provide getOrFetch(id) to serve from cache or network.
 */
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

export class OrderDetailPrefetcher {
  constructor(api = new AddressExceptionApi()) {
    this.api = api;
    this._cachedId = null;
    this._cached = null;
  }

  async prefetch(nextOrderId) {
    if (!nextOrderId) return false;
    const r = await this.api.getOrderDetail(nextOrderId);
    if (r.ok) {
      this._cachedId = nextOrderId;
      this._cached = r.value;
      return true;
    }
    return false;
  }

  async getOrFetch(orderId) {
    if (this._cachedId === orderId && this._cached) return this._cached;
    const r = await this.api.getOrderDetail(orderId);
    if (r.ok) {
      this._cachedId = orderId;
      this._cached = r.value;
      return r.value;
    }
    throw r.error;
  }

  clear() {
    this._cachedId = null;
    this._cached = null;
    return true;
  }
}


================================================================================
### PLIK: services\OrdersKpiEstimator.js
================================================================================

/**
 * ARCHITECTURE: OrdersKpiEstimator (Stub) would be responsible for calculating
 * client-side KPIs or estimates based on a list of order data.
 * This is a placeholder implementation.
 */
export class OrdersKpiEstimator {
    constructor() {
        // Configuration for KPI calculation
    }

    /**
     * Calculates KPIs from a list of worklist items.
     * @param {Array<object>} items - The list of order summary DTOs.
     * @returns {object} An object containing calculated KPIs (e.g., { pending, avgAgeMs }).
     */
    calculate(items = []) {
        const pending = items.filter(item => item.processingStatus === 'ADDRESS_NEEDS_REVIEW').length;
        const now = Date.now();
        const ages = items
            .filter(item => item.processingStatus === 'ADDRESS_NEEDS_REVIEW' && item.createdAt)
            .map(item => now - new Date(item.createdAt).getTime());

        const avgAgeMs = ages.length > 0
            ? ages.reduce((a, b) => a + b, 0) / ages.length
            : 0;

        return {
            pending: pending,
            avgAgeMs: avgAgeMs,
        };
    }
}

================================================================================
### PLIK: services\OrdersQueueService.js
================================================================================

/**
 * ARCHITECTURE: OrdersQueueService maintains a FIFO queue of orderIds for Save & Next workflows.
 * It follows the manifesto by isolating queue mechanics from components and views.
 * Responsibilities:
 * - Load from a list, advance to next, remove current, inspect current/size/ids.
 */
export class OrdersQueueService {
  constructor() {
    this._ids = [];
    this._index = 0;
  }

  loadFromItems(items) {
    this._ids = (Array.isArray(items) ? items : []).map(x => x.orderId).filter(Boolean);
    this._index = 0;
    return this.ids();
  }

  ids() {
    return this._ids.slice();
  }

  size() {
    return Math.max(0, this._ids.length - this._index);
  }

  current() {
    return this._ids[this._index] || null;
  }

  next() {
    if (this._index + 1 >= this._ids.length) return null;
    this._index++;
    return this.current();
  }

  remove(orderId) {
    const pos = this._ids.indexOf(orderId);
    if (pos === -1) return false;
    this._ids.splice(pos, 1);
    if (this._index > pos) this._index--;
    return true;
  }

  reset() {
    this._ids = [];
    this._index = 0;
    return true;
  }
}


================================================================================
### PLIK: services\OrderStatusWatcher.js
================================================================================

/**
 * ARCHITECTURE: OrderStatusWatcher polls backend for a single order until a target status is reached.
 * It follows the manifesto by isolating polling semantics from views and controllers with a clear contract.
 * Responsibilities:
 * - Poll /orders/{id} at a fixed interval and resolve when status ∈ target set or when max time elapses.
 * - Expose start(), cancel(), and onTick hooks for progress indicators without leaking transport details.
 */
import apiClient from "@/services/api";

export class OrderStatusWatcher {
  constructor(intervalMs = 2000, timeoutMs = 60000) {
    this.intervalMs = Math.max(250, intervalMs);
    this.timeoutMs = Math.max(this.intervalMs, timeoutMs);
    this._timer = null;
    this._startedAt = 0;
    this._active = false;
    this._onTick = null;
  }

  onTick(fn) {
    this._onTick = typeof fn === "function" ? fn : null;
    return this;
  }

  start(orderId, targetStatuses = ["ADDRESS_VALIDATED", "MANUALLY_CORRECTED"]) {
    if (!orderId) throw new Error("OrderStatusWatcher: orderId required.");
    this.cancel();
    this._active = true;
    this._startedAt = Date.now();
    return new Promise((resolve, reject) => {
      const tick = async () => {
        if (!this._active) return;
        try {
          const r = await apiClient.get(`/orders/${encodeURIComponent(orderId)}`);
          const status = r?.data?.processingStatus || null;
          if (this._onTick) this._onTick({ status, elapsedMs: Date.now() - this._startedAt });
          if (status && targetStatuses.includes(status)) {
            this.cancel();
            return resolve({ status, elapsedMs: Date.now() - this._startedAt });
          }
        } catch (e) {
          this.cancel();
          return reject(e);
        }
        if (Date.now() - this._startedAt > this.timeoutMs) {
          this.cancel();
          return resolve({ status: null, elapsedMs: this.timeoutMs, timeout: true });
        }
        this._timer = setTimeout(tick, this.intervalMs);
      };
      this._timer = setTimeout(tick, this.intervalMs);
    });
  }

  cancel() {
    this._active = false;
    if (this._timer) clearTimeout(this._timer);
    this._timer = null;
    return true;
  }
}


================================================================================
### PLIK: services\PollingService.js
================================================================================

/**
 * ARCHITECTURE: PollingService centralizes controlled, single-instance polling loops per key.
 * It follows the manifesto by isolating timing concerns and exposing explicit start/stop contracts.
 * Responsibilities:
 * - Start a debounced timer for an async function and prevent duplicate loops for the same key.
 * - Provide deterministic cancellation via handles and bulk stop-All capability.
 */
export class PollingService {
  constructor() {
    this._timers = new Map();
  }

  start(key, intervalMs, asyncFn) {
    if (!key || typeof asyncFn !== "function" || typeof intervalMs !== "number" || intervalMs <= 0) {
      throw new Error("PollingService.start: invalid arguments.");
    }
    this.stop(key);
    let active = true;
    const tick = async () => {
      if (!active) return;
      try {
        await asyncFn();
      } catch (_) {
        // Errors are handled upstream; polling continues unless explicitly stopped.
      }
      if (active) {
        this._timers.set(key, setTimeout(tick, intervalMs));
      }
    };
    this._timers.set(key, setTimeout(tick, intervalMs));
    return { key, stop: () => this.stop(key) };
  }

  stop(key) {
    const t = this._timers.get(key);
    if (t) {
      clearTimeout(t);
      this._timers.delete(key);
    }
  }

  stopAll() {
    for (const key of this._timers.keys()) {
      this.stop(key);
    }
  }
}


================================================================================
### PLIK: services\QuotaBackoffService.js
================================================================================

/**
 * ARCHITECTURE: QuotaBackoffService (Stub) would manage client-side rate limiting
 * or backoff strategies when interacting with external APIs (like Google)
 * that enforce quotas. This is a placeholder.
 */
import { RetryPolicy } from "@/services/RetryPolicy"; // Assumes RetryPolicy exists

export class QuotaBackoffService {
    constructor() {
        // Configure retry policy specifically for quota errors
        this.retryPolicy = new RetryPolicy(
            3, // Max 3 attempts
            500, // Base delay 500ms
            200, // Jitter 200ms
            (error) => {
                // Only retry on specific quota-related error messages or status codes
                const msg = (error?.message || "").toLowerCase();
                const status = error?.response?.status;
                return msg.includes("quota") || msg.includes("rate limit") || status === 429 || status === 503;
            }
        );
    }

    /**
     * Executes a function wrapped in the backoff/retry policy.
     * @param {Function} asyncFn - The async function to execute (e.g., () => geocoder.geocode(...)).
     * @returns {Promise<any>} The result of the async function.
     */
    async execute(asyncFn) {
        try {
            return await this.retryPolicy.execute(asyncFn);
        } catch (error) {
            console.warn("[QuotaBackoffService] Execution failed after retries:", error);
            throw error; // Re-throw the final error
        }
    }
}

================================================================================
### PLIK: services\RetryPolicy.js
================================================================================

/**
 * ARCHITECTURE: RetryPolicy executes async operations with bounded retries and jittered backoff.
 * It follows the manifesto by centralizing resilience concerns away from controllers and adapters.
 * Responsibilities:
 * - Execute a provided async function up to maxAttempts with exponential backoff and random jitter.
 * - Allow fast-fail on non-retryable errors via predicate.
 */
export class RetryPolicy {
  constructor(maxAttempts = 5, baseDelayMs = 300, jitterMs = 150, isRetryable = () => true) {
    this.maxAttempts = Math.max(1, maxAttempts);
    this.baseDelayMs = Math.max(0, baseDelayMs);
    this.jitterMs = Math.max(0, jitterMs);
    this.isRetryable = isRetryable;
  }

  async execute(fn) {
    let attempt = 0;
    let lastError = null;
    while (attempt < this.maxAttempts) {
      try {
        return await fn();
      } catch (e) {
        lastError = e;
        attempt++;
        if (attempt >= this.maxAttempts || !this.isRetryable(e)) break;
        const backoff = this.baseDelayMs * Math.pow(2, attempt - 1);
        const jitter = Math.floor(Math.random() * this.jitterMs);
        await new Promise((r) => setTimeout(r, backoff + jitter));
      }
    }
    throw lastError || new Error("RetryPolicy: execution failed.");
  }
}


================================================================================
### PLIK: services\RuntimeHealthService.js
================================================================================

/**
 * ARCHITECTURE: RuntimeHealthService is a tolerant, dev-first health probe that never blocks the UI.
 * It follows the manifesto by eliminating non-essential cross-origin calls that cause startup noise.
 * Responsibilities:
 * - Always return a "ready" structure without performing any network requests in development.
 * - Preserve the method signature so other controllers remain decoupled from transport concerns.
 */
export class RuntimeHealthService {
  constructor() {
    this.devBypass = true; // development-first: suppress all /status calls to avoid 403/5xx noise
  }

  async readiness(googleKey) {
    return {
      ready: true,
      backend: { ok: true, code: 200 },
      provider: { ok: true, code: 200 },
      google: { ok: !!googleKey },
    };
  }
}


================================================================================
### PLIK: services\SessionStorageService.js
================================================================================

/**
 * ARCHITECTURE: SessionStorageService persists small JSON blobs across reloads within the session.
 * It follows the manifesto by isolating storage read/write and providing safe JSON handling.
 * Responsibilities:
 * - Save and load values by key with automatic JSON serialization and prefixing to avoid collisions.
 * - Provide remove and clearNamespace utilities without affecting unrelated storage.
 */
export class SessionStorageService {
  constructor(namespace = "wb") {
    this.ns = namespace;
    this._prefix = `${this.ns}:`;
    this._store = typeof window !== "undefined" ? window.sessionStorage : null;
  }

  save(key, value) {
    if (!this._store) return false;
    this._store.setItem(this._prefix + key, JSON.stringify(value == null ? null : value));
    return true;
  }

  load(key, fallback = null) {
    if (!this._store) return fallback;
    const raw = this._store.getItem(this._prefix + key);
    if (raw == null) return fallback;
    try {
      return JSON.parse(raw);
    } catch {
      return fallback;
    }
  }

  remove(key) {
    if (!this._store) return false;
    this._store.removeItem(this._prefix + key);
    return true;
  }

  clearNamespace() {
    if (!this._store) return 0;
    const keys = [];
    for (let i = 0; i < this._store.length; i++) {
      const k = this._store.key(i);
      if (k && k.startsWith(this._prefix)) keys.push(k);
    }
    keys.forEach(k => this._store.removeItem(k));
    return keys.length;
  }
}


================================================================================
### PLIK: services\SuggestionConflictDetector.js
================================================================================

/**
 * ARCHITECTURE: SuggestionConflictDetector (Stub) would be responsible for
 * analyzing a list of suggestions and flagging potential conflicts
 * (e.g., same street/city but different postal codes).
 * This is a placeholder implementation.
 */
export class SuggestionConflictDetector {
    constructor() {
        // Configuration for conflict detection
    }

    /**
     * Analyzes a list of suggestions and returns conflict metadata.
     * @param {Array<object>} suggestions - List of normalized suggestions.
     * @returns {object} An object describing conflicts (e.g., { hasPostalConflict: true }).
     */
    analyze(suggestions = []) {
        if (suggestions.length < 2) {
            return { hasPostalConflict: false, hasCityConflict: false };
        }

        // Example: Check for postal code conflicts (same street/city, different postal)
        const postalCodes = new Set();
        let hasPostalConflict = false;
        const firstStreet = suggestions[0].street?.toLowerCase();
        const firstCity = suggestions[0].city?.toLowerCase();

        for (const s of suggestions) {
            if (s.postalCode) {
                // Check if this suggestion has same street/city but different postal code
                if (s.street?.toLowerCase() === firstStreet && s.city?.toLowerCase() === firstCity) {
                    postalCodes.add(s.postalCode);
                    if (postalCodes.size > 1) {
                        hasPostalConflict = true;
                        break;
                    }
                }
            }
        }

        return {
            hasPostalConflict: hasPostalConflict,
            hasCityConflict: false, // TODO: Implement city conflict logic
        };
    }
}

================================================================================
### PLIK: services\SuggestionNormalizer.js
================================================================================

/**
 * ARCHITECTURE: SuggestionNormalizer converts heterogeneous provider responses into a unified Suggestion DTO.
 * It follows the manifesto by isolating mapping/normalization concerns and avoiding provider leakage into UI.
 * Responsibilities:
 * - Accept raw Google Geocoder/Places or TES suggestion objects and output a normalized shape.
 * - Provide batch normalization and safe defaults for missing fields.
 */
export class SuggestionNormalizer {
  constructor(defaultCountry = "PL") {
    this.defaultCountry = defaultCountry;
  }

  fromGoogleGeocoder(geo) {
    if (!geo) return null;
    const comp = this._indexComponents(geo.address_components || []);
    return {
      fullAddressLabel: geo.formatted_address || null,
      street: comp.route || null,
      houseNumber: comp.street_number || null,
      postalCode: comp.postal_code || null,
      city: comp.locality || comp.postal_town || comp.administrative_area_level_2 || null,
      countryCode: comp.country_code || this.defaultCountry,
      countryName: comp.country || null,
      latitude: geo.geometry?.location?.lat?.() ?? null,
      longitude: geo.geometry?.location?.lng?.() ?? null,
      matchScore: 0.95,
      matchLevel: "GEOCODER",
      providerSource: "GOOGLE_CLIENT",
    };
  }

  fromGooglePlaces(place) {
    if (!place) return null;
    const comp = this._indexComponents(place.address_components || []);
    return {
      fullAddressLabel: null,
      street: comp.route || null,
      houseNumber: comp.street_number || null,
      postalCode: comp.postal_code || null,
      city: comp.locality || comp.postal_town || comp.administrative_area_level_2 || null,
      countryCode: comp.country_code || this.defaultCountry,
      countryName: comp.country || null,
      latitude: place.geometry?.location?.lat?.() ?? null,
      longitude: place.geometry?.location?.lng?.() ?? null,
      matchScore: 0.9,
      matchLevel: "PLACES",
      providerSource: "GOOGLE_PLACES",
    };
  }

  fromTes(item) {
    if (!item) return null;
    return {
      fullAddressLabel: item.label || null,
      street: item.street || null,
      houseNumber: item.houseNumber || null,
      postalCode: item.postalCode || null,
      city: item.city || null,
      countryCode: item.countryCode || this.defaultCountry,
      countryName: item.country || null,
      latitude: typeof item.latitude === "number" ? item.latitude : null,
      longitude: typeof item.longitude === "number" ? item.longitude : null,
      matchScore: typeof item.score === "number" ? item.score : 0.7,
      matchLevel: item.level || "TES",
      providerSource: "TES",
    };
  }

  normalizeBatch(list, origin) {
    if (!Array.isArray(list)) return [];
    if (origin === "GEOCODER") return list.map(x => this.fromGoogleGeocoder(x)).filter(Boolean);
    if (origin === "PLACES") return list.map(x => this.fromGooglePlaces(x)).filter(Boolean);
    if (origin === "TES") return list.map(x => this.fromTes(x)).filter(Boolean);
    return [];
  }

  _indexComponents(parts) {
    const map = {};
    for (const c of parts) {
      for (const t of c.types) {
        if (t === "country") {
          map.country = c.long_name;
          map.country_code = c.short_name;
        } else if (t === "locality") {
          map.locality = c.long_name;
        } else if (t === "postal_town") {
          map.postal_town = c.long_name;
        } else if (t === "administrative_area_level_2") {
          map.administrative_area_level_2 = c.long_name;
        } else if (t === "route") {
          map.route = c.long_name;
        } else if (t === "street_number") {
          map.street_number = c.long_name;
        } else if (t === "postal_code") {
          map.postal_code = c.long_name;
        }
      }
    }
    return map;
  }
}


================================================================================
### PLIK: services\SuggestionPreviewService.js
================================================================================

/**
 * ARCHITECTURE: SuggestionPreviewService creates a non-destructive preview Address object from a suggestion.
 * It follows the manifesto by isolating conversion rules away from editor state and components.
 * Responsibilities:
 * - Convert a suggestion DTO to an Address-like object the map can display without committing changes.
 */
export class SuggestionPreviewService {
  toAddressLike(s) {
    if (!s) return null;
    return {
      street: s.street || "",
      houseNumber: s.houseNumber || null,
      postalCode: s.postalCode || "",
      city: s.city || "",
      country: s.countryCode || s.country || "PL",
      latitude: typeof s.latitude === "number" ? s.latitude : null,
      longitude: typeof s.longitude === "number" ? s.longitude : null,
    };
  }
}


================================================================================
### PLIK: services\TelemetryService.js
================================================================================

/**
 * ARCHITECTURE: TelemetryService emits structured events for operational analytics without UI coupling.
 * Buffers events and flushes periodically using navigator.sendBeacon (if available) or console fallback.
 * Adheres to SRP by isolating event formatting and transport logic.
 */
export class TelemetryService {
    constructor(transportFn = null, flushIntervalMs = 15000, maxBuffer = 100) {
        // Use provided transport or default to beacon/console transport
        this.transportFn = typeof transportFn === "function"
            ? transportFn
            : this._defaultBeaconTransport; // Use beacon transport as default

        this.flushIntervalMs = Math.max(1000, flushIntervalMs);
        this.maxBuffer = Math.max(1, maxBuffer);
        this._buf = [];
        this._timer = null;
        // Endpoint for beacon/fetch - should be configurable
        this._telemetryEndpoint = "/api/telemetry"; // Example endpoint
    }

    /** Starts the periodic flushing mechanism. */
    start() {
        if (this._timer) return false;
        this._timer = setInterval(() => {
            this.flush().catch(err => console.error("[TelemetryService] Flush error:", err));
        }, this.flushIntervalMs);
        console.log("[TelemetryService] Started periodic flush.");
        // Add listener for page unload to attempt final flush
        if (typeof window !== "undefined") {
            window.addEventListener('unload', this._unloadFlushHandler);
        }
        return true;
    }

    /** Stops the periodic flushing mechanism. */
    stop() {
        if (!this._timer) return false;
        clearInterval(this._timer);
        this._timer = null;
        if (typeof window !== "undefined") {
            window.removeEventListener('unload', this._unloadFlushHandler);
        }
        console.log("[TelemetryService] Stopped periodic flush.");
        // Optional: Perform a final flush on explicit stop
        // this.flush().catch(err => console.error("[TelemetryService] Final flush error:", err));
        return true;
    }

    // Bound handler for unload event
    _unloadFlushHandler = () => {
        // Use sendBeacon for unload, as async fetch might be cancelled
        this._flushWithBeacon();
    };

    /** Emits a telemetry event, adding it to the buffer. */
    emit(event) {
        if (!event || !event.name) {
            console.warn("[TelemetryService] Invalid event emitted (missing name):", event);
            return null;
        }
        const e = {
            at: Date.now(),
            category: event?.category || "general",
            name: event.name,
            data: event?.data || {},
            corr: event?.corr || null, // Correlation ID from event context
            // Add session/user info if available globally
            // sessionId: getSessionId(),
            // userId: getUserId(),
        };
        this._buf.push(e);
        if (this._buf.length >= this.maxBuffer) {
            // Use regular flush when buffer is full (not on unload)
            this.flush().catch(err => console.error("[TelemetryService] Auto-flush error:", err));
        }
        return e;
    }

    /** Flushes the buffered events using the configured transport function. */
    async flush() {
        if (this._buf.length === 0) {
            return 0; // Nothing to flush
        }
        // Use the configured transport (beacon/console by default)
        return await this._executeFlush(this.transportFn);
    }

    /** Attempts a synchronous flush using sendBeacon, suitable for unload events. */
    _flushWithBeacon() {
        if (this._buf.length === 0 || typeof navigator?.sendBeacon !== 'function') {
            return 0; // Nothing to flush or beacon not available
        }
        // Use the beacon transport directly for unload
        const batch = this._buf.splice(0, this._buf.length);
        try {
            const blob = new Blob([JSON.stringify(batch)], { type: 'application/json' });
            navigator.sendBeacon(this._telemetryEndpoint, blob);
            // Cannot reliably log success/failure from sendBeacon
            // console.log(`[TelemetryService] Attempted beacon flush of ${batch.length} events on unload.`);
            return batch.length;
        } catch (error) {
            console.error("[TelemetryService] sendBeacon failed:", error);
            // Cannot reliably re-queue on unload
            return 0;
        }
    }


    /** Internal helper to execute flush logic and handle errors */
    async _executeFlush(transport) {
        if (!transport || this._buf.length === 0) {
            return 0;
        }
        const batch = this._buf.splice(0, this._buf.length);
        try {
            await transport(batch);
            // console.debug(`[TelemetryService] Flushed ${batch.length} events via ${transport.name}.`);
            return batch.length;
        } catch (error) {
            console.error("[TelemetryService] Transport function failed:", error);
            // Simple strategy: Drop failed batch. Implement retry/queueing if needed.
            // this._buf.unshift(...batch); // Example: Re-queue (use with caution)
            throw error;
        }
    }

    /** Default transport using navigator.sendBeacon if available, falling back to console. */
    async _defaultBeaconTransport(batch) {
        if (typeof navigator !== "undefined" && navigator.sendBeacon) {
            try {
                const blob = new Blob([JSON.stringify(batch)], { type: 'application/json' });
                // Use sendBeacon for background-safe sending, fire-and-forget
                const success = navigator.sendBeacon(this._telemetryEndpoint, blob);
                if (!success) {
                    console.warn("[TelemetryService] navigator.sendBeacon returned false, data might not have been sent.");
                    // Fallback to fetch if beacon fails immediately? Might be too late.
                }
            } catch (error) {
                console.error("[TelemetryService] Error using navigator.sendBeacon:", error);
                // Fallback to console if beacon throws (should be rare)
                console.log("[TelemetryService Fallback Console]", JSON.stringify(batch, null, 2));
            }
        } else {
            // Fallback for environments without sendBeacon
            console.log("[TelemetryService Fallback Console]", JSON.stringify(batch, null, 2));
            // Alternative: Use fetch API here, but it's not guaranteed on unload
            /* try {
                await fetch(this._telemetryEndpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(batch),
                    keepalive: true // Important for unload scenarios, but not universally supported
                });
            } catch (fetchError) {
                console.error("[TelemetryService Fallback Fetch Error]:", fetchError);
            } */
        }
    }
}

================================================================================
### PLIK: services\TesOperationPoller.js
================================================================================

/**
 * ARCHITECTURE: TesOperationPoller handles polling the DANXILS-API status endpoint
 * for asynchronous operations initiated via Kafka proxies.
 * Responsibilities:
 * - Poll a given status URL until the operation status is COMPLETED or FAILED.
 * - Implement configurable retry limits and polling intervals.
 * - Return the final operation status and result/error.
 */
import apiClient from '@/services/api';

export class TesOperationPoller {
    constructor(defaultIntervalMs = 2000, defaultMaxRetries = 15) {
        this.intervalMs = defaultIntervalMs;
        this.maxRetries = defaultMaxRetries;
    }

    async waitFor(correlationId, intervalMs = this.intervalMs, maxRetries = this.maxRetries) {
        if (!correlationId) {
            throw new Error("TesOperationPoller: correlationId is required.");
        }

        const statusUrl = `/api/admin/address-verification/operations/${correlationId}`;
        console.debug(`Polling status for ${correlationId} at ${statusUrl}...`);

        for (let i = 0; i < maxRetries; i++) {
            try {
                if (i > 0) {
                    await new Promise(resolve => setTimeout(resolve, intervalMs));
                }

                const statusResponse = await apiClient.get(statusUrl);
                const operation = statusResponse.data;

                if (!operation || !operation.status) {
                    console.warn(`Polling for ${correlationId}: Received unexpected response. Retrying...`);
                    continue;
                }

                console.debug(`Polling for ${correlationId}: Attempt ${i+1}/${maxRetries}, Status: ${operation.status}`);

                if (operation.status === 'COMPLETED') {
                    let parsedResult = operation.responsePayloadJson;
                    if (parsedResult && typeof parsedResult === 'string') {
                        try {
                            parsedResult = JSON.parse(parsedResult);
                        } catch (parseError) {
                            console.warn(`Polling for ${correlationId}: Completed, but failed to parse responsePayloadJson`, parseError);
                        }
                    }
                    return { ...operation, result: parsedResult };
                }

                if (operation.status === 'FAILED') {
                    return { ...operation, errorDetails: operation.errorMessage };
                }

            } catch (error) {
                if (error.response?.status === 404) {
                    console.warn(`Polling for ${correlationId}: Received 404. Retrying (attempt ${i+1}/${maxRetries})...`);
                } else {
                    console.error(`Polling for ${correlationId}: Error during attempt ${i+1}:`, error);
                }
            }
        }

        throw new Error(`Polling for operation ${correlationId} timed out after ${maxRetries} attempts.`);
    }
}


================================================================================
### PLIK: services\UndoStackService.js
================================================================================

/**
 * ARCHITECTURE: UndoStackService provides bounded undo/redo stacks for immutable editor state snapshots.
 * It follows the manifesto by isolating time-travel mechanics with a deterministic, dependency-free API.
 * Responsibilities:
 * - Push snapshots, undo, redo, and limit memory with a maximum capacity.
 * - Expose current() without mutating returned objects.
 */
export class UndoStackService {
  constructor(capacity = 50) {
    this.capacity = Math.max(1, capacity);
    this._past = [];
    this._future = [];
    this._current = null;
  }

  init(snapshot) {
    this._past = [];
    this._future = [];
    this._current = snapshot ? JSON.parse(JSON.stringify(snapshot)) : null;
    return this.current();
  }

  push(snapshot) {
    if (this._current != null) {
      this._past.push(this._current);
      if (this._past.length > this.capacity) this._past.shift();
    }
    this._current = snapshot ? JSON.parse(JSON.stringify(snapshot)) : null;
    this._future = [];
    return this.current();
  }

  undo() {
    if (!this._past.length) return this.current();
    this._future.unshift(this._current);
    this._current = this._past.pop();
    return this.current();
  }

  redo() {
    if (!this._future.length) return this.current();
    this._past.push(this._current);
    this._current = this._future.shift();
    return this.current();
  }

  clear() {
    this._past = [];
    this._future = [];
    return true;
  }

  current() {
    return this._current ? JSON.parse(JSON.stringify(this._current)) : null;
  }
}


================================================================================
### PLIK: services\ValidationService.js
================================================================================

/**
 * ARCHITECTURE: ValidationService provides basic, potentially country-specific,
 * validation rules for address fields. Adheres to SRP by isolating validation logic.
 * This is a basic stub implementation; enhance with actual rules as needed.
 */
export class ValidationService {
    constructor(countryCode = "PL") {
        this.countryCode = countryCode.toUpperCase();
        // Basic required fields for PL example
        this.requiredFields = ["street", "postalCode", "city", "country"];
        // Basic regex for PL postal code example
        this.postalRegex = /^\d{2}-\d{3}$/;
    }

    /**
     * Validates an address object based on configured rules.
     * @param {object} address - The address object to validate (e.g., { street, postalCode, city, country }).
     * @returns {{valid: boolean, errors: object}} - Validation result.
     */
    validate(address) {
        const errors = {};
        let valid = true;

        if (!address) {
            return { valid: false, errors: { general: "Address object is missing." } };
        }

        // Check required fields
        for (const field of this.requiredFields) {
            if (!address[field] || String(address[field]).trim() === "") {
                errors[field] = `${field} is required.`;
                valid = false;
            }
        }

        // Check postal code format (example for PL)
        if (this.countryCode === "PL" && address.postalCode && !this.postalRegex.test(String(address.postalCode).trim())) {
            errors.postalCode = "Invalid postal code format (expected XX-XXX).";
            valid = false;
        }

        // Add more specific validation rules here (length, character sets, etc.)

        return { valid, errors };
    }
}

================================================================================
### PLIK: stores\addressUploadStore.js
================================================================================

import { defineStore } from 'pinia';
import apiClient from '@/services/api';

export const useAddressUploadStore = defineStore('addressUpload', {
  state: () => ({
    jobs: {}, // Będzie przechowywać statusy zadań, np. { 'jobId': { status: 'PROCESSING', ... } }
    isLoading: false,
    error: null,
  }),
  getters: {
    // Getter do pobierania zadań jako posortowana lista (najnowsze pierwsze)
    jobList: (state) => {
      return Object.values(state.jobs).sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    },
  },
  actions: {
    async uploadFile(file) {
      if (!file) {
        this.error = 'No file selected.';
        return;
      }
      this.isLoading = true;
      this.error = null;

      const formData = new FormData();
      formData.append('file', file);

      try {
        const response = await apiClient.post('/api/address-upload', formData, {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        });
        
        const { jobId } = response.data;
        if (jobId) {
          // Inicjalizuj status zadania i zacznij go śledzić
          this.jobs[jobId] = {
            jobId,
            originalFilename: file.name,
            status: 'PENDING',
            progress: 0,
            createdAt: new Date().toISOString()
          };
          this.pollJobStatus(jobId);
        }
      } catch (err) {
        console.error('File upload failed:', err);
        this.error = err.response?.data?.error || 'File upload failed.';
      } finally {
        this.isLoading = false;
      }
    },

    async pollJobStatus(jobId) {
      const intervalId = setInterval(async () => {
        try {
          const response = await apiClient.get(`/api/address-upload/jobs/${jobId}`);
          const jobData = response.data;
          
          // Aktualizuj status zadania w store
          this.jobs[jobId] = { ...this.jobs[jobId], ...jobData };

          // Zatrzymaj śledzenie, jeśli status jest końcowy
          if (['COMPLETED', 'FAILED_WITH_ERRORS'].includes(jobData.status)) {
            clearInterval(intervalId);
          }
        } catch (error) {
          console.error(`Failed to fetch status for job ${jobId}:`, error);
          this.jobs[jobId].status = 'POLLING_ERROR';
          this.jobs[jobId].errorDetails = 'Could not fetch job status.';
          clearInterval(intervalId);
        }
      }, 3000); // Sprawdzaj status co 3 sekundy
    },
  },
});

================================================================================
### PLIK: stores\authStore.js
================================================================================

// PLIK: src/stores/authStore.js
import { defineStore } from 'pinia';
import apiClient from '@/services/api';
import { jwtDecode } from 'jwt-decode';

/**
 * ARCHITEKTURA: Magazyn stanu (Pinia Store) odpowiedzialny za uwierzytelnianie i autoryzację.
 * Nie zależy od routera; komponenty nawigują po udanym logowaniu.
 */
export const useAuthStore = defineStore('auth', {
  state: () => ({
    accessToken: localStorage.getItem('accessToken') || null,
    refreshTokenValue: localStorage.getItem('refreshToken') || null,
    user: JSON.parse(localStorage.getItem('user')) || null,
    _isInitialized: false,
  }),
  getters: {
    isAuthenticated: (state) => !!state.accessToken,
  },
  actions: {
    async login(credentials) {
      try {
        const response = await apiClient.post('/auth/login', credentials);
        const { accessToken, refreshToken, username, roles } = response.data;

        this.accessToken = accessToken;
        this.refreshTokenValue = refreshToken;
        this.user = { username, roles };

        localStorage.setItem('accessToken', accessToken);
        localStorage.setItem('refreshToken', refreshToken);
        localStorage.setItem('user', JSON.stringify({ username, roles }));

        return true;
      } catch (error) {
        this.logout();
        console.error("Błąd logowania:", error);
        throw new Error('Logowanie nie powiodło się. Sprawdź login i hasło.');
      }
    },

    async refreshToken() {
      if (!this.refreshTokenValue) {
        throw new Error("Brak refresh tokena do odświeżenia sesji.");
      }
      const response = await apiClient.post('/auth/refresh', { refreshToken: this.refreshTokenValue });
      const { accessToken } = response.data;
      this.accessToken = accessToken;
      localStorage.setItem('accessToken', accessToken);
      return accessToken;
    },

    logout() {
      this.accessToken = null;
      this.refreshTokenValue = null;
      this.user = null;
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
      localStorage.removeItem('user');
    },

    initializeAuth() {
      if (this.accessToken) {
        try {
          const decodedToken = jwtDecode(this.accessToken);
          if (decodedToken.exp * 1000 < Date.now()) {
            console.warn("Token wygasł przy inicjalizacji. Wylogowywanie.");
            this.logout();
          }
        } catch (error) {
          console.error("Błąd dekodowania tokena. Token jest nieprawidłowy. Wylogowywanie.", error);
          this.logout();
        }
      }
      this._isInitialized = true;
    }
  },
});


================================================================================
### PLIK: stores\EditorSessionStore.js
================================================================================

/**
 * ARCHITECTURE: EditorSessionStore preserves cross-view context for the Correction Editor.
 * It follows the manifesto by providing a simple, framework-agnostic state carrier.
 * Responsibilities:
 * - Remember the last worklist filter snapshot and the current orderId under edit.
 * - Expose methods to persist/restore navigation context and support "Save & Next".
 */
export class EditorSessionStore {
  constructor() {
    this.lastFilterSnapshot = null;
    this.currentOrderId = null;
  }

  setFilterSnapshot(snapshot) {
    this.lastFilterSnapshot = snapshot ? { ...snapshot } : null;
    return this.lastFilterSnapshot;
  }

  setCurrentOrder(orderId) {
    this.currentOrderId = orderId || null;
    return this.currentOrderId;
  }

  clear() {
    this.lastFilterSnapshot = null;
    this.currentOrderId = null;
  }

  snapshot() {
    return {
      lastFilterSnapshot: this.lastFilterSnapshot,
      currentOrderId: this.currentOrderId,
    };
  }
}


================================================================================
### PLIK: stores\invoicingRulesStore.js
================================================================================

import { defineStore } from 'pinia';
import apiClient from '@/services/api.js'; // Using your existing API client [cite: 26, 30]

export const useInvoicingRulesStore = defineStore('invoicingRules', {
  state: () => ({
    hubRules: [],
    isLoading: false,
    error: null,
  }),
  getters: {
    // A getter to return rules, perhaps sorted by HUB name
    sortedHubRules: (state) => {
      return [...state.hubRules].sort((a, b) => a.hubId.localeCompare(b.hubId));
    },
  },
  actions: {
    async fetchHubRules() {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.get('/api/admin/invoicing-rules?ruleType=INTERIOR');
        this.hubRules = response.data;
      } catch (err) {
        this.error = 'Failed to fetch HUB rules.';
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async saveRule(rule) {
      this.isLoading = true;
      this.error = null;
      try {
        if (rule.id) {
          // Update existing rule
          await apiClient.put(`/api/admin/invoicing-rules/${rule.id}`, rule);
        } else {
          // Create new rule
          await apiClient.post('/api/admin/invoicing-rules', rule);
        }
        // Refresh the list after saving
        await this.fetchHubRules();
      } catch (err) {
        this.error = 'Failed to save rule.';
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async deleteRule(ruleId) {
      this.isLoading = true;
      this.error = null;
      try {
        await apiClient.delete(`/api/admin/invoicing-rules/${ruleId}`);
        // Refresh the list after deleting
        await this.fetchHubRules();
      } catch (err) {
        this.error = 'Failed to delete rule.';
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },
  },
});

================================================================================
### PLIK: stores\processingErrorsStore.js
================================================================================

// PLIK: src/stores/processingErrorsStore.js (NOWY PLIK)

import { defineStore } from 'pinia';
import apiClient from '@/services/api';

/**
 * ARCHITEKTURA: Dedykowany magazyn stanu (Pinia Store) dla zarządzania błędami przetwarzania.
 * Hermetyzuje całą logikę biznesową związaną z pobieraniem, filtrowaniem i ponawianiem
 * błędnych zleceń, komunikując się z backendem przez ujednolicony apiClient.
 */
export const useProcessingErrorsStore = defineStore('processingErrors', {
  state: () => ({
    errors: [],
    pagination: {
      page: 0,
      size: 15,
      totalElements: 0,
      totalPages: 0,
    },
    currentErrorDetails: null,
    isLoading: false,
    error: null,
  }),
  actions: {
    async fetchProcessingErrors(params) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.get('/processing-errors', { params });
        this.errors = response.data.content;
        this.pagination = {
          page: response.data.number,
          size: response.data.size,
          totalElements: response.data.totalElements,
          totalPages: response.data.totalPages,
        };
      } catch (err) {
        this.error = "Nie udało się pobrać błędów przetwarzania.";
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async fetchErrorDetails(errorId) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.get(`/processing-errors/${errorId}`);
        this.currentErrorDetails = response.data;
      } catch (err) {
        this.error = `Nie udało się pobrać szczegółów błędu o ID ${errorId}.`;
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async resubmitCorrectedOrder(eventId, resubmitPayload) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.post(`/processing-errors/${eventId}/resubmit`, resubmitPayload);
        // Po udanym ponowieniu można odświeżyć listę
        await this.fetchProcessingErrors({ page: this.pagination.page, size: this.pagination.size });
        return response.data;
      } catch (err) {
        this.error = "Ponowne przetworzenie zlecenia nie powiodło się.";
        console.error(err);
        throw err; // Rzuć błąd dalej, aby komponent mógł na niego zareagować
      } finally {
        this.isLoading = false;
      }
    },
  },
});

================================================================================
### PLIK: stores\WorklistStore.js
================================================================================

import { defineStore } from 'pinia';
import { WorklistFilter } from "@/domain/WorklistFilter";
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";
// REMOVED: import { OrdersQueueService } from "@/services/OrdersQueueService"; // Queue logic decoupled

/**
 * ARCHITECTURE: Pinia store for managing the state of the Address Exception Worklist.
 * Encapsulates filters, pagination, items, selection, loading/error state,
 * and actions for interacting with the backend API (AddressExceptionApi).
 * Provides getters for derived state and actions for mutations and async operations.
 */
export const useWorklistStore = defineStore('worklist', {
    state: () => ({
        filter: new WorklistFilter(), // Use domain object for filter state
        items: [],
        pagination: {
            currentPage: 1, // Use 1-based indexing for UI
            itemsPerPage: 25,
            totalItems: 0,
            totalPages: 0,
        },
        selection: [], // Array of selected order IDs
        loading: false,
        error: null, // Stores error message string or Error object
    }),
    getters: {
        /** Checks if a specific order ID is currently selected. */
        isSelected: (state) => (orderId) => {
            return state.selection.includes(orderId);
        },
        /** Returns the current filter object. */
        currentFilter: (state) => {
            // Return a defensive copy if modification outside store is a concern
            return { ...state.filter };
        },
        /** Returns current pagination info. */
        currentPageInfo: (state) => {
            return { ...state.pagination };
        },
        /** Returns the count of selected items. */
        selectedCount: (state) => {
            return state.selection.length;
        }
    },
    actions: {
        // Internal helper to get API instance
        _getApi() {
            // In real app, manage API client instance appropriately (e.g., singleton)
            return new AddressExceptionApi();
        },

        /**
         * Loads a page of worklist items based on the current filter and pagination state.
         * Updates items, pagination, loading, and error state. Automatically clears selection.
         * @returns {Promise<Result<void, Error>>} Result indicating success or failure.
         */
        async loadPage() {
            this.loading = true;
            this.error = null;
            // Clear selection when loading/reloading data
            this.clearSelection();
            const api = this._getApi();
            try {
                // Prepare parameters for the backend API call
                const filterParams = {
                    ...this.filter.toQueryRecord(), // Convert filter object to query params
                    // Convert UI page (1-based) to backend page (0-based)
                    page: this.pagination.currentPage > 0 ? this.pagination.currentPage - 1 : 0,
                    size: this.pagination.itemsPerPage,
                    // Ensure status is always passed, default if not in filter
                    status: this.filter.status || 'ADDRESS_NEEDS_REVIEW'
                };
                // Remove null/undefined values from params if backend expects clean query
                Object.keys(filterParams).forEach(key => (filterParams[key] == null || filterParams[key] === '') && delete filterParams[key]);


                const result = await api.getWorklist(filterParams);

                if (result.ok) {
                    this.items = result.value.items || [];
                    this.pagination.totalItems = result.value.total || 0;
                    this.pagination.totalPages = Math.ceil(this.pagination.totalItems / this.pagination.itemsPerPage) || 1; // Ensure at least 1 page
                    // Ensure current page is valid after reload
                    if (this.pagination.currentPage > this.pagination.totalPages) {
                        this.pagination.currentPage = this.pagination.totalPages;
                    }
                    return Result.ok();
                } else {
                    throw result.error; // Throw error from Result.fail
                }
            } catch (err) {
                console.error("Failed to load worklist page:", err);
                this.error = err.message || "Failed to load worklist."; // Store error message
                this.items = []; // Clear items on error
                this.pagination.totalItems = 0;
                this.pagination.totalPages = 1;
                this.pagination.currentPage = 1; // Reset page on error
                return Result.fail(err);
            } finally {
                this.loading = false;
            }
        },

        /**
         * Updates the filter state with a patch and reloads the first page.
         * @param {object} patch - Partial filter object (e.g., { barcode: '123' }).
         */
        async applyFilterPatch(patch) {
            this.pagination.currentPage = 1; // Reset to page 1 on filter change
            this.filter = this.filter.withPatch(patch || {}); // Ensure patch is applied safely
            await this.loadPage(); // Reload data
        },

        /**
         * Resets the filter to defaults and reloads the first page.
         */
        async resetFilter() {
            this.filter = new WorklistFilter(); // Create new default filter
            this.pagination.currentPage = 1;
            await this.loadPage();
        },

        /**
         * Navigates to a specific page number and reloads data.
         * @param {number} pageNumber - The 1-based page number.
         */
        async goToPage(pageNumber) {
            const newPage = Math.max(1, Math.min(pageNumber, this.pagination.totalPages || 1));
            if (newPage !== this.pagination.currentPage) {
                this.pagination.currentPage = newPage;
                await this.loadPage();
            }
        },

        /**
         * Changes the number of items per page and reloads the first page.
         * @param {number} size - The new page size.
         */
        async changePageSize(size) {
            const newSize = Math.max(5, size); // Min size 5
            if (newSize !== this.pagination.itemsPerPage) {
                this.pagination.itemsPerPage = newSize;
                this.pagination.currentPage = 1; // Reset to page 1
                await this.loadPage();
            }
        },

        // --- Selection Actions ---
        /** Toggles the selection state of a single order ID. */
        toggleSelection(orderId) {
            const index = this.selection.indexOf(orderId);
            if (index > -1) {
                this.selection.splice(index, 1);
            } else {
                this.selection.push(orderId);
            }
        },
        /** Sets the selection to the provided array of order IDs. */
        setSelection(orderIds) {
            if (Array.isArray(orderIds)) {
                // Ensure unique IDs if needed
                this.selection = [...new Set(orderIds)];
            }
        },
        /** Clears the current selection. */
        clearSelection() {
            this.selection = [];
        },
        /** Selects all items currently loaded on the page. */
        selectAllOnPage() {
            this.selection = this.items.map(item => item.orderId);
        },

        // --- Bulk Actions (Placeholders) ---
        // async bulkPreview(plan) { /* ... */ },
        // async bulkApply(plan) { /* ... */ },
    },
});

================================================================================
### PLIK: tests\example.spec.js
================================================================================

// src/tests/example.spec.js
import { describe, it, expect } from 'vitest';

// Example basic test to ensure Vitest setup is working
describe('Basic Math', () => {
    it('should add two numbers correctly', () => {
        expect(1 + 1).toBe(2);
    });

    it('should handle floating point numbers', () => {
        expect(0.1 + 0.2).toBeCloseTo(0.3);
    });
});

// Example test for a simple utility function (if you had one)
/*
import { simpleUtilFunction } from '@/utils/helpers'; // Assuming a helper exists

describe('simpleUtilFunction', () => {
    it('should return uppercase', () => {
        expect(simpleUtilFunction('hello')).toBe('HELLO');
    });

     it('should handle empty string', () => {
        expect(simpleUtilFunction('')).toBe('');
    });
});
*/

================================================================================
### PLIK: viewmodels\DiffPresenter.js
================================================================================

/**
 * ARCHITECTURE: DiffPresenter formats DiffService output into UI-ready rows with labels.
 * It follows the manifesto by separating presentation decisions from diff computation.
 * Responsibilities:
 * - Map diff entries to rows; provide changed count and stable labels.
 */
export class DiffPresenter {
  constructor() {
    this.labels = {
      street: "Street",
      houseNumber: "House No.",
      postalCode: "Postal",
      city: "City",
      country: "Country",
      latitude: "Latitude",
      longitude: "Longitude",
    };
  }

  present(diffResult) {
    const entries = Array.isArray(diffResult?.entries) ? diffResult.entries : [];
    const rows = entries.map(e => ({
      field: e.field,
      label: this.labels[e.field] || e.field,
      before: e.before ?? null,
      after: e.after ?? null,
      changed: !!e.changed,
    }));
    const changed = rows.filter(r => r.changed).length;
    return { rows, changed };
  }
}


================================================================================
### PLIK: viewmodels\ErrorBannerViewModel.js
================================================================================

/**
 * ARCHITECTURE: ErrorBannerViewModel formats technical errors into concise, user-facing banner messages.
 * It follows the manifesto by separating message mapping and ensuring deterministic display content.
 * Responsibilities:
 * - Map common categories to short titles and detailed descriptions.
 * - Provide a stable shape consumable by any banner/toast component.
 */
export class ErrorBannerViewModel {
  constructor(error) {
    this.error = error instanceof Error ? error : new Error(String(error || "Unknown error"));
    this.title = this._titleFor(this.error);
    this.detail = this._detailFor(this.error);
  }

  toObject() {
    return { title: this.title, detail: this.detail };
  }

  _titleFor(err) {
    const m = (err.message || "").toLowerCase();
    if (m.includes("network")) return "Network issue";
    if (m.includes("timeout")) return "Request timeout";
    if (m.includes("unauthorized") || m.includes("forbidden")) return "Access denied";
    if (m.includes("google")) return "Google maps error";
    return "Something went wrong";
  }

  _detailFor(err) {
    const msg = err.message || "Unexpected failure.";
    return msg.length > 180 ? msg.slice(0, 177) + "..." : msg;
  }
}


================================================================================
### PLIK: viewmodels\KpiViewModel.js
================================================================================

/**
 * ARCHITECTURE: KpiViewModel formats KPI values for dashboard tiles and badges.
 * It follows the manifesto by separating presentation formatting from calculation and transport.
 * Responsibilities:
 * - Hold raw numeric KPIs and expose formatted strings for UI consumption.
 */
export class KpiViewModel {
  constructor({ pending = 0, clearancePercent = 0, avgMinutes = 0 } = {}) {
    this.pending = Number(pending || 0);
    this.clearancePercent = Number(clearancePercent || 0);
    this.avgMinutes = Number(avgMinutes || 0);
  }

  pendingText() {
    return `${this.pending}`;
  }

  clearanceText() {
    if (!Number.isFinite(this.clearancePercent)) return "0.0%";
    return `${this.clearancePercent.toFixed(1)}%`;
  }

  avgResolutionText() {
    if (!Number.isFinite(this.avgMinutes)) return "—";
    if (this.avgMinutes < 60) return `${Math.round(this.avgMinutes)} min`;
    const h = Math.floor(this.avgMinutes / 60);
    const m = Math.round(this.avgMinutes % 60);
    return `${h}h ${m}m`;
  }
}


================================================================================
### PLIK: viewmodels\StatusBadgeViewModel.js
================================================================================

/**
 * ARCHITECTURE: StatusBadgeViewModel converts processing status codes into stable badge shape for UI.
 * It follows the manifesto by separating presentation mapping from models and services.
 * Responsibilities:
 * - Map codes to {label,tone,icon} and provide a toObject() helper for templates.
 */
export class StatusBadgeViewModel {
  constructor(statusCode) {
    this.status = (statusCode || "").toUpperCase();
    this.map = {
      ADDRESS_NEEDS_REVIEW: { label: "Needs Review", tone: "warning", icon: "alert-triangle" },
      ADDRESS_VALIDATED: { label: "Validated", tone: "success", icon: "check-circle" },
      MANUALLY_CORRECTED: { label: "Corrected", tone: "success", icon: "edit-3" },
      PENDING_ADDRESS_VALIDATION: { label: "Pending", tone: "info", icon: "clock" },
      FAILED: { label: "Failed", tone: "danger", icon: "x-circle" },
    };
  }

  toObject() {
    return this.map[this.status] || { label: this.status || "Unknown", tone: "neutral", icon: "help-circle" };
  }
}


================================================================================
### PLIK: viewmodels\VerificationProgressViewModel.js
================================================================================

/**
 * ARCHITECTURE: VerificationProgressViewModel translates workflow milestones into a stable progress model.
 * It follows the manifesto by separating presentation state from controllers and network logic.
 * Responsibilities:
 * - Track phases (normalize, validate, geocode, suggest, merge, save) and compute % complete deterministically.
 * - Provide immutable snapshots for progress bars or step indicators.
 */
export class VerificationProgressViewModel {
  constructor() {
    this.steps = [
      { key: "normalize", done: false },
      { key: "validate", done: false },
      { key: "geocode", done: false },
      { key: "suggest", done: false },
      { key: "merge", done: false },
      { key: "save", done: false },
    ];
  }

  mark(key, done = true) {
    const idx = this.steps.findIndex(s => s.key === key);
    if (idx >= 0) this.steps[idx].done = !!done;
    return this.snapshot();
  }

  percent() {
    const total = this.steps.length || 1;
    const done = this.steps.filter(s => s.done).length;
    return Math.round((done / total) * 100);
  }

  reset() {
    for (const s of this.steps) s.done = false;
    return this.snapshot();
  }

  snapshot() {
    return { steps: this.steps.map(s => ({ key: s.key, done: s.done })), percent: this.percent() };
  }
}


================================================================================
### PLIK: viewmodels\VerificationStatusViewModel.js
================================================================================

