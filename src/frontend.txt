
================================================================================
### PLIK: main.js
================================================================================

/**
 * ARCHITECTURE: main.js bootstraps auth + env + orchestrator, builds router, and mounts a clean root.
 * Responsibilities:
 * - Install Pinia, hydrate Auth, build router, mount a single root that renders <router-view/>.
 */
import { createApp, h, provide } from "vue";
import { createPinia } from "pinia";
import "@/assets/main.css";
import { AppBootstrapController } from "@/controllers/AppBootstrapController";
import { createRouterWithKey } from "@/router/index";
import { AuthController } from "@/controllers/AuthController";

(async () => {
  const pinia = createPinia();

  const auth = new AuthController();
  auth.hydrateFromStorage();

  const bootstrap = new AppBootstrapController();
  const boot = await bootstrap.bootstrap();
  const router = createRouterWithKey(boot.googleKey);

  const Root = {
    name: "Root",
    setup() {
      provide("auth", auth);
      provide("orchestrator", boot.orchestrator);
      provide("googleKey", boot.googleKey);
      provide("health", boot.health);
      return () => h("router-view");
    },
  };

  const app = createApp(Root);

  app.config.errorHandler = (err, _instance, _info) => {
    console.error("[vue-error]", err);
  };
  window.addEventListener("error", (e) => {
    console.error("[window-error]", e?.error || e?.message || e);
  });

  app.use(pinia);
  app.use(router);
  app.mount("#app");
})();


================================================================================
### PLIK: adapters\GoogleGeocodingAdapter.js
================================================================================

/**
 * ARCHITECTURE: GoogleGeocodingAdapter wraps the Maps JS Geocoder into a provider-agnostic API.
 * It follows the manifesto by providing a single responsibility: address → {lat,lon,normalizedFields}.
 * Responsibilities:
 * - Accept Address-like input and call google.maps.Geocoder.
 * - Normalize results into a plain object usable by the Editor (street, houseNumber, postalCode, city, country, lat, lon).
 */
export class GoogleGeocodingAdapter {
  constructor(googleObj) {
    this.google = googleObj;
    this.geocoder = new this.google.maps.Geocoder();
  }

  async geocodeAddress(address) {
    if (!address || !address.street || !address.postalCode || !address.city) {
      return null;
    }
    const line1 = address.houseNumber ? `${address.street} ${address.houseNumber}` : address.street;
    const country = address.country || "PL";
    const query = `${line1}, ${address.postalCode} ${address.city}, ${country}`;
    const res = await this.geocoder.geocode({ address: query });
    if (!res || !Array.isArray(res.results) || res.results.length === 0) {
      return null;
    }
    const best = res.results[0];
    const components = this._indexComponents(best.address_components || []);
    const normalized = {
      street: components.route || address.street,
      houseNumber: components.street_number || address.houseNumber || null,
      postalCode: components.postal_code || address.postalCode,
      city: components.locality || components.postal_town || components.administrative_area_level_2 || address.city,
      country: components.country_code || country,
      latitude: best.geometry?.location?.lat?.() ?? null,
      longitude: best.geometry?.location?.lng?.() ?? null,
    };
    return normalized;
  }

  _indexComponents(parts) {
    const map = {};
    for (const c of parts) {
      for (const t of c.types) {
        if (t === "country") {
          map.country = c.long_name;
          map.country_code = c.short_name;
        } else if (t === "locality") {
          map.locality = c.long_name;
        } else if (t === "postal_town") {
          map.postal_town = c.long_name;
        } else if (t === "administrative_area_level_2") {
          map.administrative_area_level_2 = c.long_name;
        } else if (t === "route") {
          map.route = c.long_name;
        } else if (t === "street_number") {
          map.street_number = c.long_name;
        } else if (t === "postal_code") {
          map.postal_code = c.long_name;
        }
      }
    }
    return map;
  }
}


================================================================================
### PLIK: adapters\GoogleMapAdapter.js
================================================================================

/**
 * ARCHITECTURE: GoogleMapAdapter provides a concrete map implementation for MapController using Google Maps JS API.
 * It follows the manifesto by encapsulating all vendor-specific map calls behind a small, explicit interface.
 * Responsibilities:
 * - Create/destroy a map instance, set center/zoom, and manage a single primary marker.
 * - Avoid leaking Google objects to callers; expose only success/failure via resolved promises.
 */
export class GoogleMapAdapter {
  constructor(googleObj) {
    if (!googleObj || !googleObj.maps) throw new Error("GoogleMapAdapter: google maps object required.");
    this.google = googleObj;
    this._map = null;
    this._marker = null;
  }

  async create(container, options) {
    if (!container) throw new Error("GoogleMapAdapter.create: container is required.");
    const center = { lat: options?.lat ?? 52.2297, lng: options?.lon ?? 21.0122 };
    const zoom = options?.zoom ?? 12;
    this._map = new this.google.maps.Map(container, { center, zoom, mapTypeControl: false, streetViewControl: false });
    this._marker = new this.google.maps.Marker({ position: center, map: this._map });
    return true;
  }

  async setCenter(lat, lon, zoom) {
    if (!this._map) throw new Error("GoogleMapAdapter.setCenter: map not created.");
    const center = { lat, lng: lon };
    this._map.setCenter(center);
    if (typeof zoom === "number") this._map.setZoom(zoom);
    return true;
  }

  async setMarker(lat, lon) {
    if (!this._map || !this._marker) throw new Error("GoogleMapAdapter.setMarker: map not created.");
    const pos = { lat, lng: lon };
    this._marker.setPosition(pos);
    return true;
  }

  async fit(lat, lon) {
    if (!this._map) throw new Error("GoogleMapAdapter.fit: map not created.");
    const bounds = new this.google.maps.LatLngBounds();
    bounds.extend(new this.google.maps.LatLng(lat, lon));
    this._map.fitBounds(bounds, 64);
    return true;
  }

  async destroy() {
    if (this._marker) {
      this._marker.setMap(null);
      this._marker = null;
    }
    if (this._map) {
      this._map = null;
    }
    return true;
  }
}


================================================================================
### PLIK: adapters\GoogleMapsScriptLoader.js
================================================================================

/**
 * ARCHITECTURE: GoogleMapsScriptLoader ensures exactly-once loading of the Google Maps JS API.
 * It follows the manifesto by isolating third-party script lifecycle and exposing a minimal contract.
 * Responsibilities:
 * - Load the script with an API key and optional libraries only once per app session.
 * - Resolve when window.google is available; reject on network or auth errors.
 */
export class GoogleMapsScriptLoader {
  constructor() {
    this._promise = null;
    this._loadedKey = null;
    this._loadedLibsKey = null;
  }

  load(apiKey, libraries = []) {
    if (!apiKey || typeof apiKey !== "string") {
      return Promise.reject(new Error("GoogleMapsScriptLoader: missing apiKey."));
    }
    const libs = Array.isArray(libraries) ? libraries.slice().sort() : [];
    const libsKey = libs.join(",");
    if (this._promise && this._loadedKey === apiKey && this._loadedLibsKey === libsKey) {
      return this._promise;
    }
    if (typeof window !== "undefined" && window.google && window.google.maps) {
      this._promise = Promise.resolve(window.google);
      this._loadedKey = apiKey;
      this._loadedLibsKey = libsKey;
      return this._promise;
    }
    const src = new URL("https://maps.googleapis.com/maps/api/js");
    src.searchParams.set("key", apiKey);
    if (libs.length) src.searchParams.set("libraries", libsKey);
    src.searchParams.set("v", "weekly");
    this._promise = new Promise((resolve, reject) => {
      const s = document.createElement("script");
      s.src = src.toString();
      s.async = true;
      s.defer = true;
      s.onerror = () => reject(new Error("Google Maps script failed to load."));
      s.onload = () => {
        if (window.google && window.google.maps) {
          this._loadedKey = apiKey;
          this._loadedLibsKey = libsKey;
          resolve(window.google);
        } else {
          reject(new Error("Google Maps script loaded but window.google is undefined."));
        }
      };
      document.head.appendChild(s);
    });
    return this._promise;
  }
}


================================================================================
### PLIK: adapters\GooglePlacesAutocompleteAdapter.js
================================================================================

/**
 * ARCHITECTURE: GooglePlacesAutocompleteAdapter wraps Places Autocomplete for type-ahead address hints.
 * It follows the manifesto by isolating vendor-specific API calls and returning normalized suggestion DTOs.
 * Responsibilities:
 * - Create and reuse a session token, query AutocompleteService, and detail lookup for precise fields.
 * - Normalize results into street, houseNumber, postalCode, city, country, latitude, longitude.
 */
export class GooglePlacesAutocompleteAdapter {
  constructor(googleObj) {
    if (!googleObj || !googleObj.maps) throw new Error("GooglePlacesAutocompleteAdapter: google maps object required.");
    this.google = googleObj;
    this.service = new this.google.maps.places.AutocompleteService();
    this.details = new this.google.maps.places.PlacesService(document.createElement("div"));
    this.sessionToken = new this.google.maps.places.AutocompleteSessionToken();
  }

  async suggest(text, country = "PL") {
    if (!text || !text.trim()) return [];
    const r = await this._getPredictions(text, country);
    const picks = Array.isArray(r) ? r.slice(0, 5) : [];
    const enriched = [];
    for (const p of picks) {
      const d = await this._getDetails(p.place_id);
      if (d) {
        enriched.push(d);
      }
    }
    return enriched;
  }

  async _getPredictions(input, country) {
    return new Promise((resolve, reject) => {
      this.service.getPlacePredictions(
        { input, sessionToken: this.sessionToken, componentRestrictions: { country } },
        (predictions, status) => {
          if (status !== this.google.maps.places.PlacesServiceStatus.OK || !predictions) return resolve([]);
          resolve(predictions);
        }
      );
    });
  }

  async _getDetails(placeId) {
    return new Promise((resolve) => {
      this.details.getDetails({ placeId, sessionToken: this.sessionToken, fields: ["address_components", "geometry"] }, (place, status) => {
        if (status !== this.google.maps.places.PlacesServiceStatus.OK || !place) return resolve(null);
        const comps = this._indexComponents(place.address_components || []);
        resolve({
          fullAddressLabel: null,
          street: comps.route || null,
          houseNumber: comps.street_number || null,
          postalCode: comps.postal_code || null,
          city: comps.locality || comps.postal_town || comps.administrative_area_level_2 || null,
          countryCode: comps.country_code || null,
          countryName: comps.country || null,
          latitude: place.geometry?.location?.lat?.() ?? null,
          longitude: place.geometry?.location?.lng?.() ?? null,
          matchScore: 0.9,
          matchLevel: "PLACES",
          providerSource: "GOOGLE_PLACES",
        });
      });
    });
  }

  _indexComponents(parts) {
    const map = {};
    for (const c of parts) {
      for (const t of c.types) {
        if (t === "country") {
          map.country = c.long_name;
          map.country_code = c.short_name;
        } else if (t === "locality") {
          map.locality = c.long_name;
        } else if (t === "postal_town") {
          map.postal_town = c.long_name;
        } else if (t === "administrative_area_level_2") {
          map.administrative_area_level_2 = c.long_name;
        } else if (t === "route") {
          map.route = c.long_name;
        } else if (t === "street_number") {
          map.street_number = c.long_name;
        } else if (t === "postal_code") {
          map.postal_code = c.long_name;
        }
      }
    }
    return map;
  }
}


================================================================================
### PLIK: adapters\GooglePlacesSessionManager.js
================================================================================


================================================================================
### PLIK: adapters\GoogleRuntime.js
================================================================================

/**
 * ARCHITECTURE: GoogleRuntime caches a single Google Maps JS instance and constructs common adapters on demand.
 * It follows the manifesto by preventing duplicate script loads and centralizing third-party object reuse.
 * Responsibilities:
 * - Load and memoize window.google, expose factories for Map, Geocoder, and Places adapters.
 * - Guard callers against uninitialized usage with explicit init().
 */
import { GoogleMapsScriptLoader } from "@/adapters/GoogleMapsScriptLoader";
import { GoogleMapAdapter } from "@/adapters/GoogleMapAdapter";
import { GoogleGeocodingAdapter } from "@/adapters/GoogleGeocodingAdapter";
import { GooglePlacesAutocompleteAdapter } from "@/adapters/GooglePlacesAutocompleteAdapter";

export class GoogleRuntime {
  constructor() {
    this._loader = new GoogleMapsScriptLoader();
    this._google = null;
  }

  async init(apiKey, libraries = ["places"]) {
    if (this._google) return this._google;
    this._google = await this._loader.load(apiKey, libraries);
    return this._google;
  }

  mapAdapter() {
    if (!this._google) throw new Error("GoogleRuntime: not initialized.");
    return new GoogleMapAdapter(this._google);
  }

  geocodingAdapter() {
    if (!this._google) throw new Error("GoogleRuntime: not initialized.");
    return new GoogleGeocodingAdapter(this._google);
  }

  placesAdapter() {
    if (!this._google) throw new Error("GoogleRuntime: not initialized.");
    return new GooglePlacesAutocompleteAdapter(this._google);
  }
}


================================================================================
### PLIK: adapters\MapGeocoderAdapter.js
================================================================================

/**
 * ARCHITECTURE: MapGeocoderAdapter abstracts a geocoding function behind a stable contract.
 * It follows the manifesto by isolating vendor-specific logic and exposing a single responsibility.
 * Responsibilities:
 * - Accept an Address-like DTO and delegate to an injected geocode function.
 * - Return a normalized { lat, lon } object or null without leaking provider details.
 */
export class MapGeocoderAdapter {
  constructor(geocodeFn) {
    if (typeof geocodeFn !== "function") throw new Error("MapGeocoderAdapter: geocode function required.");
    this.geocodeFn = geocodeFn;
  }

  async geocodeAddress(address) {
    if (!address || typeof address !== "object") return null;
    const r = await this.geocodeFn({
      street: address.street,
      houseNumber: address.houseNumber ?? null,
      postalCode: address.postalCode,
      city: address.city,
      country: address.country || "PL",
    });
    if (!r || typeof r.lat !== "number" || typeof r.lon !== "number") return null;
    return { lat: r.lat, lon: r.lon };
  }
}


================================================================================
### PLIK: assets\main.css
================================================================================

@tailwind base;
@tailwind components;
@tailwind utilities;


================================================================================
### PLIK: bootstrap\GoogleAddressVerificationBootstrap.js
================================================================================

/**
 * ARCHITECTURE: GoogleAddressVerificationBootstrap initializes Google runtime, map, and adapters for the editor.
 * It follows the manifesto by centralizing third-party setup and returning ready-to-use controllers/adapters.
 * Responsibilities:
 * - Load Google script, create MapController with GoogleMapAdapter, and provide geocoder + places adapters.
 */
import { GoogleMapsScriptLoader } from "@/adapters/GoogleMapsScriptLoader";
import { GoogleMapAdapter } from "@/adapters/GoogleMapAdapter";
import { GoogleGeocodingAdapter } from "@/adapters/GoogleGeocodingAdapter";
import { GooglePlacesAutocompleteAdapter } from "@/adapters/GooglePlacesAutocompleteAdapter";
import { MapController } from "@/controllers/MapController";

export class GoogleAddressVerificationBootstrap {
  constructor(loader = new GoogleMapsScriptLoader()) {
    this.loader = loader;
    this.google = null;
    this.mapController = null;
    this.geocoderAdapter = null;
    this.placesAdapter = null;
  }

  async init(mapContainerEl, apiKey) {
    this.google = await this.loader.load(apiKey, ["places"]);
    const mapAdapter = new GoogleMapAdapter(this.google);
    this.mapController = new MapController(mapAdapter);
    await this.mapController.init(mapContainerEl, { lat: 52.2297, lon: 21.0122, zoom: 12 });
    this.geocoderAdapter = new GoogleGeocodingAdapter(this.google);
    this.placesAdapter = new GooglePlacesAutocompleteAdapter(this.google);
    return {
      google: this.google,
      mapController: this.mapController,
      geocoderAdapter: this.geocoderAdapter,
      placesAdapter: this.placesAdapter,
    };
  }
}


================================================================================
### PLIK: controllers\AddressFormController.js
================================================================================

/**
 * ARCHITECTURE: AddressFormController coordinates field masking, editability rules, guard checks, and realtime verification.
 * It follows the manifesto by isolating input lifecycle from components and wiring existing services behind one API.
 * Responsibilities:
 * - Apply masks on change, consult AddressFieldGuard for editability, and gate verification with VerificationGuardController.
 * - Invoke RealtimeVerificationOrchestrator and MapViewportPolicyController to produce instant geocode + ranked hints.
 * - Expose a stable snapshot with input, validation, instant, suggestions, and busy flags for the view.
 */
import { AddressInputMaskService } from "@/services/AddressInputMaskService";
import { AddressFieldGuard } from "@/services/AddressFieldGuard";
import { VerificationGuardController } from "@/controllers/VerificationGuardController";
import { RealtimeVerificationOrchestrator } from "@/controllers/RealtimeVerificationOrchestrator";
import { MapViewportPolicyController } from "@/controllers/MapViewportPolicyController";
import { ValidationService } from "@/services/ValidationService";
import { AddressNormalizer } from "@/services/AddressNormalizer";

export class AddressFormController {
  constructor(geocodeWithCacheController, placesAdapter, mapController) {
    this.mask = new AddressInputMaskService("PL");
    this.guard = new AddressFieldGuard();
    this.verifyGuard = new VerificationGuardController();
    this.realtime = new RealtimeVerificationOrchestrator(geocodeWithCacheController, placesAdapter, 300);
    this.viewport = new MapViewportPolicyController(mapController);
    this.validator = new ValidationService("PL");
    this.normalizer = new AddressNormalizer();
    this.input = { street: "", houseNumber: "", postalCode: "", city: "", country: "PL" };
    this.validation = { valid: false, errors: {} };
    this.instant = null;
    this.suggestions = [];
    this.loading = false;
    this.error = null;
  }

  setField(field, value) {
    if (!this.guard.canEdit(field, { country: this.input.country })) return this.snapshot();
    if (field === "postalCode") this.input.postalCode = this.mask.maskPostal(value, this.input.country);
    else if (field === "street") this.input.street = this.mask.maskStreet(value);
    else if (field === "city") this.input.city = this.mask.maskCity(value);
    else if (field === "houseNumber") this.input.houseNumber = this.mask.maskHouseNo(value);
    else if (field === "country") this.input.country = String(value || "PL").toUpperCase();
    else this.input[field] = value;
    return this.snapshot();
  }

  async verifyIfReady() {
    const gate = this.verifyGuard.shouldVerify(this.input);
    if (!gate.allow) {
      this.loading = false;
      this.error = null;
      this.instant = null;
      this.suggestions = [];
      this.validation = this.validator.validate(this.normalizer.normalize(this.input));
      return this.snapshot();
    }
    this.loading = true;
    this.error = null;
    const res = await this.realtime.verify(this.input);
    this.loading = false;
    this.instant = res.instant || null;
    this.suggestions = Array.isArray(res.suggestions) ? res.suggestions : [];
    if (this.instant) await this.viewport.focusInstant({ ...this.instant, matchLevel: "GEOCODER" });
    this.validation = this.validator.validate(this.normalizer.normalize(this.input));
    return this.snapshot();
  }

  snapshot() {
    return {
      input: { ...this.input },
      validation: { ...this.validation },
      instant: this.instant ? { ...this.instant } : null,
      suggestions: this.suggestions.slice(),
      loading: this.loading,
      error: this.error,
    };
  }
}


================================================================================
### PLIK: controllers\AddressVerificationController.js
================================================================================

/**
 * ARCHITECTURE: AddressVerificationController orchestrates Google-first verification and TES-backed suggestions.
 * It follows the manifesto by isolating IO, retries, and provider alignment (set GOOGLE) behind simple methods.
 * Responsibilities:
 * - Ensure TES provider is set to GOOGLE via admin API.
 * - Trigger on-demand suggestions and poll operation status (Kafka-based flow).
 * - Perform instant client-side geocode with Google for live map feedback.
 * - Merge and return a unified suggestion list and a normalized best candidate for the Editor.
 */
import apiClient from "@/services/api";
import { GoogleMapsScriptLoader } from "@/adapters/GoogleMapsScriptLoader";
import { GoogleGeocodingAdapter } from "@/adapters/GoogleGeocodingAdapter";

export class AddressVerificationController {
  constructor() {
    this._google = null;
    this._mapsLoader = new GoogleMapsScriptLoader();
    this._geocoder = null;
    this.providerAligned = false;
    this.loading = false;
    this.error = null;
  }

  async alignProviderToGoogle() {
    try {
      const current = await apiClient.get("/api/admin/address-verification/providers/current");
      if (current?.data?.provider !== "GOOGLE") {
        await apiClient.post("/api/admin/address-verification/providers/current", "GOOGLE", {
          headers: { "Content-Type": "text/plain" },
        });
      }
      this.providerAligned = true;
      return true;
    } catch (e) {
      this.providerAligned = false;
      throw new Error("Failed to align TES provider to GOOGLE.");
    }
  }

  async initGoogle(apiKey, libraries = []) {
    this._google = await this._mapsLoader.load(apiKey, libraries);
    this._geocoder = new GoogleGeocodingAdapter(this._google);
    return true;
  }

  async geocodeInstant(addressDto) {
    if (!this._geocoder) throw new Error("Google not initialized.");
    const normalized = await this._geocoder.geocodeAddress(addressDto);
    return normalized;
  }

  async suggestOnDemand(addressQuery) {
    if (!addressQuery || Object.values(addressQuery).every(v => !v)) {
      return [];
    }
    const start = await apiClient.post("/api/admin/address-verification/suggest-on-demand", addressQuery);
    const correlationId = start?.data?.correlationId;
    if (!correlationId) throw new Error("Missing correlationId for suggest-on-demand.");
    const suggestions = await this._pollOperation(correlationId);
    return suggestions;
  }

  async searchByName(query) {
    if (!query || !query.trim()) {
      return [];
    }
    const start = await apiClient.post("/api/admin/address-verification/search-by-name", query, {
      headers: { "Content-Type": "text/plain" },
    });
    const correlationId = start?.data?.correlationId;
    if (!correlationId) throw new Error("Missing correlationId for search-by-name.");
    const suggestions = await this._pollOperation(correlationId);
    return suggestions;
  }

  async verifyAddressFlow(googleApiKey, addressDto) {
    this.loading = true;
    this.error = null;
    try {
      await this.alignProviderToGoogle(); /* aligns TES provider to GOOGLE. :contentReference[oaicite:0]{index=0} */
      await this.initGoogle(googleApiKey, ["geocoding"]);
      const instant = await this.geocodeInstant(addressDto);
      const backendSuggestions = await this.suggestOnDemand({
        street: addressDto.street || "",
        houseNumber: addressDto.houseNumber || "",
        postalCode: addressDto.postalCode || "",
        city: addressDto.city || "",
        country: addressDto.country || "PL",
      }); /* uses async TES operation and polls status. :contentReference[oaicite:1]{index=1} */
      const merged = this._mergeSuggestions(instant, backendSuggestions);
      this.loading = false;
      return { instant, suggestions: merged };
    } catch (e) {
      this.loading = false;
      this.error = e?.message || "Verification failed.";
      throw e;
    }
  }

  _mergeSuggestions(instant, backendList) {
    const list = Array.isArray(backendList) ? backendList.slice() : [];
    const fromInstant = instant
      ? {
          fullAddressLabel: `${instant.street || ""} ${instant.houseNumber || ""}, ${instant.postalCode || ""} ${instant.city || ""}`,
          street: instant.street || null,
          houseNumber: instant.houseNumber || null,
          postalCode: instant.postalCode || null,
          city: instant.city || null,
          countryCode: instant.country || null,
          countryName: null,
          latitude: instant.latitude ?? null,
          longitude: instant.longitude ?? null,
          matchScore: 1.0,
          matchLevel: "GEOCODER",
          providerSource: "GOOGLE_CLIENT",
        }
      : null;
    if (fromInstant) list.unshift(fromInstant);
    return list;
  }

  async _pollOperation(correlationId) {
    const maxRetries = 10;
    const interval = 2000;
    for (let i = 0; i < maxRetries; i++) {
      await new Promise(r => setTimeout(r, interval));
      const status = await apiClient.get(`/api/admin/address-verification/operations/${correlationId}`);
      const op = status?.data;
      if (op?.status === "COMPLETED") {
        return op?.result?.suggestions || [];
      }
      if (op?.status === "FAILED") {
        throw new Error(op?.errorDetails || "Suggestion operation failed.");
      }
    }
    throw new Error("Address suggestion polling timeout.");
  }
}


================================================================================
### PLIK: controllers\AddressVerificationFacade.js
================================================================================

/**
 * ARCHITECTURE: AddressVerificationFacade provides a minimal API to run Google-first verification end-to-end.
 * It follows the manifesto by composing workflow, merger, ranker, and TES suggestions behind a single call.
 * Responsibilities:
 * - Accept an Address-like DTO; return {normalized, validation, instant, suggestions} ready for the editor.
 * - Optionally enrich with TES suggestions and merge/rank them alongside Google-derived candidates.
 */
import { AddressVerificationWorkflow } from "@/controllers/AddressVerificationWorkflow";
import { TesSuggestionController } from "@/controllers/TesSuggestionController";
import { AddressSuggestionMerger } from "@/services/AddressSuggestionMerger";
import { AddressSuggestionRanker } from "@/services/AddressSuggestionRanker";

export class AddressVerificationFacade {
  constructor(googleApiKey, tes = new TesSuggestionController(), merger = new AddressSuggestionMerger(), ranker = new AddressSuggestionRanker()) {
    this.workflow = new AddressVerificationWorkflow(googleApiKey);
    this.tes = tes;
    this.merger = merger;
    this.ranker = ranker;
  }

  async verify(address) {
    const base = await this.workflow.verify(address);
    if (!base.success) return base;
    const tes = await this.tes.suggestOnDemand(base.normalized, base.normalized);
    const merged = this.merger.merge(base.normalized, [base.suggestions, tes]);
    const ranked = this.ranker.rank(base.normalized, merged);
    return { ...base, suggestions: ranked };
  }
}


================================================================================
### PLIK: controllers\AddressVerificationWorkflow.js
================================================================================

/**
 * ARCHITECTURE: AddressVerificationWorkflow runs normalize→validate→(optional)geocode to build a result model.
 * It follows the manifesto by keeping verification orchestration independent from UI and transport details.
 * Responsibilities:
 * - Normalize and validate input; if geocoder is injected, resolve coordinates as an "instant" candidate.
 * - Return {success, normalized, validation, instant, suggestions[]} without throwing on user errors.
 */
import { AddressNormalizer } from "@/services/AddressNormalizer";
import { ValidationService } from "@/services/ValidationService";

export class AddressVerificationWorkflow {
  constructor(googleApiKey = null, geocoderAdapter = null) {
    void googleApiKey;
    this.normalizer = new AddressNormalizer();
    this.validator = new ValidationService("PL");
    this.geocoder = geocoderAdapter || null;
  }

  async verify(address) {
    const normalized = this.normalizer.normalize(address);
    const validation = this.validator.validate(normalized);
    if (!validation.valid) {
      return {
        success: false,
        normalized,
        validation,
        instant: null,
        suggestions: [],
      };
    }
    let instant = null;
    if (this.geocoder && typeof this.geocoder.geocodeAddress === "function") {
      try {
        const r = await this.geocoder.geocodeAddress(normalized);
        if (r && typeof r.lat === "number" && typeof r.lon === "number") {
          instant = { latitude: r.lat, longitude: r.lon, providerSource: "GOOGLE_CLIENT", matchLevel: "GEOCODER", matchScore: 1.0 };
        }
      } catch (_) {
        instant = null;
      }
    }
    return {
      success: true,
      normalized,
      validation,
      instant,
      suggestions: [],
    };
  }
}


================================================================================
### PLIK: controllers\AppBootstrapController.js
================================================================================

/**
 * ARCHITECTURE: AppBootstrapController wires config + health + orchestrator for the app shell.
 * Responsibilities:
 * - Load env config and Google key
 * - Run health gate
 * - Build IntegrationOrchestrator stub (can be extended later with Google runtime)
 * - Return { googleKey, orchestrator, health }
 */
import { EnvironmentConfigService } from "@/services/EnvironmentConfigService";
import { HealthGateController } from "@/controllers/HealthGateController";
import { IntegrationOrchestrator } from "@/controllers/IntegrationOrchestrator";

export class AppBootstrapController {
  constructor(cfg = new EnvironmentConfigService(), health = new HealthGateController()) {
    this.cfg = cfg;
    this.healthCtrl = health;
  }

  async bootstrap() {
    await this.cfg.load();
    const googleKey = this.cfg.googleKey();
    const health = await this.healthCtrl.readiness(googleKey);
    const orchestrator = new IntegrationOrchestrator(null, null);
    return { googleKey, orchestrator, health };
  }
}


================================================================================
### PLIK: controllers\AuthController.js
================================================================================

/**
 * ARCHITECTURE: AuthController coordinates login/logout by composing AuthApi, AuthSessionService, and ApiAuthBinder.
 * It follows the manifesto by exposing intent-driven methods and returning Result objects for views/guards.
 * Responsibilities:
 * - login(username,password): call AuthApi, persist session, bind Authorization header.
 * - logout(): clear session and unbind header.
 * - hydrateFromStorage(): reapply header on app start.
 * - snapshot(): expose {isAuthenticated,user}.
 */
import { Result } from "@/domain/Result";
import { AuthApi } from "@/services/AuthApi";
import { AuthSessionService } from "@/services/AuthSessionService";
import { ApiAuthBinder } from "@/services/ApiAuthBinder";

export class AuthController {
  constructor(api = new AuthApi(), session = new AuthSessionService(), binder = new ApiAuthBinder()) {
    this.api = api;
    this.session = session;
    this.binder = binder;
  }

  async login(username, password) {
    const r = await this.api.login(username, password);
    if (!r.ok) return Result.fail(r.error);
    this.session.save(r.value);
    this.binder.bind(r.value.accessToken, r.value.tokenType);
    return Result.ok(this.snapshot());
  }

  async logout() {
    this.session.clear();
    this.binder.unbind();
    return Result.ok(true);
  }

  hydrateFromStorage() {
    const token = this.session.getAccessToken();
    const type = this.session.getTokenType();
    if (token) this.binder.bind(token, type);
    return this.snapshot();
  }

  snapshot() {
    return {
      isAuthenticated: this.session.isAuthenticated(),
      user: this.session.getUser(),
      tokenPresent: !!this.session.getAccessToken(),
    };
  }
}


================================================================================
### PLIK: controllers\BulkEditController.js
================================================================================

/**
 * ARCHITECTURE: BulkEditController previews and applies batch text transforms across selected orders.
 * It follows the manifesto by isolating batch logic and delegating transport to AddressExceptionApi.
 * Responsibilities:
 * - Preview client-side transformations for confidence; apply changes via backend endpoint.
 * - Accept BulkEditPlan JSON and return Result objects for both preview and apply.
 */
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

export class BulkEditController {
  constructor(storeOrApi = null) {
    this.api = storeOrApi instanceof AddressExceptionApi ? storeOrApi : new AddressExceptionApi();
  }

  async preview(plan) {
    try {
      const { data } = await this._post("/bulk/preview", plan);
      return Result.ok(Array.isArray(data?.items) ? data.items : []);
    } catch (e) {
      return Result.fail(e);
    }
  }

  async apply(plan) {
    try {
      const { data } = await this._post("/bulk/apply", plan);
      return Result.ok(data || true);
    } catch (e) {
      return Result.fail(e);
    }
  }

  async _post(path, plan) {
    const url = `/api/address-exceptions${path}`;
    return await (await import("@/services/api")).default.post(url, plan.toJSON ? plan.toJSON() : plan);
  }
}


================================================================================
### PLIK: controllers\CorrectionEditorController.js
================================================================================

/**
 * ARCHITECTURE: CorrectionEditorController orchestrates the "side-by-side diff" editor.
 * It follows the manifesto by isolating all IO and decision logic away from the component tree.
 * Responsibilities:
 * - Loads OrderDetail and related suggestions for pickup/delivery.
 * - Maintains editable copies of addresses, integrates optional geocoder.
 * - Applies Accept Suggestion, Use Original, Manual Edit, Save, and Save & Next.
 * - Shields UI from API details via AddressExceptionApi and from map choice via MapGeocoderAdapter.
 */
import { Address } from "@/domain/WorkbenchModels";
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";
import { MapGeocoderAdapter } from "@/adapters/MapGeocoderAdapter";

export class CorrectionEditorController {
  constructor(api = new AddressExceptionApi(), geocoder = null) {
    this.api = api;
    this.geocoder = geocoder instanceof MapGeocoderAdapter ? geocoder : null;
    this.orderId = null;
    this.detail = null;
    this.loading = false;
    this.error = null;
    this.editedPickup = null;
    this.editedDelivery = null;
  }

  setGeocoderAdapter(adapter) {
    this.geocoder = adapter instanceof MapGeocoderAdapter ? adapter : null;
    return this.geocoder;
  }

  async loadOrder(orderId) {
    this.loading = true;
    this.error = null;
    this.orderId = orderId;
    this.detail = null;
    this.editedPickup = null;
    this.editedDelivery = null;
    const res = await this.api.getOrderDetail(orderId);
    if (!res.ok) {
      this.loading = false;
      this.error = res.error.message;
      return Result.fail(res.error);
    }
    this.detail = res.value;
    this.editedPickup = new Address(
      this.detail.originalPickup.street,
      this.detail.originalPickup.houseNumber,
      this.detail.originalPickup.postalCode,
      this.detail.originalPickup.city,
      this.detail.originalPickup.country,
      this.detail.originalPickup.latitude,
      this.detail.originalPickup.longitude
    );
    this.editedDelivery = new Address(
      this.detail.originalDelivery.street,
      this.detail.originalDelivery.houseNumber,
      this.detail.originalDelivery.postalCode,
      this.detail.originalDelivery.city,
      this.detail.originalDelivery.country,
      this.detail.originalDelivery.latitude,
      this.detail.originalDelivery.longitude
    );
    this.loading = false;
    return Result.ok(this.detail);
  }

  async refreshSuggestions(side) {
    if (!this.orderId) return Result.fail(new Error("Order not loaded."));
    const s = side === "pickup" ? "pickup" : "delivery";
    const res = await this.api.refreshSuggestions(this.orderId, s);
    if (!res.ok) return Result.fail(res.error);
    if (s === "pickup") this.detail.suggestedPickup = res.value;
    if (s === "delivery") this.detail.suggestedDelivery = res.value;
    return Result.ok(res.value);
  }

  acceptSuggestion(side, index = 0) {
    if (!this.detail) return Result.fail(new Error("Order not loaded."));
    const list = side === "pickup" ? this.detail.suggestedPickup : this.detail.suggestedDelivery;
    if (!Array.isArray(list) || !list[index]) return Result.fail(new Error("Suggestion not found."));
    const s = list[index];
    const addr = new Address(
      s.street || "",
      s.houseNumber || null,
      s.postalCode || "",
      s.city || "",
      s.countryCode || this._defaultCountry(),
      s.latitude ?? null,
      s.longitude ?? null
    );
    if (side === "pickup") this.editedPickup = addr;
    if (side === "delivery") this.editedDelivery = addr;
    return Result.ok(addr);
  }

  useOriginal(side) {
    if (!this.detail) return Result.fail(new Error("Order not loaded."));
    if (side === "pickup") {
      const o = this.detail.originalPickup;
      this.editedPickup = new Address(o.street, o.houseNumber, o.postalCode, o.city, o.country, o.latitude, o.longitude);
      return Result.ok(this.editedPickup);
    }
    if (side === "delivery") {
      const o = this.detail.originalDelivery;
      this.editedDelivery = new Address(o.street, o.houseNumber, o.postalCode, o.city, o.country, o.latitude, o.longitude);
      return Result.ok(this.editedDelivery);
    }
    return Result.fail(new Error("Unknown side."));
  }

  setManualAddress(side, address) {
    if (!(address instanceof Address)) return Result.fail(new Error("Invalid Address."));
    if (side === "pickup") this.editedPickup = address;
    else if (side === "delivery") this.editedDelivery = address;
    else return Result.fail(new Error("Unknown side."));
    return Result.ok(address);
  }

  async geocodeEdited(side) {
    if (!this.geocoder) return Result.fail(new Error("No geocoder."));
    const addr = side === "pickup" ? this.editedPickup : this.editedDelivery;
    if (!(addr instanceof Address)) return Result.fail(new Error("No edited address."));
    const r = await this.geocoder.geocodeAddress({
      street: addr.street,
      houseNumber: addr.houseNumber,
      postalCode: addr.postalCode,
      city: addr.city,
      country: addr.country,
    });
    if (!r) return Result.fail(new Error("Geocode not found."));
    addr.latitude = r.lat;
    addr.longitude = r.lon;
    return Result.ok({ lat: r.lat, lon: r.lon });
  }

  async saveAcceptSuggestion(side) {
    if (!this.orderId) return Result.fail(new Error("Order not loaded."));
    const payload = {
      orderId: this.orderId,
      side: side === "both" ? "both" : side === "pickup" ? "pickup" : "delivery",
      correctedPickup: side === "pickup" || side === "both" ? this.editedPickup : null,
      correctedDelivery: side === "delivery" || side === "both" ? this.editedDelivery : null,
      resolution: "ACCEPT_SUGGESTION",
    };
    const res = await this.api.saveCorrection(payload);
    if (!res.ok) return Result.fail(res.error);
    return Result.ok(res.value);
  }

  async saveUseOriginal(side) {
    if (!this.orderId) return Result.fail(new Error("Order not loaded."));
    const payload = {
      orderId: this.orderId,
      side: side === "both" ? "both" : side === "pickup" ? "pickup" : "delivery",
      correctedPickup: side === "pickup" || side === "both" ? this.editedPickup : null,
      correctedDelivery: side === "delivery" || side === "both" ? this.editedDelivery : null,
      resolution: "USE_ORIGINAL",
    };
    const res = await this.api.saveCorrection(payload);
    if (!res.ok) return Result.fail(res.error);
    return Result.ok(res.value);
  }

  async saveManual(side) {
    if (!this.orderId) return Result.fail(new Error("Order not loaded."));
    const payload = {
      orderId: this.orderId,
      side: side === "both" ? "both" : side === "pickup" ? "pickup" : "delivery",
      correctedPickup: side === "pickup" || side === "both" ? this.editedPickup : null,
      correctedDelivery: side === "delivery" || side === "both" ? this.editedDelivery : null,
      resolution: "MANUAL_EDIT",
    };
    const res = await this.api.saveCorrection(payload);
    if (!res.ok) return Result.fail(res.error);
    return Result.ok(res.value);
  }

  async saveAndNext(side, worklistStore) {
    const saveRes = await this._saveBySideKind(side);
    if (!saveRes.ok) return saveRes;
    const nextIdRes = await worklistStore.getNextAndLoad(this.orderId);
    if (!nextIdRes.ok) return Result.fail(nextIdRes.error);
    const nextId = nextIdRes.value;
    if (!nextId) return Result.ok(null);
    const loadRes = await this.loadOrder(nextId);
    if (!loadRes.ok) return Result.fail(loadRes.error);
    return Result.ok(nextId);
  }

  snapshot() {
    return {
      orderId: this.orderId,
      detail: this.detail,
      editedPickup: this.editedPickup,
      editedDelivery: this.editedDelivery,
      loading: this.loading,
      error: this.error,
    };
  }

  _defaultCountry() {
    return "PL";
  }

  async _saveBySideKind(side) {
    if (side === "pickup") return this.saveManual("pickup");
    if (side === "delivery") return this.saveManual("delivery");
    if (side === "both") return this.saveManual("both");
    return Result.fail(new Error("Unknown side."));
  }
}


================================================================================
### PLIK: controllers\EditorAutosaveController.js
================================================================================

/**
 * ARCHITECTURE: EditorAutosaveController persists draft edits to session and restores on load.
 * It follows the manifesto by composing EditorStateSerializer with a timed save loop.
 * Responsibilities:
 * - Save edited pickup/delivery every N ms if changed; restore when opening the same orderId.
 */
import { EditorStateSerializer } from "@/services/EditorStateSerializer";
import { AddressEqualityService } from "@/services/AddressEqualityService";

export class EditorAutosaveController {
  constructor(editorFacade, serializer = new EditorStateSerializer(), eq = new AddressEqualityService(), intervalMs = 2000) {
    this.editor = editorFacade;
    this.serializer = serializer;
    this.eq = eq;
    this.intervalMs = intervalMs;
    this._timer = null;
    this._last = null;
    this._orderId = null;
  }

  async restore(orderId) {
    this._orderId = orderId;
    const saved = this.serializer.load(orderId);
    if (saved?.editedPickup) this.editor.setManualPickup(saved.editedPickup);
    if (saved?.editedDelivery) this.editor.setManualDelivery(saved.editedDelivery);
    this._last = this._take();
    return saved || null;
  }

  start() {
    if (this._timer) return false;
    this._timer = setInterval(() => this._tick(), this.intervalMs);
    return true;
  }

  stop() {
    if (!this._timer) return false;
    clearInterval(this._timer);
    this._timer = null;
    return true;
  }

  _tick() {
    if (!this._orderId) return;
    const now = this._take();
    if (!this._equalDrafts(this._last, now)) {
      this.serializer.save(this._orderId, now);
      this._last = now;
    }
  }

  _take() {
    const s = this.editor.snapshot();
    return { editedPickup: s?.editor?.editedPickup || null, editedDelivery: s?.editor?.editedDelivery || null };
  }

  _equalDrafts(a, b) {
    return this.eq.equals(a?.editedPickup || {}, b?.editedPickup || {}) && this.eq.equals(a?.editedDelivery || {}, b?.editedDelivery || {});
  }
}


================================================================================
### PLIK: controllers\EditorCommandBus.js
================================================================================

/**
 * ARCHITECTURE: EditorCommandBus centralizes high-level editor commands for buttons and hotkeys.
 * It follows the manifesto by exposing intent methods that orchestrate other controllers/facades.
 * Responsibilities:
 * - Provide accept/use-original/save/save&next commands for pickup, delivery, and both.
 * - Keep a single place to wire UI actions to EditorFacade and SaveFlowController.
 */
import { Result } from "@/domain/Result";

export class EditorCommandBus {
  constructor(editorFacade, saveFlowController) {
    this.editor = editorFacade;
    this.saveFlow = saveFlowController;
  }

  acceptPickup(i = 0) {
    const r = this.editor.acceptPickupSuggestion(i);
    return r.ok ? Result.ok(true) : r;
  }

  acceptDelivery(i = 0) {
    const r = this.editor.acceptDeliverySuggestion(i);
    return r.ok ? Result.ok(true) : r;
  }

  useOriginalPickup() {
    const r = this.editor.useOriginalPickup();
    return r.ok ? Result.ok(true) : r;
  }

  useOriginalDelivery() {
    const r = this.editor.useOriginalDelivery();
    return r.ok ? Result.ok(true) : r;
  }

  async savePickupThenNext() {
    return this.saveFlow.saveThenAwait("pickup");
  }

  async saveDeliveryThenNext() {
    return this.saveFlow.saveThenAwait("delivery");
  }

  async saveBothThenNext() {
    return this.saveFlow.saveThenAwait("both");
  }
}


================================================================================
### PLIK: controllers\EditorDiffController.js
================================================================================

/**
 * ARCHITECTURE: EditorDiffController computes and presents diffs for pickup and delivery addresses.
 * It follows the manifesto by composing DiffService and DiffPresenter behind a deterministic snapshot.
 * Responsibilities:
 * - Pull before/after from EditorFacade snapshot and compute UI-ready rows for both sides.
 */
import { DiffService } from "@/services/DiffService";
import { DiffPresenter } from "@/viewmodels/DiffPresenter";

export class EditorDiffController {
  constructor(editorFacade) {
    this.editor = editorFacade;
    this.diff = new DiffService();
    this.presenter = new DiffPresenter();
    this._snapshot = { pickup: { rows: [] }, delivery: { rows: [] } };
  }

  recompute() {
    const snap = this.editor.snapshot();
    const beforeP = snap.editor?.detail?.originalPickup || null;
    const afterP = snap.editor?.editedPickup || snap.editor?.editedPickup || snap.editor?.detail?.originalPickup || null;
    const beforeD = snap.editor?.detail?.originalDelivery || null;
    const afterD = snap.editor?.editedDelivery || snap.editor?.detail?.originalDelivery || null;

    const dp = this.presenter.present(this.diff.diff(beforeP, afterP));
    const dd = this.presenter.present(this.diff.diff(beforeD, afterD));

    this._snapshot = { pickup: dp, delivery: dd };
    return this._snapshot;
  }

  snapshot() {
    return JSON.parse(JSON.stringify(this._snapshot));
  }
}


================================================================================
### PLIK: controllers\EditorFacade.js
================================================================================

/**
 * ARCHITECTURE: EditorFacade wraps CorrectionEditorController and adds map preview conveniences.
 * It follows the manifesto by exposing intent methods used by the Editor view without leaking internals.
 * Responsibilities:
 * - Load order, set manual edits, accept suggestions, and compute snapshots for UI.
 * - Optionally preview on map when accepting/applying suggestions.
 */
import { Result } from "@/domain/Result";
import { SuggestionPreviewController } from "@/controllers/SuggestionPreviewController";

export class EditorFacade {
  constructor(editorController, mapController = null, _placesAdapter = null, queue = null) {
    this.ctrl = editorController;
    this.queue = queue || null;
    this.preview = mapController ? new SuggestionPreviewController(mapController) : null;
  }

  async load(orderId) {
    return await this.ctrl.loadOrder(orderId);
  }

  snapshot() {
    return { editor: this.ctrl.snapshot(), currentOrderId: this.ctrl?.detail?.orderId || null };
  }

  setManualPickup(addr) {
    return this.ctrl.setManualAddress("pickup", addr);
  }

  setManualDelivery(addr) {
    return this.ctrl.setManualAddress("delivery", addr);
  }

  setPickupSuggestions(list) {
    return this.ctrl.setSuggestions("pickup", list);
  }

  setDeliverySuggestions(list) {
    return this.ctrl.setSuggestions("delivery", list);
  }

  acceptPickupSuggestion(i = 0) {
    const r = this.ctrl.acceptSuggestion("pickup", i);
    if (this.preview && r.ok) this.preview.show(this.ctrl.snapshot().editedPickup);
    return r.ok ? Result.ok(true) : r;
  }

  acceptDeliverySuggestion(i = 0) {
    const r = this.ctrl.acceptSuggestion("delivery", i);
    if (this.preview && r.ok) this.preview.show(this.ctrl.snapshot().editedDelivery);
    return r.ok ? Result.ok(true) : r;
  }

  useOriginalPickup() {
    return this.ctrl.useOriginal("pickup");
  }

  useOriginalDelivery() {
    return this.ctrl.useOriginal("delivery");
  }
}


================================================================================
### PLIK: controllers\EditorFocusController.js
================================================================================

/**
 * ARCHITECTURE: EditorFocusController manages a deterministic focus order across address fields.
 * It follows the manifesto by isolating focus logic from the component and DOM details.
 * Responsibilities:
 * - Provide nextField() and prevField() given current key and an ordered schema.
 * - Return the target key for the view to focus without touching the DOM.
 */
export class EditorFocusController {
  constructor(order = ["street", "houseNumber", "postalCode", "city", "country"]) {
    this.order = order.slice();
    this.index = 0;
  }

  setCurrent(key) {
    const idx = this.order.indexOf(key);
    if (idx >= 0) this.index = idx;
    return this.current();
  }

  current() {
    return this.order[this.index] || null;
  }

  next() {
    this.index = Math.min(this.order.length - 1, this.index + 1);
    return this.current();
  }

  previous() {
    this.index = Math.max(0, this.index - 1);
    return this.current();
  }

  reset() {
    this.index = 0;
    return this.current();
  }
}


================================================================================
### PLIK: controllers\EditorHotkeysController.js
================================================================================

/**
 * ARCHITECTURE: EditorHotkeysController manages keyboard shortcuts for the Correction Editor.
 * It follows the manifesto by isolating DOM listeners and mapping keys to explicit callbacks.
 * Responsibilities:
 * - Attach/detach listeners and dispatch to provided handlers (save, save&next, accept, use original).
 * - Avoid collisions by scoping to a single active instance and ignoring repeated auto-fire.
 */
export class EditorHotkeysController {
  constructor(handlers = {}) {
    this.handlers = {
      onSave: handlers.onSave || null,
      onSaveNext: handlers.onSaveNext || null,
      onAccept: handlers.onAccept || null,
      onUseOriginal: handlers.onUseOriginal || null,
    };
    this._bound = (e) => this._onKey(e);
    this._attached = false;
  }

  attach() {
    if (this._attached) return false;
    window.addEventListener("keydown", this._bound, true);
    this._attached = true;
    return true;
  }

  detach() {
    if (!this._attached) return false;
    window.removeEventListener("keydown", this._bound, true);
    this._attached = false;
    return true;
  }

  _onKey(e) {
    if (e.repeat) return;
    const mod = e.ctrlKey || e.metaKey;
    if (mod && e.key.toLowerCase() === "s") {
      e.preventDefault();
      if (e.shiftKey && this.handlers.onSaveNext) return this.handlers.onSaveNext();
      if (this.handlers.onSave) return this.handlers.onSave();
    }
    if (mod && e.key.toLowerCase() === "enter") {
      e.preventDefault();
      if (this.handlers.onAccept) return this.handlers.onAccept();
    }
    if (mod && e.key.toLowerCase() === "backspace") {
      e.preventDefault();
      if (this.handlers.onUseOriginal) return this.handlers.onUseOriginal();
    }
  }
}


================================================================================
### PLIK: controllers\EditorInitController.js
================================================================================

/**
 * ARCHITECTURE: EditorInitController prepares the Correction Editor with autosave, undo, and recovery wiring.
 * It follows the manifesto by centralizing editor startup steps for a predictable, testable flow.
 * Responsibilities:
 * - Load order, restore drafts, start autosave, initialize undo snapshot, and prefetch next order.
 * - Provide a single init(orderId) returning a stabilized snapshot for the view.
 */
import { EditorAutosaveController } from "@/controllers/EditorAutosaveController";
import { EditorUndoController } from "@/controllers/EditorUndoController";
import { OrderDetailPrefetcher } from "@/services/OrderDetailPrefetcher";
import { Result } from "@/domain/Result";

export class EditorInitController {
  constructor(editorFacade, ordersQueue, autosave = null, undo = null, prefetcher = new OrderDetailPrefetcher()) {
    this.editor = editorFacade;
    this.queue = ordersQueue;
    this.autosave = autosave instanceof EditorAutosaveController ? autosave : new EditorAutosaveController(this.editor);
    this.undo = undo instanceof EditorUndoController ? undo : new EditorUndoController(this.editor);
    this.prefetcher = prefetcher;
  }

  async init(orderId) {
    const load = await this.editor.load(orderId);
    if (!load.ok) return load;
    await this.autosave.restore(orderId);
    this.autosave.start();
    this.undo.init();
    const nextId = this.queue.current() || this.queue.next();
    if (nextId) await this.prefetcher.prefetch(nextId);
    return Result.ok(this.editor.snapshot());
  }

  stop() {
    this.autosave.stop();
    return true;
  }
}


================================================================================
### PLIK: controllers\EditorNavigationController.js
================================================================================

/**
 * ARCHITECTURE: EditorNavigationController builds route URLs to the editor preserving context when needed.
 * It follows the manifesto by isolating URL composition away from views.
 * Responsibilities:
 * - toEditor(orderId, from, state): return path with optional query for back navigation.
 */
export class EditorNavigationController {
  toEditor(orderId, from = "worklist", state = null) {
    const q = new URLSearchParams();
    q.set("from", from);
    if (state && typeof state === "object") q.set("ctx", btoa(unescape(encodeURIComponent(JSON.stringify(state)))));
    return `/editor/${encodeURIComponent(orderId)}?${q.toString()}`;
  }
}


================================================================================
### PLIK: controllers\EditorRecoveryController.js
================================================================================


================================================================================
### PLIK: controllers\EditorSavePolicyController.js
================================================================================

/**
 * ARCHITECTURE: EditorSavePolicyController decides when Save buttons should be enabled.
 * It follows the manifesto by isolating policy checks (diff, validation, geocode) from UI components.
 * Responsibilities:
 * - Evaluate readiness for pickup/delivery/both saves using diff flags and validation results.
 * - Provide explicit booleans and reasons for disabled states.
 */
export class EditorSavePolicyController {
  constructor() {
    this.requireGeocode = false;
  }

  setRequireGeocode(v) {
    this.requireGeocode = !!v;
    return this.requireGeocode;
  }

  canSavePickup(state) {
    return this._evaluate(state?.latestDiff?.pickup, state?.editor?.validation, state?.editor?.instant, "pickup");
  }

  canSaveDelivery(state) {
    return this._evaluate(state?.latestDiff?.delivery, state?.editor?.validation, state?.editor?.instant, "delivery");
  }

  canSaveBoth(state) {
    const p = this._evaluate(state?.latestDiff?.pickup, state?.editor?.validation, state?.editor?.instant, "pickup");
    const d = this._evaluate(state?.latestDiff?.delivery, state?.editor?.validation, state?.editor?.instant, "delivery");
    return { enabled: p.enabled && d.enabled, reason: p.enabled ? d.reason : p.reason };
  }

  _evaluate(diff, validation, instant, side) {
    if (!diff || !validation) return { enabled: false, reason: "No changes or validation state missing" };
    if (!diff.anyChanged) return { enabled: false, reason: "No changes detected" };
    if (!validation.valid) return { enabled: false, reason: "Invalid address fields" };
    if (this.requireGeocode && !instant) return { enabled: false, reason: "Geocode required" };
    return { enabled: true, reason: "OK" };
  }
}


================================================================================
### PLIK: controllers\EditorUndoController.js
================================================================================

/**
 * ARCHITECTURE: EditorUndoController wraps UndoStackService for pickup/delivery address edits.
 * It follows the manifesto by providing intent-driven methods without UI or storage coupling.
 * Responsibilities:
 * - Capture snapshots on change, and restore on undo/redo callbacks to the editor facade.
 * - Keep a tiny footprint: snapshot shape is {pickup,delivery}.
 */
import { UndoStackService } from "@/services/UndoStackService";

export class EditorUndoController {
  constructor(editorFacade, stack = new UndoStackService(100)) {
    this.editor = editorFacade;
    this.stack = stack;
  }

  init() {
    const snap = this._snapshot();
    this.stack.init(snap);
    return snap;
  }

  onChange() {
    return this.stack.push(this._snapshot());
  }

  undo() {
    const s = this.stack.undo();
    if (!s) return null;
    if (s.pickup) this.editor.setManualPickup(s.pickup);
    if (s.delivery) this.editor.setManualDelivery(s.delivery);
    return s;
  }

  redo() {
    const s = this.stack.redo();
    if (!s) return null;
    if (s.pickup) this.editor.setManualPickup(s.pickup);
    if (s.delivery) this.editor.setManualDelivery(s.delivery);
    return s;
  }

  _snapshot() {
    const st = this.editor.snapshot();
    return {
      pickup: st?.editor?.editedPickup || null,
      delivery: st?.editor?.editedDelivery || null,
    };
  }
}


================================================================================
### PLIK: controllers\EditorVerificationController.js
================================================================================

/**
 * ARCHITECTURE: EditorVerificationController coordinates live verification for the Correction Editor input fields.
 * It follows the manifesto by composing debounce, normalization, validation, Google geocode, and Places hints.
 * Responsibilities:
 * - Debounce user input; on settle, normalize+validate; if valid, geocode and suggest via Places.
 * - Update a MapController through an injected adapter to visualize the current candidate.
 * - Provide a snapshot for the component to render without exposing third-party APIs.
 */
import { AddressNormalizer } from "@/services/AddressNormalizer";
import { ValidationService } from "@/services/ValidationService";
import { DebounceTimer } from "@/services/DebounceTimer";

export class EditorVerificationController {
  constructor(geocoderAdapter, placesAdapter, mapController, debounceMs = 400) {
    this.normalizer = new AddressNormalizer();
    this.validator = new ValidationService();
    this.debouncer = new DebounceTimer(debounceMs);
    this.geocoder = geocoderAdapter || null;
    this.places = placesAdapter || null;
    this.map = mapController || null;
    this.input = { street: "", houseNumber: "", postalCode: "", city: "", country: "PL" };
    this.validation = { valid: false, errors: {} };
    this.instant = null;
    this.suggestions = [];
    this.loading = false;
    this.error = null;
  }

  setInputPatch(patch) {
    this.input = { ...this.input, ...(patch || {}) };
    return this.input;
  }

  async runVerification() {
    return this.debouncer.run(async () => {
      this.loading = true;
      this.error = null;
      const normalized = this.normalizer.normalize(this.input);
      const check = this.validator.validate(normalized);
      this.validation = check;
      if (!check.valid) {
        this.instant = null;
        this.suggestions = [];
        this.loading = false;
        return this.snapshot();
      }
      const instant = this.geocoder ? await this.geocoder.geocodeAddress(normalized) : null;
      if (instant && typeof instant.latitude === "number" && typeof instant.longitude === "number" && this.map) {
        await this.map.updateMarker(instant.latitude, instant.longitude, true);
      }
      const hints = this.places ? await this.places.suggest(this._composeFreeText(normalized), normalized.country) : [];
      this.instant = instant;
      this.suggestions = Array.isArray(hints) ? hints : [];
      this.loading = false;
      return this.snapshot();
    });
  }

  snapshot() {
    return {
      input: { ...this.input },
      validation: { ...this.validation },
      instant: this.instant ? { ...this.instant } : null,
      suggestions: this.suggestions.slice(),
      loading: this.loading,
      error: this.error,
    };
  }

  _composeFreeText(a) {
    const line1 = a.houseNumber ? `${a.street} ${a.houseNumber}` : a.street;
    return `${line1}, ${a.postalCode} ${a.city}`;
  }
}


================================================================================
### PLIK: controllers\EndToEndVerifyAndSaveController.js
================================================================================

/**
 * ARCHITECTURE: EndToEndVerifyAndSaveController runs normalize→validate→verify→save with telemetry.
 * It follows the manifesto by composing workflow, policy, and save flow into a single orchestrator.
 * Responsibilities:
 * - Verify pickup/delivery, apply best suggestion, and persist the result; then advance queue.
 * - Emit timing events via VerificationTelemetryController and return a concise outcome.
 */
import { AddressVerificationWorkflow } from "@/controllers/AddressVerificationWorkflow";
import { SuggestionSelectionController } from "@/controllers/SuggestionSelectionController";
import { SaveFlowController } from "@/controllers/SaveFlowController";
import { VerificationTelemetryController } from "@/controllers/VerificationTelemetryController";
import { Result } from "@/domain/Result";

export class EndToEndVerifyAndSaveController {
  constructor(googleApiKey, editorFacade, ordersQueue, saver) {
    this.workflow = new AddressVerificationWorkflow(googleApiKey);
    this.selector = new SuggestionSelectionController();
    this.saveFlow = new SaveFlowController(editorFacade, ordersQueue, saver);
    this.telemetry = new VerificationTelemetryController();
    this.editor = editorFacade;
  }

  async runForSide(side = "pickup") {
    const corr = this.telemetry.start(`e2e_${side}`);
    const addr = side === "pickup" ? this.editor.editor.editedPickup : this.editor.editor.editedDelivery;
    if (!addr) {
      this.telemetry.finish("no-input", { side });
      return Result.fail(new Error("No address to verify"));
    }
    this.telemetry.mark("verify-start", { side });
    const vr = await this.workflow.verify(addr);
    this.telemetry.mark("verify-finish", { valid: vr.success, side });
    if (!vr.success) {
      this.telemetry.finish("invalid", { side });
      return Result.fail(new Error("Validation failed"));
    }
    const best = this.selector.best(vr.normalized, vr.suggestions);
    if (best) {
      if (side === "pickup") this.editor.acceptPickupSuggestion(best.index);
      if (side === "delivery") this.editor.acceptDeliverySuggestion(best.index);
    }
    this.telemetry.mark("save-start", { side });
    const saved = await this.saveFlow.saveThenAwait(side);
    const status = saved.ok ? "ok" : "save-failed";
    this.telemetry.finish(status, { side, nextId: saved.ok ? saved.value?.nextId || null : null });
    return saved;
  }
}


================================================================================
### PLIK: controllers\erificationQueueController.js
================================================================================

/**
 * ARCHITECTURE: VerificationQueueController serializes geocode requests to respect provider quotas.
 * It follows the manifesto by isolating concurrency limits and exposing enqueue() with result promises.
 * Responsibilities:
 * - Maintain a FIFO queue, run up to N active tasks, and resolve/reject per item deterministically.
 * - Allow dynamic concurrency to adapt to UI load and throttle bursts from user typing.
 */
export class VerificationQueueController {
  constructor(concurrency = 2) {
    this.concurrency = Math.max(1, concurrency);
    this._active = 0;
    this._q = [];
  }

  setConcurrency(n) {
    this.concurrency = Math.max(1, n);
    this._drain();
    return this.concurrency;
  }

  enqueue(taskFn) {
    return new Promise((resolve, reject) => {
      this._q.push({ taskFn, resolve, reject });
      this._drain();
    });
  }

  _drain() {
    while (this._active < this.concurrency && this._q.length > 0) {
      const item = this._q.shift();
      this._run(item);
    }
  }

  async _run(item) {
    this._active++;
    try {
      const r = await item.taskFn();
      item.resolve(r);
    } catch (e) {
      item.reject(e);
    } finally {
      this._active--;
      this._drain();
    }
  }

  size() {
    return this._q.length + this._active;
  }
}


================================================================================
### PLIK: controllers\GeocodeWithCacheController.js
================================================================================

/**
 * ARCHITECTURE: GeocodeWithCacheController composes cache, quota backoff, and a verification queue for geocoding.
 * It follows the manifesto by isolating resilience and performance concerns behind a single geocode() method.
 * Responsibilities:
 * - Check in-memory cache, enqueue the provider call, and apply quota backoff on retryable errors.
 * - Store successful results back to cache with TTL.
 */
import { AddressGeocodeCache } from "@/services/AddressGeocodeCache";
import { QuotaBackoffService } from "@/services/QuotaBackoffService";
import { VerificationQueueController } from "@/controllers/VerificationQueueController";

export class GeocodeWithCacheController {
  constructor(geocoderAdapter, cache = new AddressGeocodeCache(), backoff = new QuotaBackoffService(), queue = new VerificationQueueController(2)) {
    this.geocoder = geocoderAdapter;
    this.cache = cache;
    this.backoff = backoff;
    this.queue = queue;
  }

  async geocode(address) {
    const hit = this.cache.get(address);
    if (hit) return hit;
    const task = async () => {
      const run = () => this.geocoder.geocodeAddress(address);
      const result = await this.backoff.execute(run);
      if (result) this.cache.put(address, result);
      return result;
    };
    return this.queue.enqueue(task);
  }
}


================================================================================
### PLIK: controllers\HealthGateController.js
================================================================================

/**
 * ARCHITECTURE: HealthGateController validates backend and provider readiness for the app shell.
 * It follows the manifesto by isolating health queries and returning a minimal readiness object.
 * Responsibilities:
 * - Call RuntimeHealthService; provide {ok, backend, provider, google}.
 */
import { RuntimeHealthService } from "@/services/RuntimeHealthService";

export class HealthGateController {
  constructor(runtime = new RuntimeHealthService()) {
    this.runtime = runtime;
  }

  async readiness(googleKey) {
    const r = await this.runtime.readiness(googleKey);
    return { ok: !!r.ready, backend: !!r.backend?.ok, provider: !!r.provider?.ok, google: !!r.google?.ok };
  }
}


================================================================================
### PLIK: controllers\IdempotentSaveController.js
================================================================================

/**
 * ARCHITECTURE: IdempotentSaveController wraps AddressCorrectionService with idempotency token generation.
 * It follows the manifesto by isolating token creation and persistence concerns behind one save() method.
 * Responsibilities:
 * - Generate a deterministic token per payload and pass it down to AddressExceptionApi.
 * - Return Result objects and protect against accidental duplicate submissions.
 */
import { Result } from "@/domain/Result";
import { AddressPersistenceMapper } from "@/services/AddressPersistenceMapper";
import { IdempotencyTokenService } from "@/services/IdempotencyTokenService";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

export class IdempotentSaveController {
  constructor(api = new AddressExceptionApi(), mapper = new AddressPersistenceMapper(), tokens = new IdempotencyTokenService()) {
    this.api = api;
    this.mapper = mapper;
    this.tokens = tokens;
  }

  async save(payload) {
    const orderId = payload?.orderId;
    const side = payload?.side || "both";
    const body = this.mapper.toSavePayload(orderId, side, payload?.before || null, payload?.after || null, payload?.resolution || "MANUAL_EDIT");
    const token = this.tokens.create(orderId, side, JSON.stringify(body));
    const res = await this.api.saveCorrection(body, token);
    return res.ok ? Result.ok(res.value) : Result.fail(res.error);
  }
}


================================================================================
### PLIK: controllers\IntegrationOrchestrator.js
================================================================================

/**
 * ARCHITECTURE: IntegrationOrchestrator wires shared controllers/services and exposes factories for views.
 * It follows the manifesto by centralizing cross-cutting instances (queue, polling, api) behind a stable API.
 * Responsibilities:
 * - Hold shared OrdersQueueService, AddressExceptionApi, and factories for WorklistFacade and EditorFacade.
 * - Provide getWorklist() and getEditor() used by views; keep instances memoized per app session.
 */
import { OrdersQueueService } from "@/services/OrdersQueueService";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";
import { WorklistFacade } from "@/controllers/WorklistFacade";
import { CorrectionEditorController } from "@/controllers/CorrectionEditorController";
import { EditorFacade } from "@/controllers/EditorFacade";
import { GoogleGeocodingAdapter } from "@/adapters/GoogleGeocodingAdapter";
import { GooglePlacesAutocompleteAdapter } from "@/adapters/GooglePlacesAutocompleteAdapter";

export class IntegrationOrchestrator {
  constructor(google, mapController) {
    this.google = google || null;
    this.mapController = mapController || null;
    this.queue = new OrdersQueueService();
    this.api = new AddressExceptionApi();
    this._worklist = null;
    this._editor = null;
  }

  getWorklist() {
    if (this._worklist) return this._worklist;
    this._worklist = new WorklistFacade(this.api, this.queue);
    return this._worklist;
  }

  getEditor() {
    if (this._editor) return this._editor;
    const geocoder = this.google ? new GoogleGeocodingAdapter(this.google) : null;
    const places = this.google ? new GooglePlacesAutocompleteAdapter(this.google) : null;
    const ctrl = new CorrectionEditorController(this.api, geocoder);
    this._editor = new EditorFacade(ctrl, this.mapController, places, this.queue);
    return this._editor;
  }
}


================================================================================
### PLIK: controllers\LoginFormController.js
================================================================================


================================================================================
### PLIK: controllers\MapController.js
================================================================================

/**
 * ARCHITECTURE: MapController coordinates a map adapter to create a map, update its marker, and recenter.
 * It follows the manifesto by hiding vendor API behind a minimal surface tailored to the editor workflow.
 * Responsibilities:
 * - Initialize the map, move the marker to a coordinate, and recenter with optional zoom changes.
 * - Provide idempotent destroy() to free resources on route leave.
 */
export class MapController {
  constructor(mapAdapter) {
    this.adapter = mapAdapter;
    this._container = null;
    this._center = { lat: 52.2297, lon: 21.0122, zoom: 12 };
    this._ready = false;
  }

  async init(container, options) {
    this._container = container;
    const opt = options || this._center;
    await this.adapter.create(container, { lat: opt.lat, lon: opt.lon, zoom: opt.zoom });
    this._center = { lat: opt.lat, lon: opt.lon, zoom: opt.zoom };
    this._ready = true;
    return true;
  }

  async updateMarker(lat, lon, recenter = false) {
    if (!this._ready) throw new Error("MapController: map not initialized.");
    await this.adapter.setMarker(lat, lon);
    if (recenter) {
      await this.adapter.setCenter(lat, lon, this._center.zoom);
      this._center = { ...this._center, lat, lon };
    }
    return true;
  }

  async recenter(zoom) {
    if (!this._ready) throw new Error("MapController: map not initialized.");
    const z = typeof zoom === "number" ? zoom : this._center.zoom;
    await this.adapter.setCenter(this._center.lat, this._center.lon, z);
    this._center.zoom = z;
    return true;
  }

  async destroy() {
    await this.adapter.destroy();
    this._ready = false;
    this._container = null;
    return true;
  }
}


================================================================================
### PLIK: controllers\MapViewportPolicyController.js
================================================================================

/**
 * ARCHITECTURE: MapViewportPolicyController centralizes how the editor focuses the map on addresses.
 * It follows the manifesto by hiding viewport decisions behind a minimal, deterministic API.
 * Responsibilities:
 * - Focus on instant geocode or suggestion; update marker and optionally recenter.
 */
export class MapViewportPolicyController {
  constructor(mapController) {
    this.map = mapController;
  }

  async focusInstant(model) {
    const lat = Number(model?.latitude);
    const lon = Number(model?.longitude);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) return false;
    await this.map.updateMarker(lat, lon, true);
    return true;
  }

  async focusSuggestion(suggestion) {
    const lat = Number(suggestion?.latitude);
    const lon = Number(suggestion?.longitude);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) return false;
    await this.map.updateMarker(lat, lon, true);
    return true;
  }

  async focusAddress(addr) {
    const lat = Number(addr?.latitude);
    const lon = Number(addr?.longitude);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) return false;
    await this.map.updateMarker(lat, lon, true);
    return true;
  }
}


================================================================================
### PLIK: controllers\ntegrationOrchestrator.js
================================================================================

/**
 * ARCHITECTURE: IntegrationOrchestrator provides a single entrypoint to assemble worklist and editor stacks.
 * It follows the manifesto by exposing high-level factories for rapid bootstrapping in the app shell.
 * Responsibilities:
 * - Build WorklistFacade and EditorFacade instances and share session-scoped services between them.
 * - Provide a minimal API the root view can call to wire routes and screens quickly.
 */
import { WorklistFacade } from "@/controllers/WorklistFacade";
import { EditorFacade } from "@/controllers/EditorFacade";
import { OrdersQueueService } from "@/services/OrdersQueueService";
import { PollingService } from "@/services/PollingService";
import { AddressCorrectionService } from "@/services/AddressCorrectionService";
import { AddressAuditTrailService } from "@/services/AddressAuditTrailService";

export class IntegrationOrchestrator {
  constructor(googleApiKey) {
    this.googleApiKey = googleApiKey;
    this.queue = new OrdersQueueService();
    this.polling = new PollingService();
    this.audit = new AddressAuditTrailService();
    this.correction = new AddressCorrectionService(undefined, this.audit);
    this.worklist = new WorklistFacade(undefined, undefined, this.polling, this.queue);
    this.editor = new EditorFacade(this.googleApiKey, undefined, undefined, undefined, this.correction);
  }

  getWorklist() {
    return this.worklist;
  }

  getEditor() {
    return this.editor;
  }

  getAuditTrail() {
    return this.audit;
  }
}


================================================================================
### PLIK: controllers\PlacesHintController.js
================================================================================

/**
 * ARCHITECTURE: PlacesHintController coordinates Google Places type-ahead hints with session tokens and debouncing.
 * It follows the manifesto by isolating vendor semantics and timing concerns behind a single suggest() method.
 * Responsibilities:
 * - Use GooglePlacesSessionManager to reuse/renew AutocompleteSessionToken.
 * - Debounce keystrokes, query Places adapter, and return normalized suggestions.
 */
import { GooglePlacesSessionManager } from "@/adapters/GooglePlacesSessionManager";
import { DebounceTimer } from "@/services/DebounceTimer";
import { SuggestionNormalizer } from "@/services/SuggestionNormalizer";

export class PlacesHintController {
  constructor(googleObj, placesAdapter, debounceMs = 250) {
    this.google = googleObj;
    this.places = placesAdapter;
    this.session = new GooglePlacesSessionManager(this.google);
    this.debounce = new DebounceTimer(debounceMs);
    this.normalizer = new SuggestionNormalizer();
  }

  async suggest(freeText, country = "PL") {
    return this.debounce.run(async () => {
      if (!this.places || !freeText || !freeText.trim()) return [];
      const token = this.session.getToken();
      void token;
      const raw = await this.places.suggest(freeText, country);
      return this.normalizer.normalizeBatch(raw, "PLACES");
    });
  }

  renewSession() {
    this.session.renew();
    return true;
  }
}


================================================================================
### PLIK: controllers\ProviderFallbackController.js
================================================================================


================================================================================
### PLIK: controllers\ProviderGuard.js
================================================================================

/**
 * ARCHITECTURE: ProviderGuard enforces that TES address provider is GOOGLE before verification flows run.
 * It follows the manifesto by isolating cross-cutting preconditions and exposing a single guard method.
 * Responsibilities:
 * - Read current provider; if not GOOGLE, set it to GOOGLE using admin API.
 * - Cache the result to avoid redundant network calls during the session.
 */
import apiClient from "@/services/api";

export class ProviderGuard {
  constructor() {
    this._aligned = false;
    this._inFlight = null;
  }

  async ensureGoogle() {
    if (this._aligned) return true;
    if (this._inFlight) return this._inFlight;
    this._inFlight = this._align();
    try {
      const r = await this._inFlight;
      this._aligned = true;
      return r;
    } finally {
      this._inFlight = null;
    }
  }

  async _align() {
    const current = await apiClient.get("/api/admin/address-verification/providers/current");
    if (current?.data?.provider === "GOOGLE") return true;
    await apiClient.post("/api/admin/address-verification/providers/current", "GOOGLE", {
      headers: { "Content-Type": "text/plain" },
    });
    return true;
  }
}


================================================================================
### PLIK: controllers\QuickAcceptController.js
================================================================================

/**
 * ARCHITECTURE: QuickAcceptController enables one-click "best suggestion" acceptance per side.
 * It follows the manifesto by composing SuggestionSelectionController and EditorFacade.
 * Responsibilities:
 * - Compute best suggestion for the current input and apply it; return the applied index or null.
 */
import { SuggestionSelectionController } from "@/controllers/SuggestionSelectionController";

export class QuickAcceptController {
  constructor() {
    this.selector = new SuggestionSelectionController();
  }

  applyBest(side, baseInput, suggestions, editorFacade) {
    const best = this.selector.best(baseInput, suggestions);
    if (!best) return null;
    if (side === "pickup") editorFacade.acceptPickupSuggestion(best.index);
    if (side === "delivery") editorFacade.acceptDeliverySuggestion(best.index);
    return best.index;
  }
}


================================================================================
### PLIK: controllers\RealtimeVerificationOrchestrator.js
================================================================================

/**
 * ARCHITECTURE: RealtimeVerificationOrchestrator coordinates debounced input, geocode-with-cache, and places hints.
 * It follows the manifesto by composing small services to provide a single verify() for live user typing.
 * Responsibilities:
 * - Debounce the input, validate and normalize externally, then call geocode and places in parallel.
 * - Return a deterministic structure with instant geocode, ranked suggestions, and timing info.
 */
import { DebounceTimer } from "@/services/DebounceTimer";
import { AddressSuggestionRanker } from "@/services/AddressSuggestionRanker";
import { SuggestionNormalizer } from "@/services/SuggestionNormalizer";

export class RealtimeVerificationOrchestrator {
  constructor(geocodeController, placesAdapter, debounceMs = 350) {
    this.geocode = geocodeController;
    this.places = placesAdapter;
    this.debouncer = new DebounceTimer(debounceMs);
    this.ranker = new AddressSuggestionRanker();
    this.normalizer = new SuggestionNormalizer();
  }

  async verify(baseInput) {
    return this.debouncer.run(async () => {
      const t0 = performance.now ? performance.now() : Date.now();
      const [geo, placeRaw] = await Promise.all([
        this.geocode.geocode(baseInput),
        this.places ? this.places.suggest(this._freeText(baseInput), baseInput.country || "PL") : Promise.resolve([]),
      ]);
      const instant = geo
        ? {
            fullAddressLabel: null,
            street: baseInput.street || null,
            houseNumber: baseInput.houseNumber || null,
            postalCode: baseInput.postalCode || null,
            city: baseInput.city || null,
            countryCode: baseInput.country || "PL",
            countryName: null,
            latitude: geo.lat ?? null,
            longitude: geo.lon ?? null,
            matchScore: 1.0,
            matchLevel: "GEOCODER",
            providerSource: "GOOGLE_CLIENT",
          }
        : null;
      const places = this.normalizer.normalizeBatch(placeRaw, "PLACES");
      const merged = instant ? [instant, ...places] : places.slice();
      const ranked = this.ranker.rank(baseInput, merged);
      const t1 = performance.now ? performance.now() : Date.now();
      return { instant, suggestions: ranked, elapsedMs: Math.round(t1 - t0) };
    });
  }

  _freeText(a) {
    const line1 = a.houseNumber ? `${a.street} ${a.houseNumber}` : a.street || "";
    return `${line1}, ${a.postalCode || ""} ${a.city || ""}`.trim();
  }
}


================================================================================
### PLIK: controllers\SafeSaveController.js
================================================================================

/**
 * ARCHITECTURE: SafeSaveController guards persistence with equality checks and idempotency keys.
 * It follows the manifesto by preventing duplicate saves and short-circuiting when nothing changed.
 * Responsibilities:
 * - Compute a change key using AddressEqualityService; skip save if unchanged.
 * - Generate an idempotency token to pass to backend headers when available.
 */
import { AddressEqualityService } from "@/services/AddressEqualityService";

export class SafeSaveController {
  constructor(saver, equality = new AddressEqualityService()) {
    this.saver = saver;
    this.eq = equality;
    this._lastKey = null;
  }

  async saveIfChanged(payload) {
    const before = payload?.before || {};
    const after = payload?.after || {};
    const key = this._keyOf(before, after, payload?.orderId, payload?.side, payload?.resolution);
    if (key === this._lastKey) return { skipped: true, reason: "Duplicate save call" };
    const changed =
      (after.pickup && !this.eq.equals(before.pickup || {}, after.pickup)) ||
      (after.delivery && !this.eq.equals(before.delivery || {}, after.delivery));
    if (!changed) return { skipped: true, reason: "No changes" };
    const res = await this.saver.save(payload);
    if (res?.ok) this._lastKey = key;
    return { skipped: false, result: res };
  }

  _keyOf(before, after, orderId, side, resolution) {
    const h = (a) => this.eq.hash(a || {});
    return [orderId || "", side || "", resolution || "", h(before?.pickup), h(before?.delivery), h(after?.pickup), h(after?.delivery)].join("#");
  }
}


================================================================================
### PLIK: controllers\SaveAndNextController.js
================================================================================

/**
 * ARCHITECTURE: SaveAndNextController coordinates saving an address correction and loading the next order.
 * It follows the manifesto by composing persistence, queue sequencing, and editor orchestration behind one method.
 * Responsibilities:
 * - Execute a provided save function, remove current id from queue on success, and resolve the next id.
 * - Short-circuit when the queue is empty and return null for end-of-queue conditions.
 */
import { Result } from "@/domain/Result";

export class SaveAndNextController {
  constructor(ordersQueue, editorController) {
    this.queue = ordersQueue;
    this.editor = editorController;
  }

  async saveThenNext(saveFn) {
    const currentId = this.queue.current();
    if (!currentId) return Result.ok(null);
    const res = await saveFn();
    if (!res || res.ok === false) {
      const err = res?.error || new Error("Save failed.");
      return Result.fail(err);
    }
    this.queue.remove(currentId);
    const nextId = this.queue.current() || this.queue.next();
    if (!nextId) return Result.ok(null);
    const load = await this.editor.loadOrder(nextId);
    if (!load.ok) return Result.fail(load.error);
    return Result.ok(nextId);
  }
}


================================================================================
### PLIK: controllers\SaveFlowController.js
================================================================================

/**
 * ARCHITECTURE: SaveFlowController orchestrates saving pickup/delivery/both and computing next item.
 * It follows the manifesto by isolating save intent and queue stepping away from views.
 * Responsibilities:
 * - Save via IdempotentSaveController; on success, pop next id from OrdersQueueService for Save & Next.
 */
import { Result } from "@/domain/Result";

export class SaveFlowController {
  constructor(editorFacade, queueService, idempotentSaveController) {
    this.editor = editorFacade;
    this.queue = queueService || { current: () => null, next: () => null };
    this.saveController = idempotentSaveController;
  }

  async saveThenAwait(side = "both") {
    const snap = this.editor.snapshot();
    const orderId = snap.currentOrderId || snap.editor?.detail?.orderId || null;
    if (!orderId) return Result.fail(new Error("SaveFlow: no order id."));

    const before = {
      pickup: snap.editor?.detail?.originalPickup || null,
      delivery: snap.editor?.detail?.originalDelivery || null,
    };
    const after = {
      pickup: snap.editor?.editedPickup || null,
      delivery: snap.editor?.editedDelivery || null,
    };

    const payload = { orderId, side, before, after, resolution: "MANUAL_EDIT" };
    const r = await this.saveController.save(payload);
    if (!r.ok) return r;

    const nextId = this.queue.next();
    return Result.ok({ ok: true, nextId });
  }
}


================================================================================
### PLIK: controllers\SuggestionListController.js
================================================================================

/**
 * ARCHITECTURE: SuggestionListController manages selection and application of ranked suggestions.
 * It follows the manifesto by isolating list state from UI and delegating application to EditorFacade.
 * Responsibilities:
 * - Hold a cursor over suggestions, navigate next/prev, and apply current suggestion to pickup or delivery.
 * - Coordinate map viewport focusing for visual confirmation.
 */
import { SuggestionSelectionController } from "@/controllers/SuggestionSelectionController";
import { MapViewportPolicyController } from "@/controllers/MapViewportPolicyController";

export class SuggestionListController {
  constructor(editorFacade, mapController) {
    this.editor = editorFacade;
    this.selector = new SuggestionSelectionController();
    this.viewport = new MapViewportPolicyController(mapController);
    this.items = [];
    this.index = -1;
  }

  load(list) {
    this.items = Array.isArray(list) ? list.slice() : [];
    this.index = this.items.length ? 0 : -1;
    return this.snapshot();
  }

  select(i) {
    if (typeof i !== "number" || i < 0 || i >= this.items.length) return this.snapshot();
    this.index = i;
    return this.snapshot();
  }

  next() {
    if (this.items.length === 0) return this.snapshot();
    this.index = Math.min(this.items.length - 1, this.index + 1);
    return this.snapshot();
  }

  prev() {
    if (this.items.length === 0) return this.snapshot();
    this.index = Math.max(0, this.index - 1);
    return this.snapshot();
  }

  async applyTo(side = "pickup") {
    if (this.index < 0 || this.index >= this.items.length) return false;
    const sel = { index: this.index, suggestion: this.items[this.index] };
    const ok = this.selector.accept(this.editor, side, sel);
    if (ok) await this.viewport.focusSuggestion(sel.suggestion);
    return ok;
  }

  snapshot() {
    return {
      items: this.items.slice(),
      index: this.index,
      current: this.index >= 0 ? this.items[this.index] : null,
    };
  }
}


================================================================================
### PLIK: controllers\SuggestionPreviewController.js
================================================================================

/**
 * ARCHITECTURE: SuggestionPreviewController coordinates map focusing for a chosen suggestion.
 * It follows the manifesto by isolating viewport behavior from editor and views.
 * Responsibilities:
 * - Show a suggestion on the map by updating marker and recentering using MapViewportPolicyController.
 */
import { MapViewportPolicyController } from "@/controllers/MapViewportPolicyController";

export class SuggestionPreviewController {
  constructor(mapController) {
    this.map = mapController;
    this.policy = new MapViewportPolicyController(mapController);
  }

  async show(suggestion) {
    if (!suggestion) return false;
    return await this.policy.focusSuggestion(suggestion);
  }
}


================================================================================
### PLIK: controllers\SuggestionSelectionController.js
================================================================================

/**
 * ARCHITECTURE: SuggestionSelectionController selects and applies suggestions deterministically.
 * It follows the manifesto by keeping scoring and application separate from UI and transport.
 * Responsibilities:
 * - Pick the best suggestion; apply a chosen index to the editor facade for a given side.
 */
export class SuggestionSelectionController {
  best(baseInput, suggestions) {
    const list = Array.isArray(suggestions) ? suggestions : [];
    if (!list.length) return null;
    let bestIndex = 0;
    let bestScore = -Infinity;
    for (let i = 0; i < list.length; i++) {
      const s = list[i] || {};
      const score = this._score(baseInput, s);
      if (score > bestScore) {
        bestScore = score;
        bestIndex = i;
      }
    }
    return { index: bestIndex, suggestion: list[bestIndex] };
  }

  accept(editorFacade, side, sel) {
    if (!sel || typeof sel.index !== "number") return false;
    if (side === "pickup") {
      const r = editorFacade.acceptPickupSuggestion(sel.index);
      return !!r?.ok;
    }
    if (side === "delivery") {
      const r = editorFacade.acceptDeliverySuggestion(sel.index);
      return !!r?.ok;
    }
    return false;
  }

  _score(base, sug) {
    let score = 0;
    if (typeof sug.matchScore === "number") score += sug.matchScore * 100;
    if (this._eq(base?.city, sug?.city)) score += 5;
    if (this._eq(base?.postalCode, sug?.postalCode)) score += 10;
    if (this._eq(base?.street, sug?.street)) score += 3;
    return score;
  }

  _eq(a, b) {
    return (a || "").toString().trim().toLowerCase() === (b || "").toString().trim().toLowerCase();
  }
}


================================================================================
### PLIK: controllers\TesSuggestionController.js
================================================================================

/**
 * ARCHITECTURE: TesSuggestionController starts TES suggest/search operations and collects results via poller.
 * It follows the manifesto by separating TES IO from UI and merging outputs through a stable contract.
 * Responsibilities:
 * - Trigger suggest-on-demand or search-by-name; poll until done; return normalized suggestions.
 * - Delegate normalization/merging to provided collaborators without leaking TES DTOs to callers.
 */
import apiClient from "@/services/api";
import { TesOperationPoller } from "@/services/TesOperationPoller";
import { SuggestionNormalizer } from "@/services/SuggestionNormalizer";
import { AddressSuggestionMerger } from "@/services/AddressSuggestionMerger";
import { AddressSuggestionRanker } from "@/services/AddressSuggestionRanker";

export class TesSuggestionController {
  constructor(poller = new TesOperationPoller(), normalizer = new SuggestionNormalizer(), merger = new AddressSuggestionMerger(), ranker = new AddressSuggestionRanker()) {
    this.poller = poller;
    this.normalizer = normalizer;
    this.merger = merger;
    this.ranker = ranker;
  }

  async suggestOnDemand(addressDto, baseInputForRanking = null) {
    const start = await apiClient.post("/api/admin/address-verification/suggest-on-demand", addressDto);
    const cid = start?.data?.correlationId;
    if (!cid) throw new Error("TesSuggestionController: missing correlationId.");
    const done = await this.poller.waitFor(cid);
    if (done.status !== "COMPLETED") return [];
    const raw = done.result?.suggestions || [];
    const normalized = this.normalizer.normalizeBatch(raw, "TES");
    const merged = this.merger.merge(baseInputForRanking || addressDto, [normalized]);
    return this.ranker.rank(baseInputForRanking || addressDto, merged);
  }

  async searchByName(query, baseInputForRanking = null) {
    const start = await apiClient.post("/api/admin/address-verification/search-by-name", query, { headers: { "Content-Type": "text/plain" } });
    const cid = start?.data?.correlationId;
    if (!cid) throw new Error("TesSuggestionController: missing correlationId.");
    const done = await this.poller.waitFor(cid);
    if (done.status !== "COMPLETED") return [];
    const raw = done.result?.suggestions || [];
    const normalized = this.normalizer.normalizeBatch(raw, "TES");
    const merged = this.merger.merge(baseInputForRanking || {}, [normalized]);
    return this.ranker.rank(baseInputForRanking || {}, merged);
  }
}


================================================================================
### PLIK: controllers\TriageDashboardController.js
================================================================================

/**
 * ARCHITECTURE: TriageDashboardController orchestrates KPI tiles, batch/source lists, and error-type groupings.
 * It follows the manifesto by separating read-model orchestration from UI and router glue.
 * Responsibilities:
 * - Load KPIs, recent batches, and pending-by-error-type using AddressExceptionApi.
 * - Expose immutable snapshots for rendering.
 * - Integrate PollingService to keep the dashboard fresh without duplicating timers.
 */
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";
import { PollingService } from "@/services/PollingService";

export class TriageDashboardController {
  constructor(api = new AddressExceptionApi(), polling = new PollingService()) {
    this.api = api;
    this.polling = polling;
    this.loading = false;
    this.error = null;
    this.kpis = null;
    this.recentBatches = [];
    this.pendingByErrorType = [];
    this._pollHandles = [];
  }

  async loadAll() {
    this.loading = true;
    this.error = null;
    const [kpiRes, batchRes, typeRes] = await Promise.all([
      this.api.getTriageKpis(),
      this.api.getRecentBatches(),
      this.api.getPendingByErrorType(),
    ]);
    if (!kpiRes.ok) return this._fail(kpiRes.error);
    if (!batchRes.ok) return this._fail(batchRes.error);
    if (!typeRes.ok) return this._fail(typeRes.error);
    this.kpis = kpiRes.value;
    this.recentBatches = Array.isArray(batchRes.value) ? batchRes.value : [];
    this.pendingByErrorType = Array.isArray(typeRes.value) ? typeRes.value : [];
    this.loading = false;
    return Result.ok(this.snapshot());
  }

  startPolling(intervalMs = 10000) {
    this.stopPolling();
    const k = this.polling.start("kpis", intervalMs, async () => {
      const r = await this.api.getTriageKpis();
      if (r.ok) this.kpis = r.value;
    });
    const b = this.polling.start("batches", intervalMs, async () => {
      const r = await this.api.getRecentBatches();
      if (r.ok) this.recentBatches = Array.isArray(r.value) ? r.value : [];
    });
    const e = this.polling.start("errorsByType", intervalMs, async () => {
      const r = await this.api.getPendingByErrorType();
      if (r.ok) this.pendingByErrorType = Array.isArray(r.value) ? r.value : [];
    });
    this._pollHandles = [k, b, e];
    return this._pollHandles.slice();
  }

  stopPolling() {
    this.polling.stopAll();
    this._pollHandles = [];
  }

  snapshot() {
    return {
      loading: this.loading,
      error: this.error,
      kpis: this.kpis,
      recentBatches: this.recentBatches.slice(),
      pendingByErrorType: this.pendingByErrorType.slice(),
    };
  }

  _fail(err) {
    this.loading = false;
    this.error = err?.message || "Dashboard load failed.";
    return Result.fail(err);
  }
}


================================================================================
### PLIK: controllers\VerificationGuardController.js
================================================================================

/**
 * ARCHITECTURE: VerificationGuardController prevents unnecessary verification calls when input is incomplete.
 * It follows the manifesto by enforcing minimal field requirements before hitting providers.
 * Responsibilities:
 * - Check street, postal, and city presence; expose shouldVerify() with reason codes for UI hints.
 * - Reduce wasted quota and noise during live typing.
 */
export class VerificationGuardController {
  constructor() {
    this.required = ["street", "postalCode", "city"];
  }

  shouldVerify(input) {
    const missing = [];
    for (const f of this.required) {
      if (!input || !String(input[f] || "").trim()) missing.push(f);
    }
    if (missing.length) return { allow: false, reason: "MISSING_FIELDS", missing };
    return { allow: true, reason: "OK", missing: [] };
  }
}


================================================================================
### PLIK: controllers\VerificationPipelineController.js
================================================================================

/**
 * ARCHITECTURE: VerificationPipelineController composes timeout, merger, and ranking into a single step.
 * It follows the manifesto by hiding orchestration details behind a single run() method.
 * Responsibilities:
 * - Execute geocode + places + TES with budgets; merge and rank; return final suggestions list.
 */
import { VerificationTimeoutController } from "@/controllers/VerificationTimeoutController";
import { AddressSuggestionMerger } from "@/services/AddressSuggestionMerger";
import { AddressSuggestionRanker } from "@/services/AddressSuggestionRanker";

export class VerificationPipelineController {
  constructor(timeoutController, merger = new AddressSuggestionMerger(), ranker = new AddressSuggestionRanker()) {
    this.timeout = timeoutController;
    this.merger = merger;
    this.ranker = ranker;
  }

  async run(baseInput, ms = 1500) {
    const phased = await this.timeout.verifyWithin(baseInput, ms);
    const merged = this.merger.merge(baseInput, [phased.suggestions]);
    const ranked = this.ranker.rank(baseInput, merged);
    return { instant: phased.instant, suggestions: ranked, elapsed: phased.elapsed };
  }
}


================================================================================
### PLIK: controllers\VerificationTelemetryController.js
================================================================================


================================================================================
### PLIK: controllers\VerificationTimeoutController.js
================================================================================

/**
 * ARCHITECTURE: VerificationTimeoutController applies latency budgets to geocode and suggestion steps.
 * It follows the manifesto by composing LatencyBudget with provider adapters to keep UI responsive.
 * Responsibilities:
 * - Run geocode and suggestions with independent timeouts; return partial results when needed.
 * - Provide verifyWithin() that yields {instant,suggestions,elapsed:{geo,suggest}}.
 */
import { LatencyBudget } from "@/services/LatencyBudget";

export class VerificationTimeoutController {
  constructor(geocodeController, placesAdapter, tesController, budget = new LatencyBudget()) {
    this.geocode = geocodeController;
    this.places = placesAdapter;
    this.tes = tesController;
    this.budget = budget;
  }

  async verifyWithin(baseInput, ms = 1200) {
    const geo = await this.budget.runWithTimeout(() => this.geocode.geocode(baseInput), ms, null);
    const places = await this.budget.runWithTimeout(
      () => (this.places ? this.places.suggest(this._freeText(baseInput), baseInput.country || "PL") : Promise.resolve([])),
      ms,
      []
    );
    const tes = await this.budget.runWithTimeout(() => this.tes.suggestOnDemand(baseInput, baseInput), ms * 2, []);
    return {
      instant: geo.value ? { latitude: geo.value.lat ?? null, longitude: geo.value.lon ?? null } : null,
      suggestions: ([]).concat(places.value || []).concat(tes.value || []),
      elapsed: { geocodeMs: geo.elapsedMs, placesMs: places.elapsedMs, tesMs: tes.elapsedMs },
    };
  }

  _freeText(a) {
    const line1 = a.houseNumber ? `${a.street} ${a.houseNumber}` : a.street || "";
    return `${line1}, ${a.postalCode || ""} ${a.city || ""}`.trim();
  }
}


================================================================================
### PLIK: controllers\WorklistExportController.js
================================================================================

/**
 * ARCHITECTURE: WorklistExportController generates CSV exports for selected/all rows from the worklist.
 * It follows the manifesto by isolating export formatting from views and transport concerns.
 * Responsibilities:
 * - exportSelected(items, ids): download CSV for selected IDs.
 * - exportAll(items): download CSV for all current rows.
 */
export class WorklistExportController {
  constructor() {
    this.headers = [
      "orderId",
      "customerName",
      "source",
      "errorType",
      "processingStatus",
      "updatedAt",
    ];
  }

  exportSelected(items, ids) {
    const set = new Set(Array.isArray(ids) ? ids : []);
    const rows = (Array.isArray(items) ? items : []).filter(r => set.has(r.orderId));
    if (!rows.length) return false;
    return this._download(rows, "worklist_selected.csv");
  }

  exportAll(items) {
    const rows = Array.isArray(items) ? items : [];
    if (!rows.length) return false;
    return this._download(rows, "worklist_all.csv");
  }

  _download(rows, filename) {
    const csv = this._toCsv(rows);
    const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.href = url;
    link.download = filename || "export.csv";
    link.style.display = "none";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    return true;
  }

  _toCsv(rows) {
    const head = this.headers.join(",");
    const lines = rows.map(r => this.headers.map(h => this._esc(r?.[h])).join(","));
    return [head, ...lines].join("\n");
  }

  _esc(v) {
    const s = (v == null ? "" : String(v));
    if (/[",\n]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
    return s;
  }
}


================================================================================
### PLIK: controllers\WorklistFacade.js
================================================================================

/**
 * ARCHITECTURE: WorklistFacade composes WorklistStore with polling and queue projection for the view.
 * It follows the manifesto by keeping the component thin and isolating background refresh logic.
 * Responsibilities:
 * - Load the initial page of ADDRESS_NEEDS_REVIEW items using AddressExceptionApi via WorklistStore.
 * - Start/stop timed polling that refreshes the list and synchronizes the OrdersQueueService.
 * - Expose a stable snapshot for views without leaking store internals.
 */
import { WorklistStore } from "@/stores/WorklistStore";
import { PollingService } from "@/services/PollingService";
import { Result } from "@/domain/Result";

export class WorklistFacade {
  constructor(api = null, ordersQueueService = null) {
    this.store = new WorklistStore(api);
    this.queue = ordersQueueService || { loadFromItems: () => {}, ids: () => [], current: () => null, size: () => 0 };
    this.poll = new PollingService();
  }

  async initAndLoad(filters = {}) {
    this.store.setFilterPatch(filters || {});
    const r = await this.store.loadPage();
    if (!r.ok) return r;
    this.queue.loadFromItems(this.store.items);
    return Result.ok(this.snapshot());
  }

  startPolling(intervalMs = 10000) {
    this.poll.start("worklist", intervalMs, async () => {
      const r = await this.store.loadPage();
      if (r.ok) this.queue.loadFromItems(this.store.items);
    });
    return true;
  }

  stopPolling() {
    this.poll.stop("worklist");
    return true;
  }

  snapshot() {
    return {
      store: this.store.snapshot(),
      queue: { ids: this.queue.ids(), current: this.queue.current(), size: this.queue.size() },
    };
  }
}


================================================================================
### PLIK: controllers\WorklistKpiController.js
================================================================================

/**
 * ARCHITECTURE: WorklistKpiController computes KPIs from the current worklist dataset.
 * It follows the manifesto by isolating KPI math from views and data transport.
 * Responsibilities:
 * - Compute pending review count, automated clearance percent, and average resolution minutes.
 * - Return a KpiViewModel ready to render in the dashboard.
 */
import { KpiViewModel } from "@/viewmodels/KpiViewModel";

export class WorklistKpiController {
  compute(items) {
    const arr = Array.isArray(items) ? items : [];

    const total = arr.length;
    const pending = arr.filter(x => (x?.processingStatus || "").toUpperCase() === "ADDRESS_NEEDS_REVIEW").length;
    const autoCleared = arr.filter(x => (x?.processingStatus || "").toUpperCase() === "ADDRESS_VALIDATED").length;

    const clearancePercent = total > 0 ? (autoCleared / total) * 100 : 0;

    const minutes = [];
    for (const r of arr) {
      const created = r?.createdAt ? new Date(r.createdAt).getTime() : null;
      const updated = r?.updatedAt ? new Date(r.updatedAt).getTime() : null;
      if (created && updated && updated >= created) {
        const diffMin = (updated - created) / 60000;
        if (Number.isFinite(diffMin)) minutes.push(diffMin);
      }
    }
    const avgMinutes = minutes.length ? minutes.reduce((a, b) => a + b, 0) / minutes.length : 0;

    return new KpiViewModel({
      pending,
      clearancePercent,
      avgMinutes,
    });
  }
}


================================================================================
### PLIK: controllers\WorklistSelectionController.js
================================================================================

/**
 * ARCHITECTURE: WorklistSelectionController manages single, multi, and range selections in the grid.
 * It follows the manifesto by isolating selection math from visual components.
 * Responsibilities:
 * - Toggle, select range with anchors, and expose a stable array of selected IDs.
 */
export class WorklistSelectionController {
  constructor() {
    this._selected = new Set();
    this._lastAnchorIndex = null;
  }

  toggle(id, index) {
    if (this._selected.has(id)) this._selected.delete(id);
    else this._selected.add(id);
    this._lastAnchorIndex = typeof index === "number" ? index : this._lastAnchorIndex;
    return this.ids();
  }

  set(ids) {
    this._selected = new Set(Array.isArray(ids) ? ids : []);
    return this.ids();
  }

  clear() {
    this._selected.clear();
    this._lastAnchorIndex = null;
    return [];
  }

  range(allIds, toIndex) {
    if (!Array.isArray(allIds) || typeof this._lastAnchorIndex !== "number" || typeof toIndex !== "number") return this.ids();
    const [a, b] = [this._lastAnchorIndex, toIndex].sort((x, y) => x - y);
    for (let i = a; i <= b; i++) this._selected.add(allIds[i]);
    return this.ids();
  }

  ids() {
    return Array.from(this._selected.values());
  }
}


================================================================================
### PLIK: domain\BulkEditPlan.js
================================================================================

/**
 * ARCHITEKTURA: Deklaratywna definicja operacji masowej korekty adresów z podglądem i zastosowaniem.
 * Zaprojektowana do walidacji po stronie serwera oraz ponownej weryfikacji partii.
 */
export class BulkEditPlan {
  constructor(orderIds, field, mode, findPattern, replaceWith) {
    this.orderIds = Array.isArray(orderIds) ? orderIds : [];
    this.field = field;
    this.mode = mode;
    this.findPattern = findPattern;
    this.replaceWith = replaceWith;
  }

  static findReplace(orderIds, field, findPattern, replaceWith) {
    return new BulkEditPlan(orderIds, field, "FIND_REPLACE", findPattern, replaceWith);
  }

  static append(orderIds, field, suffix) {
    return new BulkEditPlan(orderIds, field, "APPEND", null, suffix);
  }

  static prepend(orderIds, field, prefix) {
    return new BulkEditPlan(orderIds, field, "PREPEND", null, prefix);
  }
}


================================================================================
### PLIK: domain\Result.js
================================================================================

/**
 * ARCHITEKTURA: Uniwersalny nośnik wyniku operacji (sukces/porażka) bez nulli i wyjątków sterujących przepływem.
 * Zapewnia spójny kontrakt dla wywołań usług oraz ułatwia kompozycję wyników.
 */
export class Result {
  constructor(ok, value, error) {
    this.ok = ok;
    this._value = value;
    this._error = error;
  }

  static ok(value) {
    return new Result(true, value, undefined);
  }

  static fail(error) {
    return new Result(false, undefined, error instanceof Error ? error : new Error(String(error)));
  }

  get value() {
    if (!this.ok) throw new Error("Attempt to get value from failed Result.");
    return this._value;
    }

  get error() {
    if (this.ok) throw new Error("Attempt to get error from successful Result.");
    return this._error;
  }

  map(fn) {
    return this.ok ? Result.ok(fn(this._value)) : Result.fail(this._error);
  }

  asyncMap(fn) {
    if (!this.ok) return Promise.resolve(Result.fail(this._error));
    return fn(this._value).then(Result.ok).catch(err => Result.fail(err));
  }
}


================================================================================
### PLIK: domain\WorkbenchModels.js
================================================================================

/**
 * ARCHITECTURE: WorkbenchModels define immutable value objects used by the editor and worklist.
 * It follows the manifesto by centralizing simple data models away from transport and views.
 * Responsibilities:
 * - Provide Address with factory helpers to ensure safe defaults and cloning.
 * - Offer toPlain() for persistence mapping without leaking internal structure.
 */
export class Address {
  constructor({ street = "", houseNumber = null, postalCode = "", city = "", country = "PL", latitude = null, longitude = null } = {}) {
    this.street = street || "";
    this.houseNumber = houseNumber || null;
    this.postalCode = postalCode || "";
    this.city = city || "";
    this.country = country || "PL";
    this.latitude = typeof latitude === "number" ? latitude : null;
    this.longitude = typeof longitude === "number" ? longitude : null;
  }

  static from(obj) {
    if (!obj || typeof obj !== "object") return new Address();
    return new Address({
      street: obj.street,
      houseNumber: obj.houseNumber,
      postalCode: obj.postalCode,
      city: obj.city,
      country: obj.country,
      latitude: obj.latitude,
      longitude: obj.longitude,
    });
  }

  clone() {
    return new Address(this);
  }

  toPlain() {
    return {
      street: this.street,
      houseNumber: this.houseNumber,
      postalCode: this.postalCode,
      city: this.city,
      country: this.country,
      latitude: this.latitude,
      longitude: this.longitude,
    };
  }
}


================================================================================
### PLIK: domain\WorklistFilter.js
================================================================================

/**
 * ARCHITEKTURA: Niemutowalny obiekt zapytania do listy roboczej. Odpowiada za serializację filtrów do parametrów URL.
 * Separuje szczegóły filtrowania od komponentów UI oraz usług sieciowych.
 */
export class WorklistFilter {
  constructor(search = null, source = null, errorTypes = [], minConfidence = null, maxConfidence = null, page = 1, pageSize = 50) {
    this.search = search;
    this.source = source;
    this.errorTypes = Array.isArray(errorTypes) ? errorTypes : [];
    this.minConfidence = minConfidence;
    this.maxConfidence = maxConfidence;
    this.page = page;
    this.pageSize = pageSize;
  }

  withPatch(patch) {
    return new WorklistFilter(
      patch.search ?? this.search,
      patch.source ?? this.source,
      patch.errorTypes ?? this.errorTypes.slice(),
      patch.minConfidence ?? this.minConfidence,
      patch.maxConfidence ?? this.maxConfidence,
      patch.page ?? this.page,
      patch.pageSize ?? this.pageSize
    );
  }

  toQueryRecord() {
    const q = {};
    if (this.search) q.q = this.search;
    if (this.source) q.source = this.source;
    if (this.errorTypes.length) q.errorTypes = this.errorTypes.join(",");
    if (this.minConfidence != null) q.minConfidence = String(this.minConfidence);
    if (this.maxConfidence != null) q.maxConfidence = String(this.maxConfidence);
    q.page = String(this.page);
    q.pageSize = String(this.pageSize);
    return q;
  }
}


================================================================================
### PLIK: router\AuthGuard.js
================================================================================

/**
 * ARCHITECTURE: AuthGuard protects routes by requiring an authenticated session from AuthSessionService.
 * It follows the manifesto by isolating navigation policy and avoiding component-level auth checks.
 * Responsibilities:
 * - canEnter(to): allow /login; require a token otherwise; throw to redirect.
 */
import { AuthSessionService } from "@/services/AuthSessionService";

export class AuthGuard {
  constructor(session = new AuthSessionService()) {
    this.session = session;
  }

  async canEnter(to) {
    const path = String(to?.path || "");
    if (path.startsWith("/login")) return true;
    if (this.session.isAuthenticated()) return true;
    throw new Error("AuthGuard: unauthenticated.");
  }
}


================================================================================
### PLIK: router\EditorRouteGuard.js
================================================================================

/**
 * ARCHITECTURE: EditorRouteGuard ensures prerequisites are met before entering the Correction Editor route.
 * It follows the manifesto by isolating cross-cutting navigation checks behind a simple guard class.
 * Responsibilities:
 * - Verify that TES provider is GOOGLE and that Google Maps JS can be loaded.
 * - Optionally validate presence of an orderId param to prevent broken editor sessions.
 */
import { ProviderGuard } from "@/controllers/ProviderGuard";
import { GoogleMapsScriptLoader } from "@/adapters/GoogleMapsScriptLoader";

export class EditorRouteGuard {
  constructor(googleApiKey) {
    this.googleApiKey = googleApiKey;
    this._provider = new ProviderGuard();
    this._loader = new GoogleMapsScriptLoader();
  }

  async canEnter(to) {
    const orderId = to?.params?.id || to?.query?.orderId || null;
    if (!orderId) throw new Error("EditorRouteGuard: orderId is required.");
    await this._provider.ensureGoogle();
    await this._loader.load(this.googleApiKey, ["places"]);
    return true;
  }
}


================================================================================
### PLIK: router\index.js
================================================================================

/**
 * ARCHITECTURE: router/index.js defines routes and applies authentication + editor readiness guards.
 * It follows the manifesto by isolating navigation rules and prereq checks from the views.
 * Responsibilities:
 * - Register routes: /login, /dashboard, /worklist, /editor/:id.
 * - Apply global AuthGuard, and per-route EditorRouteGuard for /editor.
 */
import { createRouter, createWebHistory } from "vue-router";
import LoginView from "@/views/LoginView.vue";
import WorklistView from "@/views/WorklistView.vue";
import CorrectionEditorView from "@/views/CorrectionEditorView.vue";
import TriageDashboard from "@/views/TriageDashboard.vue";
import { EditorRouteGuard } from "@/router/EditorRouteGuard";
import { AuthGuard } from "@/router/AuthGuard";

export function createRouterWithKey(googleApiKey) {
  const editorGuard = new EditorRouteGuard(googleApiKey);
  const authGuard = new AuthGuard();
  const routes = [
    { path: "/", redirect: "/worklist" },
    { path: "/login", name: "login", component: LoginView },
    { path: "/dashboard", name: "dashboard", component: TriageDashboard },
    { path: "/worklist", name: "worklist", component: WorklistView },
    {
      path: "/editor/:id",
      name: "editor",
      component: CorrectionEditorView,
      beforeEnter: async (to, _from, next) => {
        try { await editorGuard.canEnter(to); next(); } catch { next("/worklist"); }
      },
    },
    { path: "/:pathMatch(.*)*", redirect: "/worklist" },
  ];
  const router = createRouter({ history: createWebHistory(), routes });
  router.beforeEach(async (to, from, next) => {
    try { await authGuard.canEnter(to); next(); } catch { next({ path: "/login", query: { r: to.fullPath } }); }
  });
  return router;
}


================================================================================
### PLIK: services\AddressAuditTrailService.js
================================================================================

/**
 * ARCHITECTURE: AddressAuditTrailService maintains an in-memory audit stream for user actions.
 * It follows the manifesto by isolating audit appends and allowing later persistence without UI impact.
 * Responsibilities:
 * - Append entries and read them by orderId; provide a clear method for testability.
 */
export class AddressAuditTrailService {
  constructor() {
    this._byOrder = new Map();
  }

  append(entry) {
    const id = entry?.orderId || "unknown";
    const list = this._byOrder.get(id) || [];
    list.push({ ...entry, at: new Date().toISOString() });
    this._byOrder.set(id, list);
    return true;
  }

  list(orderId) {
    return (this._byOrder.get(orderId) || []).slice();
  }

  clear(orderId) {
    if (!orderId) return false;
    this._byOrder.delete(orderId);
    return true;
  }
}


================================================================================
### PLIK: services\AddressClipboardService.js
================================================================================

/**
 * ARCHITECTURE: AddressClipboardService copies formatted addresses to clipboard for quick customer contact.
 * It follows the manifesto by isolating browser clipboard usage and formatting concerns.
 * Responsibilities:
 * - Build single-line and multi-line strings and write to navigator.clipboard if available.
 * - Provide deterministic return values indicating success or failure without throwing.
 */
export class AddressClipboardService {
  constructor() {
    this.available = typeof navigator !== "undefined" && !!navigator.clipboard;
  }

  async copyOneLine(a) {
    const str = this._oneLine(a);
    return this._copy(str);
  }

  async copyTwoLines(a) {
    const str = this._twoLines(a);
    return this._copy(str);
  }

  async _copy(str) {
    if (!this.available) return { ok: false, reason: "Clipboard unavailable" };
    try {
      await navigator.clipboard.writeText(str);
      return { ok: true };
    } catch (_) {
      return { ok: false, reason: "Clipboard write failed" };
    }
  }

  _oneLine(a) {
    const p1 = [a?.street, a?.houseNumber].filter(Boolean).join(" ");
    const p2 = [a?.postalCode, a?.city].filter(Boolean).join(" ");
    const p3 = a?.country || "PL";
    return [p1, p2, p3].filter(Boolean).join(", ");
  }

  _twoLines(a) {
    const p1 = [a?.street, a?.houseNumber].filter(Boolean).join(" ");
    const p2 = [a?.postalCode, a?.city, a?.country || "PL"].filter(Boolean).join(", ");
    return `${p1}\n${p2}`;
  }
}


================================================================================
### PLIK: services\AddressCorrectionService.js
================================================================================

/**
 * ARCHITECTURE: AddressCorrectionService persists address fixes to the backend and records an audit entry.
 * It follows the manifesto by isolating persistence and audit concerns behind one explicit contract.
 * Responsibilities:
 * - Save corrections via AddressExceptionApi with explicit resolution mode.
 * - Append audit entries using AddressAuditTrailService and provide a deterministic Result object.
 */
import { Result } from "@/domain/Result";
import { AddressAuditTrailService } from "@/services/AddressAuditTrailService";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

export class AddressCorrectionService {
  constructor(api = new AddressExceptionApi(), audit = new AddressAuditTrailService()) {
    this.api = api;
    this.audit = audit;
  }

  async save({ orderId, side, before, after, resolution }) {
    const res = await this.api.saveCorrection({
      orderId,
      side,
      correctedPickup: side === "pickup" || side === "both" ? after?.pickup || null : null,
      correctedDelivery: side === "delivery" || side === "both" ? after?.delivery || null : null,
      resolution: resolution || "MANUAL_EDIT",
    });
    if (!res.ok) return Result.fail(res.error);
    this.audit.append({
      orderId,
      side,
      action: resolution || "MANUAL_EDIT",
      before,
      after,
      diff: null,
    });
    return Result.ok(res.value);
  }
}


================================================================================
### PLIK: services\AddressEqualityService.js
================================================================================

/**
 * ARCHITECTURE: AddressEqualityService computes structural equality and a stable hash for Address DTOs.
 * It follows the manifesto by providing deterministic comparisons without UI or transport concerns.
 * Responsibilities:
 * - Compare two addresses field-by-field with normalization of whitespace and case.
 * - Produce a hash string for use in caches, audit, or deduplication logic.
 */
export class AddressEqualityService {
  constructor() {
    this._fields = ["street", "houseNumber", "postalCode", "city", "country", "latitude", "longitude"];
  }

  equals(a, b) {
    if (!a || !b) return false;
    for (const f of this._fields) {
      if (!this._eq(a[f], b[f])) return false;
    }
    return true;
  }

  hash(a) {
    const s = (x) => (x == null ? "" : String(x).trim().toLowerCase());
    const n = (x) => (typeof x === "number" ? x.toFixed(6) : "");
    const parts = [
      s(a?.street),
      s(a?.houseNumber),
      s(a?.postalCode),
      s(a?.city),
      s(a?.country),
      n(a?.latitude),
      n(a?.longitude),
    ];
    return this._simpleHash(parts.join("|"));
  }

  _eq(a, b) {
    if (typeof a === "number" || typeof b === "number") {
      return Number(a || 0).toFixed(6) === Number(b || 0).toFixed(6);
    }
    return (a || "").toString().trim().toLowerCase() === (b || "").toString().trim().toLowerCase();
  }

  _simpleHash(str) {
    let h = 0;
    for (let i = 0; i < str.length; i++) {
      h = (h << 5) - h + str.charCodeAt(i);
      h |= 0;
    }
    return `h${(h >>> 0).toString(16)}`;
  }
}


================================================================================
### PLIK: services\AddressExceptionApi.js
================================================================================

/**
 * ARCHITECTURE: AddressExceptionApi encapsulates backend endpoints for worklist and editor operations.
 * It follows the manifesto by isolating transport, shaping payloads, and returning Result objects.
 * Responsibilities:
 * - Fetch worklist pages and order detail; submit address corrections with optional idempotency token.
 */
import api from "@/services/api";
import { Result } from "@/domain/Result";

export class AddressExceptionApi {
  constructor(basePath = "/api/address-exceptions") {
    this.basePath = basePath.replace(/\/+$/, "");
  }

  async getWorklist({ page = 1, size = 25, query = null, source = null, errorTypes = [], confidenceMin = 0, confidenceMax = 100 }) {
    try {
      const q = new URLSearchParams();
      q.set("page", String(page));
      q.set("size", String(size));
      if (query) q.set("query", query);
      if (source) q.set("source", source);
      if (Array.isArray(errorTypes)) errorTypes.forEach(e => q.append("errorTypes", e));
      q.set("confidenceMin", String(confidenceMin));
      q.set("confidenceMax", String(confidenceMax));
      const res = await api.get(`${this.basePath}/worklist?${q.toString()}`);
      const data = res.data || {};
      return Result.ok({
        items: Array.isArray(data.items) ? data.items : [],
        total: Number(data.total || 0),
      });
    } catch (e) {
      return Result.fail(e);
    }
  }

  async getOrderDetail(orderId) {
    try {
      const res = await api.get(`${this.basePath}/orders/${encodeURIComponent(orderId)}`);
      const data = res.data || {};
      return Result.ok({
        orderId: data.orderId || orderId,
        originalPickup: data.originalPickup || null,
        originalDelivery: data.originalDelivery || null,
        processingStatus: data.processingStatus || null,
        createdAt: data.createdAt || null,
        updatedAt: data.updatedAt || null,
      });
    } catch (e) {
      return Result.fail(e);
    }
  }

  async saveCorrection(body, idempotencyToken = null) {
    try {
      const headers = idempotencyToken ? { "Idempotency-Key": idempotencyToken } : {};
      const res = await api.post(`${this.basePath}/orders/${encodeURIComponent(body.orderId || "")}/corrections`, body, { headers });
      return Result.ok(res.data || true);
    } catch (e) {
      return Result.fail(e);
    }
  }
}


================================================================================
### PLIK: services\AddressFieldGuard.js
================================================================================

/**
 * ARCHITECTURE: AddressFieldGuard enforces form field enable/disable rules per country and workflow state.
 * It follows the manifesto by isolating editability policies from components and controllers.
 * Responsibilities:
 * - Decide if a field is editable based on country rules, verification status, and role flags.
 * - Provide a stateless canEdit(field, context) API returning a boolean.
 */
export class AddressFieldGuard {
  constructor() {
    this._rules = new Map();
    this._rules.set("PL", {
      postalCode: () => true,
      street: () => true,
      houseNumber: () => true,
      city: () => true,
      country: () => false,
    });
  }

  register(country, rules) {
    this._rules.set((country || "PL").toUpperCase(), rules);
    return true;
  }

  canEdit(field, context) {
    const c = (context?.country || "PL").toUpperCase();
    const rules = this._rules.get(c) || this._rules.get("PL");
    if (typeof rules[field] === "function") return !!rules[field](context);
    return true;
  }
}


================================================================================
### PLIK: services\AddressFormatterService.js
================================================================================

/**
 * ARCHITECTURE: AddressFormatterService produces consistent, locale-aware display strings for addresses.
 * It follows the manifesto by separating presentation formatting from data models and controllers.
 * Responsibilities:
 * - Format single-line and multi-line address strings with optional fallbacks.
 * - Handle missing fields gracefully and avoid mutating inputs.
 */
export class AddressFormatterService {
  constructor(defaultCountry = "PL") {
    this.defaultCountry = defaultCountry;
  }

  oneLine(a) {
    if (!a) return "";
    const parts = [];
    const line1 = [a.street, a.houseNumber].filter(Boolean).join(" ").trim();
    if (line1) parts.push(line1);
    const line2 = [a.postalCode, a.city].filter(Boolean).join(" ").trim();
    if (line2) parts.push(line2);
    const c = a.country || this.defaultCountry;
    if (c) parts.push(c);
    return parts.join(", ");
  }

  twoLines(a) {
    if (!a) return { line1: "", line2: "" };
    const line1 = [a.street, a.houseNumber].filter(Boolean).join(" ").trim();
    const line2 = [[a.postalCode, a.city].filter(Boolean).join(" ").trim(), a.country || this.defaultCountry].filter(Boolean).join(", ");
    return { line1, line2 };
  }
}


================================================================================
### PLIK: services\AddressGeocodeCache.js
================================================================================


================================================================================
### PLIK: services\AddressHistoryService.js
================================================================================

/**
 * ARCHITECTURE: AddressHistoryService records a per-order timeline of edits and applied suggestions.
 * It follows the manifesto by providing an append-only log consumable by the audit or session history.
 * Responsibilities:
 * - Append events with before/after snapshots and provider info; read back per orderId.
 */
export class AddressHistoryService {
  constructor() {
    this._byOrder = new Map();
  }

  append(orderId, payload) {
    if (!orderId) return false;
    const list = this._byOrder.get(orderId) || [];
    list.push({
      at: new Date().toISOString(),
      type: payload?.type || "EDIT",
      side: payload?.side || "both",
      provider: payload?.provider || null,
      before: payload?.before || null,
      after: payload?.after || null,
    });
    this._byOrder.set(orderId, list);
    return true;
  }

  list(orderId) {
    return (this._byOrder.get(orderId) || []).slice();
  }

  clear(orderId) {
    if (!orderId) return false;
    this._byOrder.delete(orderId);
    return true;
  }
}


================================================================================
### PLIK: services\AddressInputMaskService.js
================================================================================


================================================================================
### PLIK: services\AddressNormalizer.js
================================================================================

/**
 * ARCHITECTURE: AddressNormalizer sanitizes raw address input into a consistent DTO used by verification.
 * It follows the manifesto by providing pure, deterministic transformations without UI or transport coupling.
 * Responsibilities:
 * - Trim whitespace, stabilize casing, and normalize postal code for PL (e.g., "00123" → "00-123").
 * - Guarantee presence of all expected fields with safe defaults.
 */
export class AddressNormalizer {
  constructor(defaultCountry = "PL") {
    this.defaultCountry = defaultCountry.toUpperCase();
  }

  normalize(a) {
    const street = this._sp(a?.street);
    const houseNumber = this._hn(a?.houseNumber);
    const city = this._cap(this._sp(a?.city));
    const country = this._cc(a?.country);
    const postalCode = this._postal(a?.postalCode, country);
    const latitude = this._num(a?.latitude);
    const longitude = this._num(a?.longitude);
    return { street, houseNumber, postalCode, city, country, latitude, longitude };
  }

  _sp(v) {
    return (v || "").toString().replace(/\s+/g, " ").trim();
  }

  _hn(v) {
    const s = (v == null ? "" : String(v)).replace(/\s+/g, "").trim();
    return s.length ? s : null;
  }

  _cap(v) {
    if (!v) return "";
    return v.charAt(0).toUpperCase() + v.slice(1);
  }

  _cc(v) {
    const s = (v || this.defaultCountry).toString().trim().toUpperCase();
    return s || this.defaultCountry;
  }

  _postal(v, country) {
    const raw = (v || "").replace(/\s|-/g, "");
    if ((country || "").toUpperCase() === "PL") {
      if (raw.length < 5) return raw;
      return `${raw.slice(0, 2)}-${raw.slice(2, 5)}`;
    }
    return v || "";
  }

  _num(v) {
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  }
}


================================================================================
### PLIK: services\AddressPersistenceMapper.js
================================================================================

/**
 * ARCHITECTURE: AddressPersistenceMapper shapes editor state into backend save payloads.
 * It follows the manifesto by isolating transport DTO mapping away from controllers and views.
 * Responsibilities:
 * - Map orderId, side, before/after models and resolution into /corrections payload.
 */
export class AddressPersistenceMapper {
  toSavePayload(orderId, side, before, after, resolution) {
    const s = (side || "both").toLowerCase();
    const body = {
      orderId: orderId,
      side: s === "pickup" || s === "delivery" ? s : "both",
      resolution: resolution || "MANUAL_EDIT",
      correctedPickup: s === "delivery" ? null : (after?.pickup || after?.correctedPickup || after?.editedPickup || after || null),
      correctedDelivery: s === "pickup" ? null : (after?.delivery || after?.correctedDelivery || after?.editedDelivery || after || null),
      beforePickup: s === "delivery" ? null : (before?.pickup || before?.originalPickup || before || null),
      beforeDelivery: s === "pickup" ? null : (before?.delivery || before?.originalDelivery || before || null),
    };
    return body;
  }
}


================================================================================
### PLIK: services\AddressRulesService.js
================================================================================

/**
 * ARCHITECTURE: AddressRulesService centralizes country-specific rules for required fields and masks.
 * It follows the manifesto by separating rule data from controllers and adapters.
 * Responsibilities:
 * - Provide requiredFields(country) and postalRegex(country) for validation and hints.
 */
export class AddressRulesService {
  constructor() {
    this._req = new Map();
    this._req.set("PL", ["street", "postalCode", "city", "country"]);
    this._postal = new Map();
    this._postal.set("PL", /^(\d{2}-\d{3}|\d{5})$/);
  }

  requiredFields(country = "PL") {
    return this._req.get((country || "PL").toUpperCase()) || this._req.get("PL");
  }

  postalRegex(country = "PL") {
    return this._postal.get((country || "PL").toUpperCase()) || /.*/;
  }
}


================================================================================
### PLIK: services\AddressSuggestionMerger.js
================================================================================


================================================================================
### PLIK: services\AddressSuggestionRanker.js
================================================================================

/**
 * ARCHITECTURE: AddressSuggestionRanker orders suggestions by confidence and locality relevance.
 * It follows the manifesto by keeping ranking policy separate from UI and transport details.
 * Responsibilities:
 * - Sort by matchScore desc, then city/postal match with the base input, then provider priority.
 */
export class AddressSuggestionRanker {
  rank(baseInput, list) {
    const arr = Array.isArray(list) ? list.slice() : [];
    const prio = (p) => (p === "GOOGLE_CLIENT" ? 3 : p === "GOOGLE_PLACES" ? 2 : p === "TES" ? 1 : 0);
    const eq = (a, b) => (a || "").toString().trim().toLowerCase() === (b || "").toString().trim().toLowerCase();
    arr.sort((a, b) => {
      const sa = typeof a.matchScore === "number" ? a.matchScore : 0;
      const sb = typeof b.matchScore === "number" ? b.matchScore : 0;
      if (sb !== sa) return sb - sa;
      const ca = eq(a.city, baseInput?.city) ? 1 : 0;
      const cb = eq(b.city, baseInput?.city) ? 1 : 0;
      if (cb !== ca) return cb - ca;
      const pa = eq(a.postalCode, baseInput?.postalCode) ? 1 : 0;
      const pb = eq(b.postalCode, baseInput?.postalCode) ? 1 : 0;
      if (pb !== pa) return pb - pa;
      return prio(b.providerSource) - prio(a.providerSource);
    });
    return arr;
  }
}


================================================================================
### PLIK: services\addressSuggestionService.js
================================================================================

// PLIK: services/addressSuggestionService.js

import apiClient from '@/services/api.js';

/**
 * ARCHITEKTURA: Serwis frontendowy do obsługi asynchronicznej weryfikacji adresów.
 * Komunikuje się ze starym, opartym na Kafce i pollingu, API w DANXILS_API.
 * Funkcja pollForResults cyklicznie odpytuje backend o status operacji
 * zainicjowanej przez fetchOnDemandSuggestions lub fetchByNameSearch.
 */
const pollForResults = async (correlationId) => {
  const maxRetries = 10;
  const interval = 2000;

  for (let i = 0; i < maxRetries; i++) {
    await new Promise(resolve => setTimeout(resolve, interval));
    
    // POPRAWKA: Usunięto prefiks '/api' ze ścieżki.
    // Ścieżka jest teraz względna do 'baseURL' zdefiniowanego w apiClient.
    const statusResponse = await apiClient.get(`/api/admin/address-verification/operations/${correlationId}`);
    const operation = statusResponse.data;

    if (operation.status === 'COMPLETED') {
      return operation.result?.suggestions || [];
    }
    if (operation.status === 'FAILED') {
      throw new Error(operation.errorDetails || 'Operacja wyszukiwania sugestii nie powiodła się.');
    }
  }
  throw new Error('Przekroczono czas oczekiwania na sugestie adresowe.');
};

export const fetchOnDemandSuggestions = async (addressQuery) => {
  if (!addressQuery || Object.values(addressQuery).every(v => !v)) {
    return [];
  }
  
  try {
    // POPRAWKA: Usunięto prefiks '/api'.
    const initiateResponse = await apiClient.post('/api/admin/address-verification/suggest-on-demand', addressQuery);
    const correlationId = initiateResponse.data.correlationId;
    if (!correlationId) {
        throw new Error("API nie zwróciło correlationId dla operacji sugestii.");
    }
    return await pollForResults(correlationId);
  } catch (error) {
    console.error('Błąd podczas pobierania dynamicznych sugestii:', error);
    return [];
  }
};

export const fetchByNameSearch = async (searchQuery) => {
  if (!searchQuery || searchQuery.trim() === '') {
    return [];
  }
  
  try {
    // POPRAWKA: Usunięto prefiks '/api'.
    const initiateResponse = await apiClient.post('/api/admin/address-verification/search-by-name', searchQuery, {
        headers: { 'Content-Type': 'text/plain' }
    });
    const correlationId = initiateResponse.data.correlationId;
    if (!correlationId) {
        throw new Error("API nie zwróciło correlationId dla operacji wyszukiwania.");
    }
    return await pollForResults(correlationId);
  } catch (error) {
    console.error('Błąd podczas wyszukiwania po nazwie:', error);
    return [];
  }
};

================================================================================
### PLIK: services\addressVerificationService.js
================================================================================

// PLIK: src/services/addressVerificationService.js
import apiClient from '@/services/api.js';

/**
 * ARCHITEKTURA: Serwis frontendowy do obsługi synchronicznej weryfikacji adresów.
 * Komunikuje się z nowym, synchronicznym endpointem proxy w DANXILS_API,
 * który z kolei odpytuje TES-service. Zapewnia natychmiastową odpowiedź
 * dla interfejsu użytkownika, stanowiąc dedykowane rozwiązanie dla interaktywnych
 * komponentów UI i celowo oddzielone od asynchronicznego `addressSuggestionService`.
 */
export const verifyAddress = async (addressQuery) => {
    if (!addressQuery || !addressQuery.street || !addressQuery.city || !addressQuery.postalCode) {
        throw new Error("Ulica, miasto i kod pocztowy są wymagane do weryfikacji.");
    }
    
    try {
        const response = await apiClient.get('/api/address-tools/verify', {
            params: addressQuery
        });
        return response.data;
    } catch (error) {
        console.error('Błąd podczas synchronicznej weryfikacji adresu:', error);
        const errorMessage = error.response?.data?.error || 'Wystąpił błąd podczas weryfikacji adresu.';
        throw new Error(errorMessage);
    }
};

================================================================================
### PLIK: services\api.js
================================================================================

/**
 * ARCHITECTURE: Axios singleton configured for the frontend.
 * It follows the manifesto by centralizing HTTP transport with a deterministic baseURL and JSON defaults.
 * Responsibilities:
 * - Create a single axios instance with baseURL from env (window.__API_BASE_URL__ or Vite).
 * - Expose get/post/put/delete via the instance; support Authorization binding via axios.defaults.
 */
import axios from "axios";

function resolveBaseUrl() {
  const w = typeof window !== "undefined" ? window : {};
  const winBase = (w.__API_BASE_URL__ || "").trim();
  // Vite inline env (works in dev/build)
  const viteBase = (import.meta && import.meta.env && import.meta.env.VITE_API_BASE_URL) || "";
  const base = (winBase || viteBase || "").replace(/\/+$/, "");
  return base || "http://localhost:8080";
}

const api = axios.create({
  baseURL: resolveBaseUrl(),
  withCredentials: true,
  headers: {
    "Accept": "application/json",
    "Content-Type": "application/json",
  },
});

api.interceptors.response.use(
  (res) => res,
  (err) => {
    // Keep deterministic shape for callers that expect error.message
    err.message = err?.response?.data?.message || err.message || "Request failed";
    return Promise.reject(err);
  }
);

export default api;


================================================================================
### PLIK: services\ApiAuthBinder.js
================================================================================

/**
 * ARCHITECTURE: ApiAuthBinder binds/unbinds the Authorization header on the shared ApiHttpClient singleton.
 * Responsibilities:
 * - Apply "Authorization: <type> <token>" to axios defaults; remove it on logout.
 */
import apiClient from "@/services/api";

export class ApiAuthBinder {
  constructor() {
    this.headerName = "Authorization";
  }

  bind(accessToken, tokenType = "Bearer") {
    if (!accessToken) return false;
    const scheme = String(tokenType || "Bearer").trim() || "Bearer";
    if (!apiClient.defaults.headers) apiClient.defaults.headers = {};
    if (!apiClient.defaults.headers.common) apiClient.defaults.headers.common = {};
    apiClient.defaults.headers.common[this.headerName] = `${scheme} ${accessToken}`;
    return true;
  }

  unbind() {
    if (apiClient?.defaults?.headers?.common && this.headerName in apiClient.defaults.headers.common) {
      delete apiClient.defaults.headers.common[this.headerName];
      return true;
    }
    return false;
  }
}


================================================================================
### PLIK: services\ApiErrorMapper.js
================================================================================


================================================================================
### PLIK: services\AuthApi.js
================================================================================

/**
 * ARCHITECTURE: AuthApi encapsulates authentication HTTP calls against the backend auth service.
 * It follows the manifesto by isolating transport details and returning deterministic Result objects.
 * Responsibilities:
 * - POST credentials to /auth/login and return a normalized session object on success.
 * - Keep transport client injectable for testing; default to the shared Axios instance.
 */
import api from "@/services/api";
import { Result } from "@/domain/Result";

export class AuthApi {
  constructor(httpClient = api) {
    this.http = httpClient;
  }

  async login(username, password) {
    try {
      const res = await this.http.post("/auth/login", { username, password });
      const data = res?.data || {};
      const session = {
        accessToken: data.accessToken || null,
        refreshToken: data.refreshToken || null,
        tokenType: data.tokenType || "Bearer",
        username: data.username || username || null,
        roles: Array.isArray(data.roles) ? data.roles : [],
      };
      if (!session.accessToken) return Result.fail(new Error("AuthApi: accessToken missing in response."));
      return Result.ok(session);
    } catch (e) {
      return Result.fail(e instanceof Error ? e : new Error("AuthApi: login failed"));
    }
  }
}


================================================================================
### PLIK: services\AuthSessionService.js
================================================================================

/**
 * ARCHITECTURE: AuthSessionService persists auth tokens and user profile and exposes accessors.
 * It follows the manifesto by isolating storage mechanics and providing deterministic getters/setters.
 * Responsibilities:
 * - Save/load/remove session in localStorage with a namespaced key.
 * - Expose isAuthenticated(), getAccessToken(), getTokenType(), getUser(), hasRole().
 */
export class AuthSessionService {
  constructor(namespace = "danxils_auth") {
    this.ns = namespace;
    this.store = typeof window !== "undefined" ? window.localStorage : null;
  }

  save(session) {
    if (!this.store) return false;
    const payload = {
      accessToken: session?.accessToken || null,
      refreshToken: session?.refreshToken || null,
      tokenType: session?.tokenType || "Bearer",
      username: session?.username || null,
      roles: Array.isArray(session?.roles) ? session.roles : [],
      at: Date.now(),
    };
    this.store.setItem(this.ns, JSON.stringify(payload));
    return true;
  }

  load() {
    if (!this.store) return null;
    const raw = this.store.getItem(this.ns);
    if (!raw) return null;
    try { return JSON.parse(raw); } catch { return null; }
  }

  clear() {
    if (!this.store) return false;
    this.store.removeItem(this.ns);
    return true;
  }

  isAuthenticated() {
    const s = this.load();
    return !!(s && s.accessToken);
  }

  getAccessToken() {
    const s = this.load();
    return s?.accessToken || null;
  }

  getTokenType() {
    const s = this.load();
    return s?.tokenType || "Bearer";
  }

  getUser() {
    const s = this.load();
    return { username: s?.username || null, roles: Array.isArray(s?.roles) ? s.roles : [] };
  }

  hasRole(role) {
    const s = this.load();
    const roles = Array.isArray(s?.roles) ? s.roles : [];
    return roles.includes(role);
  }
}


================================================================================
### PLIK: services\CsvBuilder.js
================================================================================

/**
 * ARCHITECTURE: CsvBuilder builds CSV text from arrays of objects without UI or transport coupling.
 * It follows the manifesto by providing a pure data-to-text transformation with stable escaping.
 * Responsibilities:
 * - Accept columns definition and rows; output RFC-4180-compliant CSV with quotes/escaping.
 * - Return a string for download or clipboard without side effects.
 */
export class CsvBuilder {
  constructor(columns) {
    if (!Array.isArray(columns) || columns.length === 0) throw new Error("CsvBuilder: columns are required.");
    this.columns = columns; // [{key:'orderId', title:'Order ID'}, ...]
  }

  build(rows) {
    const head = this.columns.map(c => this._q(c.title || c.key)).join(",");
    const body = (Array.isArray(rows) ? rows : []).map(r => this.columns.map(c => this._q(r[c.key])).join(",")).join("\n");
    return [head, body].filter(Boolean).join("\n");
  }

  _q(v) {
    const s = v == null ? "" : String(v);
    if (/[",\n]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
    return s;
  }
}


================================================================================
### PLIK: services\DebounceTimer.js
================================================================================

/**
 * ARCHITECTURE: DebounceTimer provides deterministic debouncing for keystroke-driven verification.
 * It follows the manifesto by encapsulating timing concerns and exposing a minimal, testable contract.
 * Responsibilities:
 * - Debounce a single async task, cancelling the previous one if a new call arrives within the interval.
 * - Prevent overlapping executions by using a monotonically increasing token.
 */
export class DebounceTimer {
  constructor(delayMs = 400) {
    this.delayMs = delayMs;
    this._timer = null;
    this._token = 0;
  }

  run(asyncFn) {
    return new Promise((resolve, reject) => {
      const current = ++this._token;
      if (this._timer) clearTimeout(this._timer);
      this._timer = setTimeout(async () => {
        try {
          if (current !== this._token) return resolve(null);
          const r = await asyncFn();
          if (current !== this._token) return resolve(null);
          resolve(r);
        } catch (e) {
          reject(e);
        }
      }, this.delayMs);
    });
  }

  cancel() {
    if (this._timer) clearTimeout(this._timer);
    this._timer = null;
    this._token++;
  }
}


================================================================================
### PLIK: services\DiffService.js
================================================================================

/**
 * ARCHITECTURE: DiffService computes before/after differences for Address DTO fields.
 * It follows the manifesto by isolating comparison logic from viewmodels and controllers.
 * Responsibilities:
 * - Compare two objects field-by-field; return {entries[], anyChanged}.
 */
export class DiffService {
  constructor(fields = ["street", "houseNumber", "postalCode", "city", "country", "latitude", "longitude"]) {
    this.fields = fields.slice();
  }

  diff(before, after) {
    const entries = this.fields.map(f => {
      const b = this._val(before, f);
      const a = this._val(after, f);
      const changed = !this._eq(b, a);
      return { field: f, before: b, after: a, changed };
    });
    const anyChanged = entries.some(e => e.changed);
    return { entries, anyChanged };
  }

  _val(obj, field) {
    if (!obj) return null;
    return obj[field] ?? null;
  }

  _eq(a, b) {
    if (typeof a === "number" || typeof b === "number") return Number(a || 0).toFixed(6) === Number(b || 0).toFixed(6);
    return (a || "").toString().trim().toLowerCase() === (b || "").toString().trim().toLowerCase();
  }
}


================================================================================
### PLIK: services\EditorStateSerializer.js
================================================================================

/**
 * ARCHITECTURE: EditorStateSerializer persists and restores editor state across reloads in session storage.
 * It follows the manifesto by isolating serialization concerns and avoiding component-level side effects.
 * Responsibilities:
 * - Save minimal editor payload keyed by orderId; restore and clear on demand.
 * - Handle safe JSON parse/stringify and namespace keys to avoid collisions.
 */
export class EditorStateSerializer {
  constructor(namespace = "editor") {
    this.ns = namespace;
    this._store = typeof window !== "undefined" ? window.sessionStorage : null;
  }

  save(orderId, state) {
    if (!this._store || !orderId) return false;
    const key = this._key(orderId);
    const payload = {
      at: Date.now(),
      editedPickup: state?.editedPickup || null,
      editedDelivery: state?.editedDelivery || null,
    };
    this._store.setItem(key, JSON.stringify(payload));
    return true;
  }

  load(orderId) {
    if (!this._store || !orderId) return null;
    const raw = this._store.getItem(this._key(orderId));
    if (!raw) return null;
    try {
      return JSON.parse(raw);
    } catch {
      return null;
    }
  }

  clear(orderId) {
    if (!this._store || !orderId) return false;
    this._store.removeItem(this._key(orderId));
    return true;
  }

  _key(orderId) {
    return `${this.ns}:${orderId}`;
  }
}


================================================================================
### PLIK: services\EnvironmentConfigService.js
================================================================================

/**
 * ARCHITECTURE: EnvironmentConfigService centralizes runtime configuration discovery for the frontend.
 * It follows the manifesto by isolating environment concerns and producing a deterministic config object.
 * Responsibilities:
 * - Load API base URL and flags from environment variables or window-injected globals.
 * - Expose get(key) and typed helpers; set window.__API_BASE_URL__ for ApiHttpClient consumers.
 */
export class EnvironmentConfigService {
  constructor() {
    this._loaded = false;
    this._cfg = {
      API_BASE_URL: "",
      GOOGLE_MAPS_API_KEY: "",
      APP_ENV: "development",
    };
  }

  async load() {
    if (this._loaded) return this._cfg;
    const w = typeof window !== "undefined" ? window : {};
    const env = w.__APP_ENV__ || {};
    const apiFromWindow = (w.__API_BASE_URL__ || "").trim();
    const apiFromEnv = (import.meta && import.meta.env && import.meta.env.VITE_API_BASE_URL) || "";
    const keyFromWindow = (w.__GOOGLE_MAPS_API_KEY__ || "").trim();
    const keyFromEnv = (import.meta && import.meta.env && import.meta.env.VITE_GOOGLE_MAPS_API_KEY) || "";
    const appEnv = (import.meta && import.meta.env && import.meta.env.MODE) || env.MODE || "development";
    this._cfg = {
      API_BASE_URL: apiFromWindow || apiFromEnv || "",
      GOOGLE_MAPS_API_KEY: keyFromWindow || keyFromEnv || "",
      APP_ENV: appEnv,
    };
    if (typeof window !== "undefined") {
      window.__API_BASE_URL__ = this._cfg.API_BASE_URL;
    }
    this._loaded = true;
    return this._cfg;
  }

  get(key, fallback = null) {
    return Object.prototype.hasOwnProperty.call(this._cfg, key) ? this._cfg[key] : fallback;
  }

  apiBase() {
    return this.get("API_BASE_URL", "");
  }

  googleKey() {
    return this.get("GOOGLE_MAPS_API_KEY", "");
  }

  appEnv() {
    return this.get("APP_ENV", "development");
  }
}


================================================================================
### PLIK: services\ErrorTypeDictionary.js
================================================================================

/**
 * ARCHITECTURE: ErrorTypeDictionary maps backend error codes to user-facing labels and severities.
 * It follows the manifesto by isolating presentation-neutral taxonomy from API DTOs.
 * Responsibilities:
 * - Provide stable lookups for label, severity, and suggested actions per error type.
 * - Allow extension via register() without changing existing mappings.
 */
export class ErrorTypeDictionary {
  constructor() {
    this._map = new Map();
    this._map.set("INVALID_POSTAL_CODE", { label: "Invalid ZIP/Postal Code", severity: "critical", actions: ["verify", "fix-postal"] });
    this._map.set("AMBIGUOUS_STREET", { label: "Ambiguous Street (Apt/Suite missing)", severity: "warning", actions: ["add-apartment", "verify"] });
    this._map.set("NON_STANDARDIZED", { label: "Non-standardized Address", severity: "info", actions: ["normalize", "verify"] });
  }

  get(code) {
    return this._map.get(code) || { label: code || "Unknown Error", severity: "info", actions: [] };
  }

  register(code, entry) {
    if (!code || typeof entry !== "object") throw new Error("ErrorTypeDictionary: invalid registration.");
    this._map.set(code, entry);
    return true;
  }
}


================================================================================
### PLIK: services\FeatureFlagService.js
================================================================================

/**
 * ARCHITECTURE: FeatureFlagService loads and caches runtime feature flags that guide UX policies.
 * It follows the manifesto by centralizing flag access behind explicit getters with session caching.
 * Responsibilities:
 * - Fetch flags from backend once; expose booleans for critical flows (requireGeocode, bulkEdit).
 * - Allow local overrides for testing without changing backend state.
 */
import apiClient from "@/services/api";

export class FeatureFlagService {
  constructor(endpoint = "/status/feature-flags") {
    this.endpoint = endpoint;
    this._flags = null;
    this._inFlight = null;
    this._overrides = {};
  }

  async load() {
    if (this._flags) return this._flags;
    if (this._inFlight) return this._inFlight;
    this._inFlight = apiClient.get(this.endpoint).then(r => {
      this._flags = r?.data || {};
      return this._flags;
    }).finally(() => (this._inFlight = null));
    return this._inFlight;
  }

  setOverride(key, value) {
    this._overrides[key] = value;
    return true;
  }

  get(key, fallback = false) {
    const base = this._flags && Object.prototype.hasOwnProperty.call(this._flags, key) ? this._flags[key] : fallback;
    return Object.prototype.hasOwnProperty.call(this._overrides, key) ? this._overrides[key] : base;
  }

  requireGeocode() {
    return !!this.get("REQUIRE_GEOCODE", false);
  }

  allowBulkEdit() {
    return !!this.get("ALLOW_BULK_EDIT", true);
  }
}


================================================================================
### PLIK: services\GoogleErrorTranslator.js
================================================================================

/**
 * ARCHITECTURE: GoogleErrorTranslator maps Google Maps/Places status messages to stable application errors.
 * It follows the manifesto by isolating third-party semantics from business logic and controllers.
 * Responsibilities:
 * - Translate known status/error strings to canonical codes and user-friendly messages.
 * - Provide a simple translate(err) that returns {code,message,retryable}.
 */
export class GoogleErrorTranslator {
  constructor() {
    this._map = new Map();
    this._map.set("OVER_QUERY_LIMIT", { code: "RATE_LIMIT", message: "Google quota exceeded", retryable: true });
    this._map.set("ZERO_RESULTS", { code: "NO_RESULTS", message: "No results found", retryable: false });
    this._map.set("REQUEST_DENIED", { code: "DENIED", message: "Request denied by Google", retryable: false });
    this._map.set("INVALID_REQUEST", { code: "INVALID", message: "Invalid geocoding request", retryable: false });
    this._map.set("UNKNOWN_ERROR", { code: "UNKNOWN", message: "Temporary Google error", retryable: true });
  }

  translate(error) {
    const msg = (error?.message || "").toUpperCase();
    for (const [k, v] of this._map.entries()) {
      if (msg.includes(k)) return v;
    }
    const status = error?.status || error?.response?.status || null;
    if (status === 429) return { code: "RATE_LIMIT", message: "Rate limit reached", retryable: true };
    if (status === 503) return { code: "UNAVAILABLE", message: "Service unavailable", retryable: true };
    return { code: "GENERIC", message: error?.message || "Unexpected Google error", retryable: false };
  }
}


================================================================================
### PLIK: services\GoogleKeyProvider.js
================================================================================

/**
 * ARCHITECTURE: GoogleKeyProvider offers a minimal, cached accessor for the Google Maps API key.
 * Responsibilities:
 * - Resolve the key from EnvironmentConfigService once and memoize it.
 */
import { EnvironmentConfigService } from "@/services/EnvironmentConfigService";

export class GoogleKeyProvider {
  constructor(configService = new EnvironmentConfigService()) {
    this.config = configService;
    this._key = null;
    this._inFlight = null;
  }

  async getKey() {
    if (this._key) return this._key;
    if (this._inFlight) return this._inFlight;
    this._inFlight = this.config.load().then(() => {
      this._key = this.config.googleKey();
      if (!this._key) throw new Error("GoogleKeyProvider: GOOGLE_MAPS_JS_API_KEY missing.");
      return this._key;
    }).finally(() => {
      this._inFlight = null;
    });
    return this._inFlight;
  }
}


================================================================================
### PLIK: services\IdempotencyTokenService.js
================================================================================

/**
 * ARCHITECTURE: IdempotencyTokenService creates deterministic tokens for save requests.
 * It follows the manifesto by isolating token generation from controllers and transport layers.
 * Responsibilities:
 * - Produce a stable hash-like token from orderId, side, and payload string.
 */
export class IdempotencyTokenService {
  create(orderId, side, payloadString) {
    const base = `${orderId || ""}|${side || "both"}|${payloadString || ""}`;
    // Simple Fowler–Noll–Vo (FNV-1a) 32-bit hash for deterministic tokens
    let h = 0x811c9dc5;
    for (let i = 0; i < base.length; i++) {
      h ^= base.charCodeAt(i);
      h = (h + ((h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24))) >>> 0;
    }
    return `idem-${h.toString(16)}`;
  }
}


================================================================================
### PLIK: services\LatencyBudget.js
================================================================================

/**
 * ARCHITECTURE: LatencyBudget enforces per-step execution budgets for snappy UX under load.
 * It follows the manifesto by isolating timing limits and providing a race-with-timeout helper.
 * Responsibilities:
 * - Wrap a promise with a timeout; resolve fallback when exceeded; report elapsed for telemetry.
 */
export class LatencyBudget {
  constructor(defaultMs = 1200) {
    this.defaultMs = Math.max(100, defaultMs);
  }

  async runWithTimeout(promiseFactory, timeoutMs = this.defaultMs, fallback = null) {
    const start = Date.now();
    const to = new Promise(resolve => setTimeout(() => resolve({ timeout: true, value: fallback }), Math.max(50, timeoutMs)));
    const op = Promise.resolve().then(() => promiseFactory()).then(v => ({ timeout: false, value: v }));
    const res = await Promise.race([to, op]);
    const elapsedMs = Date.now() - start;
    return { ...res, elapsedMs };
  }
}


================================================================================
### PLIK: services\LoadingBarrier.js
================================================================================

/**
 * ARCHITECTURE: LoadingBarrier serializes concurrent loads by key and ensures latest-wins semantics.
 * It follows the manifesto by centralizing anti-race logic for order detail fetches and suggestion refreshes.
 * Responsibilities:
 * - Track an incrementing ticket per key; resolve only if the ticket is still current when the promise returns.
 * - Provide a simple run(key, fn) API that callers wrap around their async loads.
 */
export class LoadingBarrier {
  constructor() {
    this._tickets = new Map();
  }

  async run(key, fn) {
    if (!key || typeof fn !== "function") throw new Error("LoadingBarrier: invalid arguments.");
    const next = (this._tickets.get(key) || 0) + 1;
    this._tickets.set(key, next);
    const myTicket = next;
    const result = await fn();
    if (this._tickets.get(key) !== myTicket) return null;
    return result;
  }

  invalidate(key) {
    const next = (this._tickets.get(key) || 0) + 1;
    this._tickets.set(key, next);
    return next;
  }
}


================================================================================
### PLIK: services\OrderDetailPrefetcher.js
================================================================================

/**
 * ARCHITECTURE: OrderDetailPrefetcher warms the cache by fetching the next order detail proactively.
 * It follows the manifesto by separating performance optimizations from core controllers.
 * Responsibilities:
 * - Prefetch via AddressExceptionApi and hold a single-item cache keyed by orderId.
 * - Provide getOrFetch(id) to serve from cache or network.
 */
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

export class OrderDetailPrefetcher {
  constructor(api = new AddressExceptionApi()) {
    this.api = api;
    this._cachedId = null;
    this._cached = null;
  }

  async prefetch(nextOrderId) {
    if (!nextOrderId) return false;
    const r = await this.api.getOrderDetail(nextOrderId);
    if (r.ok) {
      this._cachedId = nextOrderId;
      this._cached = r.value;
      return true;
    }
    return false;
  }

  async getOrFetch(orderId) {
    if (this._cachedId === orderId && this._cached) return this._cached;
    const r = await this.api.getOrderDetail(orderId);
    if (r.ok) {
      this._cachedId = orderId;
      this._cached = r.value;
      return r.value;
    }
    throw r.error;
  }

  clear() {
    this._cachedId = null;
    this._cached = null;
    return true;
  }
}


================================================================================
### PLIK: services\OrdersKpiEstimator.js
================================================================================


================================================================================
### PLIK: services\OrdersQueueService.js
================================================================================

/**
 * ARCHITECTURE: OrdersQueueService maintains a FIFO queue of orderIds for Save & Next workflows.
 * It follows the manifesto by isolating queue mechanics from components and views.
 * Responsibilities:
 * - Load from a list, advance to next, remove current, inspect current/size/ids.
 */
export class OrdersQueueService {
  constructor() {
    this._ids = [];
    this._index = 0;
  }

  loadFromItems(items) {
    this._ids = (Array.isArray(items) ? items : []).map(x => x.orderId).filter(Boolean);
    this._index = 0;
    return this.ids();
  }

  ids() {
    return this._ids.slice();
  }

  size() {
    return Math.max(0, this._ids.length - this._index);
  }

  current() {
    return this._ids[this._index] || null;
  }

  next() {
    if (this._index + 1 >= this._ids.length) return null;
    this._index++;
    return this.current();
  }

  remove(orderId) {
    const pos = this._ids.indexOf(orderId);
    if (pos === -1) return false;
    this._ids.splice(pos, 1);
    if (this._index > pos) this._index--;
    return true;
  }

  reset() {
    this._ids = [];
    this._index = 0;
    return true;
  }
}


================================================================================
### PLIK: services\OrderStatusWatcher.js
================================================================================

/**
 * ARCHITECTURE: OrderStatusWatcher polls backend for a single order until a target status is reached.
 * It follows the manifesto by isolating polling semantics from views and controllers with a clear contract.
 * Responsibilities:
 * - Poll /orders/{id} at a fixed interval and resolve when status ∈ target set or when max time elapses.
 * - Expose start(), cancel(), and onTick hooks for progress indicators without leaking transport details.
 */
import apiClient from "@/services/api";

export class OrderStatusWatcher {
  constructor(intervalMs = 2000, timeoutMs = 60000) {
    this.intervalMs = Math.max(250, intervalMs);
    this.timeoutMs = Math.max(this.intervalMs, timeoutMs);
    this._timer = null;
    this._startedAt = 0;
    this._active = false;
    this._onTick = null;
  }

  onTick(fn) {
    this._onTick = typeof fn === "function" ? fn : null;
    return this;
  }

  start(orderId, targetStatuses = ["ADDRESS_VALIDATED", "MANUALLY_CORRECTED"]) {
    if (!orderId) throw new Error("OrderStatusWatcher: orderId required.");
    this.cancel();
    this._active = true;
    this._startedAt = Date.now();
    return new Promise((resolve, reject) => {
      const tick = async () => {
        if (!this._active) return;
        try {
          const r = await apiClient.get(`/orders/${encodeURIComponent(orderId)}`);
          const status = r?.data?.processingStatus || null;
          if (this._onTick) this._onTick({ status, elapsedMs: Date.now() - this._startedAt });
          if (status && targetStatuses.includes(status)) {
            this.cancel();
            return resolve({ status, elapsedMs: Date.now() - this._startedAt });
          }
        } catch (e) {
          this.cancel();
          return reject(e);
        }
        if (Date.now() - this._startedAt > this.timeoutMs) {
          this.cancel();
          return resolve({ status: null, elapsedMs: this.timeoutMs, timeout: true });
        }
        this._timer = setTimeout(tick, this.intervalMs);
      };
      this._timer = setTimeout(tick, this.intervalMs);
    });
  }

  cancel() {
    this._active = false;
    if (this._timer) clearTimeout(this._timer);
    this._timer = null;
    return true;
  }
}


================================================================================
### PLIK: services\PollingService.js
================================================================================

/**
 * ARCHITECTURE: PollingService centralizes controlled, single-instance polling loops per key.
 * It follows the manifesto by isolating timing concerns and exposing explicit start/stop contracts.
 * Responsibilities:
 * - Start a debounced timer for an async function and prevent duplicate loops for the same key.
 * - Provide deterministic cancellation via handles and bulk stop-All capability.
 */
export class PollingService {
  constructor() {
    this._timers = new Map();
  }

  start(key, intervalMs, asyncFn) {
    if (!key || typeof asyncFn !== "function" || typeof intervalMs !== "number" || intervalMs <= 0) {
      throw new Error("PollingService.start: invalid arguments.");
    }
    this.stop(key);
    let active = true;
    const tick = async () => {
      if (!active) return;
      try {
        await asyncFn();
      } catch (_) {
        // Errors are handled upstream; polling continues unless explicitly stopped.
      }
      if (active) {
        this._timers.set(key, setTimeout(tick, intervalMs));
      }
    };
    this._timers.set(key, setTimeout(tick, intervalMs));
    return { key, stop: () => this.stop(key) };
  }

  stop(key) {
    const t = this._timers.get(key);
    if (t) {
      clearTimeout(t);
      this._timers.delete(key);
    }
  }

  stopAll() {
    for (const key of this._timers.keys()) {
      this.stop(key);
    }
  }
}


================================================================================
### PLIK: services\QuotaBackoffService.js
================================================================================


================================================================================
### PLIK: services\RetryPolicy.js
================================================================================

/**
 * ARCHITECTURE: RetryPolicy executes async operations with bounded retries and jittered backoff.
 * It follows the manifesto by centralizing resilience concerns away from controllers and adapters.
 * Responsibilities:
 * - Execute a provided async function up to maxAttempts with exponential backoff and random jitter.
 * - Allow fast-fail on non-retryable errors via predicate.
 */
export class RetryPolicy {
  constructor(maxAttempts = 5, baseDelayMs = 300, jitterMs = 150, isRetryable = () => true) {
    this.maxAttempts = Math.max(1, maxAttempts);
    this.baseDelayMs = Math.max(0, baseDelayMs);
    this.jitterMs = Math.max(0, jitterMs);
    this.isRetryable = isRetryable;
  }

  async execute(fn) {
    let attempt = 0;
    let lastError = null;
    while (attempt < this.maxAttempts) {
      try {
        return await fn();
      } catch (e) {
        lastError = e;
        attempt++;
        if (attempt >= this.maxAttempts || !this.isRetryable(e)) break;
        const backoff = this.baseDelayMs * Math.pow(2, attempt - 1);
        const jitter = Math.floor(Math.random() * this.jitterMs);
        await new Promise((r) => setTimeout(r, backoff + jitter));
      }
    }
    throw lastError || new Error("RetryPolicy: execution failed.");
  }
}


================================================================================
### PLIK: services\RuntimeHealthService.js
================================================================================

/**
 * ARCHITECTURE: RuntimeHealthService probes backend/provider readiness but never blocks the UI.
 * It follows the manifesto by isolating network checks and returning a tolerant structured result.
 * Responsibilities:
 * - Try GET /status/health and /status/provider; if they fail, mark as unknown but keep ready=true.
 * - Treat Google key presence as a soft signal only.
 */
import apiClient from "@/services/api";

export class RuntimeHealthService {
  async readiness(googleKey) {
    const out = {
      ready: true,                 // tolerant by default
      backend: { ok: false, code: null },
      provider: { ok: false, code: null },
      google: { ok: !!googleKey },
    };

    try {
      const h = await apiClient.get("/status/health");
      out.backend.ok = (h?.status === 200) || !!h?.data?.ok;
      out.backend.code = h?.status ?? 200;
    } catch (e) {
      out.backend.ok = false;
      out.backend.code = e?.response?.status ?? 0;
      // keep out.ready = true to avoid blocking the app when status routes are absent
    }

    try {
      const p = await apiClient.get("/status/provider");
      out.provider.ok = (p?.status === 200) || !!p?.data?.ok;
      out.provider.code = p?.status ?? 200;
    } catch (e) {
      out.provider.ok = false;
      out.provider.code = e?.response?.status ?? 0;
    }

    return out;
  }
}


================================================================================
### PLIK: services\SessionStorageService.js
================================================================================

/**
 * ARCHITECTURE: SessionStorageService persists small JSON blobs across reloads within the session.
 * It follows the manifesto by isolating storage read/write and providing safe JSON handling.
 * Responsibilities:
 * - Save and load values by key with automatic JSON serialization and prefixing to avoid collisions.
 * - Provide remove and clearNamespace utilities without affecting unrelated storage.
 */
export class SessionStorageService {
  constructor(namespace = "wb") {
    this.ns = namespace;
    this._prefix = `${this.ns}:`;
    this._store = typeof window !== "undefined" ? window.sessionStorage : null;
  }

  save(key, value) {
    if (!this._store) return false;
    this._store.setItem(this._prefix + key, JSON.stringify(value == null ? null : value));
    return true;
  }

  load(key, fallback = null) {
    if (!this._store) return fallback;
    const raw = this._store.getItem(this._prefix + key);
    if (raw == null) return fallback;
    try {
      return JSON.parse(raw);
    } catch {
      return fallback;
    }
  }

  remove(key) {
    if (!this._store) return false;
    this._store.removeItem(this._prefix + key);
    return true;
  }

  clearNamespace() {
    if (!this._store) return 0;
    const keys = [];
    for (let i = 0; i < this._store.length; i++) {
      const k = this._store.key(i);
      if (k && k.startsWith(this._prefix)) keys.push(k);
    }
    keys.forEach(k => this._store.removeItem(k));
    return keys.length;
  }
}


================================================================================
### PLIK: services\SuggestionConflictDetector.js
================================================================================


================================================================================
### PLIK: services\SuggestionNormalizer.js
================================================================================

/**
 * ARCHITECTURE: SuggestionNormalizer converts heterogeneous provider responses into a unified Suggestion DTO.
 * It follows the manifesto by isolating mapping/normalization concerns and avoiding provider leakage into UI.
 * Responsibilities:
 * - Accept raw Google Geocoder/Places or TES suggestion objects and output a normalized shape.
 * - Provide batch normalization and safe defaults for missing fields.
 */
export class SuggestionNormalizer {
  constructor(defaultCountry = "PL") {
    this.defaultCountry = defaultCountry;
  }

  fromGoogleGeocoder(geo) {
    if (!geo) return null;
    const comp = this._indexComponents(geo.address_components || []);
    return {
      fullAddressLabel: geo.formatted_address || null,
      street: comp.route || null,
      houseNumber: comp.street_number || null,
      postalCode: comp.postal_code || null,
      city: comp.locality || comp.postal_town || comp.administrative_area_level_2 || null,
      countryCode: comp.country_code || this.defaultCountry,
      countryName: comp.country || null,
      latitude: geo.geometry?.location?.lat?.() ?? null,
      longitude: geo.geometry?.location?.lng?.() ?? null,
      matchScore: 0.95,
      matchLevel: "GEOCODER",
      providerSource: "GOOGLE_CLIENT",
    };
  }

  fromGooglePlaces(place) {
    if (!place) return null;
    const comp = this._indexComponents(place.address_components || []);
    return {
      fullAddressLabel: null,
      street: comp.route || null,
      houseNumber: comp.street_number || null,
      postalCode: comp.postal_code || null,
      city: comp.locality || comp.postal_town || comp.administrative_area_level_2 || null,
      countryCode: comp.country_code || this.defaultCountry,
      countryName: comp.country || null,
      latitude: place.geometry?.location?.lat?.() ?? null,
      longitude: place.geometry?.location?.lng?.() ?? null,
      matchScore: 0.9,
      matchLevel: "PLACES",
      providerSource: "GOOGLE_PLACES",
    };
  }

  fromTes(item) {
    if (!item) return null;
    return {
      fullAddressLabel: item.label || null,
      street: item.street || null,
      houseNumber: item.houseNumber || null,
      postalCode: item.postalCode || null,
      city: item.city || null,
      countryCode: item.countryCode || this.defaultCountry,
      countryName: item.country || null,
      latitude: typeof item.latitude === "number" ? item.latitude : null,
      longitude: typeof item.longitude === "number" ? item.longitude : null,
      matchScore: typeof item.score === "number" ? item.score : 0.7,
      matchLevel: item.level || "TES",
      providerSource: "TES",
    };
  }

  normalizeBatch(list, origin) {
    if (!Array.isArray(list)) return [];
    if (origin === "GEOCODER") return list.map(x => this.fromGoogleGeocoder(x)).filter(Boolean);
    if (origin === "PLACES") return list.map(x => this.fromGooglePlaces(x)).filter(Boolean);
    if (origin === "TES") return list.map(x => this.fromTes(x)).filter(Boolean);
    return [];
  }

  _indexComponents(parts) {
    const map = {};
    for (const c of parts) {
      for (const t of c.types) {
        if (t === "country") {
          map.country = c.long_name;
          map.country_code = c.short_name;
        } else if (t === "locality") {
          map.locality = c.long_name;
        } else if (t === "postal_town") {
          map.postal_town = c.long_name;
        } else if (t === "administrative_area_level_2") {
          map.administrative_area_level_2 = c.long_name;
        } else if (t === "route") {
          map.route = c.long_name;
        } else if (t === "street_number") {
          map.street_number = c.long_name;
        } else if (t === "postal_code") {
          map.postal_code = c.long_name;
        }
      }
    }
    return map;
  }
}


================================================================================
### PLIK: services\SuggestionPreviewService.js
================================================================================

/**
 * ARCHITECTURE: SuggestionPreviewService creates a non-destructive preview Address object from a suggestion.
 * It follows the manifesto by isolating conversion rules away from editor state and components.
 * Responsibilities:
 * - Convert a suggestion DTO to an Address-like object the map can display without committing changes.
 */
export class SuggestionPreviewService {
  toAddressLike(s) {
    if (!s) return null;
    return {
      street: s.street || "",
      houseNumber: s.houseNumber || null,
      postalCode: s.postalCode || "",
      city: s.city || "",
      country: s.countryCode || s.country || "PL",
      latitude: typeof s.latitude === "number" ? s.latitude : null,
      longitude: typeof s.longitude === "number" ? s.longitude : null,
    };
  }
}


================================================================================
### PLIK: services\TelemetryService.js
================================================================================

/**
 * ARCHITECTURE: TelemetryService emits structured events for operational analytics without UI coupling.
 * It follows the manifesto by isolating event formatting and transport behind a simple emit() contract.
 * Responsibilities:
 * - Buffer events in-memory and flush periodically via a provided transport function.
 * - Tag events with session time, category, and correlation fields for downstream analysis.
 */
export class TelemetryService {
  constructor(transportFn = null, flushIntervalMs = 15000, maxBuffer = 200) {
    this.transportFn = typeof transportFn === "function" ? transportFn : null;
    this.flushIntervalMs = flushIntervalMs;
    this.maxBuffer = maxBuffer;
    this._buf = [];
    this._timer = null;
  }

  start() {
    if (this._timer) return false;
    this._timer = setInterval(() => this.flush().catch(() => {}), this.flushIntervalMs);
    return true;
  }

  stop() {
    if (!this._timer) return false;
    clearInterval(this._timer);
    this._timer = null;
    return true;
  }

  emit(event) {
    const e = {
      at: Date.now(),
      category: event?.category || "ux",
      name: event?.name || "unknown",
      data: event?.data || {},
      corr: event?.corr || null,
    };
    this._buf.push(e);
    if (this._buf.length >= this.maxBuffer) this.flush().catch(() => {});
    return e;
  }

  async flush() {
    if (!this.transportFn || this._buf.length === 0) return 0;
    const batch = this._buf.splice(0, this._buf.length);
    await this.transportFn(batch);
    return batch.length;
  }
}


================================================================================
### PLIK: services\TesOperationPoller.js
================================================================================


================================================================================
### PLIK: services\UndoStackService.js
================================================================================

/**
 * ARCHITECTURE: UndoStackService provides bounded undo/redo stacks for immutable editor state snapshots.
 * It follows the manifesto by isolating time-travel mechanics with a deterministic, dependency-free API.
 * Responsibilities:
 * - Push snapshots, undo, redo, and limit memory with a maximum capacity.
 * - Expose current() without mutating returned objects.
 */
export class UndoStackService {
  constructor(capacity = 50) {
    this.capacity = Math.max(1, capacity);
    this._past = [];
    this._future = [];
    this._current = null;
  }

  init(snapshot) {
    this._past = [];
    this._future = [];
    this._current = snapshot ? JSON.parse(JSON.stringify(snapshot)) : null;
    return this.current();
  }

  push(snapshot) {
    if (this._current != null) {
      this._past.push(this._current);
      if (this._past.length > this.capacity) this._past.shift();
    }
    this._current = snapshot ? JSON.parse(JSON.stringify(snapshot)) : null;
    this._future = [];
    return this.current();
  }

  undo() {
    if (!this._past.length) return this.current();
    this._future.unshift(this._current);
    this._current = this._past.pop();
    return this.current();
  }

  redo() {
    if (!this._future.length) return this.current();
    this._past.push(this._current);
    this._current = this._future.shift();
    return this.current();
  }

  clear() {
    this._past = [];
    this._future = [];
    return true;
  }

  current() {
    return this._current ? JSON.parse(JSON.stringify(this._current)) : null;
  }
}


================================================================================
### PLIK: services\ValidationService.js
================================================================================


================================================================================
### PLIK: stores\addressUploadStore.js
================================================================================

import { defineStore } from 'pinia';
import apiClient from '@/services/api';

export const useAddressUploadStore = defineStore('addressUpload', {
  state: () => ({
    jobs: {}, // Będzie przechowywać statusy zadań, np. { 'jobId': { status: 'PROCESSING', ... } }
    isLoading: false,
    error: null,
  }),
  getters: {
    // Getter do pobierania zadań jako posortowana lista (najnowsze pierwsze)
    jobList: (state) => {
      return Object.values(state.jobs).sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    },
  },
  actions: {
    async uploadFile(file) {
      if (!file) {
        this.error = 'No file selected.';
        return;
      }
      this.isLoading = true;
      this.error = null;

      const formData = new FormData();
      formData.append('file', file);

      try {
        const response = await apiClient.post('/api/address-upload', formData, {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        });
        
        const { jobId } = response.data;
        if (jobId) {
          // Inicjalizuj status zadania i zacznij go śledzić
          this.jobs[jobId] = {
            jobId,
            originalFilename: file.name,
            status: 'PENDING',
            progress: 0,
            createdAt: new Date().toISOString()
          };
          this.pollJobStatus(jobId);
        }
      } catch (err) {
        console.error('File upload failed:', err);
        this.error = err.response?.data?.error || 'File upload failed.';
      } finally {
        this.isLoading = false;
      }
    },

    async pollJobStatus(jobId) {
      const intervalId = setInterval(async () => {
        try {
          const response = await apiClient.get(`/api/address-upload/jobs/${jobId}`);
          const jobData = response.data;
          
          // Aktualizuj status zadania w store
          this.jobs[jobId] = { ...this.jobs[jobId], ...jobData };

          // Zatrzymaj śledzenie, jeśli status jest końcowy
          if (['COMPLETED', 'FAILED_WITH_ERRORS'].includes(jobData.status)) {
            clearInterval(intervalId);
          }
        } catch (error) {
          console.error(`Failed to fetch status for job ${jobId}:`, error);
          this.jobs[jobId].status = 'POLLING_ERROR';
          this.jobs[jobId].errorDetails = 'Could not fetch job status.';
          clearInterval(intervalId);
        }
      }, 3000); // Sprawdzaj status co 3 sekundy
    },
  },
});

================================================================================
### PLIK: stores\authStore.js
================================================================================

// PLIK: src/stores/authStore.js
import { defineStore } from 'pinia';
import apiClient from '@/services/api';
import { jwtDecode } from 'jwt-decode';

/**
 * ARCHITEKTURA: Magazyn stanu (Pinia Store) odpowiedzialny za uwierzytelnianie i autoryzację.
 * Nie zależy od routera; komponenty nawigują po udanym logowaniu.
 */
export const useAuthStore = defineStore('auth', {
  state: () => ({
    accessToken: localStorage.getItem('accessToken') || null,
    refreshTokenValue: localStorage.getItem('refreshToken') || null,
    user: JSON.parse(localStorage.getItem('user')) || null,
    _isInitialized: false,
  }),
  getters: {
    isAuthenticated: (state) => !!state.accessToken,
  },
  actions: {
    async login(credentials) {
      try {
        const response = await apiClient.post('/auth/login', credentials);
        const { accessToken, refreshToken, username, roles } = response.data;

        this.accessToken = accessToken;
        this.refreshTokenValue = refreshToken;
        this.user = { username, roles };

        localStorage.setItem('accessToken', accessToken);
        localStorage.setItem('refreshToken', refreshToken);
        localStorage.setItem('user', JSON.stringify({ username, roles }));

        return true;
      } catch (error) {
        this.logout();
        console.error("Błąd logowania:", error);
        throw new Error('Logowanie nie powiodło się. Sprawdź login i hasło.');
      }
    },

    async refreshToken() {
      if (!this.refreshTokenValue) {
        throw new Error("Brak refresh tokena do odświeżenia sesji.");
      }
      const response = await apiClient.post('/auth/refresh', { refreshToken: this.refreshTokenValue });
      const { accessToken } = response.data;
      this.accessToken = accessToken;
      localStorage.setItem('accessToken', accessToken);
      return accessToken;
    },

    logout() {
      this.accessToken = null;
      this.refreshTokenValue = null;
      this.user = null;
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
      localStorage.removeItem('user');
    },

    initializeAuth() {
      if (this.accessToken) {
        try {
          const decodedToken = jwtDecode(this.accessToken);
          if (decodedToken.exp * 1000 < Date.now()) {
            console.warn("Token wygasł przy inicjalizacji. Wylogowywanie.");
            this.logout();
          }
        } catch (error) {
          console.error("Błąd dekodowania tokena. Token jest nieprawidłowy. Wylogowywanie.", error);
          this.logout();
        }
      }
      this._isInitialized = true;
    }
  },
});


================================================================================
### PLIK: stores\EditorSessionStore.js
================================================================================

/**
 * ARCHITECTURE: EditorSessionStore preserves cross-view context for the Correction Editor.
 * It follows the manifesto by providing a simple, framework-agnostic state carrier.
 * Responsibilities:
 * - Remember the last worklist filter snapshot and the current orderId under edit.
 * - Expose methods to persist/restore navigation context and support "Save & Next".
 */
export class EditorSessionStore {
  constructor() {
    this.lastFilterSnapshot = null;
    this.currentOrderId = null;
  }

  setFilterSnapshot(snapshot) {
    this.lastFilterSnapshot = snapshot ? { ...snapshot } : null;
    return this.lastFilterSnapshot;
  }

  setCurrentOrder(orderId) {
    this.currentOrderId = orderId || null;
    return this.currentOrderId;
  }

  clear() {
    this.lastFilterSnapshot = null;
    this.currentOrderId = null;
  }

  snapshot() {
    return {
      lastFilterSnapshot: this.lastFilterSnapshot,
      currentOrderId: this.currentOrderId,
    };
  }
}


================================================================================
### PLIK: stores\errorStore.js
================================================================================

// PLIK: stores/processingErrorsStore.js (NOWY PLIK)

import { defineStore } from 'pinia';
import apiClient from '@/services/api';

/**
 * ARCHITEKTURA: Dedykowany magazyn stanu (Pinia Store) dla zarządzania błędami przetwarzania.
 * Hermetyzuje całą logikę biznesową związaną z pobieraniem, filtrowaniem i ponawianiem
 * błędnych zleceń, komunikując się z backendem przez ujednolicony apiClient.
 */
export const useProcessingErrorsStore = defineStore('processingErrors', {
  state: () => ({
    errors: [],
    pagination: {
      page: 0,
      size: 15,
      totalElements: 0,
      totalPages: 0,
    },
    currentErrorDetails: null,
    isLoading: false,
    error: null,
  }),
  actions: {
    async fetchProcessingErrors(params) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.get('/processing-errors', { params });
        this.errors = response.data.content;
        this.pagination = {
          page: response.data.number,
          size: response.data.size,
          totalElements: response.data.totalElements,
          totalPages: response.data.totalPages,
        };
      } catch (err) {
        this.error = "Nie udało się pobrać błędów przetwarzania.";
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async fetchErrorDetails(errorId) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.get(`/processing-errors/${errorId}`);
        this.currentErrorDetails = response.data;
      } catch (err) {
        this.error = `Nie udało się pobrać szczegółów błędu o ID ${errorId}.`;
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async resubmitCorrectedOrder(eventId, resubmitPayload) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.post(`/processing-errors/${eventId}/resubmit`, resubmitPayload);
        // Można dodać logikę odświeżenia listy po udanym ponowieniu
        return response.data;
      } catch (err) {
        this.error = "Ponowne przetworzenie zlecenia nie powiodło się.";
        console.error(err);
        throw err; // Rzuć błąd dalej, aby komponent mógł na niego zareagować
      } finally {
        this.isLoading = false;
      }
    },
  },
});

================================================================================
### PLIK: stores\invoicingRulesStore.js
================================================================================

import { defineStore } from 'pinia';
import apiClient from '@/services/api.js'; // Using your existing API client [cite: 26, 30]

export const useInvoicingRulesStore = defineStore('invoicingRules', {
  state: () => ({
    hubRules: [],
    isLoading: false,
    error: null,
  }),
  getters: {
    // A getter to return rules, perhaps sorted by HUB name
    sortedHubRules: (state) => {
      return [...state.hubRules].sort((a, b) => a.hubId.localeCompare(b.hubId));
    },
  },
  actions: {
    async fetchHubRules() {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.get('/api/admin/invoicing-rules?ruleType=INTERIOR');
        this.hubRules = response.data;
      } catch (err) {
        this.error = 'Failed to fetch HUB rules.';
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async saveRule(rule) {
      this.isLoading = true;
      this.error = null;
      try {
        if (rule.id) {
          // Update existing rule
          await apiClient.put(`/api/admin/invoicing-rules/${rule.id}`, rule);
        } else {
          // Create new rule
          await apiClient.post('/api/admin/invoicing-rules', rule);
        }
        // Refresh the list after saving
        await this.fetchHubRules();
      } catch (err) {
        this.error = 'Failed to save rule.';
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async deleteRule(ruleId) {
      this.isLoading = true;
      this.error = null;
      try {
        await apiClient.delete(`/api/admin/invoicing-rules/${ruleId}`);
        // Refresh the list after deleting
        await this.fetchHubRules();
      } catch (err) {
        this.error = 'Failed to delete rule.';
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },
  },
});

================================================================================
### PLIK: stores\processingErrorsStore.js
================================================================================

// PLIK: src/stores/processingErrorsStore.js (NOWY PLIK)

import { defineStore } from 'pinia';
import apiClient from '@/services/api';

/**
 * ARCHITEKTURA: Dedykowany magazyn stanu (Pinia Store) dla zarządzania błędami przetwarzania.
 * Hermetyzuje całą logikę biznesową związaną z pobieraniem, filtrowaniem i ponawianiem
 * błędnych zleceń, komunikując się z backendem przez ujednolicony apiClient.
 */
export const useProcessingErrorsStore = defineStore('processingErrors', {
  state: () => ({
    errors: [],
    pagination: {
      page: 0,
      size: 15,
      totalElements: 0,
      totalPages: 0,
    },
    currentErrorDetails: null,
    isLoading: false,
    error: null,
  }),
  actions: {
    async fetchProcessingErrors(params) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.get('/processing-errors', { params });
        this.errors = response.data.content;
        this.pagination = {
          page: response.data.number,
          size: response.data.size,
          totalElements: response.data.totalElements,
          totalPages: response.data.totalPages,
        };
      } catch (err) {
        this.error = "Nie udało się pobrać błędów przetwarzania.";
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async fetchErrorDetails(errorId) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.get(`/processing-errors/${errorId}`);
        this.currentErrorDetails = response.data;
      } catch (err) {
        this.error = `Nie udało się pobrać szczegółów błędu o ID ${errorId}.`;
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async resubmitCorrectedOrder(eventId, resubmitPayload) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.post(`/processing-errors/${eventId}/resubmit`, resubmitPayload);
        // Po udanym ponowieniu można odświeżyć listę
        await this.fetchProcessingErrors({ page: this.pagination.page, size: this.pagination.size });
        return response.data;
      } catch (err) {
        this.error = "Ponowne przetworzenie zlecenia nie powiodło się.";
        console.error(err);
        throw err; // Rzuć błąd dalej, aby komponent mógł na niego zareagować
      } finally {
        this.isLoading = false;
      }
    },
  },
});

================================================================================
### PLIK: stores\WorklistStore.js
================================================================================

/**
 * ARCHITECTURE: WorklistStore is a self-contained state holder for the Address Exception "to-do" grid.
 * It follows the manifesto by separating concerns: pure state + orchestration, no UI, no framework glue.
 * Responsibilities:
 * - Holds filter, paging, selection, rows, totals, loading/error flags.
 * - Talks to AddressExceptionApi for search, bulk preview/apply, and "next item" navigation.
 * - Exposes simple methods that views or Pinia wrappers can call without knowing API details.
 */
import { WorklistFilter } from "@/domain/WorklistFilter";
import { BulkEditPlan } from "@/domain/BulkEditPlan";
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

export class WorklistStore {
  constructor(api = new AddressExceptionApi()) {
    this.api = api;
    this.filter = new WorklistFilter();
    this.items = [];
    this.total = 0;
    this.loading = false;
    this.error = null;
    this.selection = new Set();
  }

  async loadPage() {
    this.loading = true;
    this.error = null;
    this.items = [];
    const res = await this.api.searchWorklist(this.filter);
    if (!res.ok) {
      this.loading = false;
      this.error = res.error.message;
      return Result.fail(res.error);
    }
    this.items = Array.isArray(res.value.items) ? res.value.items : [];
    this.total = typeof res.value.total === "number" ? res.value.total : 0;
    this.loading = false;
    return Result.ok({ items: this.items, total: this.total });
  }

  setFilterPatch(patch) {
    this.filter = this.filter.withPatch(patch || {});
    return this.filter;
  }

  resetFilter() {
    this.filter = new WorklistFilter();
    return this.filter;
  }

  setPage(pageNumber) {
    this.filter = this.filter.withPatch({ page: pageNumber });
    return this.filter.page;
  }

  setPageSize(size) {
    this.filter = this.filter.withPatch({ pageSize: size, page: 1 });
    return this.filter.pageSize;
  }

  select(orderId) {
    if (orderId) this.selection.add(orderId);
    return this.getSelection();
  }

  unselect(orderId) {
    if (orderId) this.selection.delete(orderId);
    return this.getSelection();
  }

  clearSelection() {
    this.selection.clear();
    return this.getSelection();
  }

  getSelection() {
    return Array.from(this.selection.values());
  }

  createFindReplacePlan(field, findPattern, replaceWith) {
    return BulkEditPlan.findReplace(this.getSelection(), field, findPattern, replaceWith);
  }

  createAppendPlan(field, suffix) {
    return BulkEditPlan.append(this.getSelection(), field, suffix);
  }

  createPrependPlan(field, prefix) {
    return BulkEditPlan.prepend(this.getSelection(), field, prefix);
  }

  async bulkPreview(plan) {
    if (!(plan instanceof BulkEditPlan)) return Result.fail(new Error("Invalid BulkEditPlan."));
    const res = await this.api.bulkPreview(plan);
    if (!res.ok) return Result.fail(res.error);
    return Result.ok(res.value);
  }

  async bulkApply(plan) {
    if (!(plan instanceof BulkEditPlan)) return Result.fail(new Error("Invalid BulkEditPlan."));
    const res = await this.api.bulkApply(plan);
    if (!res.ok) return Result.fail(res.error);
    await this.loadPage();
    this.clearSelection();
    return Result.ok(res.value);
  }

  async getNextAndLoad(currentOrderId) {
    const nextIdRes = await this.api.getNextOrderId(currentOrderId, this.filter);
    if (!nextIdRes.ok) return Result.fail(nextIdRes.error);
    const nextId = nextIdRes.value || null;
    if (!nextId) return Result.ok(null);
    return Result.ok(nextId);
  }

  snapshot() {
    return {
      filter: this.filter,
      items: this.items.slice(),
      total: this.total,
      loading: this.loading,
      error: this.error,
      selection: this.getSelection(),
    };
  }
}


================================================================================
### PLIK: viewmodels\DiffPresenter.js
================================================================================

/**
 * ARCHITECTURE: DiffPresenter formats DiffService output into UI-ready rows with labels.
 * It follows the manifesto by separating presentation decisions from diff computation.
 * Responsibilities:
 * - Map diff entries to rows; provide changed count and stable labels.
 */
export class DiffPresenter {
  constructor() {
    this.labels = {
      street: "Street",
      houseNumber: "House No.",
      postalCode: "Postal",
      city: "City",
      country: "Country",
      latitude: "Latitude",
      longitude: "Longitude",
    };
  }

  present(diffResult) {
    const entries = Array.isArray(diffResult?.entries) ? diffResult.entries : [];
    const rows = entries.map(e => ({
      field: e.field,
      label: this.labels[e.field] || e.field,
      before: e.before ?? null,
      after: e.after ?? null,
      changed: !!e.changed,
    }));
    const changed = rows.filter(r => r.changed).length;
    return { rows, changed };
  }
}


================================================================================
### PLIK: viewmodels\ErrorBannerViewModel.js
================================================================================

/**
 * ARCHITECTURE: ErrorBannerViewModel formats technical errors into concise, user-facing banner messages.
 * It follows the manifesto by separating message mapping and ensuring deterministic display content.
 * Responsibilities:
 * - Map common categories to short titles and detailed descriptions.
 * - Provide a stable shape consumable by any banner/toast component.
 */
export class ErrorBannerViewModel {
  constructor(error) {
    this.error = error instanceof Error ? error : new Error(String(error || "Unknown error"));
    this.title = this._titleFor(this.error);
    this.detail = this._detailFor(this.error);
  }

  toObject() {
    return { title: this.title, detail: this.detail };
  }

  _titleFor(err) {
    const m = (err.message || "").toLowerCase();
    if (m.includes("network")) return "Network issue";
    if (m.includes("timeout")) return "Request timeout";
    if (m.includes("unauthorized") || m.includes("forbidden")) return "Access denied";
    if (m.includes("google")) return "Google maps error";
    return "Something went wrong";
  }

  _detailFor(err) {
    const msg = err.message || "Unexpected failure.";
    return msg.length > 180 ? msg.slice(0, 177) + "..." : msg;
  }
}


================================================================================
### PLIK: viewmodels\KpiViewModel.js
================================================================================

/**
 * ARCHITECTURE: KpiViewModel formats KPI values for dashboard tiles and badges.
 * It follows the manifesto by separating presentation formatting from calculation and transport.
 * Responsibilities:
 * - Hold raw numeric KPIs and expose formatted strings for UI consumption.
 */
export class KpiViewModel {
  constructor({ pending = 0, clearancePercent = 0, avgMinutes = 0 } = {}) {
    this.pending = Number(pending || 0);
    this.clearancePercent = Number(clearancePercent || 0);
    this.avgMinutes = Number(avgMinutes || 0);
  }

  pendingText() {
    return `${this.pending}`;
  }

  clearanceText() {
    if (!Number.isFinite(this.clearancePercent)) return "0.0%";
    return `${this.clearancePercent.toFixed(1)}%`;
  }

  avgResolutionText() {
    if (!Number.isFinite(this.avgMinutes)) return "—";
    if (this.avgMinutes < 60) return `${Math.round(this.avgMinutes)} min`;
    const h = Math.floor(this.avgMinutes / 60);
    const m = Math.round(this.avgMinutes % 60);
    return `${h}h ${m}m`;
  }
}


================================================================================
### PLIK: viewmodels\StatusBadgeViewModel.js
================================================================================

/**
 * ARCHITECTURE: StatusBadgeViewModel converts processing status codes into stable badge shape for UI.
 * It follows the manifesto by separating presentation mapping from models and services.
 * Responsibilities:
 * - Map codes to {label,tone,icon} and provide a toObject() helper for templates.
 */
export class StatusBadgeViewModel {
  constructor(statusCode) {
    this.status = (statusCode || "").toUpperCase();
    this.map = {
      ADDRESS_NEEDS_REVIEW: { label: "Needs Review", tone: "warning", icon: "alert-triangle" },
      ADDRESS_VALIDATED: { label: "Validated", tone: "success", icon: "check-circle" },
      MANUALLY_CORRECTED: { label: "Corrected", tone: "success", icon: "edit-3" },
      PENDING_ADDRESS_VALIDATION: { label: "Pending", tone: "info", icon: "clock" },
      FAILED: { label: "Failed", tone: "danger", icon: "x-circle" },
    };
  }

  toObject() {
    return this.map[this.status] || { label: this.status || "Unknown", tone: "neutral", icon: "help-circle" };
  }
}


================================================================================
### PLIK: viewmodels\VerificationProgressViewModel.js
================================================================================

/**
 * ARCHITECTURE: VerificationProgressViewModel translates workflow milestones into a stable progress model.
 * It follows the manifesto by separating presentation state from controllers and network logic.
 * Responsibilities:
 * - Track phases (normalize, validate, geocode, suggest, merge, save) and compute % complete deterministically.
 * - Provide immutable snapshots for progress bars or step indicators.
 */
export class VerificationProgressViewModel {
  constructor() {
    this.steps = [
      { key: "normalize", done: false },
      { key: "validate", done: false },
      { key: "geocode", done: false },
      { key: "suggest", done: false },
      { key: "merge", done: false },
      { key: "save", done: false },
    ];
  }

  mark(key, done = true) {
    const idx = this.steps.findIndex(s => s.key === key);
    if (idx >= 0) this.steps[idx].done = !!done;
    return this.snapshot();
  }

  percent() {
    const total = this.steps.length || 1;
    const done = this.steps.filter(s => s.done).length;
    return Math.round((done / total) * 100);
  }

  reset() {
    for (const s of this.steps) s.done = false;
    return this.snapshot();
  }

  snapshot() {
    return { steps: this.steps.map(s => ({ key: s.key, done: s.done })), percent: this.percent() };
  }
}


================================================================================
### PLIK: viewmodels\VerificationStatusViewModel.js
================================================================================

