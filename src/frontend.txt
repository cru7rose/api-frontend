
================================================================================
### PLIK: App.vue
================================================================================

<script setup>
import { computed, ref, watch, provide, readonly } from "vue";
import { useRouter } from "vue-router";
import { useAuthStore } from "@/stores/authStore";
import { storeToRefs } from "pinia";
import SidebarNav from '@/components/layout/SidebarNav.vue'; // *** IMPORT SIDEBAR ***

// Basic global notification state (can be expanded)
const notification = ref({ show: false, message: '', type: 'info' }); // type: info, success, warning, error
const showNotification = (message, type = 'info', duration = 3000) => {
  notification.value = { show: true, message, type };
  setTimeout(() => {
    notification.value.show = false;
  }, duration);
};
provide('showNotification', showNotification); // Make available globally

const authStore = useAuthStore();
const { isAuthenticated, user } = storeToRefs(authStore);
const router = useRouter();

const handleLogout = () => {
  authStore.logout();
  router.push("/login");
  showNotification('Logged out successfully.', 'success');
};

const userInitial = computed(() => user.value?.username?.charAt(0)?.toUpperCase() || '?');

// Watch for authentication changes to potentially redirect
watch(isAuthenticated, (isAuth, oldAuth) => {
  // Only redirect if state changes from authenticated to not authenticated
  // and we are not already on the login page
  if (oldAuth === true && isAuth === false && router.currentRoute.value.path !== '/login') {
    router.push('/login');
  }
}, { immediate: false }); // Don't run immediately on load

// Provide readonly auth state for components that just need to read it
provide('isAuthenticated', readonly(isAuthenticated));
provide('currentUser', readonly(user));

</script>

<template>
  <div class="app-layout">
    <header class="app-header" v-if="isAuthenticated">
      <div class="header-content">
        <div class="logo">DANXILS Triage</div>
        <div class="user-info">
          <span class="user-initial">{{ userInitial }}</span>
          <span class="username">{{ user?.username }}</span>
          <button @click="handleLogout" class="logout-button">Logout</button>
        </div>
      </div>
    </header>

    <div class="app-body">
      <SidebarNav v-if="isAuthenticated" />

      <main class="app-content">
        <RouterView />
      </main>
    </div>


    <div v-if="notification.show" :class="['notification-banner', `notification-${notification.type}`]">
      {{ notification.message }}
    </div>

  </div>
</template>

<style scoped>
.app-layout {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

.app-header {
  background-color: var(--color-primary);
  color: white;
  padding: 0 calc(var(--spacing-unit) * 2);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  position: sticky; /* Keep header visible */
  top: 0;
  z-index: 1000;
  height: 60px; /* Fixed header height */
}

.header-content {
  max-width: 100%; /* Allow header content to span full width */
  margin: 0 auto;
  display: flex;
  align-items: center;
  height: 100%;
  justify-content: space-between; /* Push logo left, user info right */
}

.logo {
  font-weight: bold;
  font-size: 1.2rem;
}

/* Main nav removed */

.user-info {
  display: flex;
  align-items: center;
  gap: var(--spacing-unit);
}

.user-initial {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background-color: var(--color-secondary);
  color: var(--color-primary);
  font-weight: bold;
  margin-right: calc(var(--spacing-unit));
}

.username {
  font-weight: 500;
}

.logout-button {
  background: none;
  border: 1px solid white;
  color: white;
  padding: calc(var(--spacing-unit) * 0.5) var(--spacing-unit);
  border-radius: 4px;
  cursor: pointer;
  margin-left: calc(var(--spacing-unit) * 2);
}
.logout-button:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

/* *** NEW: Body Layout with Sidebar *** */
.app-body {
  display: flex;
  flex-grow: 1; /* Take remaining height */
  overflow: hidden; /* Prevent body scroll */
}

.app-content {
  flex-grow: 1;
  padding: calc(var(--spacing-unit) * 3); /* Add padding around main content */
  overflow-y: auto; /* Allow content area to scroll */
  height: calc(100vh - 60px); /* Full height minus header */
}
/* *** END NEW *** */

/* Notification Banner Styles */
.notification-banner {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  padding: 15px 25px;
  border-radius: 4px;
  color: white;
  font-weight: 500;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
  z-index: 1001;
  min-width: 250px;
  text-align: center;
}
.notification-info { background-color: var(--color-info); }
.notification-success { background-color: var(--color-success); }
.notification-warning { background-color: var(--color-warning); color: var(--color-text); } /* Yellow needs dark text */
.notification-error { background-color: var(--color-danger); }

</style>

================================================================================
### PLIK: main.js
================================================================================

// ============================================================================
// Frontend: Update main.js
// REASON: Default OSRM routing URL to the proxy path '/osrm'.
// REASON: Fix Nominatim default URL to include /search.
// REASON: Provide geoRuntime to the Vue app instance.
// ============================================================================
// FILE: src/main.js
import { createApp } from "vue";
import { createPinia } from "pinia";
import App from "@/App.vue";
import { createRouter } from "@/router/index";
import { AppBootstrapController } from "@/controllers/AppBootstrapController";
import { AuthController } from "@/controllers/AuthController";
import { GeoRuntime } from "@/adapters/GeoRuntime";
import { IntegrationOrchestrator } from "@/controllers/IntegrationOrchestrator";
import '@/assets/theme.css';

(async () => {
    const pinia = createPinia();
    const auth = new AuthController();
    auth.hydrateFromStorage();

    const bootstrap = new AppBootstrapController();
    const boot = await bootstrap.bootstrap();
    const config = boot.config || {};
    const health = boot.health || { ok: false };

    // 3. Configure GeoRuntime
    const geoProviderConfig = {
        map: (config?.VITE_MAP_PROVIDER || 'leaflet').toLowerCase(),
        geocode: (config?.VITE_GEOCODE_PROVIDER || 'nominatim').toLowerCase(),
        places: (config?.VITE_PLACES_PROVIDER || 'none').toLowerCase(),
        nominatimEmail: config?.VITE_NOMINATIM_EMAIL || 'triage-app@example.com',

        // Use the proxy path, not a direct IP
        // *** FIX: Add /search to the default path ***
        nominatimUrl: config?.VITE_NOMINATIM_URL || '/nominatim/search',

        // *** THIS IS THE FIX FOR "Routing: None" ***
        // It tells GeoRuntime to use the '/osrm' proxy path
        routingUrl: config?.VITE_ROUTING_PROVIDER_URL || '/osrm',
    };
    const googleKey =
        config?.GOOGLE_MAPS_API_KEY || config?.VITE_GOOGLE_MAPS_API_KEY || null;

    const geoRuntime = new GeoRuntime(geoProviderConfig);

    // 4. Initialize GeoRuntime
    try {
        await geoRuntime.init(googleKey);
        console.log("[main.js] Geo Runtime initialization attempted.");
    } catch(err) {
        console.error("[main.js] Global Geo Runtime initialization failed:", err?.message || err);
    }

    const router = createRouter(geoRuntime);
    const app = createApp(App);

    app.config.errorHandler = (err, instance, info) => console.error("[vue-error]", err, info, instance);
    window.addEventListener("error", (e) => console.error("[window-error]", e?.error || e?.message || e));
    window.addEventListener("unhandledrejection", (e) => console.error("[unhandled-rejection]", e?.reason || e));

    app.use(pinia);
    app.use(router);

    const orchestrator = new IntegrationOrchestrator(geoRuntime, null);
    app.provide("orchestrator", orchestrator);
    app.provide("auth", auth);
    app.provide("config", config);
    app.provide("health", health);
    app.provide("geoRuntime", geoRuntime); // <-- Provide geoRuntime

    app.mount("#app");
})();

================================================================================
### PLIK: viewmodels/DiffPresenter.js
================================================================================

/**
 * ARCHITECTURE: DiffPresenter formats DiffService output into UI-ready rows with labels.
 * It follows the manifesto by separating presentation decisions from diff computation.
 * Responsibilities:
 * - Map diff entries to rows; provide changed count and stable labels.
 */
export class DiffPresenter {
  constructor() {
    this.labels = {
      street: "Street",
      houseNumber: "House No.",
      postalCode: "Postal",
      city: "City",
      country: "Country",
      latitude: "Latitude",
      longitude: "Longitude",
    };
  }

  present(diffResult) {
    const entries = Array.isArray(diffResult?.entries) ? diffResult.entries : [];
    const rows = entries.map(e => ({
      field: e.field,
      label: this.labels[e.field] || e.field,
      before: e.before ?? null,
      after: e.after ?? null,
      changed: !!e.changed,
    }));
    const changed = rows.filter(r => r.changed).length;
    return { rows, changed };
  }
}


================================================================================
### PLIK: viewmodels/ErrorBannerViewModel.js
================================================================================

/**
 * ARCHITECTURE: ErrorBannerViewModel formats technical errors into concise, user-facing banner messages.
 * It follows the manifesto by separating message mapping and ensuring deterministic display content.
 * Responsibilities:
 * - Map common categories to short titles and detailed descriptions.
 * - Provide a stable shape consumable by any banner/toast component.
 */
export class ErrorBannerViewModel {
  constructor(error) {
    this.error = error instanceof Error ? error : new Error(String(error || "Unknown error"));
    this.title = this._titleFor(this.error);
    this.detail = this._detailFor(this.error);
  }

  toObject() {
    return { title: this.title, detail: this.detail };
  }

  _titleFor(err) {
    const m = (err.message || "").toLowerCase();
    if (m.includes("network")) return "Network issue";
    if (m.includes("timeout")) return "Request timeout";
    if (m.includes("unauthorized") || m.includes("forbidden")) return "Access denied";
    if (m.includes("google")) return "Google maps error";
    return "Something went wrong";
  }

  _detailFor(err) {
    const msg = err.message || "Unexpected failure.";
    return msg.length > 180 ? msg.slice(0, 177) + "..." : msg;
  }
}


================================================================================
### PLIK: viewmodels/KpiViewModel.js
================================================================================

/**
 * ARCHITECTURE: KpiViewModel formats KPI values for dashboard tiles and badges.
 * It follows the manifesto by separating presentation formatting from calculation and transport.
 * Responsibilities:
 * - Hold raw numeric KPIs and expose formatted strings for UI consumption.
 */
export class KpiViewModel {
  constructor({ pending = 0, clearancePercent = 0, avgMinutes = 0 } = {}) {
    this.pending = Number(pending || 0);
    this.clearancePercent = Number(clearancePercent || 0);
    this.avgMinutes = Number(avgMinutes || 0);
  }

  pendingText() {
    return `${this.pending}`;
  }

  clearanceText() {
    if (!Number.isFinite(this.clearancePercent)) return "0.0%";
    return `${this.clearancePercent.toFixed(1)}%`;
  }

  avgResolutionText() {
    if (!Number.isFinite(this.avgMinutes)) return "—";
    if (this.avgMinutes < 60) return `${Math.round(this.avgMinutes)} min`;
    const h = Math.floor(this.avgMinutes / 60);
    const m = Math.round(this.avgMinutes % 60);
    return `${h}h ${m}m`;
  }
}


================================================================================
### PLIK: viewmodels/StatusBadgeViewModel.js
================================================================================

// ============================================================================
// Frontend: Update StatusBadgeViewModel (Supersedes previous version)
// FILE: src/viewmodels/StatusBadgeViewModel.js
// REASON: Align status map with canonical mission states (now including AWAITING_ALIAS_CHECK).
// ============================================================================
// FILE: src/viewmodels/StatusBadgeViewModel.js (Supersedes previous version)

/**
 * ARCHITECTURE: StatusBadgeViewModel converts processing status codes into stable badge shape for UI.
 * It follows the manifesto by separating presentation mapping from models and services.
 * Responsibilities:
 * - Map codes to {label,tone,icon} and provide a toObject() helper for templates.
 * UPDATED: Aligned status map with canonical mission states.
 */
export class StatusBadgeViewModel {
  constructor(statusCode) {
    this.status = (statusCode || "").toUpperCase();
    this.map = {
      // --- Canonical States ---
      INGESTED: { label: "Ingested", tone: "neutral", icon: "arrow-down-circle" },
      AWAITING_ALIAS_CHECK: { label: "Checking Alias", tone: "info", icon: "search" }, // Added
      HAPPY_PATH_MATCHED: { label: "Auto-Matched", tone: "success", icon: "check-circle" },
      PENDING_VERIFICATION: { label: "Needs Review", tone: "warning", icon: "alert-triangle" },
      APPROVED: { label: "Approved", tone: "info", icon: "check" },
      SENT_TO_TRACKIT: { label: "Sent to TrackIT", tone: "info", icon: "send" },
      ACK_TRACKIT: { label: "In TrackIT", tone: "success", icon: "check-circle" },
      CDC_EVENT: { label: "CDC Event", tone: "neutral", icon: "database" },
      FAILED: { label: "Failed", tone: "danger", icon: "x-circle" },

      // --- Legacy/Compatibility States (Mapped to canonical visuals where possible) ---
      ADDRESS_NEEDS_REVIEW: { label: "Needs Review", tone: "warning", icon: "alert-triangle" },
      ADDRESS_VALIDATED: { label: "Validated", tone: "success", icon: "check-circle" }, // Maps roughly to ACK_TRACKIT or HAPPY_PATH_MATCHED
      MANUALLY_CORRECTED: { label: "Corrected", tone: "info", icon: "edit-3" }, // Maps roughly to APPROVED
      PENDING_ADDRESS_VALIDATION: { label: "Pending", tone: "info", icon: "clock" }, // Maps roughly to SENT_TO_TRACKIT or AWAITING_ALIAS_CHECK
    };
  }

  toObject() {
    return this.map[this.status] || { label: this.status || "Unknown", tone: "neutral", icon: "help-circle" };
  }
}

================================================================================
### PLIK: viewmodels/VerificationProgressViewModel.js
================================================================================

/**
 * ARCHITECTURE: VerificationProgressViewModel translates workflow milestones into a stable progress model.
 * It follows the manifesto by separating presentation state from controllers and network logic.
 * Responsibilities:
 * - Track phases (normalize, validate, geocode, suggest, merge, save) and compute % complete deterministically.
 * - Provide immutable snapshots for progress bars or step indicators.
 */
export class VerificationProgressViewModel {
  constructor() {
    this.steps = [
      { key: "normalize", done: false },
      { key: "validate", done: false },
      { key: "geocode", done: false },
      { key: "suggest", done: false },
      { key: "merge", done: false },
      { key: "save", done: false },
    ];
  }

  mark(key, done = true) {
    const idx = this.steps.findIndex(s => s.key === key);
    if (idx >= 0) this.steps[idx].done = !!done;
    return this.snapshot();
  }

  percent() {
    const total = this.steps.length || 1;
    const done = this.steps.filter(s => s.done).length;
    return Math.round((done / total) * 100);
  }

  reset() {
    for (const s of this.steps) s.done = false;
    return this.snapshot();
  }

  snapshot() {
    return { steps: this.steps.map(s => ({ key: s.key, done: s.done })), percent: this.percent() };
  }
}


================================================================================
### PLIK: viewmodels/VerificationStatusViewModel.js
================================================================================


================================================================================
### PLIK: composables/useToast.js
================================================================================

// ============================================================================
// Frontend: Add useToast.js
// FILE: src/composables/useToast.js (NEW FILE - JS Version)
// REASON: Provides toast notifications. Converted to JS for project consistency.
// ============================================================================
import { useToast as useVueToast } from 'vue-toastification'

/**
 * Custom composable for showing toasts.
 * Provides sensible defaults and simple success/error/info methods.
 */
export function useToast() {
    const toast = useVueToast()

    const toastOptions = (timeout = 5000) => ({
        position: 'top-right',
        timeout,
        closeOnClick: true,
        pauseOnFocusLoss: true,
        pauseOnHover: true,
        draggable: true,
        draggablePercent: 0.6,
        showCloseButtonOnHover: false,
        hideProgressBar: false,
        closeButton: 'button',
        icon: true,
        rtl: false
    })

    const success = (message, timeout = 5000) => {
        toast.success(message, toastOptions(timeout))
    }

    const error = (message, timeout = 10000) => {
        toast.error(message, toastOptions(timeout))
    }

    const info = (message, timeout = 3000) => {
        toast.info(message, toastOptions(timeout))
    }

    const warn = (message, timeout = 5000) => {
        toast.warning(message, toastOptions(timeout))
    }

    return {
        success,
        error,
        info,
        warn
    }
}

================================================================================
### PLIK: bootstrap/GoogleAddressVerificationBootstrap.js
================================================================================

/**
 * ARCHITECTURE: GoogleAddressVerificationBootstrap initializes Google runtime, map, and adapters for the editor.
 * It follows the manifesto by centralizing third-party setup and returning ready-to-use controllers/adapters.
 * Responsibilities:
 * - Load Google script, create MapController with GoogleMapAdapter, and provide geocoder + places adapters.
 */
import { GoogleMapsScriptLoader } from "@/adapters/GoogleMapsScriptLoader";
import { GoogleMapAdapter } from "@/adapters/GoogleMapAdapter";
import { GoogleGeocodingAdapter } from "@/adapters/GoogleGeocodingAdapter";
import { GooglePlacesAutocompleteAdapter } from "@/adapters/GooglePlacesAutocompleteAdapter";
import { MapController } from "@/controllers/MapController";

export class GoogleAddressVerificationBootstrap {
  constructor(loader = new GoogleMapsScriptLoader()) {
    this.loader = loader;
    this.google = null;
    this.mapController = null;
    this.geocoderAdapter = null;
    this.placesAdapter = null;
  }

  async init(mapContainerEl, apiKey) {
    this.google = await this.loader.load(apiKey, ["places"]);
    const mapAdapter = new GoogleMapAdapter(this.google);
    this.mapController = new MapController(mapAdapter);
    await this.mapController.init(mapContainerEl, { lat: 52.2297, lon: 21.0122, zoom: 12 });
    this.geocoderAdapter = new GoogleGeocodingAdapter(this.google);
    this.placesAdapter = new GooglePlacesAutocompleteAdapter(this.google);
    return {
      google: this.google,
      mapController: this.mapController,
      geocoderAdapter: this.geocoderAdapter,
      placesAdapter: this.placesAdapter,
    };
  }
}


================================================================================
### PLIK: tests/example.spec.js
================================================================================

// src/tests/example.spec.js
import { describe, it, expect } from 'vitest';

// Example basic test to ensure Vitest setup is working
describe('Basic Math', () => {
    it('should add two numbers correctly', () => {
        expect(1 + 1).toBe(2);
    });

    it('should handle floating point numbers', () => {
        expect(0.1 + 0.2).toBeCloseTo(0.3);
    });
});

// Example test for a simple utility function (if you had one)
/*
import { simpleUtilFunction } from '@/utils/helpers'; // Assuming a helper exists

describe('simpleUtilFunction', () => {
    it('should return uppercase', () => {
        expect(simpleUtilFunction('hello')).toBe('HELLO');
    });

     it('should handle empty string', () => {
        expect(simpleUtilFunction('')).toBe('');
    });
});
*/

================================================================================
### PLIK: stores/addressUploadStore.js
================================================================================

import { defineStore } from 'pinia';
import apiClient from '@/services/api';

export const useAddressUploadStore = defineStore('addressUpload', {
  state: () => ({
    jobs: {}, // Będzie przechowywać statusy zadań, np. { 'jobId': { status: 'PROCESSING', ... } }
    isLoading: false,
    error: null,
  }),
  getters: {
    // Getter do pobierania zadań jako posortowana lista (najnowsze pierwsze)
    jobList: (state) => {
      return Object.values(state.jobs).sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    },
  },
  actions: {
    async uploadFile(file) {
      if (!file) {
        this.error = 'No file selected.';
        return;
      }
      this.isLoading = true;
      this.error = null;

      const formData = new FormData();
      formData.append('file', file);

      try {
        const response = await apiClient.post('/api/address-upload', formData, {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        });
        
        const { jobId } = response.data;
        if (jobId) {
          // Inicjalizuj status zadania i zacznij go śledzić
          this.jobs[jobId] = {
            jobId,
            originalFilename: file.name,
            status: 'PENDING',
            progress: 0,
            createdAt: new Date().toISOString()
          };
          this.pollJobStatus(jobId);
        }
      } catch (err) {
        console.error('File upload failed:', err);
        this.error = err.response?.data?.error || 'File upload failed.';
      } finally {
        this.isLoading = false;
      }
    },

    async pollJobStatus(jobId) {
      const intervalId = setInterval(async () => {
        try {
          const response = await apiClient.get(`/api/address-upload/jobs/${jobId}`);
          const jobData = response.data;
          
          // Aktualizuj status zadania w store
          this.jobs[jobId] = { ...this.jobs[jobId], ...jobData };

          // Zatrzymaj śledzenie, jeśli status jest końcowy
          if (['COMPLETED', 'FAILED_WITH_ERRORS'].includes(jobData.status)) {
            clearInterval(intervalId);
          }
        } catch (error) {
          console.error(`Failed to fetch status for job ${jobId}:`, error);
          this.jobs[jobId].status = 'POLLING_ERROR';
          this.jobs[jobId].errorDetails = 'Could not fetch job status.';
          clearInterval(intervalId);
        }
      }, 3000); // Sprawdzaj status co 3 sekundy
    },
  },
});

================================================================================
### PLIK: stores/authStore.js
================================================================================

// PLIK: src/stores/authStore.js
import { defineStore } from 'pinia';
import apiClient from '@/services/api';
import { jwtDecode } from 'jwt-decode';

/**
 * ARCHITEKTURA: Magazyn stanu (Pinia Store) odpowiedzialny za uwierzytelnianie i autoryzację.
 * Nie zależy od routera; komponenty nawigują po udanym logowaniu.
 */
export const useAuthStore = defineStore('auth', {
  state: () => ({
    accessToken: localStorage.getItem('accessToken') || null,
    refreshTokenValue: localStorage.getItem('refreshToken') || null,
    user: JSON.parse(localStorage.getItem('user')) || null,
    _isInitialized: false,
  }),
  getters: {
    isAuthenticated: (state) => !!state.accessToken,
  },
  actions: {
    async login(credentials) {
      try {
        const response = await apiClient.post('/auth/login', credentials);
        const { accessToken, refreshToken, username, roles } = response.data;

        this.accessToken = accessToken;
        this.refreshTokenValue = refreshToken;
        this.user = { username, roles };

        localStorage.setItem('accessToken', accessToken);
        localStorage.setItem('refreshToken', refreshToken);
        localStorage.setItem('user', JSON.stringify({ username, roles }));

        return true;
      } catch (error) {
        this.logout();
        console.error("Błąd logowania:", error);
        throw new Error('Logowanie nie powiodło się. Sprawdź login i hasło.');
      }
    },

    async refreshToken() {
      if (!this.refreshTokenValue) {
        throw new Error("Brak refresh tokena do odświeżenia sesji.");
      }
      const response = await apiClient.post('/auth/refresh', { refreshToken: this.refreshTokenValue });
      const { accessToken } = response.data;
      this.accessToken = accessToken;
      localStorage.setItem('accessToken', accessToken);
      return accessToken;
    },

    logout() {
      this.accessToken = null;
      this.refreshTokenValue = null;
      this.user = null;
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
      localStorage.removeItem('user');
    },

    initializeAuth() {
      if (this.accessToken) {
        try {
          const decodedToken = jwtDecode(this.accessToken);
          if (decodedToken.exp * 1000 < Date.now()) {
            console.warn("Token wygasł przy inicjalizacji. Wylogowywanie.");
            this.logout();
          }
        } catch (error) {
          console.error("Błąd dekodowania tokena. Token jest nieprawidłowy. Wylogowywanie.", error);
          this.logout();
        }
      }
      this._isInitialized = true;
    }
  },
});


================================================================================
### PLIK: stores/EditorSessionStore.js
================================================================================

/**
 * ARCHITECTURE: EditorSessionStore preserves cross-view context for the Correction Editor.
 * It follows the manifesto by providing a simple, framework-agnostic state carrier.
 * Responsibilities:
 * - Remember the last worklist filter snapshot and the current orderId under edit.
 * - Expose methods to persist/restore navigation context and support "Save & Next".
 */
export class EditorSessionStore {
  constructor() {
    this.lastFilterSnapshot = null;
    this.currentOrderId = null;
  }

  setFilterSnapshot(snapshot) {
    this.lastFilterSnapshot = snapshot ? { ...snapshot } : null;
    return this.lastFilterSnapshot;
  }

  setCurrentOrder(orderId) {
    this.currentOrderId = orderId || null;
    return this.currentOrderId;
  }

  clear() {
    this.lastFilterSnapshot = null;
    this.currentOrderId = null;
  }

  snapshot() {
    return {
      lastFilterSnapshot: this.lastFilterSnapshot,
      currentOrderId: this.currentOrderId,
    };
  }
}


================================================================================
### PLIK: stores/invoicingRulesStore.js
================================================================================

import { defineStore } from 'pinia';
import apiClient from '@/services/api.js'; // Using your existing API client [cite: 26, 30]

export const useInvoicingRulesStore = defineStore('invoicingRules', {
  state: () => ({
    hubRules: [],
    isLoading: false,
    error: null,
  }),
  getters: {
    // A getter to return rules, perhaps sorted by HUB name
    sortedHubRules: (state) => {
      return [...state.hubRules].sort((a, b) => a.hubId.localeCompare(b.hubId));
    },
  },
  actions: {
    async fetchHubRules() {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.get('/api/admin/invoicing-rules?ruleType=INTERIOR');
        this.hubRules = response.data;
      } catch (err) {
        this.error = 'Failed to fetch HUB rules.';
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async saveRule(rule) {
      this.isLoading = true;
      this.error = null;
      try {
        if (rule.id) {
          // Update existing rule
          await apiClient.put(`/api/admin/invoicing-rules/${rule.id}`, rule);
        } else {
          // Create new rule
          await apiClient.post('/api/admin/invoicing-rules', rule);
        }
        // Refresh the list after saving
        await this.fetchHubRules();
      } catch (err) {
        this.error = 'Failed to save rule.';
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async deleteRule(ruleId) {
      this.isLoading = true;
      this.error = null;
      try {
        await apiClient.delete(`/api/admin/invoicing-rules/${ruleId}`);
        // Refresh the list after deleting
        await this.fetchHubRules();
      } catch (err) {
        this.error = 'Failed to delete rule.';
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },
  },
});

================================================================================
### PLIK: stores/processingErrorsStore.js
================================================================================

// PLIK: src/stores/processingErrorsStore.js (NOWY PLIK)

import { defineStore } from 'pinia';
import apiClient from '@/services/api';

/**
 * ARCHITEKTURA: Dedykowany magazyn stanu (Pinia Store) dla zarządzania błędami przetwarzania.
 * Hermetyzuje całą logikę biznesową związaną z pobieraniem, filtrowaniem i ponawianiem
 * błędnych zleceń, komunikując się z backendem przez ujednolicony apiClient.
 */
export const useProcessingErrorsStore = defineStore('processingErrors', {
  state: () => ({
    errors: [],
    pagination: {
      page: 0,
      size: 15,
      totalElements: 0,
      totalPages: 0,
    },
    currentErrorDetails: null,
    isLoading: false,
    error: null,
  }),
  actions: {
    async fetchProcessingErrors(params) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.get('/processing-errors', { params });
        this.errors = response.data.content;
        this.pagination = {
          page: response.data.number,
          size: response.data.size,
          totalElements: response.data.totalElements,
          totalPages: response.data.totalPages,
        };
      } catch (err) {
        this.error = "Nie udało się pobrać błędów przetwarzania.";
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async fetchErrorDetails(errorId) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.get(`/processing-errors/${errorId}`);
        this.currentErrorDetails = response.data;
      } catch (err) {
        this.error = `Nie udało się pobrać szczegółów błędu o ID ${errorId}.`;
        console.error(err);
      } finally {
        this.isLoading = false;
      }
    },

    async resubmitCorrectedOrder(eventId, resubmitPayload) {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await apiClient.post(`/processing-errors/${eventId}/resubmit`, resubmitPayload);
        // Po udanym ponowieniu można odświeżyć listę
        await this.fetchProcessingErrors({ page: this.pagination.page, size: this.pagination.size });
        return response.data;
      } catch (err) {
        this.error = "Ponowne przetworzenie zlecenia nie powiodło się.";
        console.error(err);
        throw err; // Rzuć błąd dalej, aby komponent mógł na niego zareagować
      } finally {
        this.isLoading = false;
      }
    },
  },
});

================================================================================
### PLIK: stores/useAedSftpStore.js
================================================================================

// ============================================================================
// Frontend ➜ stores/useAedSftpStore.js (NEW FILE)
// ARCHITECTURE: Pinia store for the new AED SFTP Admin view.
// ============================================================================
import { defineStore } from 'pinia';
import apiClient from '@/services/api'; // Use the shared API client
import { ref } from 'vue';

export const useAedSftpStore = defineStore('aedSftpAdmin', () => {
    const isLoading = ref(false);
    const error = ref(null);
    const successMessage = ref(null);
    const lastExportCount = ref(0);

    // Get current time minus 1 month as default
    const getDefaultStartTime = () => {
        const d = new Date();
        d.setMonth(d.getMonth() - 1);
        // Format as YYYY-MM-DDTHH:MM:SS
        return d.toISOString().substring(0, 19);
    };

    const startTime = ref(getDefaultStartTime());

    async function triggerManualExport() {
        isLoading.value = true;
        error.value = null;
        successMessage.value = null;
        lastExportCount.value = 0;

        if (!startTime.value) {
            error.value = "Start time is required.";
            isLoading.value = false;
            return;
        }

        try {
            const params = new URLSearchParams({
                startTime: startTime.value
            });

            const response = await apiClient.post(`/api/admin/aed/outbound/export-from?${params.toString()}`);

            lastExportCount.value = response.data?.exportedCount || 0;
            successMessage.value = `Successfully exported ${lastExportCount.value} 'MG' status(es) recorded since ${startTime.value}.`;

        } catch (err) {
            console.error("Failed to trigger manual AED export:", err);
            error.value = err.response?.data?.error || err.message || "Failed to trigger export.";
        } finally {
            isLoading.value = false;
        }
    }

    return {
        isLoading,
        error,
        successMessage,
        lastExportCount,
        startTime,
        triggerManualExport
    };
});

================================================================================
### PLIK: stores/useLogStore.js
================================================================================

// FILE: src/stores/useLogStore.js
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import apiClient from '@/services/api.js';
import { useAuthStore } from '@/stores/authStore.js';

export const useLogStore = defineStore('logStore', () => {
    const logs = ref([]);
    const totalElements = ref(0);
    const totalPages = ref(0);
    const currentPage = ref(0);
    const loading = ref(false);
    const error = ref(null);

    const queryFilter = ref('');
    const correlationIdFilter = ref('');
    const appNameFilter = ref('');
    const levelFilter = ref('');
    const startTimeFilter = ref('');
    const endTimeFilter = ref('');
    const pageable = ref({
        page: 0,
        size: 50,
        sort: '@timestamp,desc'
    });

    async function fetchLogs() {
        if (loading.value) return;
        loading.value = true;
        error.value = null;

        const params = new URLSearchParams({
            page: pageable.value.page,
            size: pageable.value.size,
            sort: pageable.value.sort,
        });
        if (queryFilter.value) params.set('query', queryFilter.value);
        if (correlationIdFilter.value) params.set('correlationId', correlationIdFilter.value);
        if (appNameFilter.value) params.set('appName', appNameFilter.value);
        if (levelFilter.value) params.set('level', levelFilter.value);
        if (startTimeFilter.value) params.set('startTime', startTimeFilter.value);
        if (endTimeFilter.value) params.set('endTime', endTimeFilter.value);

        try {
            // *** FIX: Added /api prefix ***
            const response = await apiClient.get(`/api/admin/logs/query?${params.toString()}`);
            // *** END FIX ***
            const data = response.data || {};

            if (data && data.content) {
                logs.value = data.content;
                totalElements.value = data.totalElements;
                totalPages.value = data.totalPages;
                currentPage.value = data.number;
            } else {
                // Fallback for potential direct response without 'data' wrapper if API changes
                if (response && response.content) {
                    logs.value = response.content;
                    totalElements.value = response.totalElements;
                    totalPages.value = response.totalPages;
                    currentPage.value = response.number;
                } else {
                    throw new Error("Invalid response format received from log query API.");
                }
            }
        } catch (err) {
            console.error("Failed to fetch logs:", err);
            // Check for 404 specifically if needed
            if (err.response?.status === 404) {
                error.value = 'Log query endpoint not found. Please check the API path.';
            } else {
                error.value = err.message || 'Failed to fetch logs.';
            }
            logs.value = [];
            totalElements.value = 0;
            totalPages.value = 0;
            currentPage.value = 0;
        } finally {
            loading.value = false;
        }
    }

    function setPage(pageNumber) {
        if (pageNumber >= 0 && pageNumber < (totalPages.value || 1) ) {
            pageable.value.page = pageNumber;
            fetchLogs();
        }
    }

    function applyFiltersAndFetch() {
        pageable.value.page = 0; // Reset to first page on filter change
        fetchLogs();
    }

    // Initial fetch can be triggered here or from the component
    // fetchLogs();

    return {
        logs, totalElements, totalPages, currentPage, loading, error,
        queryFilter, correlationIdFilter, appNameFilter, levelFilter,
        startTimeFilter, endTimeFilter, pageable,
        fetchLogs, setPage, applyFiltersAndFetch,
    };
});

================================================================================
### PLIK: stores/WorklistStore.js
================================================================================

// ============================================================================
// Frontend: Update WorklistStore (Supersedes previous version)
// FILE: src/stores/WorklistStore.js
// REASON: Align default status with canonical mission state 'PENDING_VERIFICATION'.
// ============================================================================
// FILE: src/stores/WorklistStore.js (Supersedes previous version)

import { defineStore } from 'pinia';
import { WorklistFilter } from "@/domain/WorklistFilter";
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

/**
 * ARCHITECTURE: Pinia store for managing the state of the Address Exception Worklist.
 * REFACTORED: Default filter status set to PENDING_VERIFICATION.
 */
export const useWorklistStore = defineStore('worklist', {
    state: () => ({
        // *** MODIFIED: Use PENDING_VERIFICATION ***
        filter: new WorklistFilter({
            status: 'PENDING_VERIFICATION',
            barcode: '',
            customerId: '',
            dateFrom: '', // YYYY-MM-DD
            dateTo: '',   // YYYY-MM-DD
        }), // Use domain object for filter state
        items: [], // Array of OrderSummaryDTO { id, barcode, customerId, processingStatus, createdAt, updatedAt, sourceSystem }
        pagination: {
            currentPage: 1, // Use 1-based indexing for UI
            itemsPerPage: 25,
            totalItems: 0,
            totalPages: 0,
        },
        selection: [], // Array of selected order IDs (UUIDs)
        loading: false,
        error: null, // Stores error message string or Error object
    }),
    getters: {
        isSelected: (state) => (orderId) => {
            return state.selection.includes(orderId);
        },
        currentFilter: (state) => {
            return state.filter.toPlainObject ? state.filter.toPlainObject() : { ...state.filter };
        },
        currentPageInfo: (state) => {
            return { ...state.pagination };
        },
        selectedCount: (state) => {
            return state.selection.length;
        }
    },
    actions: {
        _getApi() {
            return new AddressExceptionApi();
        },

        async loadWorklistPage() {
            this.loading = true;
            this.error = null;
            this.clearSelection();
            const api = this._getApi();
            try {
                const filterParams = {
                    ...(this.filter.toQueryRecord ? this.filter.toQueryRecord() : this.filter),
                    page: this.pagination.currentPage > 0 ? this.pagination.currentPage - 1 : 0,
                    size: this.pagination.itemsPerPage,
                };
                Object.keys(filterParams).forEach(key => (filterParams[key] == null || filterParams[key] === '') && delete filterParams[key]);
                const result = await api.getWorklist(filterParams);

                if (result.ok) {
                    this.items = result.value.items || [];
                    this.pagination.totalItems = result.value.total || 0;
                    this.pagination.totalPages = this.pagination.itemsPerPage > 0
                        ? Math.ceil(this.pagination.totalItems / this.pagination.itemsPerPage) || 1
                        : 1;
                    if (this.pagination.currentPage > this.pagination.totalPages) {
                        this.pagination.currentPage = this.pagination.totalPages;
                    }
                    return Result.ok();
                } else {
                    throw result.error;
                }
            } catch (err) {
                console.error("Failed to load worklist page:", err);
                this.error = err.message || "Failed to load worklist.";
                this.items = [];
                this.pagination.totalItems = 0;
                this.pagination.totalPages = 1;
                this.pagination.currentPage = 1;
                return Result.fail(err);
            } finally {
                this.loading = false;
            }
        },

        async applyFilterPatch(patch) {
            this.pagination.currentPage = 1;
            this.filter = this.filter.withPatch(patch || {});
            await this.loadWorklistPage();
        },

        async resetFilter() {
            // *** MODIFIED: Use PENDING_VERIFICATION ***
            this.filter = new WorklistFilter({
                status: 'PENDING_VERIFICATION',
                barcode: '',
                customerId: '',
                dateFrom: '',
                dateTo: '',
            });
            this.pagination.currentPage = 1;
            await this.loadWorklistPage();
        },

        async goToPage(pageNumber) {
            const newPage = Math.max(1, Math.min(pageNumber, this.pagination.totalPages || 1));
            if (newPage !== this.pagination.currentPage) {
                this.pagination.currentPage = newPage;
                await this.loadWorklistPage();
            }
        },

        async changePageSize(size) {
            const newSize = Math.max(5, size);
            if (newSize !== this.pagination.itemsPerPage) {
                this.pagination.itemsPerPage = newSize;
                this.pagination.currentPage = 1;
                await this.loadWorklistPage();
            }
        },

        // --- Selection Actions ---
        toggleSelection(orderId) {
            const index = this.selection.indexOf(orderId);
            if (index > -1) {
                this.selection.splice(index, 1);
            } else {
                this.selection.push(orderId);
            }
        },
        setSelection(orderIds) {
            if (Array.isArray(orderIds)) {
                this.selection = [...new Set(orderIds)];
            }
        },
        clearSelection() {
            this.selection = [];
        },
        selectAllOnPage() {
            this.selection = this.items.map(item => item.id);
        },
    },
});

================================================================================
### PLIK: adapters/GeoRuntime.js
================================================================================

// ============================================================================
// Frontend: Update GeoRuntime (Final Version)
// FILE: src/adapters/GeoRuntime.js
// REASON: Pass routing URL correctly, handle initialization errors gracefully.
// ============================================================================
// FILE: src/adapters/GeoRuntime.js
import { GoogleMapsScriptLoader } from "@/adapters/GoogleMapsScriptLoader";
import { GoogleMapAdapter } from "@/adapters/GoogleMapAdapter";
import { GoogleGeocodingAdapter } from "@/adapters/GoogleGeocodingAdapter";
import { GooglePlacesAutocompleteAdapter } from "@/adapters/GooglePlacesAutocompleteAdapter";
import { LeafletMapAdapter } from "@/adapters/LeafletMapAdapter";
import { NominatimGeocodingAdapter } from "@/adapters/NominatimGeocodingAdapter";

/**
 * ARCHITECTURE: Manages initialization and access for geographic service adapters.
 * REFACTORED: Passes OSRM routing URL (VITE_ROUTING_PROVIDER_URL) to LeafletMapAdapter. Handles errors better.
 */
export class GeoRuntime {
    constructor(providerConfig = {}) {
        this._config = {
            map: (providerConfig.map || 'leaflet').toLowerCase(),
            geocode: (providerConfig.geocode || 'nominatim').toLowerCase(),
            places: (providerConfig.places || 'none').toLowerCase(),
            nominatimEmail: providerConfig.nominatimEmail || 'danxils-triage@example.com',
            nominatimUrl: providerConfig.nominatimUrl || null,
            routingUrl: providerConfig.routingUrl || null,
        };
        log.info(`[GeoRuntime] Configured Providers - Map: ${this._config.map}, Geocode: ${this._config.geocode}, Places: ${this._config.places}, Routing: ${this._config.routingUrl ? 'OSRM' : 'None'}`);

        this._googleLoader = new GoogleMapsScriptLoader();
        this._googleInstance = null;
        this._googleApiKey = null;
        this._googleLibs = ["places", "geocoding", "marker"];
        this._googleMapAdapterInstance = null;
        this._googleGeocodingAdapterInstance = null;
        this._googlePlacesAdapterInstance = null;

        this._leafletMapAdapterInstance = null;
        this._nominatimGeocodingAdapterInstance = null;

        this._initializationPromise = null;
        this._isGoogleInitialized = false;
        this._isNonGoogleInitialized = false;
    }

    async init(googleApiKey = null) {
        if (this._initializationPromise) return this._initializationPromise;

        this._googleApiKey = googleApiKey;
        const needsGoogle = this._config.map === 'google' || this._config.geocode === 'google' || this._config.places === 'google';

        const initNonGooglePromise = Promise.resolve().then(() => {
            try {
                if (this._config.map === 'leaflet' && !this._leafletMapAdapterInstance) {
                    this._leafletMapAdapterInstance = new LeafletMapAdapter(this._config.routingUrl);
                    log.info("[GeoRuntime] LeafletMapAdapter instantiated.");
                }
                if (this._config.geocode === 'nominatim' && !this._nominatimGeocodingAdapterInstance) {
                    this._nominatimGeocodingAdapterInstance = new NominatimGeocodingAdapter(this._config.nominatimUrl, this._config.nominatimEmail);
                    log.info("[GeoRuntime] NominatimGeocodingAdapter instantiated.");
                }
                this._isNonGoogleInitialized = true;
            } catch(e) {
                log.error("[GeoRuntime] Failed to instantiate non-Google adapters:", e);
                this._isNonGoogleInitialized = false;
            }
        });

        if (needsGoogle && this._googleApiKey) {
            log.info("[GeoRuntime] Google provider configured and API Key provided. Loading Google Maps script...");
            this._initializationPromise = Promise.all([
                initNonGooglePromise,
                this._googleLoader.load(this._googleApiKey, this._googleLibs)
                    .then(google => {
                        this._googleInstance = google;
                        try {
                            if (this._config.map === 'google') this._googleMapAdapterInstance = new GoogleMapAdapter(this._googleInstance);
                            if (this._config.geocode === 'google') this._googleGeocodingAdapterInstance = new GoogleGeocodingAdapter(this._googleInstance);
                            if (this._config.places === 'google') this._googlePlacesAdapterInstance = new GooglePlacesAutocompleteAdapter(this._googleInstance);
                            this._isGoogleInitialized = true;
                            log.info("[GeoRuntime] Google Maps script loaded successfully. Relevant adapters created.");
                            return true;
                        } catch (adapterError) {
                            log.error("[GeoRuntime] Error creating Google adapters after script load:", adapterError);
                            this._isGoogleInitialized = false;
                            return false;
                        }
                    })
                    .catch(err => {
                        log.error("[GeoRuntime] Failed to load Google Maps script:", err.message);
                        this._googleInstance = null;
                        this._isGoogleInitialized = false;
                        return false;
                    })
            ]).then(() => this._isGoogleInitialized || this._isNonGoogleInitialized);
        } else {
            if (needsGoogle && !this._googleApiKey) {
                log.warn("[GeoRuntime] Google provider configured but no API Key provided. Google features unavailable.");
            }
            this._initializationPromise = initNonGooglePromise.then(() => this._isNonGoogleInitialized);
        }
        return this._initializationPromise;
    }

    mapAdapter() {
        const provider = this._config.map;
        if (provider === 'google') {
            if (!this._isGoogleInitialized || !this._googleMapAdapterInstance) {
                throw new Error("GeoRuntime: Google Maps not initialized or map adapter failed. Cannot get GoogleMapAdapter.");
            }
            return this._googleMapAdapterInstance;
        }
        if (provider === 'leaflet') {
            if (!this._leafletMapAdapterInstance) {
                throw new Error("GeoRuntime: Leaflet Map adapter not initialized.");
            }
            return this._leafletMapAdapterInstance;
        }
        throw new Error(`GeoRuntime: No map adapter configured or available for provider: ${provider}`);
    }

    geocodingAdapter() {
        const provider = this._config.geocode;
        if (provider === 'google') {
            if (!this._isGoogleInitialized || !this._googleGeocodingAdapterInstance) {
                throw new Error("GeoRuntime: Google Maps not initialized or geocoding adapter failed. Cannot get GoogleGeocodingAdapter.");
            }
            return this._googleGeocodingAdapterInstance;
        }
        if (provider === 'nominatim') {
            if (!this._nominatimGeocodingAdapterInstance) {
                throw new Error("GeoRuntime: Nominatim Geocoding adapter not initialized.");
            }
            return this._nominatimGeocodingAdapterInstance;
        }
        throw new Error(`GeoRuntime: No geocoding adapter configured or available for provider: ${provider}`);
    }

    placesAdapter() {
        const provider = this._config.places;
        if (provider === 'google') {
            if (!this._isGoogleInitialized || !this._googlePlacesAdapterInstance) {
                log.warn("GeoRuntime: Google Places requested but not initialized or adapter failed.");
                return null;
            }
            return this._googlePlacesAdapterInstance;
        }
        if (provider === 'none') {
            return null;
        }
        log.warn(`GeoRuntime: Places adapter requested for unsupported provider: ${provider}`);
        return null;
    }

    isGoogleReady() {
        return this._isGoogleInitialized;
    }

    isProviderReady(type = 'map' | 'geocode' | 'places', providerName = null) {
        if (!this._initializationPromise) return false;

        const targetProvider = (providerName || this._config[type]).toLowerCase();

        if(targetProvider === 'google') return this.isGoogleReady();
        if(targetProvider === 'leaflet' && type === 'map') return !!this._leafletMapAdapterInstance;
        if(targetProvider === 'nominatim' && type === 'geocode') return !!this._nominatimGeocodingAdapterInstance;
        if(targetProvider === 'none' && type === 'places') return true;

        log.warn(`[GeoRuntime] Readiness check for unknown or uninitialized provider type/name: ${type}/${targetProvider}`);
        return false;
    }
}

// Basic logger shim
const log = {
    info: (...args) => console.info(...args),
    warn: (...args) => console.warn(...args),
    error: (...args) => console.error(...args),
};

================================================================================
### PLIK: adapters/GoogleGeocodingAdapter.js
================================================================================

// FILE: src/adapters/GoogleGeocodingAdapter.js
// KEPT AS IS (from previous restore) - needed for optional Google usage
/**
 * ARCHITECTURE: GoogleGeocodingAdapter wraps the Maps JS Geocoder into a provider-agnostic API.
 * Provides address → {lat, lon, normalizedFields}.
 */
export class GoogleGeocodingAdapter {
  constructor(googleObj) {
    if (!googleObj || !googleObj.maps) throw new Error("GoogleGeocodingAdapter: google maps object required.");
    this.google = googleObj;
    this.geocoder = new this.google.maps.Geocoder();
  }

  async geocodeAddress(address) {
    // ... (implementation kept from previous restore) ...
    if (!address || !address.street || !address.postalCode || !address.city) {
      console.warn("[GoogleGeocode] Geocode skipped: Missing required fields.");
      return null;
    }
    const line1 = address.houseNumber ? `${address.street} ${address.houseNumber}` : address.street;
    const country = address.country || "PL";
    const query = `${line1}, ${address.postalCode} ${address.city}, ${country}`;
    const request = { address: query, region: country };
    log.debug(`[GoogleGeocode] Geocoding query: ${query}`);

    try {
      const res = await this.geocoder.geocode(request);
      if (!res || !Array.isArray(res.results) || res.results.length === 0) {
        log.warn(`[GoogleGeocode] No results found for query: ${query}`);
        return null;
      }
      const best = res.results[0];
      const components = this._indexComponents(best.address_components || []);
      const lat = best.geometry?.location?.lat?.() ?? null;
      const lon = best.geometry?.location?.lng?.() ?? null;

      if (lat == null || lon == null) {
        log.warn(`[GoogleGeocode] Result for query '${query}' missing valid coordinates.`);
        return null;
      }
      const normalized = {
        street: components.route || address.street || null,
        houseNumber: components.street_number || address.houseNumber || null,
        postalCode: components.postal_code || address.postalCode || null,
        city: components.locality || components.postal_town || components.administrative_area_level_2 || address.city || null,
        country: components.country_code || country,
        latitude: lat,
        longitude: lon,
        _provider: 'Google',
        _displayName: best.formatted_address,
        _confidence: best.geometry?.location_type === 'ROOFTOP' ? 1.0 : (best.geometry?.location_type === 'RANGE_INTERPOLATED' ? 0.9 : 0.7),
        _locationType: best.geometry?.location_type
      };
      log.debug(`[GoogleGeocode] Geocode success for query '${query}'. Result: Lat=${normalized.latitude}, Lon=${normalized.longitude}, Type=${normalized._locationType}`);
      return normalized;

    } catch (error) {
      log.error(`[GoogleGeocode] Geocoding error for query '${query}': ${error.message}`, error);
      return null;
    }
  }

  _indexComponents(parts) {
    // ... (implementation kept from previous restore) ...
    const map = {};
    for (const c of parts) {
      for (const t of c.types) {
        if (t === "country") {
          map.country = c.long_name; map.country_code = c.short_name;
        } else if (t === "locality") { map.locality = c.long_name;
        } else if (t === "postal_town") { map.postal_town = c.long_name;
        } else if (t === "administrative_area_level_2") { map.administrative_area_level_2 = c.long_name;
        } else if (t === "administrative_area_level_1") { map.administrative_area_level_1 = c.long_name;
        } else if (t === "route") { map.route = c.long_name;
        } else if (t === "street_number") { map.street_number = c.long_name;
        } else if (t === "postal_code") { map.postal_code = c.long_name; }
      }
    }
    return map;
  }
}

const log = {
  debug: (...args) => console.debug(...args),
  info: (...args) => console.info(...args),
  warn: (...args) => console.warn(...args),
  error: (...args) => console.error(...args),
};

================================================================================
### PLIK: adapters/GoogleMapAdapter.js
================================================================================

// FILE: src/adapters/GoogleMapAdapter.js
// KEPT AS IS (from previous restore) - needed for optional Google usage
/**
 * ARCHITECTURE: GoogleMapAdapter provides a concrete map implementation for MapController using Google Maps JS API.
 * Encapsulates vendor-specific map calls behind a small, explicit interface.
 * Responsibilities: Create/destroy map, set center/zoom, manage a single primary marker.
 */
export class GoogleMapAdapter {
  constructor(googleObj) {
    if (!googleObj || !googleObj.maps) throw new Error("GoogleMapAdapter: google maps object required.");
    this.google = googleObj;
    this._map = null;
    this._marker = null;
  }

  async create(container, options) {
    if (!container) throw new Error("GoogleMapAdapter.create: container is required.");
    const center = { lat: options?.lat ?? 52.2297, lng: options?.lon ?? 21.0122 };
    const zoom = options?.zoom ?? 12;
    this._map = new this.google.maps.Map(container, { center, zoom, mapTypeControl: false, streetViewControl: false });
    if (this.google.maps.marker?.AdvancedMarkerElement) {
      this._marker = new this.google.maps.marker.AdvancedMarkerElement({ position: center, map: this._map, gmpDraggable: false });
    } else {
      this._marker = new this.google.maps.Marker({ position: center, map: this._map });
    }
    return true;
  }

  async setCenter(lat, lon, zoom) {
    if (!this._map) throw new Error("GoogleMapAdapter.setCenter: map not created.");
    const center = { lat, lng: lon };
    this._map.setCenter(center);
    if (typeof zoom === "number") this._map.setZoom(zoom);
    return true;
  }

  async setMarker(lat, lon) {
    if (!this._map || !this._marker) throw new Error("GoogleMapAdapter.setMarker: map not created.");
    const pos = { lat, lng: lon };
    if (typeof this._marker. G === 'function') { // Legacy Marker
      this._marker.setPosition(pos);
    } else if (this._marker.position) { // AdvancedMarkerElement
      this._marker.position = pos;
    }
    return true;
  }

  async fit(lat, lon) {
    if (!this._map) throw new Error("GoogleMapAdapter.fit: map not created.");
    const bounds = new this.google.maps.LatLngBounds();
    bounds.extend(new this.google.maps.LatLng(lat, lon));
    this._map.fitBounds(bounds, 64);
    return true;
  }

  async destroy() {
    if (this._marker) {
      this._marker.map = null;
      if (typeof this._marker.setMap === 'function') { this._marker.setMap(null); }
      this._marker = null;
    }
    if (this._map) {
      this._map = null;
    }
    return true;
  }
}

================================================================================
### PLIK: adapters/GoogleMapsScriptLoader.js
================================================================================

// FILE: src/adapters/GoogleMapsScriptLoader.js
// KEPT AS IS (from previous restore) - needed for optional Google usage
/**
 * ARCHITECTURE: GoogleMapsScriptLoader ensures exactly-once loading of the Google Maps JS API.
 * Uses a static promise to prevent multiple script injections across the application.
 */
export class GoogleMapsScriptLoader {
  static _promise = null;
  static _loadedKey = null;
  static _loadedLibsKey = null;

  load(apiKey, libraries = []) {
    // ... (implementation kept from previous restore) ...
    if (!apiKey || typeof apiKey !== "string") { return Promise.reject(new Error("GoogleMapsScriptLoader: missing apiKey.")); }
    const libs = Array.isArray(libraries) ? libraries.slice().sort() : [];
    const libsKey = libs.join(",");
    if (GoogleMapsScriptLoader._promise && GoogleMapsScriptLoader._loadedKey === apiKey && GoogleMapsScriptLoader._loadedLibsKey === libsKey) { return GoogleMapsScriptLoader._promise; }
    if (typeof window !== "undefined" && window.google && window.google.maps) {
      if (GoogleMapsScriptLoader._promise && (GoogleMapsScriptLoader._loadedKey !== apiKey || GoogleMapsScriptLoader._loadedLibsKey !== libsKey)) { console.warn("GoogleMapsScriptLoader: Google Maps already loaded, potentially with different settings."); }
      GoogleMapsScriptLoader._promise = Promise.resolve(window.google);
      GoogleMapsScriptLoader._loadedKey = apiKey; GoogleMapsScriptLoader._loadedLibsKey = libsKey;
      return GoogleMapsScriptLoader._promise;
    }
    const src = new URL("https://maps.googleapis.com/maps/api/js");
    src.searchParams.set("key", apiKey);
    if (libs.length) src.searchParams.set("libraries", libsKey);
    src.searchParams.set("v", "weekly"); src.searchParams.set("loading", "async");
    const callbackName = `__googleMapsApiOnLoadCallback_${Date.now()}`;
    GoogleMapsScriptLoader._promise = new Promise((resolve, reject) => {
      window[callbackName] = () => {
        if (window.google && window.google.maps) {
          console.log("Google Maps API script loaded successfully via callback.");
          GoogleMapsScriptLoader._loadedKey = apiKey; GoogleMapsScriptLoader._loadedLibsKey = libsKey;
          resolve(window.google);
        } else {
          console.error("Google Maps callback executed, but window.google.maps is still undefined.");
          reject(new Error("Google Maps script loaded but window.google.maps is undefined."));
        }
        delete window[callbackName];
      };
      const scriptElement = document.createElement("script");
      scriptElement.src = `${src.toString()}&callback=${callbackName}`;
      scriptElement.async = true; scriptElement.defer = true;
      scriptElement.onerror = (err) => {
        console.error("Google Maps script failed to load.", err);
        GoogleMapsScriptLoader._promise = null; GoogleMapsScriptLoader._loadedKey = null; GoogleMapsScriptLoader._loadedLibsKey = null;
        reject(new Error("Google Maps script failed to load. Check API Key, network, and browser console."));
        delete window[callbackName];
      };
      document.head.appendChild(scriptElement);
    });
    GoogleMapsScriptLoader._loadedKey = apiKey; GoogleMapsScriptLoader._loadedLibsKey = libsKey;
    return GoogleMapsScriptLoader._promise;
  }
}

================================================================================
### PLIK: adapters/GooglePlacesAutocompleteAdapter.js
================================================================================

// FILE: src/adapters/GooglePlacesAutocompleteAdapter.js
// KEPT AS IS (from previous restore) - needed for optional Google usage
import { GooglePlacesSessionManager } from "@/adapters/GooglePlacesSessionManager";

/**
 * ARCHITECTURE: GooglePlacesAutocompleteAdapter wraps Places Autocomplete for type-ahead hints.
 * Isolates vendor API calls and returns normalized suggestion DTOs.
 */
export class GooglePlacesAutocompleteAdapter {
  constructor(googleObj) {
    if (!googleObj || !googleObj.maps || !googleObj.maps.places) {
      throw new Error("GooglePlacesAutocompleteAdapter: google maps places library required.");
    }
    this.google = googleObj;
    this.service = new this.google.maps.places.AutocompleteService();
    const mapDiv = (typeof document !== 'undefined') ? document.createElement("div") : null;
    this.detailsService = mapDiv ? new this.google.maps.places.PlacesService(mapDiv) : null;
    this.sessionManager = new GooglePlacesSessionManager(this.google);
  }

  async suggest(text, country = "PL") {
    // ... (implementation kept from previous restore) ...
    if (!this.service || !text || !text.trim()) return [];
    log.debug(`[GooglePlaces] Suggesting for: "${text}"`);
    const sessionToken = this.sessionManager.getToken();
    if (!sessionToken) {
      log.warn("[GooglePlaces] No session token available for suggestion.");
      this.sessionManager.renew();
      return [];
    }
    try {
      const predictions = await this._getPredictions(text, country, sessionToken);
      const predictionItems = Array.isArray(predictions) ? predictions.slice(0, 5) : [];
      const detailPromises = predictionItems.map(p => this._getDetails(p.place_id, sessionToken));
      const detailedResults = await Promise.all(detailPromises);
      const enriched = detailedResults
          .filter(d => d !== null)
          .map(d => this._mapDetailsToSuggestion(d));
      if (enriched.length > 0) {
        this.sessionManager.renew();
        log.debug(`[GooglePlaces] Session token renewed after fetching ${enriched.length} details.`);
      }
      return enriched;
    } catch (error) {
      log.error(`[GooglePlaces] Suggestion error for "${text}": ${error.message}`, error);
      return [];
    }
  }

  _getPredictions(input, country, sessionToken) {
    // ... (implementation kept from previous restore) ...
    return new Promise((resolve, reject) => {
      if (!this.service) return reject(new Error("Places AutocompleteService not initialized."));
      this.service.getPlacePredictions(
          { input, sessionToken, componentRestrictions: { country }, types: ['address'] },
          (predictions, status) => {
            if (status === this.google.maps.places.PlacesServiceStatus.OK) { resolve(predictions || []); }
            else if (status === this.google.maps.places.PlacesServiceStatus.ZERO_RESULTS) { resolve([]); }
            else {
              log.warn(`[GooglePlaces] getPlacePredictions failed with status: ${status}`);
              reject(new Error(`Places Autocomplete prediction failed: ${status}`));
            }
          }
      );
    });
  }

  _getDetails(placeId, sessionToken) {
    // ... (implementation kept from previous restore) ...
    return new Promise((resolve) => {
      if (!this.detailsService) { log.error("[GooglePlaces] PlacesService for details not initialized."); return resolve(null); }
      if (!placeId) return resolve(null);
      this.detailsService.getDetails(
          { placeId, sessionToken, fields: ["address_components", "geometry.location", "formatted_address"] },
          (place, status) => {
            if (status === this.google.maps.places.PlacesServiceStatus.OK && place) { resolve(place); }
            else { log.warn(`[GooglePlaces] getDetails failed for placeId ${placeId} with status: ${status}`); resolve(null); }
          }
      );
    });
  }

  _mapDetailsToSuggestion(place) {
    // ... (implementation kept from previous restore) ...
    if (!place) return null;
    const comps = this._indexComponents(place.address_components || []);
    const lat = place.geometry?.location?.lat?.() ?? null;
    const lon = place.geometry?.location?.lng?.() ?? null;
    return {
      fullAddressLabel: place.formatted_address || null,
      street: comps.route || null, houseNumber: comps.street_number || null,
      postalCode: comps.postal_code || null, city: comps.locality || comps.postal_town || comps.administrative_area_level_2 || null,
      countryCode: comps.country_code || null, countryName: comps.country || null,
      latitude: lat, longitude: lon,
      matchScore: 0.9, matchLevel: "PLACES_DETAIL", providerSource: "GOOGLE_PLACES",
    };
  }

  _indexComponents(parts) {
    // ... (implementation kept from previous restore) ...
    const map = {};
    for (const c of parts) {
      for (const t of c.types) {
        if (t === "country") { map.country = c.long_name; map.country_code = c.short_name; }
        else if (t === "locality") { map.locality = c.long_name; }
        else if (t === "postal_town") { map.postal_town = c.long_name; }
        else if (t === "administrative_area_level_2") { map.administrative_area_level_2 = c.long_name; }
        else if (t === "route") { map.route = c.long_name; }
        else if (t === "street_number") { map.street_number = c.long_name; }
        else if (t === "postal_code") { map.postal_code = c.long_name; }
      }
    }
    return map;
  }
}

const log = {
  debug: (...args) => console.debug(...args),
  warn: (...args) => console.warn(...args),
  error: (...args) => console.error(...args),
};

================================================================================
### PLIK: adapters/GooglePlacesSessionManager.js
================================================================================

/**
 * ARCHITECTURE: GooglePlacesSessionManager encapsulates the creation, retrieval,
 * and renewal of Google Places AutocompleteSessionToken objects.
 * This is crucial for managing billing correctly with the Places API.
 * This is a stub implementation as the 'google' object is not available here directly.
 */
export class GooglePlacesSessionManager {
    constructor(googleMapsInstance) {
        if (!googleMapsInstance || !googleMapsInstance.maps || !googleMapsInstance.maps.places) {
            console.warn("[GooglePlacesSessionManager] Google Maps Places library not found. Session management will be non-functional.");
            this._googlePlaces = null;
        } else {
            this._googlePlaces = googleMapsInstance.maps.places;
        }
        this._token = null;
        this._renewToken(); // Initialize first token
    }

    /**
     * Retrieves the current session token.
     * @returns {google.maps.places.AutocompleteSessionToken | null} The current token.
     */
    getToken() {
        if (!this._token) {
            // Attempt to create one if it was missed, though it should be initialized.
            this._renewToken();
        }
        return this._token;
    }

    /**
     * Renews the session token. This should be called after a successful
     * 'getDetails' call, invalidating the previous token.
     */
    renew() {
        this._renewToken();
    }

    /**
     * Internal helper to create a new token.
     */
    _renewToken() {
        if (this._googlePlaces) {
            try {
                this._token = new this._googlePlaces.AutocompleteSessionToken();
            } catch (e) {
                console.error("[GooglePlacesSessionManager] Failed to create new AutocompleteSessionToken:", e);
                this._token = null;
            }
        } else {
            this._token = null;
        }
    }
}

================================================================================
### PLIK: adapters/GoogleRuntime.js
================================================================================

// FILE: src/adapters/GoogleRuntime.js
import { GoogleMapsScriptLoader } from "@/adapters/GoogleMapsScriptLoader";
import { GoogleMapAdapter } from "@/adapters/GoogleMapAdapter";
import { GoogleGeocodingAdapter } from "@/adapters/GoogleGeocodingAdapter";
import { GooglePlacesAutocompleteAdapter } from "@/adapters/GooglePlacesAutocompleteAdapter";

export class GoogleRuntime {
  constructor() {
    // Use the static loader instance
    this._loader = new GoogleMapsScriptLoader();
    this._google = null;
  }

  async init(apiKey, libraries = ["places", "geocoding"]) {
    // Check static property on the loader class
    if (GoogleMapsScriptLoader._promise) {
      this._google = await GoogleMapsScriptLoader._promise;
      return this._google;
    }
    // Call the instance method if not already loading/loaded
    this._google = await this._loader.load(apiKey, libraries);
    return this._google;
  }

  mapAdapter() {
    if (!this._google) throw new Error("GoogleRuntime: not initialized.");
    return new GoogleMapAdapter(this._google);
  }

  geocodingAdapter() {
    if (!this._google) throw new Error("GoogleRuntime: not initialized.");
    return new GoogleGeocodingAdapter(this._google);
  }

  placesAdapter() {
    if (!this._google) throw new Error("GoogleRuntime: not initialized.");
    return new GooglePlacesAutocompleteAdapter(this._google);
  }
}

================================================================================
### PLIK: adapters/LeafletMapAdapter.js
================================================================================

// FILE: src/adapters/LeafletMapAdapter.js
// MODIFIED - Added multiple markers, routing, and proper config
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import iconRetinaUrl from 'leaflet/dist/images/marker-icon-2x.png';
import iconUrl from 'leaflet/dist/images/marker-icon.png';
import shadowUrl from 'leaflet/dist/images/marker-shadow.png';

// --- Create custom Green and Red icons ---
const greenIcon = new L.Icon({
    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    shadowSize: [41, 41]
});

const redIcon = new L.Icon({
    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    shadowSize: [41, 41]
});
// --- End custom icons ---

/**
 * ARCHITECTURE: LeafletMapAdapter provides a map implementation using Leaflet JS.
 * REFACTORED: Now supports distinct pickup/delivery markers and OSRM routing.
 */
export class LeafletMapAdapter {
    constructor(osrmRoutingUrl = null) {
        this._map = null;
        this._pickupMarker = null;
        this._deliveryMarker = null;
        this._routeLine = null;
        this._osrmRoutingUrl = osrmRoutingUrl; // URL for OSRM service
        this._defaultCenter = { lat: 52.2297, lon: 21.0122 }; // Warsaw
        this._defaultZoom = 6;
    }

    async create(container, options) {
        if (!container) throw new Error("LeafletMapAdapter.create: container is required.");
        if (this._map) {
            await this.destroy();
        }
        const center = L.latLng(options?.lat ?? this._defaultCenter.lat, options?.lon ?? this._defaultCenter.lon);
        const zoom = options?.zoom ?? this._defaultZoom;
        const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        });
        this._map = L.map(container, { center, zoom, layers: [osmLayer], zoomControl: true });

        // Initialize markers (hidden at first)
        this._pickupMarker = L.marker(center, { icon: greenIcon, opacity: 0 });
        this._deliveryMarker = L.marker(center, { icon: redIcon, opacity: 0 });
        this._pickupMarker.addTo(this._map);
        this._deliveryMarker.addTo(this._map);

        setTimeout(() => this._map?.invalidateSize(), 100);
        return true;
    }

    async setCenter(lat, lon, zoom) {
        if (!this._map) throw new Error("LeafletMapAdapter.setCenter: map not created.");
        const center = L.latLng(lat, lon);
        const newZoom = (typeof zoom === "number")? zoom : this._map.getZoom();
        this._map.setView(center, newZoom);
        return true;
    }

    // --- NEW MARKER METHODS ---
    async setMarker(lat, lon) {
        // Legacy method, just moves the pickup marker
        return this.setPickupMarker(lat, lon);
    }

    async setPickupMarker(lat, lon, zoomTo = false) {
        if (!this._map || !this._pickupMarker) throw new Error("LeafletMapAdapter.setPickupMarker: map/marker not created.");
        const pos = L.latLng(lat, lon);
        this._pickupMarker.setLatLng(pos).setOpacity(1); // Make visible
        if(zoomTo) this._map.setView(pos, 15);
        return true;
    }

    async setDeliveryMarker(lat, lon, zoomTo = false) {
        if (!this._map || !this._deliveryMarker) throw new Error("LeafletMapAdapter.setDeliveryMarker: map/marker not created.");
        const pos = L.latLng(lat, lon);
        this._deliveryMarker.setLatLng(pos).setOpacity(1); // Make visible
        if(zoomTo) this._map.setView(pos, 15);
        return true;
    }
    // --- END NEW MARKER METHODS ---

    async fitBounds(pickupPos, deliveryPos) {
        if (!this._map) return false;
        if (!pickupPos || !deliveryPos) return false;

        const pLatLon = L.latLng(pickupPos.lat, pickupPos.lon);
        const dLatLon = L.latLng(deliveryPos.lat, deliveryPos.lon);

        this._map.fitBounds(L.latLngBounds([pLatLon, dLatLon]), { padding: [50, 50] }); // Add 50px padding
        return true;
    }

    async drawRoute(pickupPos, deliveryPos) {
        if (!this._osrmRoutingUrl) {
            console.warn("MapAdapter: OSRM routing URL not configured. Skipping route line.");
            return false;
        }
        if (!this._map) return false;
        if (!pickupPos || !deliveryPos) return false;

        // Clear existing route
        if (this._routeLine) {
            this._routeLine.remove();
            this._routeLine = null;
        }

        // OSRM expects {lon},{lat};{lon},{lat}
        const coords = `${pickupPos.lon},${pickupPos.lat};${deliveryPos.lon},${deliveryPos.lat}`;
        const url = `${this._osrmRoutingUrl}/route/v1/driving/${coords}?overview=full&geometries=polyline`;

        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`OSRM responded with ${response.status}`);
            const data = await response.json();

            if (data.routes && data.routes[0] && data.routes[0].geometry) {
                // Need to decode polyline. Using a simple decoder.
                const geometry = data.routes[0].geometry;
                const latlngs = this.decodePolyline(geometry); // Implement decoder

                this._routeLine = L.polyline(latlngs, { color: 'var(--color-primary)', weight: 3, opacity: 0.7 }).addTo(this._map);
                return true;
            }
        } catch (e) {
            console.error("LeafletMapAdapter: Failed to fetch route from OSRM:", e);
        }
        return false;
    }

    // Polyline decoder (common algorithm)
    decodePolyline(str, precision = 5) {
        let index = 0, lat = 0, lng = 0, coordinates = [],
            shift = 0, result = 0,
            byte = null, latitude_change, longitude_change,
            factor = Math.pow(10, precision);

        while (index < str.length) {
            byte = null; shift = 0; result = 0;
            do {
                byte = str.charCodeAt(index++) - 63;
                result |= (byte & 0x1f) << shift;
                shift += 5;
            } while (byte >= 0x20);
            latitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));
            shift = result = 0;
            do {
                byte = str.charCodeAt(index++) - 63;
                result |= (byte & 0x1f) << shift;
                shift += 5;
            } while (byte >= 0x20);
            longitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));
            lat += latitude_change;
            lng += longitude_change;
            coordinates.push([lat / factor, lng / factor]);
        }
        return coordinates;
    }

    async destroy() {
        if (this._pickupMarker) this._pickupMarker.remove();
        if (this._deliveryMarker) this._deliveryMarker.remove();
        if (this._routeLine) this._routeLine.remove();
        if (this._map) this._map.remove();

        this._map = null;
        this._pickupMarker = null;
        this._deliveryMarker = null;
        this._routeLine = null;
        return true;
    }
}

================================================================================
### PLIK: adapters/MapGeocoderAdapter.js
================================================================================

/**
 * ARCHITECTURE: MapGeocoderAdapter abstracts a geocoding function behind a stable contract.
 * It follows the manifesto by isolating vendor-specific logic and exposing a single responsibility.
 * Responsibilities:
 * - Accept an Address-like DTO and delegate to an injected geocode function.
 * - Return a normalized { lat, lon } object or null without leaking provider details.
 */
export class MapGeocoderAdapter {
  constructor(geocodeFn) {
    if (typeof geocodeFn !== "function") throw new Error("MapGeocoderAdapter: geocode function required.");
    this.geocodeFn = geocodeFn;
  }

  async geocodeAddress(address) {
    if (!address || typeof address !== "object") return null;
    const r = await this.geocodeFn({
      street: address.street,
      houseNumber: address.houseNumber ?? null,
      postalCode: address.postalCode,
      city: address.city,
      country: address.country || "PL",
    });
    if (!r || typeof r.lat !== "number" || typeof r.lon !== "number") return null;
    return { lat: r.lat, lon: r.lon };
  }
}


================================================================================
### PLIK: adapters/NominatimGeocodingAdapter.js
================================================================================

// ============================================================================
// Frontend: Update NominatimGeocodingAdapter
// FILE: src/adapters/NominatimGeocodingAdapter.js
// REASON: Change hardcoded default URL to use the '/nominatim' proxy path.
// REASON: Remove hardcoded '/search' path, as it's now in the config URL.
// ============================================================================
// FILE: src/adapters/NominatimGeocodingAdapter.js
import { AddressNormalizer } from '@/services/AddressNormalizer';
/**
 * ARCHITECTURE: NominatimGeocodingAdapter wraps OpenStreetMap Nominatim API for geocoding.
 * REFACTORED: Default URL now points to the proxy path '/nominatim/search'.
 * REFACTORED: Adapter no longer appends '/search'.
 */
export class NominatimGeocodingAdapter {
    constructor(nominatimUrl, email) {
        // *** FIX: Apply defaults internally to handle null/undefined inputs ***
        const effectiveUrl = nominatimUrl || '/nominatim/search'; // *** UPDATED DEFAULT ***
        const effectiveEmail = email || 'triage-app@example.com';
        // *** END FIX ***

        this.baseUrl = effectiveUrl.replace(/\/+$/, "");
        this.email = effectiveEmail;
        this.normalizer = new AddressNormalizer();
        this.fetchOptions = {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
                'User-Agent': `DanxilsTriageApp/1.0 (${this.email})`,
            },
        };
    }

    async geocodeAddress(address) {
        if (!address || !address.street || !address.postalCode || !address.city) {
            console.warn("[Nominatim] Geocode skipped: Missing required fields (street, postalCode, city).");
            return null;
        }

        const params = new URLSearchParams({
            street: `${address.houseNumber || ''} ${address.street || ''}`.trim(),
            city: address.city || '',
            postalcode: address.postalCode || '',
            country: address.country || 'PL',
            format: 'jsonv2',
            addressdetails: '1',
            limit: '1',
            email: this.email,
        });

        // *** FIX: Removed hardcoded '/search' ***
        const url = `${this.baseUrl}?${params.toString()}`;
        // *** END FIX ***

        const queryDesc = `${params.get('street')}, ${params.get('postalcode')} ${params.get('city')}`;
        log.debug(`[Nominatim] Geocoding query: ${queryDesc}`);
        try {
            const response = await fetch(url, this.fetchOptions);
            if (!response.ok) {
                const errorBody = await response.text();
                log.error(`[Nominatim] API error ${response.status} for query '${queryDesc}'. Body: ${errorBody}`);
                throw new Error(`Nominatim API error ${response.status}`);
            }
            const results = await response.json();
            if (!Array.isArray(results) || results.length === 0) {
                log.warn(`[Nominatim] No results found for query: ${queryDesc}`);
                return null;
            }
            const best = results[0];
            const components = best.address || {};
            const lat = best.lat ? parseFloat(best.lat) : null;
            const lon = best.lon ? parseFloat(best.lon) : null;

            if (lat == null || lon == null || isNaN(lat) || isNaN(lon)) {
                log.warn(`[Nominatim] Result for query '${queryDesc}' missing valid coordinates. Lat: ${best.lat}, Lon: ${best.lon}`);
                return null;
            }

            const normalized = {
                street: components.road || address.street || null,
                houseNumber: components.house_number || address.houseNumber || null,
                postalCode: components.postcode || address.postalCode || null,
                city: components.city || components.town || components.village || address.city || null,
                country: (components.country_code || address.country || 'pl').toUpperCase(),
                latitude: lat,
                longitude: lon,
                _provider: 'Nominatim',
                _displayName: best.display_name,
                _osmType: best.osm_type,
                _osmId: best.osm_id,
                _confidence: best.importance ? parseFloat(best.importance) : null,
            };
            log.debug(`[Nominatim] Geocode success for query '${queryDesc}'. Result: Lat=${normalized.latitude}, Lon=${normalized.longitude}`);
            return normalized;
        } catch (error) {
            log.error(`[Nominatim] Network or processing error during geocode for query '${queryDesc}': ${error.message}`, error);
            return null;
        }
    }
}

const log = {
    debug: (...args) => console.debug(...args),
    info: (...args) => console.info(...args),
    warn: (...args) => console.warn(...args),
    error: (...args) => console.error(...args),
};

================================================================================
### PLIK: components/AddressCorrectionCard.vue
================================================================================

<template>
  <div class="bg-white dark:bg-gray-800 shadow rounded-lg divide-y divide-gray-200 dark:divide-gray-700">
    <div class="px-4 py-5 sm:px-6">
      <h3 class="text-lg font-semibold leading-6 text-gray-900 dark:text-gray-100">{{ title }}</h3>
      <p v-if="reasonCode" class="mt-1 text-sm text-red-600 dark:text-red-400">
        Reason: {{ reasonCode }}
      </p>
    </div>

    <div class="px-4 py-5 sm:p-6">
      <div class="sm:hidden">
        <label for="tabs" class="sr-only">Select a tab</label>
        <select
            :id="`${side}-tabs`"
            name="tabs"
            class="block w-full rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:border-blue-500 focus:ring-blue-500"
            @change="currentTab = $event.target.value"
        >
          <option value="edit" :selected="currentTab === 'edit'">Edit</option>
          <option value="original" :selected="currentTab === 'original'">Original (From Source)</option>
          <option value="stored" :selected="currentTab === 'stored'" v-if="storedAddress">
            Stored (TrackIT)
          </option>
        </select>
      </div>
      <div class="hidden sm:block">
        <div class="border-b border-gray-200 dark:border-gray-700">
          <nav class="-mb-px flex space-x-8" aria-label="Tabs">
            <button
                @click="currentTab = 'edit'"
                :class="[
                currentTab === 'edit'
                  ? 'border-blue-500 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-gray-400 dark:hover:text-gray-200 dark:hover:border-gray-500',
                'whitespace-nowrap border-b-2 py-4 px-1 text-sm font-medium'
              ]"
            >
              Edit
            </button>
            <button
                @click="currentTab = 'original'"
                :class="[
                currentTab === 'original'
                  ? 'border-blue-500 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-gray-400 dark:hover:text-gray-200 dark:hover:border-gray-500',
                'whitespace-nowrap border-b-2 py-4 px-1 text-sm font-medium'
              ]"
            >
              Original (From Source)
            </button>
            <button
                v-if="storedAddress"
                @click="currentTab = 'stored'"
                :class="[
                currentTab === 'stored'
                  ? 'border-blue-500 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-gray-400 dark:hover:text-gray-200 dark:hover:border-gray-500',
                'whitespace-nowrap border-b-2 py-4 px-1 text-sm font-medium'
              ]"
            >
              Stored (TrackIT)
            </button>
          </nav>
        </div>
      </div>

      <div class="mt-6">
        <div v-show="currentTab === 'edit'" class="space-y-4">

          <FormInput
              :label="`${title} Alias`"
              :model-value="editableAddress.alias"
              @update:model-value="emitChange('alias', $event)"
              :id="`${side}-alias`"
              :disabled="!isPending"
          />
          <FormInput
              :label="`${title} Name (Attention)`"
              :model-value="editableAddress.name"
              @update:model-value="emitChange('name', $event)"
              :id="`${side}-name`"
              :disabled="!isPending"
          />

          <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <FormInput
                label="Street"
                :model-value="editableAddress.street"
                @update:model-value="emitChange('street', $event)"
                :id="`${side}-street`"
                :disabled="!isPending"
            />
            <FormInput
                label="House No."
                :model-value="editableAddress.houseNumber"
                @update:model-value="emitChange('houseNumber', $event)"
                :id="`${side}-houseNumber`"
                :disabled="!isPending"
            />
            <FormInput
                label="Postal Code"
                :model-value="editableAddress.postalCode"
                @update:model-value="emitChange('postalCode', $event)"
                :id="`${side}-postalCode`"
                :disabled="!isPending"
            />
            <FormInput
                label="City"
                :model-value="editableAddress.city"
                @update:model-value="emitChange('city', $event)"
                :id="`${side}-city`"
                :disabled="!isPending"
            />

            <FormInput
                label="Latitude"
                type="number"
                step="any"
                :model-value="editableAddress.latitude"
                @update:model-value="emitChange('latitude', $event ? parseFloat($event) : null)"
                :id="`${side}-latitude`"
                :disabled="!isPending"
            />
            <FormInput
                label="Longitude"
                type="number"
                step="any"
                :model-value="editableAddress.longitude"
                @update:model-value="emitChange('longitude', $event ? parseFloat($event) : null)"
                :id="`${side}-longitude`"
                :disabled="!isPending"
            />
          </div>

          <div class="pt-4 flex justify-between">
            <button
                @click="emit('use-original')"
                :disabled="!isPending"
                class="rounded-md bg-gray-200 px-3 py-2 text-sm font-semibold text-gray-700 shadow-sm hover:bg-gray-300 disabled:opacity-50"
            >
              Use Original
            </button>

            <div class="flex gap-2">
              <button
                  @click="emit('geocode')"
                  :disabled="!isPending || geocodeLoading"
                  class="rounded-md bg-green-600 px-3 py-2 text-sm font-semibold text-white shadow-sm hover:bg-green-500 disabled:opacity-50"
              >
                {{ geocodeLoading ? 'Geocoding...' : 'Geocode & Fill' }}
              </button>

              <button
                  @click="emit('save')"
                  :disabled="!isPending"
                  class="rounded-md bg-blue-600 px-3 py-2 text-sm font-semibold text-white shadow-sm hover:bg-blue-500 disabled:opacity-50"
              >
                Save {{ title }}
              </button>
            </div>
          </div>
        </div>

        <div v-show="currentTab === 'original'">
          <AddressDisplay :address="originalAddress" title="Original Address" :show-coords="true" />
        </div>

        <div v-show="currentTab === 'stored'" v-if="storedAddress">
          <AddressDisplay :address="storedAddress" title="Stored Address (TrackIT)" :show-coords="true" />
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, defineProps, defineEmits } from 'vue';
import AddressDisplay from '@/components/AddressDisplay.vue';
import FormInput from '@/components/FormInput.vue';
// Note: AddressInputGroup is removed and fields are now in this component

const props = defineProps({
  title: { type: String, required: true },
  side: { type: String, required: true },
  originalAddress: { type: Object, default: () => ({}) },
  storedAddress: { type: Object, default: undefined },
  reasonCode: { type: String, default: '' },
  isPending: { type: Boolean, default: false },
  editableAddress: { type: Object, required: true }, // Expects full Address object from WorkbenchModels
  geocodeLoading: { type: Boolean, default: false }
});

const emit = defineEmits([
  'update:editableAddress',
  'geocode',
  'save',
  'use-original'
]);

const currentTab = ref('edit');

const emitChange = (field, value) => {
  emit('update:editableAddress', {
    ...props.editableAddress,
    [field]: value
  });
};
</script>

================================================================================
### PLIK: components/AddressDiffCard.vue
================================================================================

<script setup>
import { computed } from 'vue';

const props = defineProps({
  title: String,
  address: Object,
  storedAddress: Object,
  storedLabel: {
    type: String,
    default: 'Stored (TrackIT - if mismatched)'
  },
  diffSnapshot: Object
});
</script>

<template>
  <div class="bg-white p-4 rounded-lg shadow-sm border border-gray-200 space-y-4">
    <h3 class="text-lg font-semibold text-gray-800">{{ title }}</h3>

    <!-- Current/Original Address -->
    <div class="border-b pb-2">
      <h4 class="text-sm font-medium text-gray-600">Original Address (Input)</h4>
      <pre class="bg-gray-50 p-2 text-xs rounded mt-1 overflow-x-auto">{{ JSON.stringify(address, null, 2) }}</pre>
    </div>

    <!-- Stored Address -->
    <div>
      <h4 class="text-sm font-medium text-gray-600">{{ storedLabel }}</h4>
      <pre class="bg-gray-50 p-2 text-xs rounded mt-1 overflow-x-auto">{{ storedAddress ? JSON.stringify(storedAddress, null, 2) : 'N/A' }}</pre>
    </div>

  </div>
</template>


================================================================================
### PLIK: components/AddressDisplay.vue
================================================================================

<template>
  <div class="address-display">
    <h3 v-if="title">{{ title }}</h3>
    <div v-if="alias" class="alias-display">
      <strong>Alias:</strong> {{ alias }}
    </div>
    <pre v-if="address">{{ formattedAddress }}</pre>
    <p v-else class="na-text">N/A</p>
  </div>
</template>

<script setup>
import { computed } from 'vue';

const props = defineProps({
  title: String,
  address: Object, // Expects Address-like object
  alias: String,   // Added alias prop
});

const formattedAddress = computed(() => {
  if (!props.address) return "N/A";
  try {
    // Create a copy for display, remove alias if it exists
    const displayObj = { ...props.address };
    delete displayObj.alias;

    return JSON.stringify(displayObj, null, 2);
  } catch {
    return "Invalid Address Data";
  }
});
</script>

<style scoped>
.address-display {
  margin-bottom: 15px;
}
h3 {
  margin-top: 0;
  margin-bottom: 5px;
  font-size: 1em;
  font-weight: bold;
  color: #444;
}
.alias-display {
  font-size: 0.9em;
  font-weight: 600;
  color: #0056b3; /* Dark blue for alias */
  margin-bottom: 5px;
  padding: 4px 0;
}
pre {
  background-color: #f4f4f4;
  padding: 10px;
  border-radius: 4px;
  font-size: 0.85em;
  white-space: pre-wrap;
  word-break: break-all;
  border: 1px solid #e0e0e0;
}
p.na-text {
  color: #888;
  font-style: italic;
  padding: 10px;
  background-color: #f9f9f9;
  border: 1px dashed #ddd;
  border-radius: 4px;
}
</style>

================================================================================
### PLIK: components/AddressEditForm.vue
================================================================================

<script setup>
import { Address } from "@/domain/WorkbenchModels.js";
import { ref, watch, computed } from 'vue';

const props = defineProps({
  title: String,
  initialAddress: Object,
  validation: Object,
  savePolicy: Object
});

const emit = defineEmits(['change', 'useOriginal', 'saveAndNext']);

const formAddress = ref(Address.from(props.initialAddress));
const formState = ref({
  isChanged: false,
  isGeocoding: false,
  error: null,
  // Add state for bulk checkbox
  applyToSimilar: false
});

// Watch initialAddress to update form state when parent loads new data
watch(() => props.initialAddress, (newAddr) => {
  formAddress.value = Address.from(newAddr);
  formState.value.isChanged = false;
  formState.value.applyToSimilar = false; // Reset checkbox on new order load
}, { deep: true, immediate: true });

// Emit changes to parent whenever formAddress changes
watch(formAddress, (newAddr) => {
  // Basic change detection logic to enable/disable save
  const changed = JSON.stringify(newAddr.toPlain()) !== JSON.stringify(props.initialAddress.toPlain());
  formState.value.isChanged = changed;
  // Emit the new address and the bulk flag status
  emit('change', newAddr, formState.value.applyToSimilar);
}, { deep: true });

// Emit change whenever applyToSimilar state changes
watch(() => formState.value.applyToSimilar, (newVal) => {
  emit('change', formAddress.value, newVal);
});


const errors = computed(() => props.validation?.errors || {});

function handleGeocode() {
  formState.value.isGeocoding = true;
  setTimeout(() => formState.value.isGeocoding = false, 1000); // Simulate loading
}

function handleSave() {
  // Pass the bulk flag when saving
  emit('saveAndNext', formState.value.applyToSimilar);
}
</script>

<template>
  <div class="bg-white p-4 rounded-lg shadow-sm border border-gray-200 space-y-4">
    <h3 class="text-lg font-semibold text-gray-800">{{ title }}</h3>

    <div class="grid grid-cols-2 gap-4">
      <div class="flex flex-col">
        <label class="text-sm font-medium">Street</label>
        <input type="text" v-model="formAddress.street"
               :class="{'border-red-500': errors.street}" class="border p-2 rounded text-sm"/>
        <p v-if="errors.street" class="text-xs text-red-500 mt-1">{{ errors.street }}</p>
      </div>

      <div class="flex flex-col">
        <label class="text-sm font-medium">House No.</label>
        <input type="text" v-model="formAddress.houseNumber"
               :class="{'border-red-500': errors.houseNumber}" class="border p-2 rounded text-sm"/>
        <p v-if="errors.houseNumber" class="text-xs text-red-500 mt-1">{{ errors.houseNumber }}</p>
      </div>

      <div class="flex flex-col">
        <label class="text-sm font-medium">Postal Code</label>
        <input type="text" v-model="formAddress.postalCode"
               :class="{'border-red-500': errors.postalCode}" class="border p-2 rounded text-sm"/>
        <p v-if="errors.postalCode" class="text-xs text-red-500 mt-1">{{ errors.postalCode }}</p>
      </div>

      <div class="flex flex-col">
        <label class="text-sm font-medium">City</label>
        <input type="text" v-model="formAddress.city"
               :class="{'border-red-500': errors.city}" class="border p-2 rounded text-sm"/>
        <p v-if="errors.city" class="text-xs text-red-500 mt-1">{{ errors.city }}</p>
      </div>

      <!-- Latitude/Longitude -->
      <div class="flex flex-col">
        <label class="text-sm font-medium">Latitude</label>
        <input type="text" v-model="formAddress.latitude"
               :class="{'border-red-500': errors.latitude}" class="border p-2 rounded text-sm"/>
      </div>

      <div class="flex flex-col">
        <label class="text-sm font-medium">Longitude</label>
        <input type="text" v-model="formAddress.longitude"
               :class="{'border-red-500': errors.longitude}" class="border p-2 rounded text-sm"/>
      </div>
    </div>

    <!-- Bulk/Policy Control -->
    <div class="pt-2 border-t mt-4">
      <label class="flex items-center text-sm font-medium cursor-pointer">
        <input type="checkbox" v-model="formState.applyToSimilar"
               class="mr-2 h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
        Apply correction to all similar pending orders
      </label>
    </div>

    <div class="flex justify-between items-center pt-2">
      <div class="text-sm font-medium" :class="{'text-red-600': !savePolicy?.enabled && formState.isChanged, 'text-gray-600': !formState.isChanged}">
        {{ formState.isChanged ? `Unsaved changes. Reason: ${savePolicy?.reason}` : 'No changes detected.' }}
      </div>

      <div class="flex gap-2">
        <button @click="$emit('useOriginal')"
                class="bg-gray-200 text-gray-700 px-3 py-1 rounded text-sm font-medium hover:bg-gray-300 transition">
          Use Original
        </button>

        <button @click="handleGeocode" :disabled="formState.isGeocoding"
                class="bg-yellow-600 text-white px-3 py-1 rounded text-sm font-medium hover:bg-yellow-700 transition disabled:bg-gray-400">
          {{ formState.isGeocoding ? 'Geocoding...' : 'Geocode Edited' }}
        </button>

        <button @click="handleSave" :disabled="!savePolicy?.enabled"
                class="bg-blue-600 text-white px-3 py-1 rounded text-sm font-medium hover:bg-blue-700 transition disabled:bg-gray-400">
          Save & Next
        </button>
      </div>
    </div>
  </div>
</template>


================================================================================
### PLIK: components/AddressForm.vue
================================================================================

<template>
  <div class="address-form">
    <h3>Edit {{ sideLabel }}</h3>
    <div class="form-group alias-group">
      <label :for="`${side}-alias`">Alias</label>
      <input
          :id="`${side}-alias`"
          type="text"
          :value="addressModelValue?.alias"
          @input="emitUpdate('alias', $event.target.value)"
          readonly
          disabled
      />
    </div>

    <div class="form-grid">
      <div class="form-group suggestion-group">
        <label :for="`${side}-street`">Street</label>
        <input
            :id="`${side}-street`"
            type="text"
            :value="addressModelValue?.street"
            @input="handleInput('street', $event.target.value)"
            @focus="handleFocus('street')"
            @blur="hideSuggestions"
            @keydown="handleKeydown"
            autocomplete="off"
        />
        <ul v-if="showSuggestions && activeField === 'street'" class="suggestions-dropdown" ref="streetSuggestionsRef">
          <li v-if="suggestionsLoading" class="loading-item">Loading...</li>
          <li v-else-if="suggestionsError" class="error-item">{{ suggestionsError }}</li>
          <li v-else-if="suggestions.length === 0" class="no-results-item">No suggestions found.</li>
          <li
              v-for="(suggestion, index) in suggestions"
              :key="index"
              :class="{ active: activeSuggestionIndex === index }"
              @mousedown.prevent="selectSuggestion(suggestion)"
              @mouseenter="activeSuggestionIndex = index"
          >
            {{ formatSuggestion(suggestion) }}
          </li>
        </ul>
      </div>

      <div class="form-group">
        <label :for="`${side}-houseNumber`">House No.</label>
        <input
            :id="`${side}-houseNumber`"
            type="text"
            :value="addressModelValue?.houseNumber"
            @input="emitUpdate('houseNumber', $event.target.value)"
        />
      </div>

      <div class="form-group suggestion-group">
        <label :for="`${side}-postalCode`">Postal Code</label>
        <input
            :id="`${side}-postalCode`"
            type="text"
            :value="addressModelValue?.postalCode"
            @input="handleInput('postalCode', $event.target.value)"
            @focus="handleFocus('postalCode')"
            @blur="hideSuggestions"
            @keydown="handleKeydown"
            autocomplete="off"
        />
        <ul v-if="showSuggestions && activeField === 'postalCode'" class="suggestions-dropdown" ref="postalSuggestionsRef">
          <li v-if="suggestionsLoading" class="loading-item">Loading...</li>
          <li v-else-if="suggestionsError" class="error-item">{{ suggestionsError }}</li>
          <li v-else-if="suggestions.length === 0" class="no-results-item">No suggestions found.</li>
          <li
              v-for="(suggestion, index) in suggestions"
              :key="index"
              :class="{ active: activeSuggestionIndex === index }"
              @mousedown.prevent="selectSuggestion(suggestion)"
              @mouseenter="activeSuggestionIndex = index"
          >
            {{ formatSuggestion(suggestion) }}
          </li>
        </ul>
      </div>

      <div class="form-group suggestion-group">
        <label :for="`${side}-city`">City</label>
        <input
            :id="`${side}-city`"
            type="text"
            :value="addressModelValue?.city"
            @input="handleInput('city', $event.target.value)"
            @focus="handleFocus('city')"
            @blur="hideSuggestions"
            @keydown="handleKeydown"
            autocomplete="off"
        />
        <ul v-if="showSuggestions && activeField === 'city'" class="suggestions-dropdown" ref="citySuggestionsRef">
          <li v-if="suggestionsLoading" class="loading-item">Loading...</li>
          <li v-else-if="suggestionsError" class="error-item">{{ suggestionsError }}</li>
          <li v-else-if="suggestions.length === 0" class="no-results-item">No suggestions found.</li>
          <li
              v-for="(suggestion, index) in suggestions"
              :key="index"
              :class="{ active: activeSuggestionIndex === index }"
              @mousedown.prevent="selectSuggestion(suggestion)"
              @mouseenter="activeSuggestionIndex = index"
          >
            {{ formatSuggestion(suggestion) }}
          </li>
        </ul>
      </div>

      <div class="form-group">
        <label :for="`${side}-country`">Country</label>
        <input
            :id="`${side}-country`"
            type="text"
            :value="addressModelValue?.country"
            @input="emitUpdate('country', $event.target.value)"
            maxlength="2"
        />
      </div>

      <div class="form-group coords">
        <label :for="`${side}-latitude`">Latitude</label>
        <input
            :id="`${side}-latitude`"
            type="number"
            step="any"
            :value="addressModelValue?.latitude"
            @input="emitUpdate('latitude', $event.target.value ? parseFloat($event.target.value) : null)"
        />
      </div>

      <div class="form-group coords">
        <label :for="`${side}-longitude`">Longitude</label>
        <input
            :id="`${side}-longitude`"
            type="number"
            step="any"
            :value="addressModelValue?.longitude"
            @input="emitUpdate('longitude', $event.target.value ? parseFloat($event.target.value) : null)"
        />
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, reactive, watch, onUnmounted, nextTick } from 'vue';
import { AddressExceptionApi } from '@/services/AddressExceptionApi';
import { DebounceTimer } from '@/services/DebounceTimer';

const props = defineProps({
  side: {
    type: String,
    required: true,
  },
  initialAddress: {
    type: Object,
    default: () => ({ street: '', houseNumber: null, postalCode: '', city: '', country: 'PL', latitude: null, longitude: null, alias: '' }),
  },
  placesAdapter: {
    type: Object,
    default: null,
  },
});

const emit = defineEmits(['update']);

// --- State ---
const suggestions = ref([]);
const showSuggestions = ref(false);
const suggestionsLoading = ref(false);
const suggestionsError = ref(null);
const activeField = ref(null);
const activeSuggestionIndex = ref(-1);
const activeSuggestionSource = ref('none'); // 'google' or 'backend'

const api = new AddressExceptionApi();
const placesDebouncer = new DebounceTimer(400); // Debounce for Google API calls
const backendDebouncer = new DebounceTimer(300); // Debounce for backend API calls

const addressModelValue = computed(() => props.initialAddress);
const sideLabel = computed(() => props.side.charAt(0).toUpperCase() + props.side.slice(1));
const localPlacesAdapter = ref(props.placesAdapter);

// --- Watch for adapter prop ---
watch(() => props.placesAdapter, (newAdapter) => {
  localPlacesAdapter.value = newAdapter;
  if(newAdapter) console.log(`Google Places Adapter received in AddressForm (${props.side}).`);
});

// --- Suggestion Fetching Logic ---

const fetchGoogleSuggestions = async (field, value) => {
  if (!localPlacesAdapter.value || !value || value.length < 3) {
    suggestions.value = [];
    showSuggestions.value = true;
    return;
  }

  activeSuggestionSource.value = 'google';
  activeField.value = field;
  activeSuggestionIndex.value = -1;
  suggestionsLoading.value = true;
  suggestionsError.value = null;
  showSuggestions.value = true;

  try {
    const query = value;
    const countryCode = addressModelValue.value?.country || 'PL';
    const results = await localPlacesAdapter.value.suggest(query, countryCode);
    suggestions.value = results || [];
  } catch (e) {
    suggestionsError.value = "Failed to fetch Google suggestions.";
    console.error(`fetchGoogleSuggestions error (${props.side}):`, e);
    suggestions.value = [];
  } finally {
    suggestionsLoading.value = false;
  }
};

const fetchBackendSuggestions = async (field) => {
  // Only proceed if Google is not currently active
  if (activeSuggestionSource.value === 'google' && suggestions.value.length > 0) return;

  activeSuggestionSource.value = 'backend';
  activeField.value = field;
  activeSuggestionIndex.value = -1;
  suggestionsLoading.value = true;
  suggestionsError.value = null;
  showSuggestions.value = true; // Show dropdown
  suggestions.value = []; // Clear previous

  let result;
  let contextMissing = false;

  try {
    const addr = addressModelValue.value;
    if (field === 'street') {
      if (!addr?.postalCode) { suggestionsError.value = "Enter Postal Code first."; contextMissing = true; }
      else result = await api.getStreetsForPostalCode(addr.postalCode, addr.city);
    } else if (field === 'postalCode') {
      if (!addr?.street || !addr?.city) { suggestionsError.value = "Enter Street and City first."; contextMissing = true; }
      else result = await api.getPostalCodesForStreet(addr.street, addr.city);
    } else if (field === 'city') {
      if (!addr?.postalCode) { suggestionsError.value = "Enter Postal Code first."; contextMissing = true; }
      else result = await api.getCitiesForPostalCode(addr.postalCode);
    } else {
      contextMissing = true; // Not a field we fetch for
    }

    if (contextMissing) {
      suggestions.value = [];
      // Do not show "no results" if context was missing
      if (!suggestionsError.value) showSuggestions.value = false;
    } else if (result && result.ok) {
      suggestions.value = result.value; // Expecting AddressLookupSuggestionDTO[]
    } else if (result) {
      suggestionsError.value = result.error.message;
    }
  } catch (e) {
    suggestionsError.value = `Failed to fetch ${field} suggestions.`;
    console.error(`fetchBackendSuggestions (${field}) error:`, e);
  } finally {
    suggestionsLoading.value = false;
  }
};

// --- Event Handlers ---

const emitUpdate = (field, value) => {
  emit('update', props.side, field, value);
};

const handleInput = (field, value) => {
  emitUpdate(field, value);

  // Trigger Google Places (debounced) as primary suggestion source on type
  if (field === 'street' || field === 'city' || field === 'postalCode') {
    placesDebouncer.run(() => fetchGoogleSuggestions(field, value));
  } else {
    // Clear suggestions for other fields
    hideSuggestions();
    placesDebouncer.cancel();
    backendDebouncer.cancel();
  }
};

const handleFocus = (field) => {
  // Hide any other open dropdowns
  hideSuggestions();
  // Set active field for keyboard nav and context
  activeField.value = field;
  activeSuggestionIndex.value = -1;
  activeSuggestionSource.value = 'none'; // Reset source

  // Trigger backend suggestions (debounced) on focus
  if (field === 'street' || field === 'postalCode' || field === 'city') {
    // Only run if Google suggestions aren't already active from typing
    if (suggestions.value.length === 0) {
      backendDebouncer.run(() => fetchBackendSuggestions(field));
    }
  }
};

const selectSuggestion = (suggestion) => {
  if (!suggestion) return;

  const source = activeSuggestionSource.value;

  if (source === 'google') {
    // Google suggestion selected (full object)
    emitUpdate('street', suggestion.street || addressModelValue.value.street || '');
    emitUpdate('houseNumber', suggestion.houseNumber || addressModelValue.value.houseNumber || null);
    emitUpdate('postalCode', suggestion.postalCode || addressModelValue.value.postalCode || '');
    emitUpdate('city', suggestion.city || addressModelValue.value.city || '');
    emitUpdate('country', suggestion.countryCode || addressModelValue.value.country || 'PL');
    emitUpdate('latitude', suggestion.latitude);
    emitUpdate('longitude', suggestion.longitude);

    if (localPlacesAdapter.value) {
      localPlacesAdapter.value.session.renew();
    }
  } else if (source === 'backend') {
    // Backend suggestion selected (AddressLookupSuggestionDTO)
    const field = activeField.value; // Field that was focused
    emitUpdate(field, suggestion.value);
    if (suggestion.latitude != null) emitUpdate('latitude', suggestion.latitude);
    if (suggestion.longitude != null) emitUpdate('longitude', suggestion.longitude);

    // Auto-fetch related fields
    nextTick(() => {
      if (field === 'postalCode') {
        fetchCitySuggestions();
        fetchStreetSuggestions();
      } else if (field === 'city') {
        fetchPostalCodeSuggestions();
      } else if (field === 'street') {
        fetchPostalCodeSuggestions();
      }
    });
  }

  hideSuggestions();
};

const hideSuggestions = () => {
  setTimeout(() => {
    showSuggestions.value = false;
    activeField.value = null;
    activeSuggestionSource.value = 'none';
    activeSuggestionIndex.value = -1;
    suggestions.value = [];
    suggestionsError.value = null;
  }, 150); // Delay closing dropdown
};

const formatSuggestion = (s) => {
  // Google Places suggestion
  if (s.providerSource === 'GOOGLE_PLACES') {
    if (s.fullAddressLabel) return s.fullAddressLabel;
    const parts = [s.street, s.houseNumber, s.postalCode, s.city, s.countryCode].filter(Boolean);
    return parts.join(', ') || 'Suggestion';
  }
  // Backend suggestion (AddressLookupSuggestionDTO)
  return s.value;
};

// --- Keyboard Navigation ---
const handleKeydown = (event) => {
  if (!showSuggestions.value) return;

  const currentList = suggestions.value;
  if (currentList.length === 0 && !suggestionsLoading.value) return;

  if (event.key === 'ArrowDown') {
    event.preventDefault();
    activeSuggestionIndex.value = (activeSuggestionIndex.value + 1) % currentList.length;
  } else if (event.key === 'ArrowUp') {
    event.preventDefault();
    activeSuggestionIndex.value = (activeSuggestionIndex.value - 1 + currentList.length) % currentList.length;
  } else if (event.key === 'Enter') {
    event.preventDefault();
    if (activeSuggestionIndex.value >= 0 && currentList[activeSuggestionIndex.value]) {
      selectSuggestion(currentList[activeSuggestionIndex.value]);
    }
  } else if (event.key === 'Escape') {
    event.preventDefault();
    hideSuggestions();
  }
};

onUnmounted(() => {
  placesDebouncer.cancel();
  backendDebouncer.cancel();
});
</script>

<style scoped>
.address-form {
  margin-top: 15px;
}
.form-grid {
  display: grid;
  /* Flexible columns, min 200px, max 1fr */
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 12px 18px; /* Increased gap */
}
/* Style the alias field separately */
.alias-group {
  /* Span full width */
  grid-column: 1 / -1;
}
.alias-group input {
  background-color: #f4f4f4; /* Disabled appearance */
  color: #333;
  font-weight: bold;
  cursor: not-allowed;
}

.form-group {
  display: flex;
  flex-direction: column;
  position: relative;
}
.form-group label {
  margin-bottom: 5px;
  font-size: 0.9em;
  color: #333;
  font-weight: 600;
}
.form-group input {
  padding: 10px 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 1em;
  position: relative;
  z-index: 2;
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
}
.form-group input:focus {
  z-index: 11;
  border-color: #007bff;
  box-shadow: 0 0 0 3px rgba(0,123,255,.25);
  outline: none;
}

.form-group.coords input {
  font-size: 0.9em;
  color: #495057;
}

/* Suggestions Dropdown */
.suggestions-dropdown {
  position: absolute;
  top: 100%; /* Position below the input */
  left: 0;
  right: 0;
  background-color: white;
  border: 1px solid #007bff; /* Match focus color */
  border-top: none;
  border-radius: 0 0 5px 5px;
  max-height: 180px; /* Taller list */
  overflow-y: auto;
  list-style: none;
  margin: 0;
  padding: 4px 0; /* Padding top/bottom */
  z-index: 10;
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  /* Floating effect */
  margin-top: -1px; /* Overlap input border */
}
.suggestions-dropdown li {
  padding: 10px 14px;
  cursor: pointer;
  font-size: 0.95em;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.suggestions-dropdown li:hover,
.suggestions-dropdown li.active { /* Style for active item */
  background-color: #007bff;
  color: white;
}
.suggestions-dropdown li.loading-item,
.suggestions-dropdown li.error-item,
.suggestions-dropdown li.no-results-item {
  font-style: italic;
  color: #6c757d;
  cursor: default;
  background-color: #f8f9fa;
  padding: 10px 14px;
}
.suggestions-dropdown li.error-item {
  color: #dc3545;
}


.suggestion-error {
  font-size: 0.8em;
  color: #dc3545;
  margin-top: 4px;
  padding: 4px 6px;
  border-radius: 3px;
  background-color: #f8d7da;
  border: 1px solid #f5c6cb;
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  z-index: 9;
  border-radius: 0 0 4px 4px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  margin-top: -1px;
}
.suggestion-error.context-error {
  color: #856404;
  background-color: #fff3cd;
  border: 1px solid #ffeeba;
}
</style>

================================================================================
### PLIK: components/AddressSuggestionCard.vue
================================================================================

<script setup>
import { AddressFormatterService } from "@/services/AddressFormatterService.js";
import { computed } from 'vue';

const props = defineProps({
  title: String,
  suggestions: Array
});

const emit = defineEmits(['accept']);

const formatter = new AddressFormatterService();

const formattedSuggestions = computed(() => {
  return (props.suggestions || []).map(s => ({
    ...s,
    display: s.fullAddressLabel || formatter.oneLine(s)
  }));
});
</script>

<template>
  <div class="bg-white p-4 rounded-lg shadow-sm border border-gray-200 space-y-3">
    <h3 class="text-lg font-semibold text-gray-800">{{ title }} ({{ (suggestions || []).length }})</h3>

    <div v-if="(suggestions || []).length === 0" class="text-sm text-gray-500 italic">
      No suggestions available.
    </div>

    <div v-else class="space-y-2">
      <div v-for="(suggestion, index) in formattedSuggestions" :key="index"
           class="p-3 border rounded-lg hover:bg-blue-50 cursor-pointer transition flex justify-between items-center"
           @click="emit('accept', index)">
        <div class="text-sm">
          {{ suggestion.display }}
          <div class="text-xs text-gray-500 mt-1">
            Score: {{ (suggestion.matchScore * 100).toFixed(0) }}%, Source: {{ suggestion.providerSource }}
          </div>
        </div>
        <button class="text-blue-600 font-medium text-xs flex-shrink-0">
          Accept
        </button>
      </div>
    </div>
  </div>
</template>


================================================================================
### PLIK: components/Button.vue
================================================================================

<script setup>
const props = defineProps({
  label: String,
  variant: {
    type: String,
    default: 'primary'
  },
  iconLeft: String,
  iconRight: String,
  disabled: Boolean,
  to: [String, Object]
});
</script>

<template>
  <component :is="to ? 'router-link' : 'button'" :to="to"
             :disabled="disabled"
             :class="{
      'bg-blue-600 hover:bg-blue-700 text-white': variant === 'primary' && !disabled,
      'bg-gray-200 hover:bg-gray-300 text-gray-700': variant === 'secondary' && !disabled,
      'bg-red-600 hover:bg-red-700 text-white': variant === 'danger' && !disabled,
      'bg-yellow-600 hover:bg-yellow-700 text-white': variant === 'warning' && !disabled,
      'bg-gray-400 text-gray-700 cursor-not-allowed': disabled,
    }"
             class="px-4 py-2 rounded-lg font-medium transition duration-150 inline-flex items-center justify-center gap-2 text-sm"
  >
    <div v-if="iconLeft" :class="iconLeft"></div>
    {{ label }}
    <div v-if="iconRight" :class="iconRight"></div>
  </component>
</template>


================================================================================
### PLIK: components/CorrectionMap.vue
================================================================================

<!--
============================================================================
Frontend: New Map Component
FILE: src/components/CorrectionMap.vue
REASON: Converted to JavaScript, removed all TypeScript syntax.
============================================================================
-->
<template>
  <div class="bg-white dark:bg-gray-800 shadow rounded-lg p-4">
    <div ref="mapContainer" style="height: 400px; width: 100%; border-radius: 8px"></div>
    <div v-if="route" class="mt-4 text-center text-gray-700 dark:text-gray-200">
      <p>
        <strong>Distance:</strong> {{ (route.distance / 1000).toFixed(2) }} km |
        <strong>Duration:</strong> {{ (route.duration / 60).toFixed(0) }} minutes
      </p>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted, watch, nextTick } from 'vue'

// Import Leaflet. This relies on Leaflet being installed in the project.
import 'leaflet/dist/leaflet.css'
import L from 'leaflet'

// Fix for default marker icons
// @ts-ignore
import iconRetinaUrl from 'leaflet/dist/images/marker-icon-2x.png'
import iconUrl from 'leaflet/dist/images/marker-icon.png'
import shadowUrl from 'leaflet/dist/images/marker-shadow.png'

L.Icon.Default.mergeOptions({
  iconRetinaUrl: iconRetinaUrl,
  iconUrl: iconUrl,
  shadowUrl: shadowUrl
})

// Define custom icons
const pickupIcon = new L.Icon({
  iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

const deliveryIcon = new L.Icon({
  iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

const props = defineProps({
  pickup: {
    type: Object,
    required: true
  },
  delivery: {
    type: Object,
    required: true
  },
  route: {
    type: Object,
    default: null
  }
})

const mapContainer = ref(null)
const map = ref(null)
const pickupMarker = ref(null)
const deliveryMarker = ref(null)
const routeLayer = ref(null)

onMounted(() => {
  if (mapContainer.value) {
    map.value = L.map(mapContainer.value).setView([52.23, 21.01], 6) // Center on Poland

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution:
          '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map.value)

    // Wait for initial props to be available
    nextTick(() => {
      updateMarkers()
      updateRoute()
    })
  }
})

onUnmounted(() => {
  if (map.value) {
    map.value.remove()
  }
})

// --- Helper Functions ---

const updateMarkers = () => {
  if (!map.value) return

  // Pickup Marker
  if (props.pickup.latitude && props.pickup.longitude) {
    if (pickupMarker.value) {
      pickupMarker.value.setLatLng([props.pickup.latitude, props.pickup.longitude])
    } else {
      pickupMarker.value = L.marker([props.pickup.latitude, props.pickup.longitude], {
        icon: pickupIcon
      })
          .addTo(map.value)
          .bindPopup('Point A: Pickup')
    }
  }

  // Delivery Marker
  if (props.delivery.latitude && props.delivery.longitude) {
    if (deliveryMarker.value) {
      deliveryMarker.value.setLatLng([props.delivery.latitude, props.delivery.longitude])
    } else {
      deliveryMarker.value = L.marker([props.delivery.latitude, props.delivery.longitude], {
        icon: deliveryIcon
      })
          .addTo(map.value)
          .bindPopup('Point B: Delivery')
    }
  }

  fitBounds()
}

const updateRoute = () => {
  if (!map.value) return

  // Remove old route
  if (routeLayer.value) {
    map.value.removeLayer(routeLayer.value)
  }

  // Add new route
  if (props.route && props.route.geometry) {
    routeLayer.value = L.geoJSON(props.route.geometry, {
      style: {
        color: '#0055b3', // A nice blue
        weight: 5
      }
    }).addTo(map.value)
  }

  fitBounds()
}

const fitBounds = () => {
  if (!map.value) return

  const bounds = L.latLngBounds([])
  if (pickupMarker.value) {
    bounds.extend(pickupMarker.value.getLatLng())
  }
  if (deliveryMarker.value) {
    bounds.extend(deliveryMarker.value.getLatLng())
  }

  if (bounds.isValid()) {
    map.value.fitBounds(bounds, { padding: [50, 50] })
  }
}

// Watch for changes in props and update map
watch(() => props.pickup, updateMarkers, { deep: true })
watch(() => props.delivery, updateMarkers, { deep: true })
watch(() => props.route, updateRoute)
</script>


================================================================================
### PLIK: components/DiffTable.vue
================================================================================

<template>
  <div class="diff-table-component">
    <div class="diff-section">
      <h4>Pickup Differences ({{ pickupDiff?.changed || 0 }})</h4>
      <table v-if="pickupDiff?.rows?.length">
        <thead>
        <tr>
          <th>Field</th>
          <th>Before</th>
          <th>After</th>
        </tr>
        </thead>
        <tbody>
        <tr v-for="row in pickupDiff.rows" :key="row.field" :class="{ changed: row.changed }">
          <td>{{ row.label }}</td>
          <td>{{ formatValue(row.before) }}</td>
          <td>{{ formatValue(row.after) }}</td>
        </tr>
        </tbody>
      </table>
      <p v-else>No pickup diff data.</p>
    </div>

    <div class="diff-section">
      <h4>Delivery Differences ({{ deliveryDiff?.changed || 0 }})</h4>
      <table v-if="deliveryDiff?.rows?.length">
        <thead>
        <tr>
          <th>Field</th>
          <th>Before</th>
          <th>After</th>
        </tr>
        </thead>
        <tbody>
        <tr v-for="row in deliveryDiff.rows" :key="row.field" :class="{ changed: row.changed }">
          <td>{{ row.label }}</td>
          <td>{{ formatValue(row.before) }}</td>
          <td>{{ formatValue(row.after) }}</td>
        </tr>
        </tbody>
      </table>
      <p v-else>No delivery diff data.</p>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue';

const props = defineProps({
  pickupDiff: Object, // Expects { rows: [{field, label, before, after, changed}], changed: number }
  deliveryDiff: Object,
});

const formatValue = (value) => {
  if (value === null || value === undefined) return '(empty)';
  return String(value);
};

</script>

<style scoped>
.diff-table-component {
  display: flex;
  gap: 20px;
  flex-wrap: wrap;
}
.diff-section {
  flex: 1;
  min-width: 300px;
}
h4 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 1em;
  color: #555;
}
table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.9em;
}
th, td {
  border: 1px solid #eee;
  padding: 6px 8px;
  text-align: left;
  vertical-align: top;
  word-break: break-word;
}
th {
  background-color: #f8f8f8;
}
tr.changed td {
  background-color: #fff3cd; /* Highlight changed rows */
  font-weight: bold;
}
td:first-child { /* Field name */
  font-style: italic;
  color: #666;
  width: 100px; /* Fixed width for field names */
}
p {
  font-style: italic;
  color: #888;
}
</style>

================================================================================
### PLIK: components/ErrorBanner.vue
================================================================================

<script setup>
import { ErrorBannerViewModel } from "@/viewmodels/ErrorBannerViewModel.js";
import { computed } from 'vue';

const props = defineProps({
  error: [String, Object, Error],
  class: String
});

const viewModel = computed(() => {
  if (!props.error) return null;
  return new ErrorBannerViewModel(props.error).toObject();
});
</script>

<template>
  <div v-if="viewModel" :class="props.class" class="bg-red-100 border border-red-400 text-red-700 p-4 rounded-lg flex items-center">
    <span class="font-bold mr-2">Error: {{ viewModel.title }}</span>
    <span class="text-sm">{{ viewModel.detail }}</span>
  </div>
</template>


================================================================================
### PLIK: components/ErrorDetailsModal.vue
================================================================================

<template>
  <BaseModal :is-open="isOpen" @close="$emit('close')">
    <template #header>
      Szczegóły błędu: {{ error?.id }}
    </template>
    
    <template #body>
      <div class="address-verification-section mt-4 pt-4 border-t">
        <h4 class="text-lg font-semibold mb-3">Weryfikacja Adresu</h4>
        
        <div v-if="state.status === 'IDLE'">
          <p class="text-sm text-gray-600 mb-4">Adres w zleceniu może być niepoprawny. Rozpocznij weryfikację, aby pobrać sugestie.</p>
          <button @click="startVerification" :disabled="state.isLoading" class="w-full bg-indigo-600 text-white py-2 rounded-md hover:bg-indigo-700 disabled:bg-indigo-300">
            Rozpocznij weryfikację
          </button>
        </div>
        
        <div v-if="state.isLoading" class="text-center p-4">
          <p>Weryfikowanie adresu... To może potrwać chwilę.</p>
        </div>

        <div v-if="state.error" class="p-3 bg-red-100 text-red-700 rounded-md">
          <p><b>Błąd:</b> {{ state.error }}</p>
          <button @click="startVerification" class="mt-2 text-sm font-bold">Spróbuj ponownie</button>
        </div>

        <div v-if="state.status === 'COMPLETED'">
          <div v-if="state.suggestions.length > 0">
            <h5 class="font-semibold mb-2">Wybierz poprawny adres:</h5>
            <ul>
              <li v-for="(suggestion, index) in state.suggestions" :key="index" @click="selectedSuggestion = suggestion"
                  :class="{'bg-indigo-100': selectedSuggestion === suggestion}"
                  class="p-2 cursor-pointer hover:bg-gray-100 rounded">
                {{ suggestion.fullAddressLabel }}
              </li>
            </ul>
            <button @click="submitCorrection" :disabled="!selectedSuggestion || state.isSubmitting" class="w-full bg-green-600 text-white py-2 rounded-md mt-4 hover:bg-green-700 disabled:bg-green-300">
              Zatwierdź i zaktualizuj zlecenie
            </button>
          </div>
          <div v-else class="text-center p-4 bg-gray-50 rounded-md">
            <p>Nie znaleziono sugestii dla podanego adresu.</p>
          </div>
        </div>
      </div>
    </template>
  </BaseModal>
</template>

<script setup>
import { ref, reactive, onUnmounted, watch } from 'vue';
import apiClient from '@/services/api';
import BaseModal from '@/components/Shared/BaseModal.vue'; // Przykładowy komponent modala

const props = defineProps({
  error: { type: Object, default: null },
  isOpen: { type: Boolean, required: true },
});
const emit = defineEmits(['close', 'correction-success']);

const state = reactive({
  status: 'IDLE', // IDLE, PENDING, COMPLETED, FAILED
  isLoading: false, isSubmitting: false, error: null, jobId: null, suggestions: [],
});
const selectedSuggestion = ref(null);
let pollingInterval = null;

const resetState = () => {
  stopPolling();
  Object.assign(state, { status: 'IDLE', isLoading: false, isSubmitting: false, error: null, jobId: null, suggestions: [] });
  selectedSuggestion.value = null;
};

// Resetuj stan za każdym razem, gdy modal jest otwierany z nowym błędem
watch(() => props.error, (newError) => {
  if (newError) resetState();
});

const startVerification = async () => {
  if (!props.error?.order?.id) return;
  resetState();
  state.isLoading = true;
  try {
    const response = await apiClient.post(`/api/address-verification/start/${props.error.order.id}`);
    state.jobId = response.data.verificationJobId;
    state.status = 'PENDING';
    startPolling();
  } catch (err) {
    state.error = 'Nie udało się rozpocząć procesu weryfikacji.';
    state.isLoading = false;
  }
};

const startPolling = () => {
  pollingInterval = setInterval(async () => {
    try {
      const response = await apiClient.get(`/api/address-verification/status/${state.jobId}`);
      const { status, suggestions } = response.data;
      if (status === 'COMPLETED' || status === 'FAILED') {
        stopPolling();
        state.isLoading = false;
        state.status = status;
        state.suggestions = status === 'COMPLETED' ? (suggestions || []) : [];
        if (status === 'FAILED') state.error = 'Weryfikacja adresu nie powiodła się.';
      }
    } catch (err) {
      stopPolling();
      state.isLoading = false;
      state.error = 'Błąd podczas sprawdzania statusu weryfikacji.';
    }
  }, 3000);
};

const stopPolling = () => clearInterval(pollingInterval);

const submitCorrection = async () => {
  if (!selectedSuggestion.value || !props.error?.order?.id) return;
  state.isSubmitting = true;
  try {
    await apiClient.put(`/api/orders/${props.error.order.id}/address`, selectedSuggestion.value);
    emit('correction-success');
    emit('close');
  } catch (err) {
    state.error = 'Nie udało się zaktualizować zlecenia.';
  } finally {
    state.isSubmitting = false;
  }
};

onUnmounted(stopPolling);
</script>

================================================================================
### PLIK: components/FormInput.vue
================================================================================

<template>
  <div>
    <label :for="id" class="block text-sm font-medium leading-6 text-gray-900 dark:text-gray-100">{{ label }}</label>
    <div class="mt-2">
      <input
          :type="type"
          :name="id"
          :id="id"
          :value="modelValue"
          @input="$emit('update:modelValue', $event.target.value)"
          :disabled="disabled"
          :step="step"
          class="block w-full rounded-md border-0 py-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-blue-600 sm:text-sm sm:leading-6 dark:bg-gray-700 dark:text-gray-100 dark:ring-gray-600 dark:focus:ring-blue-500"
          :class="{ 'disabled:opacity-50 disabled:bg-gray-100 dark:disabled:bg-gray-700/50': disabled }"
      />
    </div>
  </div>
</template>

<script setup>
defineProps({
  modelValue: [String, Number],
  label: String,
  id: String,
  type: {
    type: String,
    default: 'text'
  },
  disabled: {
    type: Boolean,
    default: false
  },
  step: {
    type: String,
    default: 'any'
  }
});
defineEmits(['update:modelValue']);
</script>

================================================================================
### PLIK: components/Icon.vue
================================================================================

<script setup>
// This component simply exports strings representing the class names for icons
const Icon = {
  ArrowLeft: 'i-heroicons-arrow-left-20-solid',
  ArrowRight: 'i-heroicons-arrow-right-20-solid',
  RefreshCw: 'i-heroicons-arrow-path-20-solid',
  Undo2: 'i-heroicons-arrow-uturn-left-20-solid',
  Redo2: 'i-heroicons-arrow-uturn-right-20-solid',
  // Add other icons as needed
};
</script>


================================================================================
### PLIK: components/OrderMetadataCard.vue
================================================================================

<script setup>
const props = defineProps({
  detail: Object
});
</script>

<template>
  <div v-if="detail" class="bg-white p-4 rounded-lg shadow-sm border border-gray-200">
    <h3 class="text-xs font-semibold text-gray-500 uppercase mb-2">Order Details</h3>
    <div class="grid grid-cols-3 gap-y-1 text-sm">
      <div class="font-medium text-gray-700">Barcode:</div>
      <div>{{ detail.barcode }}</div>
      <div></div>

      <div class="font-medium text-gray-700">Customer ID:</div>
      <div>{{ detail.customerId }}</div>
      <div></div>

      <div class="font-medium text-gray-700">Request ID:</div>
      <div>{{ detail.requestId }}</div>
      <div></div>
    </div>
  </div>
</template>


================================================================================
### PLIK: components/PageHeader.vue
================================================================================

<template>
  <div class="border-b border-gray-200 dark:border-gray-700 pb-5">
    <div class="flex flex-col md:flex-row md:items-center md:justify-between">
      <h2 class="text-2xl font-bold leading-7 text-gray-900 dark:text-gray-100 sm:truncate sm:tracking-tight">
        {{ title }}
      </h2>
      <div class="mt-3 flex md:ml-4 md:mt-0">
        <slot name="actions"></slot>
      </div>
    </div>
    <p v-if="subtitle" class="mt-1 text-sm text-gray-500 dark:text-gray-400">
      {{ subtitle }}
    </p>
  </div>
</template>

<script setup lang="ts">
defineProps({
  title: {
    type: String,
    required: true
  },
  subtitle: {
    type: String,
    default: ''
  }
})
</script>

================================================================================
### PLIK: components/Sidebar.vue
================================================================================

<template>
  <aside
    class="fixed inset-y-0 left-0 z-40 flex flex-col bg-slate-800 text-slate-100 transition-all duration-300 ease-in-out print:hidden"
    :class="isOpen ? 'w-64' : 'w-16 items-center'"
  >
    <div class="flex items-center justify-center h-16 flex-shrink-0 border-b border-slate-700">
      <router-link to="/dashboard" class="flex items-center justify-center">
        <div v-if="isOpen" class="text-xl font-bold text-white tracking-wider">DANXILS</div>
        <div v-else class="text-xl font-bold text-white">DX</div>
      </router-link>
    </div>

    <nav class="flex-1 overflow-y-auto overflow-x-hidden">
      <ul class="flex flex-col py-4 space-y-1">
        <li>
          <router-link to="/dashboard" class="flex items-center py-2 px-4 space-x-3 rounded-md text-slate-200 hover:bg-slate-700 hover:text-white transition-colors duration-200">
            <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"/></svg>
            <span :class="textClasses">Dashboard</span>
          </router-link>
        </li>
        <li>
          <router-link to="/order-statuses" class="flex items-center py-2 px-4 space-x-3 rounded-md text-slate-200 hover:bg-slate-700 hover:text-white transition-colors duration-200">
            <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4" /></svg>
            <span :class="textClasses">Order Statuses</span>
          </router-link>
        </li>

        <template v-if="authStore.isAdmin">
          <li class="px-4 pt-4 pb-2">
            <span :class="isOpen ? 'text-xs font-semibold text-slate-400 uppercase' : 'hidden'">
              Administration
            </span>
          </li>
          <li>
            <router-link to="/hub-invoicing-rules" class="flex items-center py-2 px-4 space-x-3 rounded-md text-slate-200 hover:bg-slate-700 hover:text-white transition-colors duration-200">
              <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 9V7a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2m2 4h10a2 2 0 002-2v-6a2 2 0 00-2-2H9a2 2 0 00-2 2v6a2 2 0 002 2zm7-5a2 2 0 11-4 0 2 2 0 014 0z" /></svg>
              <span :class="textClasses">HUB Invoicing Rules</span>
            </router-link>
          </li>
          <li>
            <router-link to="/client-invoicing-rules" class="flex items-center py-2 px-4 space-x-3 rounded-md text-slate-200 hover:bg-slate-700 hover:text-white transition-colors duration-200">
              <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" /></svg>
              <span :class="textClasses">Client Invoicing Rules</span>
            </router-link>
          </li>
          <li>
            <router-link to="/rejected-requests" class="flex items-center py-2 px-4 space-x-3 rounded-md text-slate-200 hover:bg-slate-700 hover:text-white transition-colors duration-200">
             <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636" /></svg>
              <span :class="textClasses">Rejected Requests</span>
            </router-link>
          </li>
        </template>
        
      </ul>
    </nav>

    <div class="flex-shrink-0 border-t border-slate-700">
      <router-link to="/change-password" class="flex items-center py-2 px-4 space-x-3 rounded-md text-slate-200 hover:bg-slate-700 hover:text-white transition-colors duration-200">
        <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 7a2 2 0 012 2m4 0a6 6 0 01-7.743 5.743L11 17H9v2H7v2H5v-2H3v-2H1v-4a6 6 0 0110.257-4.95zM15 7a2 2 0 00-2-2H9a2 2 0 00-2 2" /></svg>
        <span :class="textClasses">Change Password</span>
      </router-link>
    </div>
  </aside>
</template>

<script setup>
import { computed } from 'vue';
import { useAuthStore } from '@/stores/authStore';

const props = defineProps({
  isOpen: {
    type: Boolean,
    required: true,
  },
});

const authStore = useAuthStore();

const textClasses = computed(() => {
  return props.isOpen ? 'opacity-100 transition-opacity duration-200' : 'opacity-0 w-0 h-0';
});
</script>

<style>
/* Add these styles to your main CSS file, e.g., main.css, to style the active link */
.router-link-exact-active {
  @apply bg-slate-900 text-white;
}
</style>

================================================================================
### PLIK: components/SidebarLink.vue
================================================================================

<template>
  <router-link
    :to="to"
    custom
    v-slot="{ href, navigate, isActive, isExactActive }"
  >
    <a
      :href="href"
      @click="navigate"
      class="flex items-center px-2 py-2.5 text-sm font-medium rounded-md group transition-colors"
      :class="[
        (isActive || isExactActive) ? 'bg-indigo-600 text-white shadow-lg' : 'text-slate-300 hover:bg-slate-700 hover:text-white',
        { 'justify-center': !isOpen }
      ]"
      :title="isOpen ? '' : $slots.default()[0].children"
    >
      <component
        :is="getIcon(iconClass)"
        class="flex-shrink-0 h-5 w-5 group-hover:text-white transition-colors"
        :class="[(isActive || isExactActive) ? 'text-white' : 'text-slate-400 group-hover:text-slate-300', isOpen ? 'mr-3' : 'mx-auto']"
        aria-hidden="true"
      />
      <span v-if="isOpen" class="truncate"><slot></slot></span>
    </a>
  </router-link>
</template>

<script setup>
import { defineAsyncComponent } from 'vue';

const props = defineProps({
  to: {
    type: [String, Object],
    required: true,
  },
  iconClass: {
    type: String,
    required: true,
  },
  isOpen: {
    type: Boolean,
    default: true,
  }
});

const getIcon = (iconName) => {
  const icons = {
    'home': () => import('@heroicons/vue/24/outline/HomeIcon'),
    'exclamation-triangle': () => import('@heroicons/vue/24/outline/ExclamationTriangleIcon'),
    'key': () => import('@heroicons/vue/24/outline/KeyIcon'),
    'list-ul': () => import('@heroicons/vue/24/outline/ListBulletIcon'),
  };
  return defineAsyncComponent(icons[iconName] || icons['home']);
};
</script>

================================================================================
### PLIK: components/StatusExport.vue
================================================================================

<template>
  <div class="bg-white p-6 rounded-xl shadow-lg">
    <h2 class="text-xl font-bold text-slate-800 mb-4">Eksport Statusów Zamówień</h2>
    <p class="text-sm text-slate-600 mb-4">
      Pliki ze statusami generowane są automatycznie co 15 minut. Kliknij przycisk poniżej, aby pobrać ostatnio wygenerowany plik.
    </p>
    <div v-if="lastFileInfo.fileName" class="text-xs text-gray-500 mb-4">
      Ostatni plik: <span class="font-mono bg-gray-200 p-1 rounded">{{ lastFileInfo.fileName }}</span>
    </div>

    <button @click="downloadFile" :disabled="isLoading" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition-colors flex items-center disabled:opacity-50">
      <svg v-if="!isLoading" class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
      <svg v-else class="animate-spin h-5 w-5 mr-2 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
      {{ isLoading ? 'Pobieranie...' : 'Pobierz Plik ze Statusami' }}
    </button>
    <p v-if="errorMessage" class="text-red-500 text-sm mt-2">{{ errorMessage }}</p>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import apiClient from '@/services/api.js';

const isLoading = ref(false);
const errorMessage = ref('');
const lastFileInfo = ref({ fileName: null, content: '' });

const downloadFile = async () => {
  isLoading.value = true;
  errorMessage.value = '';
  try {
    const response = await apiClient.get('/api/status-export/latest');
    const { fileName, content } = response.data;
    
    lastFileInfo.value = { fileName, content };

    if (!content || content.includes("Brak wygenerowanych statusów")) {
        errorMessage.value = "Brak dostępnych plików do pobrania. Poczekaj na następny cykl generowania.";
        return;
    }

    const blob = new Blob([content], { type: 'application/json;charset=utf-8;' });
    const link = document.createElement('a');
    if (link.download !== undefined) {
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', fileName);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  } catch (error) {
    console.error('Błąd podczas pobierania pliku statusów:', error);
    errorMessage.value = 'Nie udało się pobrać pliku. Sprawdź konsolę, aby uzyskać więcej informacji.';
  } finally {
    isLoading.value = false;
  }
};
</script>

================================================================================
### PLIK: components/SuggestionList.vue
================================================================================

<template>
  <div class="suggestion-list">
    <h3 v-if="title">{{ title }}</h3>
    <ul v-if="suggestions && suggestions.length > 0">
      <li v-for="(suggestion, index) in suggestions" :key="index">
        <p><strong>{{ suggestion.fullAddressLabel || formatSuggestion(suggestion) }}</strong></p>
        <p>Score: {{ suggestion.matchScore?.toFixed(2) || 'N/A' }}, Level: {{ suggestion.matchLevel || 'N/A' }}, Source: {{ suggestion.providerSource || 'N/A' }}</p>
        <button @click="emitAccept(index)">Accept</button>
      </li>
    </ul>
    <p v-else>No suggestions available.</p>
  </div>
</template>

<script setup>
const props = defineProps({
  title: String,
  suggestions: {
    type: Array,
    default: () => [],
  },
});

const emit = defineEmits(['accept']);

const emitAccept = (index) => {
  emit('accept', index);
};

// Helper to format suggestion if full label is missing
const formatSuggestion = (s) => {
  const parts = [
    s.street, s.houseNumber, s.postalCode, s.city, s.countryCode
  ].filter(Boolean);
  return parts.join(', ') || 'Suggestion detail';
};
</script>

<style scoped>
.suggestion-list {
  margin-top: 15px;
}
h3 {
  margin-bottom: 10px;
  font-size: 1em;
  font-weight: bold;
}
ul {
  list-style: none;
  padding: 0;
  margin: 0;
  max-height: 200px; /* Limit height */
  overflow-y: auto; /* Add scroll */
  border: 1px solid #eee;
  border-radius: 4px;
}
li {
  padding: 10px;
  border-bottom: 1px solid #eee;
}
li:last-child {
  border-bottom: none;
}
li p {
  margin: 0 0 5px 0;
  font-size: 0.9em;
}
li button {
  padding: 3px 8px;
  font-size: 0.8em;
  cursor: pointer;
  margin-top: 5px;
}
p {
  font-style: italic;
  color: #888;
}
</style>

================================================================================
### PLIK: components/forms/AddressCorrectionForm.vue
================================================================================

<template>
    <div :class="{ 'opacity-50 pointer-events-none': disabled }">
        <h4 class="font-semibold text-md text-slate-700 mb-2 flex items-center">
            {{ title }}
            <span v-if="disabled" class="ml-2 text-xs font-bold text-green-700 bg-green-100 px-2 py-0.5 rounded-full">
                Adres Istnieje w Bazie
            </span>
        </h4>
        <div class="bg-white p-4 border border-slate-200 rounded-lg space-y-3">
            
            <div>
                <label class="block text-xs font-medium text-slate-600 mb-1">Nazwa Miejsca / Firmy (wyszukaj):</label>
                <input type="text" v-model="placeSearchQuery" @input="debouncedNameSearch"
                       placeholder="np. Stadion Narodowy, Galeria Młociny..."
                       :disabled="disabled"
                       class="p-2 w-full border border-slate-300 rounded-md shadow-sm text-sm disabled:bg-slate-100" />
            </div>

            <div class="border-t border-slate-200 my-3"></div>

            <div>
                <label class="block text-xs font-medium text-slate-600 mb-1">Alias:</label>
                <input type="text" :value="addressData.alias" @input="updateField('alias', $event.target.value)"
                       :disabled="disabled"
                       class="p-2 w-full border border-slate-300 rounded-md shadow-sm text-sm disabled:bg-slate-100" />
            </div>
            <div>
                <label class="block text-xs font-medium text-slate-600 mb-1">Ulica:</label>
                <input type="text" :value="addressData.street" @input="onInput('street', $event.target.value)"
                       :disabled="disabled"
                       class="p-2 w-full border border-slate-300 rounded-md shadow-sm text-sm disabled:bg-slate-100" />
            </div>
            <div class="grid grid-cols-3 gap-3">
                <div>
                    <label class="block text-xs font-medium text-slate-600 mb-1">Nr domu:</label>
                    <input type="text" :value="addressData.houseNo" @input="onInput('houseNo', $event.target.value)"
                           :disabled="disabled"
                           class="p-2 w-full border border-slate-300 rounded-md shadow-sm text-sm disabled:bg-slate-100" />
                </div>
                <div>
                    <label class="block text-xs font-medium text-slate-600 mb-1">Kod pocztowy:</label>
                    <input type="text" :value="addressData.postalCode" @input="onInput('postalCode', $event.target.value)"
                           :disabled="disabled"
                           class="p-2 w-full border border-slate-300 rounded-md shadow-sm text-sm disabled:bg-slate-100" />
                </div>
                <div>
                    <label class="block text-xs font-medium text-slate-600 mb-1">Miasto:</label>
                    <input type="text" :value="addressData.city" @input="onInput('city', $event.target.value)"
                           :disabled="disabled"
                           class="p-2 w-full border border-slate-300 rounded-md shadow-sm text-sm disabled:bg-slate-100" />
                </div>
            </div>
            <div v-if="isLoadingSuggestions" class="text-center text-sm text-slate-500 pt-2 flex items-center justify-center">
                <div class="animate-spin rounded-full h-4 w-4 border-t-2 border-b-2 border-indigo-500 mr-2"></div>
                <span>Szukanie sugestii...</span>
            </div>
            <div v-if="suggestions.length > 0" class="border-t pt-2 mt-2">
                 <ul class="border border-slate-200 rounded-lg bg-white max-h-32 overflow-y-auto">
                    <li v-for="(suggestion, index) in suggestions" :key="index" @click="selectDynamicSuggestion(suggestion)"
                        class="p-2 border-b last:border-b-0 text-xs text-slate-600 hover:bg-indigo-50 cursor-pointer transition-colors">
                        {{ suggestion.fullAddressLabel }}
                    </li>
                </ul>
            </div>
        </div>
    </div>
</template>

<script setup>
import { ref } from 'vue';
import { fetchOnDemandSuggestions, fetchByNameSearch } from '@/services/addressSuggestionService.js';

const props = defineProps({
    title: String,
    addressData: Object,
    disabled: {
        type: Boolean,
        default: false
    }
});

const emit = defineEmits(['update']);

const suggestions = ref([]);
const isLoadingSuggestions = ref(false);
const placeSearchQuery = ref('');
let debounceTimer = null;

const updateField = (field, value) => {
    emit('update', { ...props.addressData, [field]: value });
};

const onInput = (field, value) => {
    updateField(field, value);
    
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => {
        getDynamicSuggestionsByAddress();
    }, 600);
};

const getDynamicSuggestionsByAddress = async () => {
    const query = {
        street: props.addressData.street,
        houseNumber: props.addressData.houseNo,
        postalCode: props.addressData.postalCode,
        city: props.addressData.city,
        country: 'Polska'
    };
    if (Object.values(query).every(v => !v || v.trim() === '')) {
        suggestions.value = [];
        return;
    }
    isLoadingSuggestions.value = true;
    suggestions.value = await fetchOnDemandSuggestions(query);
    isLoadingSuggestions.value = false;
};

const getDynamicSuggestionsByName = async () => {
    isLoadingSuggestions.value = true;
    suggestions.value = await fetchByNameSearch(placeSearchQuery.value);
    isLoadingSuggestions.value = false;
};

const debouncedNameSearch = () => {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(getDynamicSuggestionsByName, 600);
};

const selectDynamicSuggestion = (suggestion) => {
    emit('update', {
        ...props.addressData,
        street: suggestion.street || '',
        houseNo: suggestion.houseNumber || '',
        postalCode: suggestion.postalCode || '',
        city: suggestion.city || '',
    });
    suggestions.value = [];
    placeSearchQuery.value = suggestion.fullAddressLabel;
};
</script>


================================================================================
### PLIK: components/layout/SidebarNav.vue
================================================================================

<script setup>
import { computed } from 'vue';
import { useAuthStore } from '@/stores/authStore';

const authStore = useAuthStore();
const user = computed(() => authStore.user);
const isAdmin = computed(() => user.value?.roles?.includes('ADMIN'));

</script>

<template>
  <aside class="sidebar-nav">
    <nav>
      <ul>
        <li><router-link to="/dashboard"><i class="icon icon-dashboard"></i> Dashboard</router-link></li>
        <li><router-link to="/worklist"><i class="icon icon-list"></i> Worklist</router-link></li>
        <li v-if="isAdmin"><router-link to="/admin/logs"><i class="icon icon-file-text"></i> Logs</router-link></li>
        <li v-if="isAdmin"><router-link to="/admin/aed-sftp"><i class="icon icon-server"></i> AED SFTP</router-link></li>
      </ul>
    </nav>
  </aside>
</template>

<style scoped>
.sidebar-nav {
  width: 240px;
  background-color: #f8f9fa; /* Light background for sidebar */
  border-right: 1px solid var(--color-border);
  padding: calc(var(--spacing-unit) * 2);
  height: calc(100vh - 60px); /* Full height minus header */
  position: sticky; /* Make sidebar stick */
  top: 60px; /* Position below header */
  overflow-y: auto; /* Allow scrolling if content overflows */
  flex-shrink: 0; /* Prevent sidebar from shrinking */
}

nav ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

nav li {
  margin-bottom: var(--spacing-unit);
}

nav a {
  display: flex;
  align-items: center;
  padding: calc(var(--spacing-unit)) calc(var(--spacing-unit) * 1.5);
  border-radius: 4px;
  color: var(--color-text);
  text-decoration: none;
  transition: background-color 0.2s ease, color 0.2s ease;
}

nav a i {
  margin-right: var(--spacing-unit);
  /* Basic icon styling - replace with actual icon font/SVG setup */
  display: inline-block;
  width: 16px;
  height: 16px;
  /* background: gray; */ /* Placeholder */
}

nav a:hover {
  background-color: var(--color-border);
}

nav a.router-link-exact-active {
  background-color: var(--color-primary);
  color: white;
  font-weight: 500;
}
/* Basic icon placeholders - you'll need an icon library like Feather Icons */
.icon-dashboard::before { content: '📊'; }
.icon-list::before { content: '📋'; }
.icon-file-text::before { content: '📄'; }
.icon-server::before { content: '☁️'; }


</style>

================================================================================
### PLIK: components/modals/ErrorDetailsModal.vue
================================================================================

<template>
  <div class="error-details-modal">
    <div class="address-verification-section">
      <h4>Weryfikacja Adresu</h4>

      <div v-if="verificationState.status === 'IDLE'">
        <p>Adres w tym zleceniu wygląda na niepoprawny. Rozpocznij weryfikację, aby uzyskać sugestie.</p>
        <button @click="handleStartVerification" :disabled="verificationState.isLoading">
          Rozpocznij weryfikację
        </button>
      </div>
      
      <div v-if="verificationState.isLoading">
        <p>Weryfikowanie adresu... <span class="spinner"></span></p>
        <p>To może potrwać chwilę.</p>
      </div>

      <div v-if="verificationState.error" class="error-message">
        <p>Wystąpił błąd podczas weryfikacji: {{ verificationState.error }}</p>
        <button @click="handleStartVerification">Spróbuj ponownie</button>
      </div>

      <div v-if="verificationState.status === 'COMPLETED' && verificationState.suggestions.length > 0">
        <h5>Wybierz poprawny adres:</h5>
        <ul>
          <li 
            v-for="(suggestion, index) in verificationState.suggestions" 
            :key="index"
            @click="selectSuggestion(suggestion)"
            :class="{ selected: selectedSuggestion === suggestion }">
            {{ suggestion.fullAddressLabel }}
          </li>
        </ul>
        <button @click="submitCorrection" :disabled="!selectedSuggestion">
          Zatwierdź i zaktualizuj zlecenie
        </button>
      </div>
      
      <div v-if="verificationState.status === 'COMPLETED' && verificationState.suggestions.length === 0">
        <p>Nie znaleziono sugestii dla podanego adresu.</p>
      </div>
    </div>

    </div>
</template>

<script setup>
import { ref, reactive } from 'vue';
import api from '@/services/api'; // Import naszego klienta API

// Props, np. ID zlecenia
const props = defineProps({
  orderId: {
    type: String,
    required: true,
  },
});

// Reaktywny stan do zarządzania procesem weryfikacji
const verificationState = reactive({
  status: 'IDLE', // IDLE, PENDING, COMPLETED, FAILED
  isLoading: false,
  error: null,
  jobId: null,
  suggestions: [],
});

const selectedSuggestion = ref(null);
let pollingInterval = null;

// --- GŁÓWNA LOGIKA ---

const handleStartVerification = async () => {
  resetState();
  verificationState.isLoading = true;
  
  try {
    const response = await api.startAddressVerification(props.orderId);
    verificationState.jobId = response.data.verificationJobId;
    verificationState.status = 'PENDING';
    startPolling();
  } catch (err) {
    verificationState.error = 'Nie udało się rozpocząć procesu weryfikacji.';
    verificationState.isLoading = false;
  }
};

const startPolling = () => {
  // Ustawiamy interwał - odpytujemy co 2 sekundy
  pollingInterval = setInterval(async () => {
    try {
      const response = await api.getVerificationStatus(verificationState.jobId);
      const { status, suggestions } = response.data;

      // Jeśli zadanie jest zakończone, przerywamy polling i aktualizujemy stan
      if (status === 'COMPLETED' || status === 'FAILED') {
        stopPolling();
        verificationState.isLoading = false;
        verificationState.status = status;
        
        if (status === 'COMPLETED') {
          verificationState.suggestions = suggestions || [];
        } else {
          verificationState.error = 'Weryfikacja adresu nie powiodła się po stronie serwera.';
        }
      }
      // Jeśli status to wciąż PENDING, nic nie robimy, czekamy na kolejny cykl
    } catch (err) {
      stopPolling();
      verificationState.isLoading = false;
      verificationState.error = 'Błąd podczas sprawdzania statusu weryfikacji.';
    }
  }, 2000); // 2000 ms = 2 sekundy

  // Zabezpieczenie: przerywamy polling po 30 sekundach, aby uniknąć nieskończonej pętli
  setTimeout(() => {
    if (pollingInterval) {
        stopPolling();
        verificationState.isLoading = false;
        verificationState.error = 'Przekroczono limit czasu oczekiwania na odpowiedź.';
    }
  }, 30000); // 30s timeout
};

const stopPolling = () => {
  clearInterval(pollingInterval);
  pollingInterval = null;
};

const selectSuggestion = (suggestion) => {
  selectedSuggestion.value = suggestion;
};

const submitCorrection = async () => {
  if (!selectedSuggestion.value) return;
  verificationState.isLoading = true;
  
  try {
    await api.submitAddressCorrection(props.orderId, selectedSuggestion.value);
    // Tutaj można wyemitować zdarzenie do rodzica, aby zamknąć modal i odświeżyć listę
    // emit('address-corrected');
    alert('Adres został pomyślnie zaktualizowany!');
    resetState();
  } catch (err) {
    verificationState.error = 'Nie udało się zaktualizować zlecenia.';
  } finally {
    verificationState.isLoading = false;
  }
};

const resetState = () => {
    stopPolling();
    verificationState.status = 'IDLE';
    verificationState.isLoading = false;
    verificationState.error = null;
    verificationState.jobId = null;
    verificationState.suggestions = [];
    selectedSuggestion.value = null;
};

</script>

<style scoped>
/* Dodaj style dla feedbacku wizualnego */
.spinner {
  /* Prosty spinner CSS */
  display: inline-block;
  border: 4px solid rgba(0,0,0,.1);
  border-left-color: #7983ff;
  border-radius: 50%;
  width: 16px;
  height: 16px;
  animation: spin 1s linear infinite;
}
@keyframes spin {
  to { transform: rotate(360deg); }
}
.error-message { color: red; }
ul li { cursor: pointer; padding: 5px; margin: 2px 0; }
ul li.selected { background-color: #e0e0ff; }
</style>

================================================================================
### PLIK: components/common/ActionButton.vue
================================================================================

<script setup>
defineProps({
  label: String,
  disabled: Boolean,
  title: String
});
defineEmits(['click']);
</script>

<template>
  <button
      :disabled="disabled"
      :title="title"
      @click="$emit('click')"
  >
    {{ label }}
  </button>
</template>

<style scoped>
/* Inherits .button and .button.secondary styles from theme.css */
button {
  /* Ensure it picks up the base .button class styles */
  display: inline-block;
  padding: calc(var(--spacing-unit) * 1.5) calc(var(--spacing-unit) * 3);
  background-color: var(--color-primary);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  text-align: center;
  transition: background-color 0.2s ease;
}
button:hover:not(:disabled) {
  background-color: #004477; /* Darker blue */
}
button.secondary {
  background-color: var(--color-secondary);
  color: var(--color-text);
}
button.secondary:hover:not(:disabled) {
  background-color: #e0a800; /* Darker yellow */
}
button:disabled {
  background-color: var(--color-border);
  color: var(--color-text-light);
  cursor: not-allowed;
}
</style>

================================================================================
### PLIK: components/common/StatusBadge.vue
================================================================================

<script setup>
import { computed } from 'vue';
import { StatusBadgeViewModel } from '@/viewmodels/StatusBadgeViewModel';

const props = defineProps({
  status: {
    type: String,
    default: 'UNKNOWN'
  }
});

const badge = computed(() => {
  return new StatusBadgeViewModel(props.status).toObject();
});
</script>

<template>
  <span class="badge" :class="badge.tone">
    {{ badge.label }}
  </span>
</template>

<style scoped>
.badge {
  display: inline-block;
  padding: calc(var(--spacing-unit) * 0.5) calc(var(--spacing-unit));
  font-size: 0.75rem;
  font-weight: 600;
  line-height: 1;
  text-align: center;
  white-space: nowrap;
  vertical-align: baseline;
  border-radius: 4px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* Tones based on theme.css variables */
.badge.success {
  background-color: var(--color-success);
  color: #fff;
}
.badge.warning {
  background-color: var(--color-warning);
  color: var(--color-text); /* Yellow needs dark text */
}
.badge.danger {
  background-color: var(--color-danger);
  color: #fff;
}
.badge.info {
  background-color: var(--color-info);
  color: #fff;
}
.badge.neutral {
  background-color: var(--color-neutral);
  color: #fff;
}
.badge.unknown {
  background-color: var(--color-border);
  color: var(--color-text-light);
}
</style>

================================================================================
### PLIK: components/editor/AddressDisplay.vue
================================================================================

<script setup>
import { computed } from 'vue';

const props = defineProps({
  title: String,
  address: Object,
  formatter: Object,
  showCoords: {
    type: Boolean,
    default: false
  }
});

const formatted = computed(() => {
  if (!props.address) return null;
  return props.formatter?.twoLines(props.address);
});
</script>

<template>
  <div class="address-display card">
    <h4>{{ title }}</h4>
    <div v-if="!address" class="address-data empty-state">
      N/A
    </div>
    <div v-else class="address-data">
      <div class="address-line">{{ formatted.line1 }}</div>
      <div class="address-line">{{ formatted.line2 }}</div>
      <div v-if="showCoords" class="coords">
        Lat: {{ address.latitude || 'N/A' }}, Lon: {{ address.longitude || 'N/A' }}
      </div>
    </div>
  </div>
</template>

<style scoped>
.address-display {
  background-color: #f8f9fa; /* Lighter background for display */
  padding: calc(var(--spacing-unit) * 1.5);
  border-radius: 4px;
}
.address-display h4 {
  margin-top: 0;
  margin-bottom: var(--spacing-unit);
  color: var(--color-text-light);
  font-size: 0.9rem;
}
.address-data {
  font-family: monospace;
  font-size: 0.9rem;
}
.address-line {
  min-height: 1.2em; /* Ensure line takes up space even if empty */
}
.empty-state {
  color: var(--color-text-light);
}
.coords {
  font-size: 0.8rem;
  color: var(--color-info);
  margin-top: var(--spacing-unit);
}
</style>

================================================================================
### PLIK: components/editor/AddressEditor.vue
================================================================================

<script setup>
import { computed } from 'vue';

const props = defineProps({
  title: String,
  address: Object, // This should be an Address object
  suggestions: {
    type: Array,
    default: () => []
  },
  loadingSuggestions: Boolean
});

const emit = defineEmits(['update:address', 'street-input', 'select-suggestion']);

// Create computed properties for v-model
const internalAddress = computed({
  get: () => props.address,
  set: (value) => {
    emit('update:address', value);
  }
});

// Emit an update for a single field
const onFieldChange = (field, value) => {
  emit('update:address', { ...internalAddress.value, [field]: value });
};

const onStreetKeydown = (event) => {
  if (event.key === 'ArrowDown' && props.suggestions.length > 0) {
    event.preventDefault();
    // TODO: Focus list
  }
}
</script>

<template>
  <div class="address-editor card">
    <h4>{{ title }}</h4>
    <div class="form-grid">

      <div class="form-group street-group">
        <label for="street">Street</label>
        <input
            type="text"
            id="street"
            :value="internalAddress.street"
            @input="onFieldChange('street', $event.target.value); $emit('street-input', $event)"
            @keydown="onStreetKeydown"
            autocomplete="off"
        />
        <div v-if="loadingSuggestions" class="suggestions-loading">Loading...</div>
        <ul v-if="suggestions.length > 0" class="suggestions-list">
          <li
              v-for="s in suggestions"
              :key="s.value"
              @mousedown.prevent="$emit('select-suggestion', s)"
          >
            {{ s.value }}
          </li>
        </ul>
      </div>

      <div class="form-group">
        <label for="houseNo">House No.</label>
        <input type="text" id="houseNo" :value="internalAddress.houseNumber" @input="onFieldChange('houseNumber', $event.target.value)" />
      </div>

      <div class="form-group">
        <label for="postalCode">Postal Code</label>
        <input type="text" id="postalCode" :value="internalAddress.postalCode" @input="onFieldChange('postalCode', $event.target.value)" />
      </div>

      <div class="form-group">
        <label for="city">City</label>
        <input type="text" id="city" :value="internalAddress.city" @input="onFieldChange('city', $event.target.value)" />
      </div>

      <div class="form-group">
        <label for="country">Country</label>
        <input type="text" id="country" :value="internalAddress.country" @input="onFieldChange('country', $event.target.value)" />
      </div>

      <div class="form-group">
        <label for="lat">Latitude</label>
        <input type="text" id="lat" :value="internalAddress.latitude" @input="onFieldChange('latitude', $event.target.value)" />
      </div>

      <div class="form-group">
        <label for="lon">Longitude</label>
        <input type="text" id="lon" :value="internalAddress.longitude" @input="onFieldChange('longitude', $event.target.value)" />
      </div>
    </div>
  </div>
</template>

<style scoped>
.address-editor {
  padding: calc(var(--spacing-unit) * 1.5);
  border: 1px solid var(--color-border);
  box-shadow: none;
}
.address-editor h4 {
  margin-top: 0;
  margin-bottom: var(--spacing-unit);
  color: var(--color-text-light);
  font-size: 0.9rem;
}

.form-grid {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: var(--spacing-unit);
}

.form-group {
  display: flex;
  flex-direction: column;
}

.form-group.street-group {
  grid-column: 1 / span 2;
  position: relative;
}

.form-group label {
  font-size: 0.8rem;
  font-weight: 500;
  margin-bottom: calc(var(--spacing-unit) * 0.5);
}

.form-group input {
  width: 100%;
  padding: var(--spacing-unit);
  border: 1px solid var(--color-border);
  border-radius: 4px;
  box-sizing: border-box; /* Important for grid layout */
}

.form-group input:disabled {
  background-color: #f0f0f0;
  color: var(--color-text-light);
}

.suggestions-loading {
  position: absolute;
  top: 100%;
  left: 0;
  width: 100%;
  background: white;
  border: 1px solid var(--color-border);
  padding: var(--spacing-unit);
  color: var(--color-text-light);
  z-index: 10;
}

.suggestions-list {
  position: absolute;
  top: 100%;
  left: 0;
  width: 100%;
  background: white;
  border: 1px solid var(--color-border);
  border-top: none;
  list-style: none;
  padding: 0;
  margin: 0;
  z-index: 10;
  max-height: 200px;
  overflow-y: auto;
}
.suggestions-list li {
  padding: var(--spacing-unit);
  cursor: pointer;
}
.suggestions-list li:hover {
  background-color: #f0f0f0;
}
</style>

================================================================================
### PLIK: layouts/DashboardLayout.vue
================================================================================

<script setup>
import { useAuthStore } from '@/stores/authStore';
import { useRouter } from 'vue-router';

const authStore = useAuthStore();
const router = useRouter();

const handleLogout = () => {
  authStore.logout();
};

// Podstawowa nawigacja na podstawie router/index.js
const adminNavLinks = [
  { name: 'Dashboard', path: '/dashboard' },
  { name: 'Change Password', path: '/dashboard/change-password' },
  { name: 'Order Statuses', path: '/dashboard/order-statuses' },
  { name: 'Rejected Requests', path: '/dashboard/rejected-requests', admin: true },
  { name: 'Status Export', path: '/dashboard/status-export', admin: true },
  { name: 'Address Providers', path: '/dashboard/admin/address-providers', admin: true },
  { name: 'Recently Added', path: '/dashboard/recently-added-addresses', admin: true },
  { name: 'Address Upload', path: '/dashboard/admin/address-upload', admin: true },
  { name: 'HUB Invoicing Rules', path: '/dashboard/hub-invoicing-rules', admin: true },
];

</script>

<template>
  <div class="flex h-screen bg-gray-100 font-sans">
    <aside class="w-64 flex-shrink-0 bg-gray-800 text-white flex flex-col">
      <div class="h-16 flex items-center justify-center text-2xl font-bold border-b border-gray-700">
        Admin Panel
      </div>
      <nav class="flex-1 px-4 py-4 space-y-2">
        <template v-for="link in adminNavLinks" :key="link.path">
            <router-link
              v-if="!link.admin || authStore.isAdmin"
              :to="link.path"
              class="flex items-center px-4 py-2 rounded-md hover:bg-gray-700 transition-colors"
              active-class="bg-gray-900"
            >
              {{ link.name }}
            </router-link>
        </template>
      </nav>
      <div class="px-4 py-4 border-t border-gray-700">
        <div class="text-sm text-gray-400 mb-2">Logged in as: <strong>{{ authStore.username }}</strong></div>
        <button
          @click="handleLogout"
          class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition-colors"
        >
          Logout
        </button>
      </div>
    </aside>

    <main class="flex-1 p-8 overflow-y-auto">
      <div class="max-w-7xl mx-auto">
        <router-view />
      </div>
    </main>
  </div>
</template>

<style scoped>
/* Scoped styles for the layout */
.router-link-exact-active {
  background-color: #1a202c; /* bg-gray-900 */
}
</style>

================================================================================
### PLIK: controllers/AddressFormController.js
================================================================================

/**
 * ARCHITECTURE: AddressFormController coordinates field masking, editability rules, guard checks, and realtime verification.
 * It follows the manifesto by isolating input lifecycle from components and wiring existing services behind one API.
 * Responsibilities:
 * - Apply masks on change, consult AddressFieldGuard for editability, and gate verification with VerificationGuardController.
 * - Invoke RealtimeVerificationOrchestrator and MapViewportPolicyController to produce instant geocode + ranked hints.
 * - Expose a stable snapshot with input, validation, instant, suggestions, and busy flags for the view.
 *
 * REFACTORED: Constructor aligned with RealtimeVerificationOrchestrator dependencies.
 * This class requires (geoRuntime, geocodeWithCacheController, mapController) to be injected.
 */
import { AddressInputMaskService } from "@/services/AddressInputMaskService";
import { AddressFieldGuard } from "@/services/AddressFieldGuard";
import { VerificationGuardController } from "@/controllers/VerificationGuardController";
import { RealtimeVerificationOrchestrator } from "@/controllers/RealtimeVerificationOrchestrator";
import { MapViewportPolicyController } from "@/controllers/MapViewportPolicyController";
import { ValidationService } from "@/services/ValidationService";
import { AddressNormalizer } from "@/services/AddressNormalizer";

export class AddressFormController {
  constructor(
      geoRuntime, // *** Injected GeoRuntime ***
      geocodeWithCacheController, // Geocode controller (uses Nominatim/Google adapter)
      mapController // Map controller (uses Leaflet/Google adapter)
  ) {
    if (!geoRuntime || !geocodeWithCacheController || !mapController) {
      const missing = [!geoRuntime && "geoRuntime", !geocodeWithCacheController && "geocodeWithCacheController", !mapController && "mapController"].filter(Boolean).join(', ');
      log.error(`[AddressFormController] CRITICAL: Missing required dependencies in constructor: ${missing}.`);
      // This controller is often instantiated by a view; throwing might be too harsh.
    }

    this.mask = new AddressInputMaskService("PL");
    this.guard = new AddressFieldGuard();
    this.verifyGuard = new VerificationGuardController();

    // *** FIX: Instantiate orchestrator with correct (geoRuntime, geocodeController, debounce) ***
    this.realtime = new RealtimeVerificationOrchestrator(
        geoRuntime,
        geocodeWithCacheController,
        300 // Debounce time
    );
    this.viewport = new MapViewportPolicyController(mapController);
    this.validator = new ValidationService("PL");
    this.normalizer = new AddressNormalizer();
    this.input = { street: "", houseNumber: "", postalCode: "", city: "", country: "PL" };
    this.validation = { valid: false, errors: {} };
    this.instant = null;
    this.suggestions = [];
    this.loading = false;
    this.error = null;
  }

  setField(field, value) {
    if (!this.guard.canEdit(field, { country: this.input.country })) return this.snapshot();

    // Apply masks (implementation is currently stubbed)
    if (field === "postalCode") this.input.postalCode = this.mask.maskPostal(value, this.input.country);
    else if (field === "street") this.input.street = this.mask.maskStreet(value);
    else if (field === "city") this.input.city = this.mask.maskCity(value);
    else if (field === "houseNumber") this.input.houseNumber = this.mask.maskHouseNo(value);
    else if (field === "country") this.input.country = String(value || "PL").toUpperCase();
    else this.input[field] = value; // Handle other fields directly

    // Trigger verification after field update (will be debounced by orchestrator)
    this.verifyIfReady(); // No await needed, runs async

    return this.snapshot(); // Return current state immediately
  }

  async verifyIfReady() {
    // Check if enough fields are present to trigger verification
    const gate = this.verifyGuard.shouldVerify(this.input);
    const currentNormalized = this.normalizer.normalize(this.input); // Normalize for validation
    this.validation = this.validator.validate(currentNormalized); // Update validation state regardless

    if (!gate.allow) {
      log.debug("[AddressForm] Verification skipped:", gate.reason, gate.missing);
      this.loading = false;
      this.error = null;
      this.instant = null; // Clear previous results if input becomes invalid
      this.suggestions = [];
      return this.snapshot(); // Return updated validation state
    }

    // Input is sufficient, trigger debounced verification
    this.loading = true;
    this.error = null;
    try {
      const res = await this.realtime.verify(this.input); // Await the debounced result
      this.instant = res.instant || null;
      this.suggestions = Array.isArray(res.suggestions) ? res.suggestions : [];

      // Focus map on the instant result if available
      if (this.instant && this.instant.latitude != null && this.instant.longitude != null && this.viewport) {
        await this.viewport.focusInstant({ ...this.instant, matchLevel: "GEOCODER" });
      }
    } catch (err) {
      log.error("[AddressForm] Realtime verification failed:", err);
      this.error = "Verification failed.";
      this.instant = null;
      this.suggestions = [];
    } finally {
      this.loading = false;
    }

    return this.snapshot();
  }

  snapshot() {
    return {
      input: { ...this.input },
      validation: { ...this.validation },
      instant: this.instant ? { ...this.instant } : null,
      suggestions: this.suggestions.slice(),
      loading: this.loading,
      error: this.error,
    };
  }
}

// Basic logger shim
const log = {
  debug: (...args) => console.debug(...args),
  warn: (...args) => console.warn(...args),
  error: (...args) => console.error(...args),
};


================================================================================
### PLIK: controllers/AddressVerificationController.js
================================================================================

/**
 * ARCHITECTURE: Coordinates address form field interactions and triggers realtime verification.
 * REFACTORED: Constructor aligned with RealtimeVerificationOrchestrator dependencies.
 * This class requires (geoRuntime, geocodeWithCacheController, mapController) to be injected.
 * NOTE: This file appears to be a duplicate of AddressFormController.js and exports
 * the same class name. Both files have been corrected to the same implementation.
 */
import { AddressInputMaskService } from "@/services/AddressInputMaskService";
import { AddressFieldGuard } from "@/services/AddressFieldGuard";
import { VerificationGuardController } from "@/controllers/VerificationGuardController";
import { RealtimeVerificationOrchestrator } from "@/controllers/RealtimeVerificationOrchestrator";
import { MapViewportPolicyController } from "@/controllers/MapViewportPolicyController";
import { ValidationService } from "@/services/ValidationService";
import { AddressNormalizer } from "@/services/AddressNormalizer";

export class AddressFormController {
    constructor(
        geoRuntime, // *** Injected GeoRuntime ***
        geocodeWithCacheController, // Geocode controller (uses Nominatim/Google adapter)
        mapController // Map controller (uses Leaflet/Google adapter)
    ) {
        if (!geoRuntime || !geocodeWithCacheController || !mapController) {
            const missing = [!geoRuntime && "geoRuntime", !geocodeWithCacheController && "geocodeWithCacheController", !mapController && "mapController"].filter(Boolean).join(', ');
            log.error(`[AddressFormController-Verification] CRITICAL: Missing required dependencies in constructor: ${missing}.`);
            // This controller is often instantiated by a view; throwing might be too harsh.
        }

        this.mask = new AddressInputMaskService("PL");
        this.guard = new AddressFieldGuard();
        this.verifyGuard = new VerificationGuardController();

        // *** FIX: Instantiate orchestrator with correct (geoRuntime, geocodeController, debounce) ***
        this.realtime = new RealtimeVerificationOrchestrator(
            geoRuntime,
            geocodeWithCacheController,
            300 // Debounce time
        );
        this.viewport = new MapViewportPolicyController(mapController);
        this.validator = new ValidationService("PL");
        this.normalizer = new AddressNormalizer();
        this.input = { street: "", houseNumber: "", postalCode: "", city: "", country: "PL" };
        this.validation = { valid: false, errors: {} };
        this.instant = null;
        this.suggestions = [];
        this.loading = false;
        this.error = null;
    }

    setField(field, value) {
        if (!this.guard.canEdit(field, { country: this.input.country })) return this.snapshot();

        if (field === "postalCode") this.input.postalCode = this.mask.maskPostal(value, this.input.country);
        else if (field === "street") this.input.street = this.mask.maskStreet(value);
        else if (field === "city") this.input.city = this.mask.maskCity(value);
        else if (field === "houseNumber") this.input.houseNumber = this.mask.maskHouseNo(value);
        else if (field === "country") this.input.country = String(value || "PL").toUpperCase();
        else this.input[field] = value;

        this.verifyIfReady(); // No await needed, runs async
        return this.snapshot(); // Return current state immediately
    }

    async verifyIfReady() {
        const gate = this.verifyGuard.shouldVerify(this.input);
        const currentNormalized = this.normalizer.normalize(this.input);
        this.validation = this.validator.validate(currentNormalized);

        if (!gate.allow) {
            log.debug("[AddressForm-Verification] Verification skipped:", gate.reason, gate.missing);
            this.loading = false;
            this.error = null;
            this.instant = null;
            this.suggestions = [];
            return this.snapshot();
        }

        this.loading = true;
        this.error = null;
        try {
            const res = await this.realtime.verify(this.input);
            this.instant = res.instant || null;
            this.suggestions = Array.isArray(res.suggestions) ? res.suggestions : [];

            if (this.instant && this.instant.latitude != null && this.instant.longitude != null && this.viewport) {
                await this.viewport.focusInstant({ ...this.instant, matchLevel: "GEOCODER" });
            }
        } catch (err) {
            log.error("[AddressForm-Verification] Realtime verification failed:", err);
            this.error = "Verification failed.";
            this.instant = null;
            this.suggestions = [];
        } finally {
            this.loading = false;
        }

        return this.snapshot();
    }

    snapshot() {
        return {
            input: { ...this.input },
            validation: { ...this.validation },
            instant: this.instant ? { ...this.instant } : null,
            suggestions: this.suggestions.slice(),
            loading: this.loading,
            error: this.error,
        };
    }
}

// Basic logger shim
const log = {
    debug: (...args) => console.debug(...args),
    warn: (...args) => console.warn(...args),
    error: (...args) => console.error(...args),
};


================================================================================
### PLIK: controllers/AddressVerificationFacade.js
================================================================================

/**
 * ARCHITECTURE: AddressVerificationFacade provides a minimal API to run Google-first verification end-to-end.
 * It follows the manifesto by composing workflow, merger, ranker, and TES suggestions behind a single call.
 * Responsibilities:
 * - Accept an Address-like DTO; return {normalized, validation, instant, suggestions} ready for the editor.
 * - Optionally enrich with TES suggestions and merge/rank them alongside Google-derived candidates.
 */
import { AddressVerificationWorkflow } from "@/controllers/AddressVerificationWorkflow";
import { TesSuggestionController } from "@/controllers/TesSuggestionController";
import { AddressSuggestionMerger } from "@/services/AddressSuggestionMerger";
import { AddressSuggestionRanker } from "@/services/AddressSuggestionRanker";

export class AddressVerificationFacade {
  constructor(googleApiKey, tes = new TesSuggestionController(), merger = new AddressSuggestionMerger(), ranker = new AddressSuggestionRanker()) {
    this.workflow = new AddressVerificationWorkflow(googleApiKey);
    this.tes = tes;
    this.merger = merger;
    this.ranker = ranker;
  }

  async verify(address) {
    const base = await this.workflow.verify(address);
    if (!base.success) return base;
    const tes = await this.tes.suggestOnDemand(base.normalized, base.normalized);
    const merged = this.merger.merge(base.normalized, [base.suggestions, tes]);
    const ranked = this.ranker.rank(base.normalized, merged);
    return { ...base, suggestions: ranked };
  }
}


================================================================================
### PLIK: controllers/AddressVerificationWorkflow.js
================================================================================

/**
 * ARCHITECTURE: AddressVerificationWorkflow runs normalize→validate→(optional)geocode to build a result model.
 * It follows the manifesto by keeping verification orchestration independent from UI and transport details.
 * Responsibilities:
 * - Normalize and validate input; if geocoder is injected, resolve coordinates as an "instant" candidate.
 * - Return {success, normalized, validation, instant, suggestions[]} without throwing on user errors.
 */
import { AddressNormalizer } from "@/services/AddressNormalizer";
import { ValidationService } from "@/services/ValidationService";

export class AddressVerificationWorkflow {
  constructor(googleApiKey = null, geocoderAdapter = null) {
    void googleApiKey;
    this.normalizer = new AddressNormalizer();
    this.validator = new ValidationService("PL");
    this.geocoder = geocoderAdapter || null;
  }

  async verify(address) {
    const normalized = this.normalizer.normalize(address);
    const validation = this.validator.validate(normalized);
    if (!validation.valid) {
      return {
        success: false,
        normalized,
        validation,
        instant: null,
        suggestions: [],
      };
    }
    let instant = null;
    if (this.geocoder && typeof this.geocoder.geocodeAddress === "function") {
      try {
        const r = await this.geocoder.geocodeAddress(normalized);
        if (r && typeof r.lat === "number" && typeof r.lon === "number") {
          instant = { latitude: r.lat, longitude: r.lon, providerSource: "GOOGLE_CLIENT", matchLevel: "GEOCODER", matchScore: 1.0 };
        }
      } catch (_) {
        instant = null;
      }
    }
    return {
      success: true,
      normalized,
      validation,
      instant,
      suggestions: [],
    };
  }
}


================================================================================
### PLIK: controllers/AppBootstrapController.js
================================================================================

// FILE: src/controllers/AppBootstrapController.js
// CORRECTED FILE
import { EnvironmentConfigService } from "@/services/EnvironmentConfigService";
import { HealthGateController } from "@/controllers/HealthGateController";
// import { IntegrationOrchestrator } from "@/controllers/IntegrationOrchestrator"; // REMOVED

/**
 * ARCHITECTURE: Controller responsible for initial application bootstrap steps.
 * Loads configuration, checks basic health, and prepares core services.
 * REFACTORED: Removed unnecessary placeholder creation of IntegrationOrchestrator.
 */
export class AppBootstrapController {
  constructor(
      cfg = new EnvironmentConfigService(),
      health = new HealthGateController()
  ) {
    this.cfg = cfg;
    this.healthCtrl = health;
  }

  async bootstrap() {
    const config = await this.cfg.load();

    const health = await this.healthCtrl.readiness(config?.GOOGLE_MAPS_API_KEY);

    // REMOVED: Unnecessary and failing placeholder instantiation:
    // const orchestrator = new IntegrationOrchestrator(null, null);

    return {
      config,
      health
      // REMOVED: orchestrator
    };
  }
}

================================================================================
### PLIK: controllers/AuthController.js
================================================================================

/**
 * ARCHITECTURE: AuthController coordinates login/logout by composing AuthApi, AuthSessionService, and ApiAuthBinder.
 * It follows the manifesto by exposing intent-driven methods and returning Result objects for views/guards.
 * Responsibilities:
 * - login(username,password): call AuthApi, persist session, bind Authorization header.
 * - logout(): clear session and unbind header.
 * - hydrateFromStorage(): reapply header on app start.
 * - snapshot(): expose {isAuthenticated,user}.
 */
import { Result } from "@/domain/Result";
import { AuthApi } from "@/services/AuthApi";
import { AuthSessionService } from "@/services/AuthSessionService";
import { ApiAuthBinder } from "@/services/ApiAuthBinder";

export class AuthController {
  constructor(api = new AuthApi(), session = new AuthSessionService(), binder = new ApiAuthBinder()) {
    this.api = api;
    this.session = session;
    this.binder = binder;
  }

  async login(username, password) {
    const r = await this.api.login(username, password);
    if (!r.ok) return Result.fail(r.error);
    this.session.save(r.value);
    this.binder.bind(r.value.accessToken, r.value.tokenType);
    return Result.ok(this.snapshot());
  }

  async logout() {
    this.session.clear();
    this.binder.unbind();
    return Result.ok(true);
  }

  hydrateFromStorage() {
    const token = this.session.getAccessToken();
    const type = this.session.getTokenType();
    if (token) this.binder.bind(token, type);
    return this.snapshot();
  }

  snapshot() {
    return {
      isAuthenticated: this.session.isAuthenticated(),
      user: this.session.getUser(),
      tokenPresent: !!this.session.getAccessToken(),
    };
  }
}


================================================================================
### PLIK: controllers/AuthController.spec.js
================================================================================

// src/controllers/AuthController.spec.js
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { AuthController } from '@/controllers/AuthController';
import { Result } from '@/domain/Result';

// Mock the dependencies (AuthApi, AuthSessionService, ApiAuthBinder)
const mockAuthApi = {
    login: vi.fn(),
};
const mockSessionService = {
    save: vi.fn(),
    clear: vi.fn(),
    isAuthenticated: vi.fn(),
    getUser: vi.fn(),
    getAccessToken: vi.fn(),
    getTokenType: vi.fn(),
};
const mockApiBinder = {
    bind: vi.fn(),
    unbind: vi.fn(),
};

describe('AuthController', () => {
    let authController;

    beforeEach(() => {
        vi.resetAllMocks();
        authController = new AuthController(mockAuthApi, mockSessionService, mockApiBinder);
    });

    describe('login', () => {
        it('should call AuthApi, save session, bind token, and return Ok Result on success', async () => {
            // Arrange
            const username = 'test';
            const password = 'pw';
            const mockSessionData = {
                accessToken: 'atoken',
                refreshToken: 'rtoken',
                tokenType: 'Bearer',
                username: username,
                roles: ['USER'],
            };
            const mockSnapshot = { isAuthenticated: true, user: { username: username, roles: ['USER'] } };
            mockAuthApi.login.mockResolvedValue(Result.ok(mockSessionData));
            // Mock snapshot call within the controller's login method
            vi.spyOn(authController, 'snapshot').mockReturnValue(mockSnapshot);

            // Act
            const result = await authController.login(username, password);

            // Assert
            expect(mockAuthApi.login).toHaveBeenCalledWith(username, password);
            expect(mockSessionService.save).toHaveBeenCalledWith(mockSessionData);
            expect(mockApiBinder.bind).toHaveBeenCalledWith(mockSessionData.accessToken, mockSessionData.tokenType);
            expect(result.ok).toBe(true);
            expect(result.value).toEqual(mockSnapshot); // Login returns the snapshot
        });

        it('should return Fail Result if AuthApi.login fails', async () => {
            // Arrange
            const username = 'test';
            const password = 'pw';
            const mockError = new Error('Invalid credentials');
            mockAuthApi.login.mockResolvedValue(Result.fail(mockError));

            // Act
            const result = await authController.login(username, password);

            // Assert
            expect(mockAuthApi.login).toHaveBeenCalledWith(username, password);
            expect(mockSessionService.save).not.toHaveBeenCalled();
            expect(mockApiBinder.bind).not.toHaveBeenCalled();
            expect(result.ok).toBe(false);
            expect(result.error).toBe(mockError);
        });
    });

    describe('logout', () => {
        it('should clear session and unbind token', async () => {
            // Act
            const result = await authController.logout();

            // Assert
            expect(mockSessionService.clear).toHaveBeenCalledTimes(1);
            expect(mockApiBinder.unbind).toHaveBeenCalledTimes(1);
            expect(result.ok).toBe(true);
        });
    });

    describe('hydrateFromStorage', () => {
        it('should bind token if found in session', () => {
            // Arrange
            mockSessionService.getAccessToken.mockReturnValue('storedToken');
            mockSessionService.getTokenType.mockReturnValue('Bearer');

            // Act
            authController.hydrateFromStorage();

            // Assert
            expect(mockApiBinder.bind).toHaveBeenCalledWith('storedToken', 'Bearer');
        });

        it('should not bind token if not found in session', () => {
            // Arrange
            mockSessionService.getAccessToken.mockReturnValue(null);

            // Act
            authController.hydrateFromStorage();

            // Assert
            expect(mockApiBinder.bind).not.toHaveBeenCalled();
        });
    });

    describe('snapshot', () => {
        it('should return current auth state from session service', () => {
            // Arrange
            mockSessionService.isAuthenticated.mockReturnValue(true);
            mockSessionService.getUser.mockReturnValue({ username: 'snapUser', roles: ['TEST']});
            mockSessionService.getAccessToken.mockReturnValue('snapToken');

            // Act
            const snapshot = authController.snapshot();

            // Assert
            expect(snapshot).toEqual({
                isAuthenticated: true,
                user: { username: 'snapUser', roles: ['TEST']},
                tokenPresent: true
            });
        });
    });
});

================================================================================
### PLIK: controllers/BulkEditController.js
================================================================================

/**
 * ARCHITECTURE: BulkEditController previews and applies batch text transforms across selected orders.
 * It follows the manifesto by isolating batch logic and delegating transport to AddressExceptionApi.
 * Responsibilities:
 * - Preview client-side transformations for confidence; apply changes via backend endpoint.
 * - Accept BulkEditPlan JSON and return Result objects for both preview and apply.
 */
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

export class BulkEditController {
  constructor(storeOrApi = null) {
    this.api = storeOrApi instanceof AddressExceptionApi ? storeOrApi : new AddressExceptionApi();
  }

  async preview(plan) {
    try {
      const { data } = await this._post("/bulk/preview", plan);
      return Result.ok(Array.isArray(data?.items) ? data.items : []);
    } catch (e) {
      return Result.fail(e);
    }
  }

  async apply(plan) {
    try {
      const { data } = await this._post("/bulk/apply", plan);
      return Result.ok(data || true);
    } catch (e) {
      return Result.fail(e);
    }
  }

  async _post(path, plan) {
    const url = `/api/address-exceptions${path}`;
    return await (await import("@/services/api")).default.post(url, plan.toJSON ? plan.toJSON() : plan);
  }
}


================================================================================
### PLIK: controllers/CorrectionEditorController.js
================================================================================

// ============================================================================
// Frontend: Update CorrectionEditorController
// FILE: src/controllers/CorrectionEditorController.js
// REASON: Populate 'name' and 'alias' fields in editedPickup/editedDelivery
//         state upon load, acceptSuggestion, and useOriginal.
// ============================================================================
/**
 * ARCHITECTURE: CorrectionEditorController orchestrates the "side-by-side diff" editor.
 * It follows the manifesto by isolating all IO and decision logic away from the component tree.
 * REFACTORED: Now accepts a GeocodeWithCacheController.
 * UPDATED: Now maps 'name' and 'alias' into the editable state.
 */
import { Address } from "@/domain/WorkbenchModels";
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";
import { GeocodeWithCacheController } from "@/controllers/GeocodeWithCacheController";

export class CorrectionEditorController {
  constructor(api = new AddressExceptionApi(), geocoder = null) {
    this.api = api;
    this.geocoder = geocoder instanceof GeocodeWithCacheController ? geocoder : null;
    if (!this.geocoder) {
      console.warn("[CorrectionEditorController] Geocoder (GeocodeWithCacheController) was not provided or invalid.");
    }
    this.orderId = null;
    this.detail = null;
    this.loading = false;
    this.error = null;
    this.editedPickup = null;
    this.editedDelivery = null;
  }

  setGeocoderAdapter(adapter) {
    this.geocoder = adapter instanceof GeocodeWithCacheController ? adapter : null;
    return this.geocoder;
  }

  async loadOrder(orderId) {
    this.loading = true;
    this.error = null;
    this.orderId = orderId;
    this.detail = null;
    this.editedPickup = null;
    this.editedDelivery = null;
    const res = await this.api.getOrderDetail(orderId);
    if (!res.ok) {
      this.loading = false;
      this.error = res.error.message;
      return Result.fail(res.error);
    }
    this.detail = res.value;

    // --- UPDATED: Populate name/alias from original data ---
    this.editedPickup = new Address({
      street: this.detail.originalPickup.street,
      houseNumber: this.detail.originalPickup.houseNumber,
      postalCode: this.detail.originalPickup.postalCode,
      city: this.detail.originalPickup.city,
      country: this.detail.originalPickup.country,
      latitude: this.detail.originalPickup.latitude,
      longitude: this.detail.originalPickup.longitude,
      name: this.detail.originalPickup.name, // Added
      alias: this.detail.originalPickup.alias // Added
    });
    this.editedDelivery = new Address({
      street: this.detail.originalDelivery.street,
      houseNumber: this.detail.originalDelivery.houseNumber,
      postalCode: this.detail.originalDelivery.postalCode,
      city: this.detail.originalDelivery.city,
      country: this.detail.originalDelivery.country,
      latitude: this.detail.originalDelivery.latitude,
      longitude: this.detail.originalDelivery.longitude,
      name: this.detail.originalDelivery.name, // Added
      alias: this.detail.originalDelivery.alias // Added
    });
    // --- END UPDATE ---

    this.loading = false;
    return Result.ok(this.detail);
  }

  async refreshSuggestions(side) {
    if (!this.orderId) return Result.fail(new Error("Order not loaded."));
    const s = side === "pickup" ? "pickup" : "delivery";
    const res = await this.api.refreshSuggestions(this.orderId, s);
    if (!res.ok) return Result.fail(res.error);
    if (s === "pickup") this.detail.suggestedPickup = res.value;
    if (s === "delivery") this.detail.suggestedDelivery = res.value;
    return Result.ok(res.value);
  }

  acceptSuggestion(side, index = 0) {
    if (!this.detail) return Result.fail(new Error("Order not loaded."));
    const list = side === "pickup" ? this.detail.suggestedPickup : this.detail.suggestedDelivery;
    if (!Array.isArray(list) || !list[index]) return Result.fail(new Error("Suggestion not found."));
    const s = list[index];

    const base = side === "pickup" ? this.editedPickup : this.editedDelivery;
    const addr = new Address({
      street: s.street || "",
      houseNumber: s.houseNumber || null,
      postalCode: s.postalCode || "",
      city: s.city || "",
      country: s.countryCode || this._defaultCountry(),
      latitude: s.latitude ?? null,
      longitude: s.longitude ?? null,
      name: base?.name || null, // Preserve existing edited name
      alias: base?.alias || null // Preserve existing edited alias
    });
    if (side === "pickup") this.editedPickup = addr;
    if (side === "delivery") this.editedDelivery = addr;
    return Result.ok(addr);
  }

  useOriginal(side) {
    if (!this.detail) return Result.fail(new Error("Order not loaded."));
    if (side === "pickup") {
      const o = this.detail.originalPickup;
      // --- UPDATED: Copy name/alias ---
      this.editedPickup = new Address({
        street: o.street, houseNumber: o.houseNumber, postalCode: o.postalCode, city: o.city, country: o.country,
        latitude: o.latitude, longitude: o.longitude,
        name: o.name, // Added
        alias: o.alias // Added
      });
      // --- END UPDATE ---
      return Result.ok(this.editedPickup);
    }
    if (side === "delivery") {
      const o = this.detail.originalDelivery;
      // --- UPDATED: Copy name/alias ---
      this.editedDelivery = new Address({
        street: o.street, houseNumber: o.houseNumber, postalCode: o.postalCode, city: o.city, country: o.country,
        latitude: o.latitude, longitude: o.longitude,
        name: o.name, // Added
        alias: o.alias // Added
      });
      // --- END UPDATE ---
      return Result.ok(this.editedDelivery);
    }
    return Result.fail(new Error("Unknown side."));
  }

  setManualAddress(side, address) {
    if (!(address instanceof Address)) return Result.fail(new Error("Invalid Address object."));
    if (side === "pickup") this.editedPickup = address;
    else if (side === "delivery") this.editedDelivery = address;
    else return Result.fail(new Error("Unknown side."));
    return Result.ok(address);
  }

  async geocodeEdited(side) {
    if (!this.geocoder) return Result.fail(new Error("No geocoder available."));
    const addr = side === "pickup" ? this.editedPickup : this.editedDelivery;
    if (!(addr instanceof Address)) return Result.fail(new Error("No edited address."));
    const r = await this.geocoder.geocode({
      street: addr.street,
      houseNumber: addr.houseNumber,
      postalCode: addr.postalCode,
      city: addr.city,
      country: addr.country,
    });
    if (!r) return Result.fail(new Error("Geocode not found."));

    addr.latitude = r.latitude;
    addr.longitude = r.longitude;

    return Result.ok({ lat: r.latitude, lon: r.longitude });
  }

  // --- DEPRECATED SAVE METHODS ---
  // Kept for facade compatibility
  async saveAcceptSuggestion(side) {
    log.warn("DEPRECATED: saveAcceptSuggestion called. Use SaveFlowController.");
    return Result.fail(new Error("Save logic is deprecated."));
  }
  async saveUseOriginal(side) {
    log.warn("DEPRECATED: saveUseOriginal called. Use SaveFlowController.");
    return Result.fail(new Error("Save logic is deprecated."));
  }
  async saveManual(side) {
    log.warn("DEPRECATED: saveManual called. Use SaveFlowController.");
    return Result.fail(new Error("Save logic is deprecated."));
  }
  async saveAndNext(side, worklistStore) {
    log.warn("DEPRECATED: saveAndNext called. Use SaveFlowController.");
    return Result.fail(new Error("Save logic is deprecated."));
  }
  // --- END DEPRECATED ---

  snapshot() {
    return {
      orderId: this.orderId,
      detail: this.detail,
      editedPickup: this.editedPickup,
      editedDelivery: this.editedDelivery,
      loading: this.loading,
      error: this.error,
    };
  }

  _defaultCountry() {
    return "PL";
  }

  async _saveBySideKind(side) {
    log.warn("DEPRECATED: _saveBySideKind called. Use SaveFlowController.");
    return Result.fail(new Error("Save logic is deprecated."));
  }
}

// Basic logger shim
const log = {
  info: (...args) => console.info(...args),
  warn: (...args) => console.warn(...args),
  error: (...args) => console.error(...args),
};

================================================================================
### PLIK: controllers/EditorAutosaveController.js
================================================================================

/**
 * ARCHITECTURE: EditorAutosaveController persists draft edits to session and restores on load.
 * It follows the manifesto by composing EditorStateSerializer with a timed save loop.
 * Responsibilities:
 * - Save edited pickup/delivery every N ms if changed; restore when opening the same orderId.
 */
import { EditorStateSerializer } from "@/services/EditorStateSerializer";
import { AddressEqualityService } from "@/services/AddressEqualityService";

export class EditorAutosaveController {
  constructor(editorFacade, serializer = new EditorStateSerializer(), eq = new AddressEqualityService(), intervalMs = 2000) {
    this.editor = editorFacade;
    this.serializer = serializer;
    this.eq = eq;
    this.intervalMs = intervalMs;
    this._timer = null;
    this._last = null;
    this._orderId = null;
  }

  async restore(orderId) {
    this._orderId = orderId;
    const saved = this.serializer.load(orderId);
    if (saved?.editedPickup) this.editor.setManualPickup(saved.editedPickup);
    if (saved?.editedDelivery) this.editor.setManualDelivery(saved.editedDelivery);
    this._last = this._take();
    return saved || null;
  }

  start() {
    if (this._timer) return false;
    this._timer = setInterval(() => this._tick(), this.intervalMs);
    return true;
  }

  stop() {
    if (!this._timer) return false;
    clearInterval(this._timer);
    this._timer = null;
    return true;
  }

  _tick() {
    if (!this._orderId) return;
    const now = this._take();
    if (!this._equalDrafts(this._last, now)) {
      this.serializer.save(this._orderId, now);
      this._last = now;
    }
  }

  _take() {
    const s = this.editor.snapshot();
    return { editedPickup: s?.editor?.editedPickup || null, editedDelivery: s?.editor?.editedDelivery || null };
  }

  _equalDrafts(a, b) {
    return this.eq.equals(a?.editedPickup || {}, b?.editedPickup || {}) && this.eq.equals(a?.editedDelivery || {}, b?.editedDelivery || {});
  }
}


================================================================================
### PLIK: controllers/EditorCommandBus.js
================================================================================

/**
 * ARCHITECTURE: EditorCommandBus centralizes high-level editor commands for buttons and hotkeys.
 * It follows the manifesto by exposing intent methods that orchestrate other controllers/facades.
 * Responsibilities:
 * - Provide accept/use-original/save/save&next commands for pickup, delivery, and both.
 * - Keep a single place to wire UI actions to EditorFacade and SaveFlowController.
 */
import { Result } from "@/domain/Result";

export class EditorCommandBus {
  constructor(editorFacade, saveFlowController) {
    this.editor = editorFacade;
    this.saveFlow = saveFlowController;
  }

  acceptPickup(i = 0) {
    const r = this.editor.acceptPickupSuggestion(i);
    return r.ok ? Result.ok(true) : r;
  }

  acceptDelivery(i = 0) {
    const r = this.editor.acceptDeliverySuggestion(i);
    return r.ok ? Result.ok(true) : r;
  }

  useOriginalPickup() {
    const r = this.editor.useOriginalPickup();
    return r.ok ? Result.ok(true) : r;
  }

  useOriginalDelivery() {
    const r = this.editor.useOriginalDelivery();
    return r.ok ? Result.ok(true) : r;
  }

  async savePickupThenNext() {
    return this.saveFlow.saveThenAwait("pickup");
  }

  async saveDeliveryThenNext() {
    return this.saveFlow.saveThenAwait("delivery");
  }

  async saveBothThenNext() {
    return this.saveFlow.saveThenAwait("both");
  }
}


================================================================================
### PLIK: controllers/EditorDiffController.js
================================================================================

/**
 * ARCHITECTURE: EditorDiffController computes and presents diffs for pickup and delivery addresses.
 * It follows the manifesto by composing DiffService and DiffPresenter behind a deterministic snapshot.
 * Responsibilities:
 * - Pull before/after from EditorFacade snapshot and compute UI-ready rows for both sides.
 */
import { DiffService } from "@/services/DiffService";
import { DiffPresenter } from "@/viewmodels/DiffPresenter";

export class EditorDiffController {
  constructor(editorFacade) {
    this.editor = editorFacade;
    this.diff = new DiffService();
    this.presenter = new DiffPresenter();
    this._snapshot = { pickup: { rows: [] }, delivery: { rows: [] } };
  }

  recompute() {
    const snap = this.editor.snapshot();
    const beforeP = snap.editor?.detail?.originalPickup || null;
    const afterP = snap.editor?.editedPickup || snap.editor?.editedPickup || snap.editor?.detail?.originalPickup || null;
    const beforeD = snap.editor?.detail?.originalDelivery || null;
    const afterD = snap.editor?.editedDelivery || snap.editor?.detail?.originalDelivery || null;

    const dp = this.presenter.present(this.diff.diff(beforeP, afterP));
    const dd = this.presenter.present(this.diff.diff(beforeD, afterD));

    this._snapshot = { pickup: dp, delivery: dd };
    return this._snapshot;
  }

  snapshot() {
    return JSON.parse(JSON.stringify(this._snapshot));
  }
}


================================================================================
### PLIK: controllers/EditorFacade.js
================================================================================

// ============================================================================
// Frontend: Update EditorFacade.js
// FILE: src/controllers/EditorFacade.js
// REASON: Draw markers and route on load. Pass 'side' to preview controller.
// ============================================================================
/**
 * ARCHITECTURE: EditorFacade wraps CorrectionEditorController and adds map preview conveniences.
 * It follows the manifesto by exposing intent methods used by the Editor view without leaking internals.
 * REFACTORED:
 * - 'load' now draws both markers and the OSRM route on success.
 * - 'accept...Suggestion' methods now pass the correct 'side' to the previewer.
 */
import { Result } from "@/domain/Result";
import { SuggestionPreviewController } from "@/controllers/SuggestionPreviewController";

export class EditorFacade {
  constructor(editorController, mapController = null, _placesAdapter = null, queue = null) {
    this.ctrl = editorController;
    this.queue = queue || null;
    this.preview = mapController ? new SuggestionPreviewController(mapController) : null;
  }

  async load(orderId) {
    const loadResult = await this.ctrl.loadOrder(orderId);

    // --- NEW: Draw markers and route on load ---
    if (loadResult.ok && this.preview) {
      try {
        const snap = this.ctrl.snapshot();
        // Use editedPickup/Delivery which are initialized from the originals
        if (snap.editedPickup && snap.editedDelivery) {
          log.info("[EditorFacade] Loading complete. Drawing initial markers and route.");
          await this.preview.policy.showAndFitRoute(
              snap.editedPickup,
              snap.editedDelivery
          );
        }
      } catch (e) {
        log.error("[EditorFacade] Failed to draw map route on load:", e);
      }
    }
    // --- END NEW ---

    return loadResult;
  }

  snapshot() {
    return { editor: this.ctrl.snapshot(), currentOrderId: this.ctrl?.detail?.orderId || null };
  }

  setManualPickup(addr) {
    return this.ctrl.setManualAddress("pickup", addr);
  }

  setManualDelivery(addr) {
    return this.ctrl.setManualAddress("delivery", addr);
  }

  setPickupSuggestions(list) {
    // This method (setSuggestions) doesn't exist on CorrectionEditorController
    // but I am leaving the facade as-is to match your file.
    return this.ctrl.setSuggestions("pickup", list);
  }

  setDeliverySuggestions(list) {
    // This method (setSuggestions) doesn't exist on CorrectionEditorController
    return this.ctrl.setSuggestions("delivery", list);
  }

  acceptPickupSuggestion(i = 0) {
    const r = this.ctrl.acceptSuggestion("pickup", i);
    // --- UPDATED: Pass side to previewer ---
    if (this.preview && r.ok) this.preview.show("pickup", this.ctrl.snapshot().editedPickup);
    return r.ok ? Result.ok(true) : r;
  }

  acceptDeliverySuggestion(i = 0) {
    const r = this.ctrl.acceptSuggestion("delivery", i);
    // --- UPDATED: Pass side to previewer ---
    if (this.preview && r.ok) this.preview.show("delivery", this.ctrl.snapshot().editedDelivery);
    return r.ok ? Result.ok(true) : r;
  }

  useOriginalPickup() {
    return this.ctrl.useOriginal("pickup");
  }

  useOriginalDelivery() {
    return this.ctrl.useOriginal("delivery");
  }

  /**
   * Geocodes the *edited* address for a given side and focuses the map.
   * This is called when the user clicks the "Geocode" button.
   * @param {'pickup' | 'delivery'} side
   */
  async geocodeAndFocus(side) {
    const geocodeResult = await this.ctrl.geocodeEdited(side);
    if (!geocodeResult.ok) {
      return geocodeResult;
    }

    // Now focus the map on the newly geocoded point
    const snap = this.ctrl.snapshot();
    const addr = (side === 'pickup') ? snap.editedPickup : snap.editedDelivery;

    if (this.preview) {
      await this.preview.policy.focusAddress(side, addr);
    }

    return geocodeResult;
  }

  /**
   * Refreshes the route on the map using the *current* coordinates
   * from the editor state.
   */
  async refreshRoute() {
    if (!this.preview) {
      return Result.fail(new Error("Map controller not available."));
    }
    try {
      const snap = this.ctrl.snapshot();
      if (snap.editedPickup && snap.editedDelivery) {
        log.info("[EditorFacade] Refreshing map route.");
        await this.preview.policy.showAndFitRoute(
            snap.editedPickup,
            snap.editedDelivery
        );
        return Result.ok(true);
      } else {
        return Result.fail(new Error("Missing pickup or delivery address."));
      }
    } catch (e) {
      log.error("[EditorFacade] Failed to refresh map route:", e);
      return Result.fail(e);
    }
  }
}

// Basic logger shim
const log = {
  info: (...args) => console.info(...args),
  warn: (...args) => console.warn(...args),
  error: (...args) => console.error(...args),
};

================================================================================
### PLIK: controllers/EditorFocusController.js
================================================================================

/**
 * ARCHITECTURE: EditorFocusController manages a deterministic focus order across address fields.
 * It follows the manifesto by isolating focus logic from the component and DOM details.
 * Responsibilities:
 * - Provide nextField() and prevField() given current key and an ordered schema.
 * - Return the target key for the view to focus without touching the DOM.
 */
export class EditorFocusController {
  constructor(order = ["street", "houseNumber", "postalCode", "city", "country"]) {
    this.order = order.slice();
    this.index = 0;
  }

  setCurrent(key) {
    const idx = this.order.indexOf(key);
    if (idx >= 0) this.index = idx;
    return this.current();
  }

  current() {
    return this.order[this.index] || null;
  }

  next() {
    this.index = Math.min(this.order.length - 1, this.index + 1);
    return this.current();
  }

  previous() {
    this.index = Math.max(0, this.index - 1);
    return this.current();
  }

  reset() {
    this.index = 0;
    return this.current();
  }
}


================================================================================
### PLIK: controllers/EditorHotkeysController.js
================================================================================

/**
 * ARCHITECTURE: EditorHotkeysController manages keyboard shortcuts for the Correction Editor.
 * It follows the manifesto by isolating DOM listeners and mapping keys to explicit callbacks.
 * Responsibilities:
 * - Attach/detach listeners and dispatch to provided handlers (save, save&next, accept, use original).
 * - Avoid collisions by scoping to a single active instance and ignoring repeated auto-fire.
 */
export class EditorHotkeysController {
  constructor(handlers = {}) {
    this.handlers = {
      onSave: handlers.onSave || null,
      onSaveNext: handlers.onSaveNext || null,
      onAccept: handlers.onAccept || null,
      onUseOriginal: handlers.onUseOriginal || null,
    };
    this._bound = (e) => this._onKey(e);
    this._attached = false;
  }

  attach() {
    if (this._attached) return false;
    window.addEventListener("keydown", this._bound, true);
    this._attached = true;
    return true;
  }

  detach() {
    if (!this._attached) return false;
    window.removeEventListener("keydown", this._bound, true);
    this._attached = false;
    return true;
  }

  _onKey(e) {
    if (e.repeat) return;
    const mod = e.ctrlKey || e.metaKey;
    if (mod && e.key.toLowerCase() === "s") {
      e.preventDefault();
      if (e.shiftKey && this.handlers.onSaveNext) return this.handlers.onSaveNext();
      if (this.handlers.onSave) return this.handlers.onSave();
    }
    if (mod && e.key.toLowerCase() === "enter") {
      e.preventDefault();
      if (this.handlers.onAccept) return this.handlers.onAccept();
    }
    if (mod && e.key.toLowerCase() === "backspace") {
      e.preventDefault();
      if (this.handlers.onUseOriginal) return this.handlers.onUseOriginal();
    }
  }
}


================================================================================
### PLIK: controllers/EditorInitController.js
================================================================================

/**
 * ARCHITECTURE: EditorInitController prepares the Correction Editor with autosave, undo, and recovery wiring.
 * It follows the manifesto by centralizing editor startup steps for a predictable, testable flow.
 * Responsibilities:
 * - Load order, restore drafts, start autosave, initialize undo snapshot, and prefetch next order.
 * - Provide a single init(orderId) returning a stabilized snapshot for the view.
 */
import { EditorAutosaveController } from "@/controllers/EditorAutosaveController";
import { EditorUndoController } from "@/controllers/EditorUndoController";
import { OrderDetailPrefetcher } from "@/services/OrderDetailPrefetcher";
import { Result } from "@/domain/Result";

export class EditorInitController {
  constructor(editorFacade, ordersQueue, autosave = null, undo = null, prefetcher = new OrderDetailPrefetcher()) {
    this.editor = editorFacade;
    this.queue = ordersQueue;
    this.autosave = autosave instanceof EditorAutosaveController ? autosave : new EditorAutosaveController(this.editor);
    this.undo = undo instanceof EditorUndoController ? undo : new EditorUndoController(this.editor);
    this.prefetcher = prefetcher;
  }

  async init(orderId) {
    const load = await this.editor.load(orderId);
    if (!load.ok) return load;
    await this.autosave.restore(orderId);
    this.autosave.start();
    this.undo.init();
    const nextId = this.queue.current() || this.queue.next();
    if (nextId) await this.prefetcher.prefetch(nextId);
    return Result.ok(this.editor.snapshot());
  }

  stop() {
    this.autosave.stop();
    return true;
  }
}


================================================================================
### PLIK: controllers/EditorNavigationController.js
================================================================================

/**
 * ARCHITECTURE: EditorNavigationController builds route URLs to the editor preserving context when needed.
 * It follows the manifesto by isolating URL composition away from views.
 * Responsibilities:
 * - toEditor(orderId, from, state): return path with optional query for back navigation.
 */
export class EditorNavigationController {
  toEditor(orderId, from = "worklist", state = null) {
    const q = new URLSearchParams();
    q.set("from", from);
    if (state && typeof state === "object") q.set("ctx", btoa(unescape(encodeURIComponent(JSON.stringify(state)))));
    return `/editor/${encodeURIComponent(orderId)}?${q.toString()}`;
  }
}


================================================================================
### PLIK: controllers/EditorRecoveryController.js
================================================================================

/**
 * ARCHITECTURE: EditorRecoveryController (Stub) would be responsible for
 * handling recovery from save failures or state inconsistencies in the editor,
 * potentially by retrying, resetting state, or alerting the user.
 * This is a placeholder implementation.
 */
import { Result } from "@/domain/Result";

export class EditorRecoveryController {
    constructor(editorFacade, saveFlowController) {
        this.editor = editorFacade;
        this.saveFlow = saveFlowController;
    }

    /**
     * Attempts to recover from a failed save state.
     * @param {object} lastKnownGoodState - The snapshot before the failed save.
     * @param {Error} error - The error that occurred.
     * @returns {Promise<Result<any, Error>>}
     */
    async attemptRecovery(lastKnownGoodState, error) {
        console.warn("[EditorRecoveryController] Recovery requested for error:", error, "Last state:", lastKnownGoodState);
        // Placeholder: Simple recovery might just be to inform the user.
        // A complex one might check error type and retry if retryable.
        return Result.fail(new Error("Automatic recovery not implemented. Please check your connection and try saving again."));
    }
}

================================================================================
### PLIK: controllers/EditorSavePolicyController.js
================================================================================

/**
 * ARCHITECTURE: EditorSavePolicyController decides when Save buttons should be enabled.
 * It follows the manifesto by isolating policy checks (diff, validation, geocode) from UI components.
 * Responsibilities:
 * - Evaluate readiness for pickup/delivery/both saves using diff flags and validation results.
 * - Provide explicit booleans and reasons for disabled states.
 */
export class EditorSavePolicyController {
  constructor() {
    this.requireGeocode = false;
  }

  setRequireGeocode(v) {
    this.requireGeocode = !!v;
    return this.requireGeocode;
  }

  canSavePickup(state) {
    return this._evaluate(state?.latestDiff?.pickup, state?.editor?.validation, state?.editor?.instant, "pickup");
  }

  canSaveDelivery(state) {
    return this._evaluate(state?.latestDiff?.delivery, state?.editor?.validation, state?.editor?.instant, "delivery");
  }

  canSaveBoth(state) {
    const p = this._evaluate(state?.latestDiff?.pickup, state?.editor?.validation, state?.editor?.instant, "pickup");
    const d = this._evaluate(state?.latestDiff?.delivery, state?.editor?.validation, state?.editor?.instant, "delivery");
    return { enabled: p.enabled && d.enabled, reason: p.enabled ? d.reason : p.reason };
  }

  _evaluate(diff, validation, instant, side) {
    if (!diff || !validation) return { enabled: false, reason: "No changes or validation state missing" };
    if (!diff.anyChanged) return { enabled: false, reason: "No changes detected" };
    if (!validation.valid) return { enabled: false, reason: "Invalid address fields" };
    if (this.requireGeocode && !instant) return { enabled: false, reason: "Geocode required" };
    return { enabled: true, reason: "OK" };
  }
}


================================================================================
### PLIK: controllers/EditorUndoController.js
================================================================================

/**
 * ARCHITECTURE: EditorUndoController wraps UndoStackService for pickup/delivery address edits.
 * It follows the manifesto by providing intent-driven methods without UI or storage coupling.
 * Responsibilities:
 * - Capture snapshots on change, and restore on undo/redo callbacks to the editor facade.
 * - Keep a tiny footprint: snapshot shape is {pickup,delivery}.
 */
import { UndoStackService } from "@/services/UndoStackService";

export class EditorUndoController {
  constructor(editorFacade, stack = new UndoStackService(100)) {
    this.editor = editorFacade;
    this.stack = stack;
  }

  init() {
    const snap = this._snapshot();
    this.stack.init(snap);
    return snap;
  }

  onChange() {
    return this.stack.push(this._snapshot());
  }

  undo() {
    const s = this.stack.undo();
    if (!s) return null;
    if (s.pickup) this.editor.setManualPickup(s.pickup);
    if (s.delivery) this.editor.setManualDelivery(s.delivery);
    return s;
  }

  redo() {
    const s = this.stack.redo();
    if (!s) return null;
    if (s.pickup) this.editor.setManualPickup(s.pickup);
    if (s.delivery) this.editor.setManualDelivery(s.delivery);
    return s;
  }

  _snapshot() {
    const st = this.editor.snapshot();
    return {
      pickup: st?.editor?.editedPickup || null,
      delivery: st?.editor?.editedDelivery || null,
    };
  }
}


================================================================================
### PLIK: controllers/EditorVerificationController.js
================================================================================

// FILE: src/controllers/EditorVerificationController.js
// UPDATED FILE (Remove Places dependency)
import { AddressNormalizer } from "@/services/AddressNormalizer";
import { ValidationService } from "@/services/ValidationService";
import { DebounceTimer } from "@/services/DebounceTimer";

/**
 * ARCHITECTURE: Coordinates live verification for the Correction Editor input fields.
 * REFACTORED: Removed Google Places adapter dependency. Relies on geocoder only.
 */
export class EditorVerificationController {
  constructor(
      geocoderAdapter, // e.g., NominatimGeocodingAdapter instance
      // Removed placesAdapter
      mapController,
      debounceMs = 400
  ) {
    this.normalizer = new AddressNormalizer();
    this.validator = new ValidationService(); // Assuming country PL default or configurable
    this.debouncer = new DebounceTimer(debounceMs);
    this.geocoder = geocoderAdapter || null;
    // this.places = null; // Removed
    this.map = mapController || null;
    this.input = { street: "", houseNumber: "", postalCode: "", city: "", country: "PL" };
    this.validation = { valid: false, errors: {} };
    this.instant = null; // Result from geocoder
    this.suggestions = []; // Now likely just [instant] or []
    this.loading = false;
    this.error = null;
  }

  setInputPatch(patch) {
    this.input = { ...this.input, ...(patch || {}) };
    return this.input;
  }

  async runVerification() {
    return this.debouncer.run(async () => {
      this.loading = true;
      this.error = null;
      this.instant = null; // Reset results
      this.suggestions = [];

      const normalized = this.normalizer.normalize(this.input);
      const check = this.validator.validate(normalized);
      this.validation = check;

      if (!check.valid) {
        log.debug("[EditorVerify] Input invalid, skipping geocode:", check.errors);
        this.loading = false;
        return this.snapshot();
      }

      let instantResult = null;
      if (this.geocoder) {
        try {
          instantResult = await this.geocoder.geocodeAddress(normalized);
          this.instant = instantResult; // Store the geocoded result
          if (instantResult) {
            this.suggestions = [this.mapGeoResultToSuggestion(instantResult, normalized)]; // Create suggestion from result
          }
        } catch (geoError) {
          log.error("[EditorVerify] Geocoder failed:", geoError);
          this.error = "Geocoding failed.";
          this.instant = null;
          this.suggestions = [];
        }
      } else {
        log.warn("[EditorVerify] No geocoder configured.");
      }

      // Update map marker if geocoding was successful and map exists
      if (instantResult && typeof instantResult.latitude === "number" && typeof instantResult.longitude === "number" && this.map) {
        try {
          await this.map.updateMarker(instantResult.latitude, instantResult.longitude, true); // Recenter map
        } catch (mapError) {
          log.error("[EditorVerify] Failed to update map marker:", mapError);
          // Non-critical error, continue
        }
      }

      this.loading = false;
      return this.snapshot();
    });
  }

  // Helper to map geocoder result to the suggestion format expected by downstream components
  mapGeoResultToSuggestion(geoResult, baseInput) {
    return {
      fullAddressLabel: geoResult._displayName || `${geoResult.street || ''} ${geoResult.houseNumber || ''}, ${geoResult.postalCode || ''} ${geoResult.city || ''}`.replace(/ ,|,$/,'').trim(),
      street: geoResult.street || null,
      houseNumber: geoResult.houseNumber || null,
      postalCode: geoResult.postalCode || null,
      city: geoResult.city || null,
      countryCode: geoResult.country || baseInput.country || "PL",
      countryName: null,
      latitude: geoResult.latitude ?? null,
      longitude: geoResult.longitude ?? null,
      matchScore: geoResult._confidence ?? 0.8,
      matchLevel: geoResult._osmType || "GEOCODER",
      providerSource: geoResult._provider || "GEOCODER_CLIENT",
    };
  }

  snapshot() {
    return {
      input: { ...this.input },
      validation: { ...this.validation },
      instant: this.instant ? { ...this.instant } : null,
      suggestions: this.suggestions.slice(),
      loading: this.loading,
      error: this.error,
    };
  }

  _composeFreeText(a) { // Keep for potential future use
    const line1 = a.houseNumber ? `${a.street || ''} ${a.houseNumber}` : a.street || "";
    return `${line1}, ${a.postalCode || ""} ${a.city || ""}`.trim();
  }
}

// Basic logger shim
const log = {
  debug: (...args) => console.debug(...args),
  warn: (...args) => console.warn(...args),
  error: (...args) => console.error(...args),
};

================================================================================
### PLIK: controllers/EndToEndVerifyAndSaveController.js
================================================================================

/**
 * ARCHITECTURE: EndToEndVerifyAndSaveController runs normalize→validate→verify→save with telemetry.
 * It follows the manifesto by composing workflow, policy, and save flow into a single orchestrator.
 * Responsibilities:
 * - Verify pickup/delivery, apply best suggestion, and persist the result; then advance queue.
 * - Emit timing events via VerificationTelemetryController and return a concise outcome.
 */
import { AddressVerificationWorkflow } from "@/controllers/AddressVerificationWorkflow";
import { SuggestionSelectionController } from "@/controllers/SuggestionSelectionController";
import { SaveFlowController } from "@/controllers/SaveFlowController";
import { VerificationTelemetryController } from "@/controllers/VerificationTelemetryController";
import { Result } from "@/domain/Result";

export class EndToEndVerifyAndSaveController {
  constructor(googleApiKey, editorFacade, ordersQueue, saver) {
    this.workflow = new AddressVerificationWorkflow(googleApiKey);
    this.selector = new SuggestionSelectionController();
    this.saveFlow = new SaveFlowController(editorFacade, ordersQueue, saver);
    this.telemetry = new VerificationTelemetryController();
    this.editor = editorFacade;
  }

  async runForSide(side = "pickup") {
    const corr = this.telemetry.start(`e2e_${side}`);
    const addr = side === "pickup" ? this.editor.editor.editedPickup : this.editor.editor.editedDelivery;
    if (!addr) {
      this.telemetry.finish("no-input", { side });
      return Result.fail(new Error("No address to verify"));
    }
    this.telemetry.mark("verify-start", { side });
    const vr = await this.workflow.verify(addr);
    this.telemetry.mark("verify-finish", { valid: vr.success, side });
    if (!vr.success) {
      this.telemetry.finish("invalid", { side });
      return Result.fail(new Error("Validation failed"));
    }
    const best = this.selector.best(vr.normalized, vr.suggestions);
    if (best) {
      if (side === "pickup") this.editor.acceptPickupSuggestion(best.index);
      if (side === "delivery") this.editor.acceptDeliverySuggestion(best.index);
    }
    this.telemetry.mark("save-start", { side });
    const saved = await this.saveFlow.saveThenAwait(side);
    const status = saved.ok ? "ok" : "save-failed";
    this.telemetry.finish(status, { side, nextId: saved.ok ? saved.value?.nextId || null : null });
    return saved;
  }
}


================================================================================
### PLIK: controllers/erificationQueueController.js
================================================================================

/**
 * ARCHITECTURE: VerificationQueueController serializes geocode requests to respect provider quotas.
 * It follows the manifesto by isolating concurrency limits and exposing enqueue() with result promises.
 * Responsibilities:
 * - Maintain a FIFO queue, run up to N active tasks, and resolve/reject per item deterministically.
 * - Allow dynamic concurrency to adapt to UI load and throttle bursts from user typing.
 */
export class VerificationQueueController {
  constructor(concurrency = 2) {
    this.concurrency = Math.max(1, concurrency);
    this._active = 0;
    this._q = [];
  }

  setConcurrency(n) {
    this.concurrency = Math.max(1, n);
    this._drain();
    return this.concurrency;
  }

  enqueue(taskFn) {
    return new Promise((resolve, reject) => {
      this._q.push({ taskFn, resolve, reject });
      this._drain();
    });
  }

  _drain() {
    while (this._active < this.concurrency && this._q.length > 0) {
      const item = this._q.shift();
      this._run(item);
    }
  }

  async _run(item) {
    this._active++;
    try {
      const r = await item.taskFn();
      item.resolve(r);
    } catch (e) {
      item.reject(e);
    } finally {
      this._active--;
      this._drain();
    }
  }

  size() {
    return this._q.length + this._active;
  }
}


================================================================================
### PLIK: controllers/GeocodeWithCacheController.js
================================================================================

// FILE: src/controllers/GeocodeWithCacheController.js
// MODIFIED - Request adapter without specifying provider
import { AddressGeocodeCache } from "@/services/AddressGeocodeCache";
import { QuotaBackoffService } from "@/services/QuotaBackoffService";

/**
 * ARCHITECTURE: Composes cache, quota backoff for geocoding.
 * Uses injected GeoRuntime to get the configured geocoder adapter.
 */
export class GeocodeWithCacheController {
    constructor(
        geoRuntime,
        cache = new AddressGeocodeCache(),
        backoff = new QuotaBackoffService()
    ) {
        if (!geoRuntime) throw new Error("GeocodeWithCacheController requires GeoRuntime.");
        this.geoRuntime = geoRuntime;
        this.cache = cache;
        this.backoff = backoff;
        this._geocoderAdapter = null;
        // Lazy load
    }

    _getAdapter() {
        // *** FIX: Ensure GeoRuntime is initialized before requesting adapter ***
        // This relies on GeoRuntime.init() being called globally in main.js
        // or the router guard.
        if (!this._geocoderAdapter) {
            try {
                // Request the *configured* geocoding adapter
                this._geocoderAdapter = this.geoRuntime.geocodingAdapter();
                if(!this._geocoderAdapter) throw new Error("GeoRuntime returned null geocoding adapter.");
            } catch (e) {
                log.error("Failed to get configured geocoding adapter from GeoRuntime:", e);
                throw e; // Re-throw if no adapter available
            }
        }
        return this._geocoderAdapter;
    }


    async geocode(address) {
        const hit = this.cache.get(address);
        if (hit) {
            log.debug("[GeocodeCache] Cache hit for address:", address);
            return hit;
        }
        log.debug("[GeocodeCache] Cache miss for address:", address);

        // *** FIX: Ensure adapter is requested *before* task execution if not already loaded ***
        try {
            this._getAdapter();
        } catch (e) {
            log.error("[GeocodeCache] Cannot geocode, adapter unavailable:", e.message);
            return null;
        }
        // *** END FIX ***

        const task = async () => {
            const adapter = this._getAdapter();
            const run = () => adapter.geocodeAddress(address);
            const result = await this.backoff.execute(run);
            if (result && typeof result.latitude === 'number' && typeof result.longitude === 'number') {
                log.debug("[GeocodeCache] Geocode success, caching:", address, result);
                this.cache.put(address, result);
            } else {
                log.debug("[GeocodeCache] Geocode returned null/empty or invalid coordinates, not caching:", address);
            }
            return result;
        };

        return task();
    }
}

const log = {
    debug: (...args) => console.debug(...args),
    error: (...args) => console.error(...args),
};

================================================================================
### PLIK: controllers/HealthGateController.js
================================================================================

/**
 * ARCHITECTURE: HealthGateController returns a stable readiness object without external dependencies.
 * It follows the manifesto by short-circuiting health checks in dev so the shell can render immediately.
 * Responsibilities:
 * - Delegate to RuntimeHealthService (which is dev-bypassed) and forward the normalized result.
 */
import { RuntimeHealthService } from "@/services/RuntimeHealthService";

export class HealthGateController {
  constructor(runtime = new RuntimeHealthService()) {
    this.runtime = runtime;
  }

  async readiness(googleKey) {
    const r = await this.runtime.readiness(googleKey);
    return { ok: !!r.ready, backend: !!r.backend?.ok, provider: !!r.provider?.ok, google: !!r.google?.ok };
  }
}


================================================================================
### PLIK: controllers/IdempotentSaveController.js
================================================================================

// ============================================================================
// Frontend: Mark IdempotentSaveController as Deprecated
// FILE: src/controllers/IdempotentSaveController.js
// REASON: This controller's logic (targeting /approve) is obsolete.
//         The new flow is handled by SaveFlowController targeting
//         /processing-errors/{eventId}/resubmit.
// ============================================================================
// FILE: src/controllers/IdempotentSaveController.js (Supersedes previous version)

import { Result } from "@/domain/Result";
import { IdempotencyTokenService } from "@/services/IdempotencyTokenService";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

/**
 * ARCHITECTURE: Wraps AddressExceptionApi with idempotency token generation.
 * @deprecated This controller is deprecated. The new save flow is managed
 * by SaveFlowController, which builds a resubmission payload for
 * the /processing-errors endpoint and calls AddressExceptionApi.saveResubmission.
 */
export class IdempotentSaveController {
  constructor(api = new AddressExceptionApi(), mapper = null, tokens = new IdempotencyTokenService()) {
    this.api = api;
    this.tokens = tokens;
    console.warn("DEPRECATED: IdempotentSaveController is obsolete and should not be used.");
  }

  async save(payload) {
    console.error("DEPRECATED: IdempotentSaveController.save() was called. This flow is no longer supported.");
    return Result.fail(new Error("IdempotentSaveController is deprecated."));
  }
}

================================================================================
### PLIK: controllers/IntegrationOrchestrator.js
================================================================================

// ============================================================================
// Frontend: Update IntegrationOrchestrator (Final Version)
// FILE: src/controllers/IntegrationOrchestrator.js
// REASON: Instantiate GeocodeWithCacheController correctly.
// ============================================================================
// FILE: src/controllers/IntegrationOrchestrator.js
import { OrdersQueueService } from "@/services/OrdersQueueService";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";
import { PollingService } from "@/services/PollingService";
import { WorklistFacade } from "@/controllers/WorklistFacade";
import { CorrectionEditorController } from "@/controllers/CorrectionEditorController";
import { EditorFacade } from "@/controllers/EditorFacade";
// Import GeocodeWithCacheController
import { GeocodeWithCacheController } from "@/controllers/GeocodeWithCacheController";

/**
 * ARCHITECTURE: Central factory/provider for core application controllers and services.
 * Injects dependencies like GeoRuntime and MapController to construct facades.
 * REFACTORED: Requests adapters from GeoRuntime without specifying provider type.
 * FIX: Instantiates GeocodeWithCacheController here to pass to EditorFacade.
 */
export class IntegrationOrchestrator {
  constructor(geoRuntime, mapController) { // mapController might be null initially
    if (!geoRuntime) throw new Error("IntegrationOrchestrator requires a GeoRuntime instance.");
    this._geoRuntime = geoRuntime;
    this._mapController = mapController || null; // MapController instance (using configured map adapter)

    this.queue = new OrdersQueueService();
    this.api = new AddressExceptionApi();
    this.polling = new PollingService();
    this._worklist = null;
    this._editor = null;

    // Instantiate shared GeocodeWithCacheController using the provided GeoRuntime
    // This assumes GeoRuntime.init() will be called before geocodeController.geocode() is needed.
    this._geocodeController = new GeocodeWithCacheController(this._geoRuntime);
  }

  getWorklist() {
    if (this._worklist) return this._worklist;
    // Instantiate WorklistFacade on demand
    this._worklist = new WorklistFacade(this.polling);
    return this._worklist;
  }

  getEditor(mapControllerInstance = null) { // Allow passing map controller if created later
    // If an editor instance already exists, return it
    if (this._editor) {
      // If a new map controller is provided (e.g., editor view re-created), update it
      if (mapControllerInstance && this._editor.preview) {
        this._editor.preview.map = mapControllerInstance; // Update the map controller in the preview helper
      }
      return this._editor;
    }

    // Use the mapController passed during creation or the one provided now
    const effectiveMapController = mapControllerInstance || this._mapController;

    let placesAdapter = null; // Places adapter might be null if config is 'none'

    try {
      // Attempt to get the *configured* places adapter from the runtime
      // Geocoder is handled by the injected _geocodeController
      placesAdapter = this._geoRuntime.placesAdapter(); // May return null
      if(placesAdapter) {
        console.info("[IntegrationOrchestrator] Places adapter obtained for EditorFacade.");
      } else {
        console.info("[IntegrationOrchestrator] Places adapter is null/unavailable. Editor hints disabled.");
      }
    } catch(e) {
      console.error("IntegrationOrchestrator: Failed to get configured places adapter from GeoRuntime:", e.message);
      // Continue with null adapter
    }

    // Instantiate CorrectionEditorController, passing the shared GeocodeWithCacheController
    const ctrl = new CorrectionEditorController(this.api, this._geocodeController);

    // Instantiate EditorFacade, passing the relevant components
    this._editor = new EditorFacade(
        ctrl,
        effectiveMapController, // Pass the map controller instance
        placesAdapter,          // Pass potentially null places adapter
        this.queue              // Pass the orders queue
    );
    return this._editor;
  }
}

================================================================================
### PLIK: controllers/LoginFormController.js
================================================================================


================================================================================
### PLIK: controllers/MapController.js
================================================================================

/**
 * ARCHITECTURE: MapController coordinates a map adapter to create a map, update its marker, and recenter.
 * REFACTORED: Now supports distinct pickup/delivery markers and route drawing.
 */
export class MapController {
  constructor(mapAdapter) {
    this.adapter = mapAdapter;
    this._container = null;
    this._center = { lat: 52.2297, lon: 21.0122, zoom: 6 };
    this._ready = false;
  }

  async init(container, options) {
    this._container = container;
    const opt = options || this._center;
    await this.adapter.create(container, { lat: opt.lat, lon: opt.lon, zoom: opt.zoom });
    this._center = { lat: opt.lat, lon: opt.lon, zoom: opt.zoom };
    this._ready = true;
    return true;
  }

  // *** MODIFIED: This legacy method now controls the PICKUP marker ***
  async updateMarker(lat, lon, recenter = false) {
    return this.updatePickupMarker(lat, lon, recenter);
  }

  // *** NEW METHODS ***
  async updatePickupMarker(lat, lon, zoomTo = false) {
    if (!this._ready) throw new Error("MapController: map not initialized.");
    await this.adapter.setPickupMarker(lat, lon, zoomTo);
    if(zoomTo) this._center = { ...this._center, lat, lon };
    return true;
  }

  async updateDeliveryMarker(lat, lon, zoomTo = false) {
    if (!this._ready) throw new Error("MapController: map not initialized.");
    await this.adapter.setDeliveryMarker(lat, lon, zoomTo);
    if(zoomTo) this._center = { ...this._center, lat, lon };
    return true;
  }

  async drawRouteAndFit(pickupPos, deliveryPos) {
    if (!this._ready) throw new Error("MapController: map not initialized.");
    if (!pickupPos || !deliveryPos) return false;

    const routeDrawn = await this.adapter.drawRoute(pickupPos, deliveryPos);
    const boundsFitted = await this.adapter.fitBounds(pickupPos, deliveryPos);

    return routeDrawn && boundsFitted;
  }
  // *** END NEW METHODS ***

  async recenter(zoom) {
    if (!this._ready) throw new Error("MapController: map not initialized.");
    const z = typeof zoom === "number" ? zoom : this._center.zoom;
    await this.adapter.setCenter(this._center.lat, this._center.lon, z);
    this._center.zoom = z;
    return true;
  }

  async destroy() {
    await this.adapter.destroy();
    this._ready = false;
    this._container = null;
    return true;
  }
}

================================================================================
### PLIK: controllers/MapViewportPolicyController.js
================================================================================

// ============================================================================
// Frontend: Update MapViewportPolicyController.js
// FILE: src/controllers/MapViewportPolicyController.js
// REASON: Remove non-existent 'this.map.clearAll()' call.
// ============================================================================
/**
 * ARCHITECTURE: MapViewportPolicyController centralizes how the editor focuses the map.
 * It follows the manifesto by hiding viewport decisions behind a minimal, deterministic API.
 * REFACTORED: Now accepts a 'side' parameter to control either the
 * pickup (green) or delivery (red) marker, and adds 'showAndFitRoute'.
 * FIX: Removed non-existent clearAll() call.
 */
export class MapViewportPolicyController {
  constructor(mapController) {
    this.map = mapController;
  }

  /**
   * Focuses the map on an instant geocode result for a specific side.
   * @param {'pickup' | 'delivery'} side
   * @param {object} model - Address-like object with latitude/longitude.
   */
  async focusInstant(side, model) {
    return this.focusAddress(side, model);
  }

  /**
   * Focuses the map on a suggestion for a specific side.
   * @param {'pickup' | 'delivery'} side
   * @param {object} suggestion - Suggestion object with latitude/longitude.
   */
  async focusSuggestion(side, suggestion) {
    return this.focusAddress(side, suggestion);
  }

  /**
   * Updates the marker for a specific side (pickup or delivery) and
   * centers the map on it.
   * @param {'pickup' | 'delivery'} side
   * @param {object} addr - Address-like object with latitude/longitude.
   */
  async focusAddress(side, addr) {
    const lat = Number(addr?.latitude);
    const lon = Number(addr?.longitude);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) return false;

    try {
      if (!this.map) throw new Error("MapController not available");
      if (side === 'pickup') {
        await this.map.updatePickupMarker(lat, lon, true);
      } else if (side === 'delivery') {
        await this.map.updateDeliveryMarker(lat, lon, true);
      } else {
        // Fallback for old calls, defaults to pickup
        await this.map.updatePickupMarker(lat, lon, true);
      }
      return true;
    } catch (e) {
      console.error(`[MapViewportPolicy] Failed to focus ${side} marker:`, e);
      return false;
    }
  }

  /**
   * Draws both pickup and delivery markers and fits the map to show the route.
   * @param {object} pickupAddr
   * @param {object} deliveryAddr
   */
  async showAndFitRoute(pickupAddr, deliveryAddr) {
    if (!this.map) {
      console.error("[MapViewportPolicy] Cannot show route, map is not initialized.");
      return false;
    }

    const pLat = Number(pickupAddr?.latitude);
    const pLon = Number(pickupAddr?.longitude);
    const dLat = Number(deliveryAddr?.latitude);
    const dLon = Number(deliveryAddr?.longitude);

    let pickupValid = Number.isFinite(pLat) && Number.isFinite(pLon);
    let deliveryValid = Number.isFinite(dLat) && Number.isFinite(dLon);

    try {
      // *** FIX: Removed this.map.clearAll() call ***

      if (pickupValid) {
        await this.map.updatePickupMarker(pLat, pLon, false);
      }
      if (deliveryValid) {
        await this.map.updateDeliveryMarker(dLat, dLon, false);
      }

      // If both are valid, draw the route and fit the bounds
      if (pickupValid && deliveryValid) {
        await this.map.drawRouteAndFit(
            { lat: pLat, lon: pLon },
            { lat: dLat, lon: dLon }
        );
      }
      return true;
    } catch (e) {
      console.error(`[MapViewportPolicy] Failed to showAndFitRoute:`, e);
      return false;
    }
  }
}

================================================================================
### PLIK: controllers/PlacesHintController.js
================================================================================

/**
 * ARCHITECTURE: PlacesHintController coordinates Google Places type-ahead hints with session tokens and debouncing.
 * It follows the manifesto by isolating vendor semantics and timing concerns behind a single suggest() method.
 * Responsibilities:
 * - Use GooglePlacesSessionManager to reuse/renew AutocompleteSessionToken.
 * - Debounce keystrokes, query Places adapter, and return normalized suggestions.
 */
import { GooglePlacesSessionManager } from "@/adapters/GooglePlacesSessionManager";
import { DebounceTimer } from "@/services/DebounceTimer";
import { SuggestionNormalizer } from "@/services/SuggestionNormalizer";

export class PlacesHintController {
  constructor(googleObj, placesAdapter, debounceMs = 250) {
    this.google = googleObj;
    this.places = placesAdapter;
    this.session = new GooglePlacesSessionManager(this.google);
    this.debounce = new DebounceTimer(debounceMs);
    this.normalizer = new SuggestionNormalizer();
  }

  async suggest(freeText, country = "PL") {
    return this.debounce.run(async () => {
      if (!this.places || !freeText || !freeText.trim()) return [];
      const token = this.session.getToken();
      void token;
      const raw = await this.places.suggest(freeText, country);
      return this.normalizer.normalizeBatch(raw, "PLACES");
    });
  }

  renewSession() {
    this.session.renew();
    return true;
  }
}


================================================================================
### PLIK: controllers/ProviderFallbackController.js
================================================================================


================================================================================
### PLIK: controllers/ProviderGuard.js
================================================================================

/**
 * ARCHITECTURE: ProviderGuard enforces that TES address provider is GOOGLE before verification flows run.
 * It follows the manifesto by isolating cross-cutting preconditions and exposing a single guard method.
 * Responsibilities:
 * - Read current provider via DANXILS-API proxy; if not GOOGLE, request it be set to GOOGLE.
 * - Since the backend uses Kafka, this involves initiating requests and polling for completion status.
 * - Cache the result to avoid redundant network calls during the session.
 */
import apiClient from "@/services/api";
import { TesOperationPoller } from "@/services/TesOperationPoller";

export class ProviderGuard {
    constructor(poller = new TesOperationPoller()) {
        this._aligned = false;
        this._inFlight = null;
        this._poller = poller;
    }

    async ensureGoogle() {
        if (this._aligned) return true;
        if (this._inFlight) return this._inFlight;

        this._inFlight = (async () => {
            try {
                const getCurrentResponse = await apiClient.get("/api/admin/address-verification/providers/current");
                if (getCurrentResponse.status !== 202 || !getCurrentResponse.data?.correlationId) {
                    throw new Error("Failed to initiate get-current-provider request.");
                }
                const currentProviderResult = await this._poller.waitFor(getCurrentResponse.data.correlationId);
                if (currentProviderResult.status !== 'COMPLETED') {
                    throw new Error(`Polling for current provider failed: ${currentProviderResult.errorDetails || 'Unknown error'}`);
                }

                const currentProviderName = currentProviderResult.result;
                if (typeof currentProviderName === 'string' && currentProviderName.toUpperCase() === "GOOGLE") {
                    this._aligned = true;
                    return true;
                }

                console.warn(`TES Provider is '${currentProviderName}', attempting to set to GOOGLE.`);
                const setProviderResponse = await apiClient.post("/api/admin/address-verification/providers/current", "GOOGLE", {
                    headers: { "Content-Type": "text/plain" },
                });
                if (setProviderResponse.status !== 202 || !setProviderResponse.data?.correlationId) {
                    throw new Error("Failed to initiate set-current-provider request.");
                }
                const setProviderResult = await this._poller.waitFor(setProviderResponse.data.correlationId);
                if (setProviderResult.status !== 'COMPLETED') {
                    throw new Error(`Polling for set provider failed: ${setProviderResult.errorDetails || 'Unknown error'}`);
                }

                this._aligned = true;
                console.log("Successfully requested TES provider alignment to GOOGLE.");
                return true;
            } catch (error) {
                this._aligned = false;
                console.error("ProviderGuard alignment failed:", error);
                throw new Error(`Failed to ensure TES provider is GOOGLE: ${error.message}`);
            } finally {
                this._inFlight = null;
            }
        })();

        return this._inFlight;
    }
}


================================================================================
### PLIK: controllers/QuickAcceptController.js
================================================================================

/**
 * ARCHITECTURE: QuickAcceptController enables one-click "best suggestion" acceptance per side.
 * It follows the manifesto by composing SuggestionSelectionController and EditorFacade.
 * Responsibilities:
 * - Compute best suggestion for the current input and apply it; return the applied index or null.
 */
import { SuggestionSelectionController } from "@/controllers/SuggestionSelectionController";

export class QuickAcceptController {
  constructor() {
    this.selector = new SuggestionSelectionController();
  }

  applyBest(side, baseInput, suggestions, editorFacade) {
    const best = this.selector.best(baseInput, suggestions);
    if (!best) return null;
    if (side === "pickup") editorFacade.acceptPickupSuggestion(best.index);
    if (side === "delivery") editorFacade.acceptDeliverySuggestion(best.index);
    return best.index;
  }
}


================================================================================
### PLIK: controllers/RealtimeVerificationOrchestrator.js
================================================================================

// FILE: src/controllers/RealtimeVerificationOrchestrator.js
// MODIFIED - Handle potentially null places adapter
import { DebounceTimer } from "@/services/DebounceTimer";
import { AddressSuggestionRanker } from "@/services/AddressSuggestionRanker";
import { SuggestionNormalizer } from "@/services/SuggestionNormalizer";
/**
 * ARCHITECTURE: Coordinates debounced input, geocode-with-cache, and optional places hints.
 * REFACTORED: Gets configured adapters from GeoRuntime.
 * Handles null places adapter gracefully.
 * *** FIX: Corrected constructor to accept GeoRuntime and GeocodeController. ***
 */
export class RealtimeVerificationOrchestrator {
    constructor(
        geoRuntime, // Inject GeoRuntime
        geocodeController, // Inject GeocodeWithCacheController
        debounceMs = 350
    ) {
        if (!geoRuntime || !geocodeController) throw new Error("GeoRuntime and GeocodeController are required.");
        this.geoRuntime = geoRuntime;
        this.geocode = geocodeController;

        // Attempt to get the *configured* places adapter, may be null
        try {
            this.places = this.geoRuntime.placesAdapter();
            // Returns null if config is 'none'
            if(this.places) {
                log.info("[RealtimeVerify] Places adapter successfully obtained.");
            } else {
                log.info("[RealtimeVerify] Places provider configured as 'none' or unavailable. Hints disabled.");
            }
        } catch(e) {
            log.warn("Could not get places adapter during RealtimeVerificationOrchestrator init:", e.message);
            this.places = null; // Ensure it's null on error
        }

        this.debouncer = new DebounceTimer(debounceMs);
        this.ranker = new AddressSuggestionRanker();
        this.normalizer = new SuggestionNormalizer();
    }

    async verify(baseInput) {
        return this.debouncer.run(async () => {
            const t0 = performance.now ? performance.now() : Date.now();

            const geocodePromise = this.geocode.geocode(baseInput);
            // Only call places if the adapter is available
            const placesPromise = this.places
                ? this.places.suggest(this._freeText(baseInput), baseInput.country || "PL")
                : Promise.resolve([]); // Resolve empty if no places adapter

            const [geoResult, placeRaw] = await Promise.all([geocodePromise, placesPromise]);

            const instant = geoResult
                ? this.mapGeoResultToSuggestion(geoResult, baseInput) // Use helper
                : null;

            // Normalize places results (will be empty if this.places is null)
            const placesSuggestions = this.normalizer.normalizeBatch(placeRaw, "PLACES_DETAIL"); // Assume details if Places ran

            const merged = instant ? [instant, ...placesSuggestions] : [...placesSuggestions];
            const ranked = this.ranker.rank(baseInput, merged);
            const t1 = performance.now ? performance.now() : Date.now();
            return { instant, suggestions: ranked, elapsedMs: Math.round(t1 - t0) };
        });
    }

    mapGeoResultToSuggestion(geoResult, baseInput, providerSource = "GEOCODER_CLIENT") {
        if (!geoResult) return null;
        // Determine provider source based on adapter type if possible
        let source = providerSource;
        if (geoResult._provider === 'Google') source = 'GOOGLE_CLIENT';
        else if (geoResult._provider === 'Nominatim') source = 'NOMINATIM_CLIENT';
        return {
            fullAddressLabel: geoResult._displayName || `${geoResult.street ||
            ''} ${geoResult.houseNumber || ''}, ${geoResult.postalCode || ''} ${geoResult.city || ''}`.replace(/ ,|,$/,'').trim(),
            street: geoResult.street ||
                null,
            houseNumber: geoResult.houseNumber ||
                null,
            postalCode: geoResult.postalCode ||
                null,
            city: geoResult.city ||
                null,
            countryCode: geoResult.country || baseInput?.country ||
                "PL",
            countryName: null,
            latitude: geoResult.latitude ??
                null,
            longitude: geoResult.longitude ??
                null,
            matchScore: geoResult._confidence ??
                0.8,
            matchLevel: geoResult._locationType || geoResult._osmType ||
                "GEOCODER",
            providerSource: source,
        };
    }

    _freeText(a) {
        const line1 = a?.houseNumber ? `${a.street ||
        ''} ${a.houseNumber}` : a?.street || "";
        return `${line1}, ${a?.postalCode || ""} ${a?.city || ""}`.trim();
    }
}

const log = {
    info: (...args) => console.info(...args),
    debug: (...args) => console.debug(...args),
    warn: (...args) => console.warn(...args),
    error: (...args) => console.error(...args),
};

================================================================================
### PLIK: controllers/SafeSaveController.js
================================================================================

/**
 * ARCHITECTURE: SafeSaveController guards persistence with equality checks and idempotency keys.
 * It follows the manifesto by preventing duplicate saves and short-circuiting when nothing changed.
 * Responsibilities:
 * - Compute a change key using AddressEqualityService; skip save if unchanged.
 * - Generate an idempotency token to pass to backend headers when available.
 */
import { AddressEqualityService } from "@/services/AddressEqualityService";

export class SafeSaveController {
  constructor(saver, equality = new AddressEqualityService()) {
    this.saver = saver;
    this.eq = equality;
    this._lastKey = null;
  }

  async saveIfChanged(payload) {
    const before = payload?.before || {};
    const after = payload?.after || {};
    const key = this._keyOf(before, after, payload?.orderId, payload?.side, payload?.resolution);
    if (key === this._lastKey) return { skipped: true, reason: "Duplicate save call" };
    const changed =
      (after.pickup && !this.eq.equals(before.pickup || {}, after.pickup)) ||
      (after.delivery && !this.eq.equals(before.delivery || {}, after.delivery));
    if (!changed) return { skipped: true, reason: "No changes" };
    const res = await this.saver.save(payload);
    if (res?.ok) this._lastKey = key;
    return { skipped: false, result: res };
  }

  _keyOf(before, after, orderId, side, resolution) {
    const h = (a) => this.eq.hash(a || {});
    return [orderId || "", side || "", resolution || "", h(before?.pickup), h(before?.delivery), h(after?.pickup), h(after?.delivery)].join("#");
  }
}


================================================================================
### PLIK: controllers/SaveAndNextController.js
================================================================================

/**
 * ARCHITECTURE: SaveAndNextController coordinates saving an address correction and loading the next order.
 * It follows the manifesto by composing persistence, queue sequencing, and editor orchestration behind one method.
 * Responsibilities:
 * - Execute a provided save function, remove current id from queue on success, and resolve the next id.
 * - Short-circuit when the queue is empty and return null for end-of-queue conditions.
 */
import { Result } from "@/domain/Result";

export class SaveAndNextController {
  constructor(ordersQueue, editorController) {
    this.queue = ordersQueue;
    this.editor = editorController;
  }

  async saveThenNext(saveFn) {
    const currentId = this.queue.current();
    if (!currentId) return Result.ok(null);
    const res = await saveFn();
    if (!res || res.ok === false) {
      const err = res?.error || new Error("Save failed.");
      return Result.fail(err);
    }
    this.queue.remove(currentId);
    const nextId = this.queue.current() || this.queue.next();
    if (!nextId) return Result.ok(null);
    const load = await this.editor.loadOrder(nextId);
    if (!load.ok) return Result.fail(load.error);
    return Result.ok(nextId);
  }
}


================================================================================
### PLIK: controllers/SaveFlowController.js
================================================================================

// ============================================================================
// Frontend: REWRITE SaveFlowController (Final Version)
// FILE: src/controllers/SaveFlowController.js
// REASON: Implement new save logic.
//         - Build corrected OrderEvent JSON from original.
//         - Build ResubmitRequestDto with 'applyToSimilar' flag.
//         - Call new api.saveResubmission endpoint.
// ============================================================================
// FILE: src/controllers/SaveFlowController.js
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";
import { Address } from "@/domain/WorkbenchModels";

/**
 * ARCHITECTURE: SaveFlowController orchestrates saving a correction and advancing the queue.
 * REFACTORED:
 * - Constructor now takes AddressExceptionApi.
 * - `saveThenAwait` now implements the new "resubmission" flow.
 * - It patches the original OrderEvent JSON with the user's edits.
 * - It builds the ResubmitRequestDto (including correctedRawPayload and applyToSimilar).
 * - It calls api.saveResubmission() instead of the old /approve flow.
 */
export class SaveFlowController {
  constructor(editorFacade, queueService, api = new AddressExceptionApi()) {
    if (!editorFacade) throw new Error("SaveFlowController requires an EditorFacade.");
    if (!queueService) throw new Error("SaveFlowController requires a QueueService.");
    if (!api) throw new Error("SaveFlowController requires an AddressExceptionApi.");

    this.editor = editorFacade;
    this.queue = queueService;
    this.api = api;
  }

  /**
   * Saves the correction and advances to the next item in the queue.
   * @param {string} side - 'pickup', 'delivery', or 'both'. (Used to check which address was edited).
   * @param {boolean} applyToSimilar - Flag from the UI to trigger bulk reprocessing.
   */
  async saveThenAwait(side = "both", applyToSimilar = false) {
    const snap = this.editor.snapshot();
    const orderId = snap.currentOrderId || snap.editor?.detail?.orderId || null;

    // 1. Get the original error Event ID
    const errorEventId = snap.editor?.detail?.relatedError?.eventId || null;
    if (!errorEventId) {
      log.error("[SaveFlow] Cannot save: Missing relatedError.eventId in editor state.", snap.editor?.detail);
      return Result.fail(new Error("SaveFlow: Cannot save, original error event ID is missing."));
    }

    // 2. Get the original OrderEvent payload
    const originalEventJson = snap.editor?.detail?.originalOrderEventJson || null;
    if (!originalEventJson) {
      log.error("[SaveFlow] Cannot save: Missing originalOrderEventJson in editor state.", snap.editor?.detail);
      return Result.fail(new Error("SaveFlow: Cannot save, original order payload is missing."));
    }

    // 3. Reconstruct the *corrected* payload
    let correctedPayload;
    try {
      correctedPayload = this._buildCorrectedPayload(
          originalEventJson,
          snap.editor?.editedPickup,
          snap.editor?.editedDelivery
      );
    } catch (e) {
      log.error("[SaveFlow] Failed to build corrected payload:", e.message);
      return Result.fail(e);
    }

    // 4. Build the ResubmitRequestDto
    const resubmitDto = {
      errorEventId: errorEventId,
      correctedRawPayload: JSON.stringify(correctedPayload),
      applyToSimilar: !!applyToSimilar, // Pass the flag
      // 'correctedName' is not used by the new backend flow
    };

    // 5. Call the new API endpoint
    log.info(`[SaveFlow] Calling saveResubmission for EventID: ${errorEventId}, ApplySimilar: ${applyToSimilar}`);
    const saveResult = await this.api.saveResubmission(errorEventId, resubmitDto);

    if (!saveResult.ok) {
      log.error("[SaveFlow] saveResubmission failed:", saveResult.error);
      return Result.fail(saveResult.error); // Return failure
    }

    log.info(`[SaveFlow] Save successful for Order ID ${orderId}.`);

    // 6. Advance the queue
    const currentQueueId = this.queue.current();
    if (currentQueueId === orderId) {
      this.queue.remove(currentQueueId);
      log.info(`[SaveFlow] Removed Order ID ${currentQueueId} from queue.`);
    } else {
      log.warn(`[SaveFlow] Queue ID ('${currentQueueId}') mismatch saved ID ('${orderId}').`);
    }

    const nextId = this.queue.current() || this.queue.next();
    log.info(`[SaveFlow] Next Order ID in queue: ${nextId || 'None'}`);
    return Result.ok({ success: true, skipped: false, nextOrderId: nextId });
  }

  /**
   * Patches the original OrderEvent JSON with fields from the edited models.
   * @param {string} originalJsonString - The raw JSON of the original OrderEvent.
   * @param {Address} editedPickup - The frontend Address model for pickup.
   * @param {Address} editedDelivery - The frontend Address model for delivery.
   * @returns {object} The patched OrderEvent object.
   */
  _buildCorrectedPayload(originalJsonString, editedPickup, editedDelivery) {
    let payload;
    try {
      payload = JSON.parse(originalJsonString);
    } catch (e) {
      throw new Error("Failed to parse originalOrderEventJson: " + e.message);
    }

    // Overwrite pickup fields if the edited model is provided
    if (editedPickup) {
      payload.pickUpAlias = editedPickup.alias;
      payload.pickUpName = editedPickup.name;
      payload.pickUpStreet = editedPickup.street;
      payload.pickUpHouseNo = editedPickup.houseNumber;
      payload.pickUpPostalCode = editedPickup.postalCode;
      payload.pickUpCity = editedPickup.city;
      payload.pickUpLatitude = editedPickup.latitude;
      payload.pickUpLongitude = editedPickup.longitude;
    }

    // Overwrite delivery fields if the edited model is provided
    if (editedDelivery) {
      payload.deliveryAlias = editedDelivery.alias;
      payload.deliveryName = editedDelivery.name;
      payload.deliveryStreet = editedDelivery.street;
      payload.deliveryHouseNo = editedDelivery.houseNumber;
      payload.deliveryPostalCode = editedDelivery.postalCode;
      payload.deliveryCity = editedDelivery.city;
      payload.deliveryLatitude = editedDelivery.latitude;
      payload.deliveryLongitude = editedDelivery.longitude;
    }

    return payload;
  }
}

// Basic logger shim
const log = {
  info: (...args) => console.info(...args),
  warn: (...args) => console.warn(...args),
  error: (...args) => console.error(...args),
};

================================================================================
### PLIK: controllers/SuggestionListController.js
================================================================================

/**
 * ARCHITECTURE: SuggestionListController manages selection and application of ranked suggestions.
 * It follows the manifesto by isolating list state from UI and delegating application to EditorFacade.
 * Responsibilities:
 * - Hold a cursor over suggestions, navigate next/prev, and apply current suggestion to pickup or delivery.
 * - Coordinate map viewport focusing for visual confirmation.
 */
import { SuggestionSelectionController } from "@/controllers/SuggestionSelectionController";
import { MapViewportPolicyController } from "@/controllers/MapViewportPolicyController";

export class SuggestionListController {
  constructor(editorFacade, mapController) {
    this.editor = editorFacade;
    this.selector = new SuggestionSelectionController();
    this.viewport = new MapViewportPolicyController(mapController);
    this.items = [];
    this.index = -1;
  }

  load(list) {
    this.items = Array.isArray(list) ? list.slice() : [];
    this.index = this.items.length ? 0 : -1;
    return this.snapshot();
  }

  select(i) {
    if (typeof i !== "number" || i < 0 || i >= this.items.length) return this.snapshot();
    this.index = i;
    return this.snapshot();
  }

  next() {
    if (this.items.length === 0) return this.snapshot();
    this.index = Math.min(this.items.length - 1, this.index + 1);
    return this.snapshot();
  }

  prev() {
    if (this.items.length === 0) return this.snapshot();
    this.index = Math.max(0, this.index - 1);
    return this.snapshot();
  }

  async applyTo(side = "pickup") {
    if (this.index < 0 || this.index >= this.items.length) return false;
    const sel = { index: this.index, suggestion: this.items[this.index] };
    const ok = this.selector.accept(this.editor, side, sel);
    if (ok) await this.viewport.focusSuggestion(sel.suggestion);
    return ok;
  }

  snapshot() {
    return {
      items: this.items.slice(),
      index: this.index,
      current: this.index >= 0 ? this.items[this.index] : null,
    };
  }
}


================================================================================
### PLIK: controllers/SuggestionPreviewController.js
================================================================================

// ============================================================================
// Frontend: Update SuggestionPreviewController.js
// FILE: src/controllers/SuggestionPreviewController.js
// REASON: Update 'show' method to accept a 'side' parameter.
// ============================================================================
/**
 * ARCHITECTURE: SuggestionPreviewController coordinates map focusing for a chosen suggestion.
 * It follows the manifesto by isolating viewport behavior from editor and views.
 * REFACTORED: Now accepts a 'side' parameter.
 */
import { MapViewportPolicyController } from "@/controllers/MapViewportPolicyController";

export class SuggestionPreviewController {
  constructor(mapController) {
    this.map = mapController;
    this.policy = new MapViewportPolicyController(mapController);
  }

  /**
   * Shows a suggestion on the map for a specific side.
   * @param {'pickup' | 'delivery'} side
   * @param {object} suggestion
   */
  async show(side, suggestion) {
    if (!suggestion) return false;
    // Pass the side to the policy
    return await this.policy.focusSuggestion(side, suggestion);
  }
}

================================================================================
### PLIK: controllers/SuggestionSelectionController.js
================================================================================

/**
 * ARCHITECTURE: SuggestionSelectionController selects and applies suggestions deterministically.
 * It follows the manifesto by keeping scoring and application separate from UI and transport.
 * Responsibilities:
 * - Pick the best suggestion; apply a chosen index to the editor facade for a given side.
 */
export class SuggestionSelectionController {
  best(baseInput, suggestions) {
    const list = Array.isArray(suggestions) ? suggestions : [];
    if (!list.length) return null;
    let bestIndex = 0;
    let bestScore = -Infinity;
    for (let i = 0; i < list.length; i++) {
      const s = list[i] || {};
      const score = this._score(baseInput, s);
      if (score > bestScore) {
        bestScore = score;
        bestIndex = i;
      }
    }
    return { index: bestIndex, suggestion: list[bestIndex] };
  }

  accept(editorFacade, side, sel) {
    if (!sel || typeof sel.index !== "number") return false;
    if (side === "pickup") {
      const r = editorFacade.acceptPickupSuggestion(sel.index);
      return !!r?.ok;
    }
    if (side === "delivery") {
      const r = editorFacade.acceptDeliverySuggestion(sel.index);
      return !!r?.ok;
    }
    return false;
  }

  _score(base, sug) {
    let score = 0;
    if (typeof sug.matchScore === "number") score += sug.matchScore * 100;
    if (this._eq(base?.city, sug?.city)) score += 5;
    if (this._eq(base?.postalCode, sug?.postalCode)) score += 10;
    if (this._eq(base?.street, sug?.street)) score += 3;
    return score;
  }

  _eq(a, b) {
    return (a || "").toString().trim().toLowerCase() === (b || "").toString().trim().toLowerCase();
  }
}


================================================================================
### PLIK: controllers/TesSuggestionController.js
================================================================================

/**
 * ARCHITECTURE: TesSuggestionController starts TES suggest/search operations and collects results via poller.
 * It follows the manifesto by separating TES IO from UI and merging outputs through a stable contract.
 * Responsibilities:
 * - Trigger suggest-on-demand or search-by-name; poll until done; return normalized suggestions.
 * - Delegate normalization/merging to provided collaborators without leaking TES DTOs to callers.
 */
import apiClient from "@/services/api";
import { TesOperationPoller } from "@/services/TesOperationPoller";
import { SuggestionNormalizer } from "@/services/SuggestionNormalizer";
import { AddressSuggestionMerger } from "@/services/AddressSuggestionMerger";
import { AddressSuggestionRanker } from "@/services/AddressSuggestionRanker";

export class TesSuggestionController {
  constructor(poller = new TesOperationPoller(), normalizer = new SuggestionNormalizer(), merger = new AddressSuggestionMerger(), ranker = new AddressSuggestionRanker()) {
    this.poller = poller;
    this.normalizer = normalizer;
    this.merger = merger;
    this.ranker = ranker;
  }

  async suggestOnDemand(addressDto, baseInputForRanking = null) {
    const start = await apiClient.post("/api/admin/address-verification/suggest-on-demand", addressDto);
    const cid = start?.data?.correlationId;
    if (!cid) throw new Error("TesSuggestionController: missing correlationId.");
    const done = await this.poller.waitFor(cid);
    if (done.status !== "COMPLETED") return [];
    const raw = done.result?.suggestions || [];
    const normalized = this.normalizer.normalizeBatch(raw, "TES");
    const merged = this.merger.merge(baseInputForRanking || addressDto, [normalized]);
    return this.ranker.rank(baseInputForRanking || addressDto, merged);
  }

  async searchByName(query, baseInputForRanking = null) {
    const start = await apiClient.post("/api/admin/address-verification/search-by-name", query, { headers: { "Content-Type": "text/plain" } });
    const cid = start?.data?.correlationId;
    if (!cid) throw new Error("TesSuggestionController: missing correlationId.");
    const done = await this.poller.waitFor(cid);
    if (done.status !== "COMPLETED") return [];
    const raw = done.result?.suggestions || [];
    const normalized = this.normalizer.normalizeBatch(raw, "TES");
    const merged = this.merger.merge(baseInputForRanking || {}, [normalized]);
    return this.ranker.rank(baseInputForRanking || {}, merged);
  }
}


================================================================================
### PLIK: controllers/TriageDashboardController.js
================================================================================

// ============================================================================
// Frontend: Fix TriageDashboardController
// FILE: src/controllers/TriageDashboardController.js (Supersedes previous version)
// REASON: Remove call to non-existent 'getRecentBatches' method.
// ============================================================================
// FILE: src/controllers/TriageDashboardController.js
import { Result } from "@/domain/Result";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";
import { PollingService } from "@/services/PollingService";

export class TriageDashboardController {
  constructor(api = new AddressExceptionApi(), polling = new PollingService()) {
    this.api = api;
    this.polling = polling;
    this.loading = false;
    this.error = null;
    this.kpis = null;
    this.recentBatches = [];
    this.pendingByErrorType = [];
    this._pollHandles = [];
  }

  async loadAll() {
    this.loading = true;
    this.error = null;

    // *** MODIFICATION: Removed getRecentBatches() call ***
    const [kpiRes, typeRes] = await Promise.all([
      this.api.getTriageKpis(),
      // this.api.getRecentBatches(), // <-- This line should be gone
      this.api.getPendingByErrorType(), // <-- This line is correct
    ]);
    // *** END MODIFICATION ***

    // Safety check for kpiRes (solves 'items' of undefined)
    if (!kpiRes.ok) return this._fail(kpiRes.error);
    if (!kpiRes.value) {
      console.warn("TriageDashboardController: getTriageKpis returned OK but value is null/undefined.");
      this.kpis = { pendingReviewCount: 0, automatedClearancePercent: 0, avgResolutionMinutes: null };
    } else {
      this.kpis = kpiRes.value;
    }

    // Safety check for batchRes (Set to empty array)
    this.recentBatches = [];

    // Safety check for typeRes
    if (!typeRes.ok) return this._fail(typeRes.error);
    this.pendingByErrorType = Array.isArray(typeRes.value) ? typeRes.value : [];

    this.loading = false;
    return Result.ok(this.snapshot());
  }

  startPolling(intervalMs = 10000) {
    this.stopPolling();
    const k = this.polling.start("kpis", intervalMs, async () => {
      const r = await this.api.getTriageKpis();
      if (r.ok && r.value) this.kpis = r.value;
    });
    // *** MODIFICATION: Removed polling for batches ***
    // const b = this.polling.start("batches", intervalMs, async () => {
    //   const r = await this.api.getRecentBatches();
    //   if (r.ok) this.recentBatches = Array.isArray(r.value) ? r.value : [];
    // });
    // *** END MODIFICATION ***
    const e = this.polling.start("errorsByType", intervalMs, async () => {
      const r = await this.api.getPendingByErrorType();
      if (r.ok) this.pendingByErrorType = Array.isArray(r.value) ? r.value : [];
    });
    this._pollHandles = [k, e]; // Removed 'b' from handles
    return this._pollHandles.slice();
  }

  stopPolling() {
    this.polling.stopAll();
    this._pollHandles = [];
  }

  snapshot() {
    return {
      loading: this.loading,
      error: this.error,
      kpis: this.kpis,
      recentBatches: this.recentBatches.slice(),
      pendingByErrorType: this.pendingByErrorType.slice(),
    };
  }

  _fail(err) {
    this.loading = false;
    this.error = err?.message || "Dashboard load failed.";
    return Result.fail(err);
  }
}

================================================================================
### PLIK: controllers/VerificationGuardController.js
================================================================================

/**
 * ARCHITECTURE: VerificationGuardController prevents unnecessary verification calls when input is incomplete.
 * It follows the manifesto by enforcing minimal field requirements before hitting providers.
 * Responsibilities:
 * - Check street, postal, and city presence; expose shouldVerify() with reason codes for UI hints.
 * - Reduce wasted quota and noise during live typing.
 */
export class VerificationGuardController {
  constructor() {
    this.required = ["street", "postalCode", "city"];
  }

  shouldVerify(input) {
    const missing = [];
    for (const f of this.required) {
      if (!input || !String(input[f] || "").trim()) missing.push(f);
    }
    if (missing.length) return { allow: false, reason: "MISSING_FIELDS", missing };
    return { allow: true, reason: "OK", missing: [] };
  }
}


================================================================================
### PLIK: controllers/VerificationPipelineController.js
================================================================================

/**
 * ARCHITECTURE: VerificationPipelineController composes timeout, merger, and ranking into a single step.
 * It follows the manifesto by hiding orchestration details behind a single run() method.
 * Responsibilities:
 * - Execute geocode + places + TES with budgets; merge and rank; return final suggestions list.
 */
import { VerificationTimeoutController } from "@/controllers/VerificationTimeoutController";
import { AddressSuggestionMerger } from "@/services/AddressSuggestionMerger";
import { AddressSuggestionRanker } from "@/services/AddressSuggestionRanker";

export class VerificationPipelineController {
  constructor(timeoutController, merger = new AddressSuggestionMerger(), ranker = new AddressSuggestionRanker()) {
    this.timeout = timeoutController;
    this.merger = merger;
    this.ranker = ranker;
  }

  async run(baseInput, ms = 1500) {
    const phased = await this.timeout.verifyWithin(baseInput, ms);
    const merged = this.merger.merge(baseInput, [phased.suggestions]);
    const ranked = this.ranker.rank(baseInput, merged);
    return { instant: phased.instant, suggestions: ranked, elapsed: phased.elapsed };
  }
}


================================================================================
### PLIK: controllers/VerificationTelemetryController.js
================================================================================

/**
 * ARCHITECTURE: VerificationTelemetryController (Stub) would be responsible for
 * emitting detailed, structured telemetry events specific to the address
 * verification lifecycle (e.g., timings, provider success/fail, user choices).
 * Composes the base TelemetryService.
 */
import { TelemetryService } from "@/services/TelemetryService"; // Assuming base service exists

export class VerificationTelemetryController {
    constructor(telemetryService = new TelemetryService()) {
        this.telemetry = telemetryService;
        this.currentCorrelation = null;
        this.startTime = 0;
    }

    /**
     * Starts a new verification telemetry trace.
     * @param {string} correlationId - A unique ID for this verification flow.
     * @returns {string} The correlation ID.
     */
    start(correlationId) {
        this.currentCorrelation = correlationId || `telemetry-${Date.now()}-${Math.random()}`;
        this.startTime = Date.now();
        this.telemetry.emit({
            category: "verification",
            name: "start",
            corr: this.currentCorrelation,
        });
        return this.currentCorrelation;
    }

    /**
     * Marks a specific milestone within the verification flow.
     * @param {string} name - Name of the milestone (e.g., "verify-start", "geocode-finish").
     * @param {object} data - Additional context data.
     */
    mark(name, data = {}) {
        this.telemetry.emit({
            category: "verification",
            name: name,
            data: {
                ...data,
                elapsedMs: Date.now() - this.startTime,
            },
            corr: this.currentCorrelation,
        });
    }

    /**
     * Finishes the verification telemetry trace with a final status.
     * @param {string} status - The final outcome (e.g., "ok", "save-failed", "invalid").
     * @param {object} data - Additional context data.
     */
    finish(status, data = {}) {
        this.telemetry.emit({
            category: "verification",
            name: "finish",
            data: {
                ...data,
                status,
                totalElapsedMs: Date.now() - this.startTime,
            },
            corr: this.currentCorrelation,
        });
        // Clear context for the next trace
        this.currentCorrelation = null;
        this.startTime = 0;
    }
}

================================================================================
### PLIK: controllers/VerificationTimeoutController.js
================================================================================

/**
 * ARCHITECTURE: VerificationTimeoutController applies latency budgets to geocode and suggestion steps.
 * It follows the manifesto by composing LatencyBudget with provider adapters to keep UI responsive.
 * Responsibilities:
 * - Run geocode and suggestions with independent timeouts; return partial results when needed.
 * - Provide verifyWithin() that yields {instant,suggestions,elapsed:{geo,suggest}}.
 */
import { LatencyBudget } from "@/services/LatencyBudget";

export class VerificationTimeoutController {
  constructor(geocodeController, placesAdapter, tesController, budget = new LatencyBudget()) {
    this.geocode = geocodeController;
    this.places = placesAdapter;
    this.tes = tesController;
    this.budget = budget;
  }

  async verifyWithin(baseInput, ms = 1200) {
    const geo = await this.budget.runWithTimeout(() => this.geocode.geocode(baseInput), ms, null);
    const places = await this.budget.runWithTimeout(
      () => (this.places ? this.places.suggest(this._freeText(baseInput), baseInput.country || "PL") : Promise.resolve([])),
      ms,
      []
    );
    const tes = await this.budget.runWithTimeout(() => this.tes.suggestOnDemand(baseInput, baseInput), ms * 2, []);
    return {
      instant: geo.value ? { latitude: geo.value.lat ?? null, longitude: geo.value.lon ?? null } : null,
      suggestions: ([]).concat(places.value || []).concat(tes.value || []),
      elapsed: { geocodeMs: geo.elapsedMs, placesMs: places.elapsedMs, tesMs: tes.elapsedMs },
    };
  }

  _freeText(a) {
    const line1 = a.houseNumber ? `${a.street} ${a.houseNumber}` : a.street || "";
    return `${line1}, ${a.postalCode || ""} ${a.city || ""}`.trim();
  }
}


================================================================================
### PLIK: controllers/WorklistExportController.js
================================================================================

/**
 * ARCHITECTURE: WorklistExportController generates CSV exports for selected/all rows from the worklist.
 * It follows the manifesto by isolating export formatting from views and transport concerns.
 * Responsibilities:
 * - exportSelected(items, ids): download CSV for selected IDs.
 * - exportAll(items): download CSV for all current rows.
 */
export class WorklistExportController {
  constructor() {
    this.headers = [
      "orderId",
      "customerName",
      "source",
      "errorType",
      "processingStatus",
      "updatedAt",
    ];
  }

  exportSelected(items, ids) {
    const set = new Set(Array.isArray(ids) ? ids : []);
    const rows = (Array.isArray(items) ? items : []).filter(r => set.has(r.orderId));
    if (!rows.length) return false;
    return this._download(rows, "worklist_selected.csv");
  }

  exportAll(items) {
    const rows = Array.isArray(items) ? items : [];
    if (!rows.length) return false;
    return this._download(rows, "worklist_all.csv");
  }

  _download(rows, filename) {
    const csv = this._toCsv(rows);
    const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.href = url;
    link.download = filename || "export.csv";
    link.style.display = "none";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    return true;
  }

  _toCsv(rows) {
    const head = this.headers.join(",");
    const lines = rows.map(r => this.headers.map(h => this._esc(r?.[h])).join(","));
    return [head, ...lines].join("\n");
  }

  _esc(v) {
    const s = (v == null ? "" : String(v));
    if (/[",\n]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
    return s;
  }
}


================================================================================
### PLIK: controllers/WorklistFacade.js
================================================================================

// ============================================================================
// Frontend: Fix WorklistFacade import
// FILE: src/controllers/WorklistFacade.js (Supersedes previous version)
// REASON: Correct the case of the 'worklistStore' import to 'WorklistStore'
//         to match the filename, fixing the Docker build failure.
// ============================================================================
// FILE: src/controllers/WorklistFacade.js
import { useWorklistStore } from "@/stores/WorklistStore.js"; // *** CORRECTED FILE CASE ***
import { PollingService } from "@/services/PollingService.js";
import { Result } from "@/domain/Result";

export class WorklistFacade {
    constructor(polling = new PollingService()) {
        this._store = useWorklistStore();
        this.poll = polling;
        this._pollHandle = null;
    }

    async initAndLoad(filters = {}) {
        if (Object.keys(filters).length > 0) {
            this._store.filter = this._store.filter.withPatch(filters);
            this._store.pagination.currentPage = 1;
        }
        const result = await this._store.loadWorklistPage();
        return result.ok ? Result.ok(this.snapshot()) : Result.fail(result.error);
    }

    startPolling(intervalMs = 15000) {
        if (this._pollHandle) {
            this.stopPolling();
        }
        this._pollHandle = this.poll.start("worklist", intervalMs, async () => {
            // CORRECTED: Use the correct store action name 'loadWorklistPage'
            await this._store.loadWorklistPage();
        });
        // Removed console.log for production readiness
        return true;
    }

    stopPolling() {
        if (this._pollHandle) {
            this.poll.stop("worklist");
            this._pollHandle = null;
            // Removed console.log for production readiness
            return true;
        }
        return false;
    }

    snapshot() {
        return {
            filter: { ...this._store.filter },
            items: [...this._store.items],
            pagination: { ...this._store.pagination },
            loading: this._store.loading,
            error: this._store.error,
            selection: [...this._store.selection],
        };
    }

    async applyFilterPatch(patch) {
        return await this._store.applyFilterPatch(patch);
    }

    async resetFilter() {
        return await this._store.resetFilter();
    }

    async goToPage(pageNumber) {
        return await this._store.goToPage(pageNumber);
    }

    async changePageSize(size) {
        return await this._store.changePageSize(size);
    }

    toggleSelection(orderId) {
        this._store.toggleSelection(orderId);
    }

    clearSelection() {
        this._store.clearSelection();
    }

    getSelection() {
        return [...this._store.selection];
    }
}


================================================================================
### PLIK: controllers/WorklistKpiController.js
================================================================================

/**
 * ARCHITECTURE: WorklistKpiController computes KPIs from the current worklist dataset.
 * It follows the manifesto by isolating KPI math from views and data transport.
 * Responsibilities:
 * - Compute pending review count, automated clearance percent, and average resolution minutes.
 * - Return a KpiViewModel ready to render in the dashboard.
 */
import { KpiViewModel } from "@/viewmodels/KpiViewModel";

export class WorklistKpiController {
  compute(items) {
    const arr = Array.isArray(items) ? items : [];

    const total = arr.length;
    const pending = arr.filter(x => (x?.processingStatus || "").toUpperCase() === "ADDRESS_NEEDS_REVIEW").length;
    const autoCleared = arr.filter(x => (x?.processingStatus || "").toUpperCase() === "ADDRESS_VALIDATED").length;

    const clearancePercent = total > 0 ? (autoCleared / total) * 100 : 0;

    const minutes = [];
    for (const r of arr) {
      const created = r?.createdAt ? new Date(r.createdAt).getTime() : null;
      const updated = r?.updatedAt ? new Date(r.updatedAt).getTime() : null;
      if (created && updated && updated >= created) {
        const diffMin = (updated - created) / 60000;
        if (Number.isFinite(diffMin)) minutes.push(diffMin);
      }
    }
    const avgMinutes = minutes.length ? minutes.reduce((a, b) => a + b, 0) / minutes.length : 0;

    return new KpiViewModel({
      pending,
      clearancePercent,
      avgMinutes,
    });
  }
}


================================================================================
### PLIK: controllers/WorklistSelectionController.js
================================================================================

/**
 * ARCHITECTURE: WorklistSelectionController manages single, multi, and range selections in the grid.
 * It follows the manifesto by isolating selection math from visual components.
 * Responsibilities:
 * - Toggle, select range with anchors, and expose a stable array of selected IDs.
 */
export class WorklistSelectionController {
  constructor() {
    this._selected = new Set();
    this._lastAnchorIndex = null;
  }

  toggle(id, index) {
    if (this._selected.has(id)) this._selected.delete(id);
    else this._selected.add(id);
    this._lastAnchorIndex = typeof index === "number" ? index : this._lastAnchorIndex;
    return this.ids();
  }

  set(ids) {
    this._selected = new Set(Array.isArray(ids) ? ids : []);
    return this.ids();
  }

  clear() {
    this._selected.clear();
    this._lastAnchorIndex = null;
    return [];
  }

  range(allIds, toIndex) {
    if (!Array.isArray(allIds) || typeof this._lastAnchorIndex !== "number" || typeof toIndex !== "number") return this.ids();
    const [a, b] = [this._lastAnchorIndex, toIndex].sort((x, y) => x - y);
    for (let i = a; i <= b; i++) this._selected.add(allIds[i]);
    return this.ids();
  }

  ids() {
    return Array.from(this._selected.values());
  }
}


================================================================================
### PLIK: views/AddressHistoryView.vue
================================================================================

<template>
  <div class="container mx-auto p-4 sm:p-6 lg:p-8">
    <div class="bg-gradient-to-r from-cyan-700 to-blue-900 text-white p-6 rounded-xl shadow-2xl mb-8">
      <div>
        <h1 class="text-3xl sm:text-4xl font-bold">Ostatnio Dodane Adresy</h1>
        <p class="mt-2 text-blue-200">Historia adresów, które zostały niedawno zweryfikowane i dodane do bazy TrackIT.</p>
      </div>
    </div>

    <div v-if="isLoading" class="text-center py-16">
      <div class="animate-spin rounded-full h-12 w-12 border-t-4 border-b-4 border-blue-500 mx-auto"></div>
      <p class="text-lg text-slate-500 mt-5">Ładowanie historii adresów...</p>
    </div>

    <div v-else-if="addresses.length === 0" class="text-center py-16 bg-white rounded-xl shadow-md">
      <svg class="mx-auto h-16 w-16 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
      <h3 class="mt-3 text-lg font-medium text-slate-800">Brak danych</h3>
      <p class="mt-1 text-sm text-slate-500">Nie znaleziono ostatnio dodanych adresów w bazie danych.</p>
    </div>

    <div v-else class="bg-white rounded-xl shadow-xl overflow-x-auto">
      <table class="min-w-full divide-y divide-slate-200">
        <thead class="bg-slate-50">
          <tr>
            <th class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Alias</th>
            <th class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Nazwa (Attention Name)</th>
            <th class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Adres</th>
            <th class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Data Dodania</th>
            <th class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Cust ID</th>
          </tr>
        </thead>
        <tbody class="bg-white divide-y divide-slate-200">
          <tr v-for="(address, index) in addresses" :key="index" class="hover:bg-slate-50">
            <td class="px-4 py-3 whitespace-nowrap text-sm font-medium text-slate-800">{{ address.alias }}</td>
            <td class="px-4 py-3 whitespace-nowrap text-sm text-slate-600">{{ address.attentionName }}</td>
            <td class="px-4 py-3 whitespace-nowrap text-sm text-slate-600">
              {{ address.street }} {{ address.houseNo }}, {{ address.postalCode }} {{ address.city }}
            </td>
            <td class="px-4 py-3 whitespace-nowrap text-sm text-slate-600">{{ formatDate(address.createdAt) }}</td>
            <td class="px-4 py-3 whitespace-nowrap text-sm text-slate-600">{{ address.custId }}</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import apiClient from '@/services/api';

const addresses = ref([]);
const isLoading = ref(false);

const fetchRecentAddresses = async () => {
  isLoading.value = true;
  try {
    const response = await apiClient.get('/tes-api/address-history/recent?limit=100');
    addresses.value = response.data;
  } catch (error) {
    console.error('Błąd podczas pobierania historii adresów:', error);
    addresses.value = [];
  } finally {
    isLoading.value = false;
  }
};

const formatDate = (dateString) => {
  if (!dateString) return 'N/A';
  const date = new Date(dateString);
  return date.toLocaleString('pl-PL', { dateStyle: 'short', timeStyle: 'medium' });
};

onMounted(() => {
  fetchRecentAddresses();
});
</script>

================================================================================
### PLIK: views/AddressUploadView.vue
================================================================================

// ============================================================================
// Frontend: New Placeholder View
// FILE: src/views/HubRulesView.vue
// REASON: Fixes "Failed to resolve import" error during build.
// ============================================================================
<template>
  <div class="page-container p-4">
    <h1 class="text-2xl font-bold text-gray-700">Hub Rules Management</h1>
    <div class="mt-4 p-6 bg-white rounded-lg shadow-md">
      <p class="text-gray-600">This is a placeholder page for administering Hub Rules.</p>
      <p class="mt-2 text-gray-500">Content to be added here.</p>
    </div>
  </div>
</template>

<script setup>
import { onMounted } from 'vue';

onMounted(() => {
  console.log("HubRulesView.vue placeholder loaded.");
});
</script>

<style scoped>
/* Scoped styles for this view if needed */
.page-container {
  max-width: 1200px;
  margin: 0 auto;
}
</style>


================================================================================
### PLIK: views/AedAdminView.vue
================================================================================

<template>
  <div class="admin-view-container">
    <h2>AED (MG) SFTP Export</h2>
    <p>
      Manually trigger an export of 'MG' customer statuses to the AED SFTP server.
    </p>
    <p class="warning-text">
      <strong>Warning:</strong> This queries all 'MG' statuses recorded after the
      specified start time, regardless of whether they were previously exported.
      Use this only if you suspect statuses were missed by the automated process.
    </p>

    <div class="export-controls">
      <div class="form-group">
        <label for="start-time">Export Statuses From (Local Time):</label>
        <input
            id="start-time"
            type="datetime-local"
            v-model="store.startTime"
            :disabled="store.isLoading"
        />
      </div>

      <button @click="handleTriggerExport" :disabled="store.isLoading || !store.startTime">
        {{ store.isLoading ? 'Exporting...' : 'Trigger Manual Export' }}
      </button>
    </div>

    <div v-if="store.isLoading" class="feedback-message loading">
      Processing request...
    </div>
    <div v-if="store.error" class="feedback-message error">
      <strong>Error:</strong> {{ store.error }}
    </div>
    <div v-if="store.successMessage" class="feedback-message success">
      <strong>Success:</strong> {{ store.successMessage }}
    </div>
  </div>
</template>

<script setup>
import { useAedSftpStore } from '@/stores/useAedSftpStore';
import { onMounted } from 'vue';

const store = useAedSftpStore();

// Clear old messages on component mount
onMounted(() => {
  store.error = null;
  store.successMessage = null;
  store.lastExportCount = 0;
});

const handleTriggerExport = () => {
  if (confirm(`Are you sure you want to export all 'MG' statuses since ${store.startTime}?`)) {
    store.triggerManualExport();
  }
};
</script>

<style scoped>
.admin-view-container {
  padding: 2rem;
  max-width: 800px;
  margin: 2rem auto;
  border: 1px solid #ddd;
  border-radius: 8px;
  background: #f9f9f9;
}

h2 {
  border-bottom: 2px solid #004a99; /* DANXILS blue */
  padding-bottom: 0.5rem;
  color: #004a99;
}

.warning-text {
  background-color: #fffbe6;
  border: 1px solid #ffe58f;
  padding: 1rem;
  border-radius: 4px;
  color: #a0522d;
}

.export-controls {
  margin-top: 1.5rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.form-group {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

label {
  font-weight: bold;
  font-size: 0.9rem;
}

input[type="datetime-local"] {
  padding: 0.5rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-family: inherit;
  font-size: 1rem;
}

button {
  padding: 0.75rem 1rem;
  font-size: 1rem;
  font-weight: bold;
  color: #fff;
  background-color: #004a99; /* DANXILS blue */
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s;
}

button:hover:not(:disabled) {
  background-color: #003366; /* Darker blue */
}

button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}

.feedback-message {
  margin-top: 1.5rem;
  padding: 1rem;
  border-radius: 4px;
  border: 1px solid transparent;
}

.loading {
  background-color: #e6f7ff;
  border-color: #b3e0ff;
  color: #0056b3;
}

.error {
  background-color: #fff1f0;
  border-color: #ffccc7;
  color: #d9363e;
}

.success {
  background-color: #f6ffed;
  border-color: #d9f7be;
  color: #389e0d;
}
</style>

================================================================================
### PLIK: views/ChangePasswordView.vue
================================================================================

<script setup>
import { ref } from 'vue';

const oldPassword = ref('');
const newPassword = ref('');
const confirmPassword = ref('');
const message = ref('');
const error = ref('');

const handleChangePassword = () => {
  // Reset messages
  message.value = '';
  error.value = '';

  if (newPassword.value !== confirmPassword.value) {
    error.value = "New passwords do not match.";
    return;
  }

  // --- UZUPEŁNIJ ---
  // Tutaj należy dodać wywołanie do API w celu zmiany hasła.
  // Prawdopodobnie trzeba będzie stworzyć nową akcję w `authStore`
  // lub dedykowanym `userStore`.
  console.log('Changing password for:', {
    oldPassword: oldPassword.value,
    newPassword: newPassword.value,
  });

  // Po pomyślnym wywołaniu API
  message.value = "Password changed successfully!";
  oldPassword.value = '';
  newPassword.value = '';
  confirmPassword.value = '';
};
</script>

<template>
    <div class="bg-white p-6 rounded-lg shadow-md">
        <h1 class="text-2xl font-bold text-gray-800 mb-6">Change Password</h1>
        <form @submit.prevent="handleChangePassword" class="space-y-4 max-w-lg">
            <div>
                <label for="oldPassword" class="block text-sm font-medium text-gray-700">Old Password</label>
                <input type="password" id="oldPassword" v-model="oldPassword" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" required>
            </div>
            <div>
                <label for="newPassword" class="block text-sm font-medium text-gray-700">New Password</label>
                <input type="password" id="newPassword" v-model="newPassword" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" required>
            </div>
            <div>
                <label for="confirmPassword" class="block text-sm font-medium text-gray-700">Confirm New Password</label>
                <input type="password" id="confirmPassword" v-model="confirmPassword" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" required>
            </div>
            
            <div v-if="error" class="text-red-600 text-sm">{{ error }}</div>
            <div v-if="message" class="text-green-600 text-sm">{{ message }}</div>

            <div>
                <button type="submit" class="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                    Update Password
                </button>
            </div>
        </form>
    </div>
</template>

================================================================================
### PLIK: views/CorrectionEditorView.vue
================================================================================

<template>
  <div class="p-4 sm:p-6 lg:p-8">
    <div v-if="state.loading" class="text-center">
      <p>Loading order details...</p>
    </div>
    <div v-else-if="state.error" class="text-red-500 text-center">
      <p>
        Failed to load order details: {{ state.error }}
        <span v-if="orderId"> (ID: {{ orderId }})</span>
      </p>
    </div>

    <div v-else-if="state.detail" class="space-y-8">
      <PageHeader
          :title="`Correction Editor (Barcode: ${state.detail.barcode})`"
          :subtitle="`Source: ${state.detail.sourceSystem} | Status: ${state.detail.processingStatus}`"
      />

      <div class="mt-8" style="min-height: 400px">
        <div ref="mapContainer" style="height: 400px; width: 100%; border-radius: 8px"></div>
        <div v-if="routeInfo" class="mt-4 text-center text-gray-700 dark:text-gray-200">
          <p>
            <strong>Distance:</strong> {{ (routeInfo.distance / 1000).toFixed(2) }} km |
            <strong>Duration:</strong> {{ (routeInfo.duration / 60).toFixed(0) }} minutes
          </p>
        </div>
      </div>

      <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <AddressCorrectionCard
            title="Pickup Address"
            side="pickup"
            :original-address="state.detail.originalPickup"
            :stored-address="state.detail.pickupStoredAddress"
            :reason-code="state.detail.pickupReasonCode"
            :is-pending="isPending"
            :editable-address="state.editedPickup"
            :geocode-loading="state.geocodeLoading"
            @update:editableAddress="updateAddress('pickup', $event)"
            @geocode="handleGeocode('pickup')"
            @save="handleSave('pickup')"
            @use-original="handleUseOriginal('pickup')"
        />

        <AddressCorrectionCard
            title="Delivery Address"
            side="delivery"
            :original-address="state.detail.originalDelivery"
            :stored-address="state.detail.deliveryStoredAddress"
            :reason-code="state.detail.deliveryReasonCode"
            :is-pending="isPending"
            :editable-address="state.editedDelivery"
            :geocode-loading="state.geocodeLoading"
            @update:editableAddress="updateAddress('delivery', $event)"
            @geocode="handleGeocode('delivery')"
            @save="handleSave('delivery')"
            @use-original="handleUseOriginal('delivery')"
        />
      </div>

      <div
          v-if="isPending"
          class="mt-8 p-4 bg-white dark:bg-gray-800 shadow rounded-lg flex flex-col sm:flex-row items-center justify-between gap-4"
      >
        <div class="flex items-center">
          <input
              id="applyToSimilar"
              type="checkbox"
              v-model="applyToSimilar"
              class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
          />
          <label for="applyToSimilar" class="ml-2 block text-sm text-gray-900 dark:text-gray-100"
          >Apply this correction to all similar pending errors</label
          >
        </div>

        <div class="flex items-center space-x-2">
          <button
              @click="handleSave('both')"
              :disabled="state.saveLoading"
              class="rounded-md bg-blue-600 px-4 py-2 text-sm font-semibold text-white shadow-sm hover:bg-blue-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-600 disabled:opacity-50"
          >
            {{ state.saveLoading ? 'Saving...' : 'Save Both & Go to Next' }}
          </button>
        </div>
      </div>
      <div v-else class="mt-8 p-4 bg-white dark:bg-gray-800 shadow rounded-lg text-center">
        <p class="font-semibold text-gray-700 dark:text-gray-200">
          This order is not in a 'PENDING_VERIFICATION' state and cannot be corrected. (Status:
          {{ state.detail.processingStatus }})
        </p>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, reactive, computed, onMounted, onUnmounted, inject, nextTick, watch } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { useToast } from '@/composables/useToast.js';
import PageHeader from '@/components/PageHeader.vue';
import AddressCorrectionCard from '@/components/AddressCorrectionCard.vue';

// Import Manifesto architecture controllers
import { MapController } from "@/controllers/MapController.js";
import { EditorFacade } from "@/controllers/EditorFacade.js";
import { SaveFlowController } from "@/controllers/SaveFlowController.js";
import { IdempotentSaveController } from "@/controllers/IdempotentSaveController.js";
import { EditorCommandBus } from "@/controllers/EditorCommandBus.js";
import { useWorklistStore } from '@/stores/WorklistStore.js'; // To get the queue
import { Address } from '@/domain/WorkbenchModels.js';

// === Injections ===
const orchestrator = inject("orchestrator");
const geoRuntime = inject("geoRuntime");
const showNotification = inject("showNotification");
const toast = useToast();

// === Route & Store ===
const route = useRoute();
const router = useRouter();
const worklistStore = useWorklistStore();
const orderId = ref(route.params.id);

// === Local State ===
const state = reactive({
  loading: true,
  error: null,
  detail: null,
  editedPickup: new Address(),
  editedDelivery: new Address(),
  geocodeLoading: false,
  saveLoading: false,
});
const applyToSimilar = ref(false);
const routeInfo = ref(null);
const mapContainer = ref(null); // DOM ref for map

// === Controller Setup ===
let mapController = null;
let editorFacade = null;
let saveFlow = null;
let commandBus = null;

const isPending = computed(
    () => state.detail?.processingStatus === 'PENDING_VERIFICATION'
);

// === Lifecycle Hooks ===
onMounted(async () => {
  if (!orchestrator || !geoRuntime) {
    state.error = "Critical error: Orchestrator or GeoRuntime not injected.";
    state.loading = false;
    return;
  }

  // 1. Initialize Editor Facade (mapController is null for now)
  editorFacade = orchestrator.getEditor(null);

  // 2. Initialize Save Controllers
  const saveController = new IdempotentSaveController();
  saveFlow = new SaveFlowController(editorFacade, worklistStore, saveController);
  commandBus = new EditorCommandBus(editorFacade, saveFlow);

  // 3. Load Order Data (this will trigger the 'watch' block to init the map)
  await loadOrderData();
});

onUnmounted(() => {
  // Clean up map
  if (mapController) {
    mapController.destroy();
    mapController = null;
  }
});

// *** FIX: Use a watch to initialize the map ***
// This watch fires when the 'mapContainer' ref changes.
// 1. On load, it's null.
// 2. After loadOrderData() sets state.detail, Vue renders the <div>.
// 3. Vue attaches the <div> to the ref, so mapContainer.value becomes non-null.
// 4. This 'watch' block fires, and we can safely initialize the map.
watch(mapContainer, async (newMapEl) => {
  if (newMapEl && !mapController) { // Only init if we have the element AND map isn't already initted
    log.info("Map container is now in DOM. Initializing MapController...");
    try {
      const mapAdapter = geoRuntime.mapAdapter();
      mapController = new MapController(mapAdapter);
      await mapController.init(newMapEl, { lat: 52.23, lon: 21.01, zoom: 6 });

      // Inject the map into the facade
      editorFacade.preview = orchestrator.createPreviewController(mapController);
      log.info("MapController initialized and injected into facade.");

      // Now draw the initial route
      if (state.editedPickup && state.editedDelivery) {
        await editorFacade.preview.policy.showAndFitRoute(
            state.editedPickup,
            state.editedDelivery
        );
        log.info("Initial route and markers drawn.");
      }

      // And fetch route stats
      await refreshRouteInfo();

    } catch (err) {
      log.error("Failed to initialize MapController in watch block:", err);
      toast.error("Failed to load map: " + err.message, 10000);
    }
  } else if (!newMapEl && mapController) {
    // This happens on unmount/reload
    log.info("Map container removed. Destroying map controller.");
    await mapController.destroy();
    mapController = null;
    if (editorFacade) editorFacade.preview = null;
  }
});

// === Methods ===
async function loadOrderData() {
  state.loading = true;
  state.error = null;

  // Destroy the old map controller IF it exists
  // This sets mapContainer.value to null (when v-if hides it), triggering the watch's cleanup
  if (mapController) {
    await mapController.destroy();
    mapController = null;
    if (editorFacade) editorFacade.preview = null;
  }

  // Set detail to null to hide the old view and unmount the mapContainer ref
  state.detail = null;

  const result = await editorFacade.load(orderId.value);

  if (result.ok) {
    const snap = editorFacade.snapshot().editor;
    // Setting these will trigger the v-else-if and THEN the mapContainer watch
    state.detail = snap.detail;
    state.editedPickup = snap.editedPickup;
    state.editedDelivery = snap.editedDelivery;
  } else {
    state.error = result.error.message;
    toast.error(`Failed to load order: ${state.error}`, 10000);
  }
  state.loading = false;
}

// Fetches route stats from OSRM (via proxy)
async function refreshRouteInfo() {
  if (!geoRuntime || !geoRuntime._config.routingUrl) {
    log.warn("Cannot refresh route info: No routingUrl in geoRuntime.");
    return;
  }

  const p = state.editedPickup;
  const d = state.editedDelivery;

  if (!p?.longitude || !p?.latitude || !d?.longitude || !d?.latitude) {
    routeInfo.value = null;
    return;
  }

  const coords = `${p.longitude},${p.latitude};${d.longitude},${d.latitude}`;
  const url = `${geoRuntime._config.routingUrl}/route/v1/driving/${coords}?overview=full&geometries=geojson&steps=false`;

  try {
    const response = await fetch(url); // Use fetch, as it's not an API call
    if (!response.ok) throw new Error(`OSRM responded with ${response.status}`);
    const data = await response.json();
    if (data && data.code === 'Ok' && data.routes && data.routes.length > 0) {
      routeInfo.value = {
        distance: data.routes[0].distance,
        duration: data.routes[0].duration,
      };
    } else {
      routeInfo.value = null;
    }
  } catch (error) {
    log.error('Error fetching OSRM route info:', error);
    routeInfo.value = null;
    toast.error(`Could not calculate route: ${error.message}`, 4000);
  }
}

// Update local state and facade state
function updateAddress(side, newAddressObject) {
  if (side === 'pickup') {
    state.editedPickup = newAddressObject;
    editorFacade.setManualPickup(newAddressObject);
  } else {
    state.editedDelivery = newAddressObject;
    editorFacade.setManualDelivery(newAddressObject);
  }
  // After manual edit, refresh route
  refreshRouteInfo();
  if (mapController) {
    editorFacade.refreshRoute(); // Redraw map line
  }
}

async function handleGeocode(side) {
  state.geocodeLoading = true;
  toast.info(`Geocoding ${side} address...`, 2000);

  // This uses the Manifesto stack (GeoRuntime -> NominatimAdapter)
  const result = await editorFacade.geocodeAndFocus(side);

  if (result.ok) {
    const snap = editorFacade.snapshot().editor;
    if (side === 'pickup') {
      state.editedPickup = snap.editedPickup;
    } else {
      state.editedDelivery = snap.editedDelivery;
    }
    await editorFacade.refreshRoute(); // Redraw route
    await refreshRouteInfo(); // Get new stats
    toast.success('Geocoding successful. Address updated.', 3000);
  } else {
    log.error(`Geocode failed for ${side}:`, result.error);
    toast.error(`Geocoding failed: ${result.error.message}`, 5000);
  }
  state.geocodeLoading = false;
}

function handleUseOriginal(side) {
  if (side === 'pickup') {
    commandBus.useOriginalPickup();
  } else {
    commandBus.useOriginalDelivery();
  }
  // Update local state from facade
  const snap = editorFacade.snapshot().editor;
  state.editedPickup = snap.editedPickup;
  state.editedDelivery = snap.editedDelivery;

  editorFacade.refreshRoute();
  refreshRouteInfo();
  toast.info(`Original ${side} address restored.`, 2000);
}

async function handleSave(side) {
  state.saveLoading = true;
  let result;

  try {
    if (side === 'pickup') {
      toast.info("Saving pickup and fetching next order...", 3000);
      result = await saveFlow.saveThenAwait('pickup', applyToSimilar.value);
    } else if (side === 'delivery') {
      toast.info("Saving delivery and fetching next order...", 3000);
      result = await saveFlow.saveThenAwait('delivery', applyToSimilar.value);
    } else {
      toast.info("Saving both and fetching next order...", 3000);
      result = await saveFlow.saveThenAwait('both', applyToSimilar.value);
    }

    if (result.ok) {
      if (result.value.nextOrderId) {
        toast.success("Save successful! Loading next order.", 3000);
        router.push({ name: 'editor', params: { id: result.value.nextOrderId } });
        // Reload data for the new ID
        orderId.value = result.value.nextOrderId;
        await loadOrderData();
      } else {
        toast.success("Save successful! No more orders in queue.", 4000);
        router.push({ name: 'worklist' });
      }
    } else {
      throw result.error;
    }
  } catch (e) {
    log.error(`Save flow failed for side '${side}':`, e);
    toast.error(`Save failed: ${e.message}`, 10000);
  } finally {
    state.saveLoading = false;
  }
}

// Basic logger shim
const log = {
  info: (...args) => console.info(...args),
  warn: (...args) => console.warn(...args),
  error: (...args) => console.error(...args),
};
</script>

================================================================================
### PLIK: views/DashboardView.vue
================================================================================

<script setup>
import { useAuthStore } from '@/stores/authStore';
const authStore = useAuthStore();
</script>

<template>
  <div>
    <h1 class="text-3xl font-bold text-gray-800 mb-4">Welcome, {{ authStore.username }}!</h1>
    <p class="text-gray-600">This is your main dashboard. Select an option from the sidebar to get started.</p>
  </div>
</template>

================================================================================
### PLIK: views/HomeView.vue
================================================================================

<template>
  <div class="min-h-screen bg-gradient-to-tr from-[#121212] via-[#1e1e1e] to-[#000000] text-white">
    <div class="min-h-screen flex flex-col items-center justify-center px-6 py-12 relative">
      <div class="absolute top-0 left-0 right-0 p-6 flex justify-between items-center">
        <h1 class="text-3xl font-extrabold tracking-tight text-white">Danxils<span class="text-green-500">.js</span></h1>
        <button @click="toggleDarkMode" class="px-4 py-2 text-sm font-medium text-white bg-zinc-800 hover:bg-zinc-700 rounded-md">Toggle Theme</button>
      </div>

      <div class="text-center z-10">
        <h2 class="text-6xl md:text-7xl font-bold mb-6 leading-tight">
          <span class="text-white">Zanurz się w</span>
          <span class="block bg-gradient-to-r from-green-400 to-blue-500 text-transparent bg-clip-text">Nowoczesny Panel</span>
        </h2>
        <p class="text-zinc-400 text-lg md:text-xl max-w-2xl mx-auto mb-10">
          Zarządzaj błędami, kontroluj adresy, przetwarzaj dane i optymalizuj wszystko w czasie rzeczywistym. Z estetyką, która inspiruje.
        </p>

        <div class="flex flex-col sm:flex-row justify-center gap-4">
          <router-link to="/dashboard" class="inline-flex items-center justify-center px-8 py-3 text-base font-semibold text-black bg-green-400 hover:bg-green-300 rounded-full shadow-xl transition-all">Wejdź do Panelu</router-link>
          <router-link to="/login" class="inline-flex items-center justify-center px-8 py-3 text-base font-semibold text-white border border-white hover:bg-white hover:text-black rounded-full transition-all">Zaloguj się</router-link>
        </div>
      </div>

      <div class="absolute inset-0 -z-10 overflow-hidden">
        <div class="absolute -top-20 left-1/3 w-[600px] h-[600px] bg-green-600 rounded-full blur-[150px] opacity-30 animate-blob"></div>
        <div class="absolute top-1/2 right-1/4 w-[400px] h-[400px] bg-blue-600 rounded-full blur-[150px] opacity-20 animate-blob animation-delay-2000"></div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'
const darkMode = ref(false)
const toggleDarkMode = () => {
  darkMode.value = !darkMode.value
}
</script>

<style scoped>
@keyframes blob {
  0%, 100% {
    transform: translate(0px, 0px) scale(1);
  }
  33% {
    transform: translate(30px, -50px) scale(1.1);
  }
  66% {
    transform: translate(-20px, 20px) scale(0.9);
  }
}

.animate-blob {
  animation: blob 15s infinite ease-in-out;
}
.animation-delay-2000 {
  animation-delay: -7s;
}
</style>


================================================================================
### PLIK: views/HubRulesView.vue
================================================================================

// ============================================================================
// Frontend: New Placeholder View
// FILE: src/views/HubRulesView.vue
// REASON: Fixes "Failed to resolve import" error during build.
// ============================================================================
<template>
  <div class="page-container p-4">
    <h1 class="text-2xl font-bold text-gray-700">Hub Rules Management</h1>
    <div class="mt-4 p-6 bg-white rounded-lg shadow-md">
      <p class="text-gray-600">This is a placeholder page for administering Hub Rules.</p>
      <p class="mt-2 text-gray-500">Content to be added here.</p>
    </div>
  </div>
</template>

<script setup>
import { onMounted } from 'vue';

onMounted(() => {
  console.log("HubRulesView.vue placeholder loaded.");
});
</script>

<style scoped>
/* Scoped styles for this view if needed */
.page-container {
  max-width: 1200px;
  margin: 0 auto;
}
</style>


================================================================================
### PLIK: views/LogDashboardView.vue
================================================================================

// FILE: src/views/LogDashboardView.vue
// NEW FILE
<template>
  <div class="log-dashboard">
    <h1>Application Logs</h1>

    <div class="filters">
      <input type="text" v-model="logStore.queryFilter" placeholder="Search query..." @keyup.enter="applyFilters"/>
      <input type="text" v-model="logStore.correlationIdFilter" placeholder="Correlation ID..." @keyup.enter="applyFilters"/>
      <select v-model="logStore.appNameFilter" @change="applyFilters">
        <option value="">All Apps</option>
        <option value="danxils-api">DANXILS-API</option>
        <option value="tes">TES</option>
        <option value="frontend">Frontend</option>
      </select>
      <select v-model="logStore.levelFilter" @change="applyFilters">
        <option value="">All Levels</option>
        <option value="ERROR">ERROR</option>
        <option value="WARN">WARN</option>
        <option value="INFO">INFO</option>
        <option value="DEBUG">DEBUG</option>
        <option value="TRACE">TRACE</option>
      </select>
      <button @click="applyFilters" :disabled="logStore.loading">Search</button>
    </div>

    <div v-if="logStore.loading" class="loading">Loading logs...</div>
    <div v-if="logStore.error" class="error-message">Error: {{ logStore.error }}</div>

    <div v-if="!logStore.loading && logStore.logs.length === 0 && !logStore.error" class="no-results">
      No log entries found for the current filters. (Note: Log aggregation infrastructure must be configured.)
    </div>

    <div v-if="logStore.logs.length > 0" class="log-entries">
      <table>
        <thead>
        <tr>
          <th>Timestamp</th>
          <th>Level</th>
          <th>App</th>
          <th>Correlation ID</th>
          <th>Message</th>
        </tr>
        </thead>
        <tbody>
        <tr v-for="(log, index) in logStore.logs" :key="index" :class="`level-${log.level?.toLowerCase()}`">
          <td>{{ formatTimestamp(log['@timestamp'] || log.timestamp) }}</td>
          <td>{{ log.level || log.log?.level }}</td>
          <td>{{ log.appName || log.service?.name || '?' }}</td>
          <td>{{ log.correlationId || log.trace?.id || '?' }}</td>
          <td class="message">{{ log.message }}</td>
        </tr>
        </tbody>
      </table>

      <div class="pagination">
        <button @click="prevPage" :disabled="logStore.currentPage === 0 || logStore.loading">Previous</button>
        <span>Page {{ logStore.currentPage + 1 }} of {{ logStore.totalPages }}</span>
        <button @click="nextPage" :disabled="logStore.currentPage >= logStore.totalPages - 1 || logStore.loading">Next</button>
      </div>
    </div>

  </div>
</template>

<script setup>
import { onMounted } from 'vue';
import { useLogStore } from '@/stores/useLogStore';

const logStore = useLogStore();

onMounted(() => {
  logStore.fetchLogs(); // Initial fetch
});

const applyFilters = () => {
  logStore.applyFiltersAndFetch();
};

const prevPage = () => {
  logStore.setPage(logStore.currentPage - 1);
};

const nextPage = () => {
  logStore.setPage(logStore.currentPage + 1);
};

// Basic timestamp formatter (adjust as needed)
const formatTimestamp = (ts) => {
  if (!ts) return '-';
  try {
    // Attempt to parse ISO string or epoch millis
    const date = new Date(isNaN(ts) ? ts : Number(ts));
    return date.toLocaleString(); // Use locale-specific format
  } catch (e) {
    return ts; // Return original if parsing fails
  }
};
</script>

<style scoped>
.log-dashboard {
  padding: 20px;
  font-family: sans-serif;
}

.filters {
  margin-bottom: 20px;
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
}
.filters input, .filters select {
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
}
.filters button {
  padding: 8px 15px;
  cursor: pointer;
}

.loading, .error-message, .no-results {
  margin-top: 20px;
  padding: 15px;
  border-radius: 4px;
}
.loading { background-color: #e0e0e0; }
.error-message { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
.no-results { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }

.log-entries table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 20px;
  font-size: 0.9em;
}
.log-entries th, .log-entries td {
  border: 1px solid #ddd;
  padding: 8px;
  text-align: left;
  vertical-align: top;
}
.log-entries th {
  background-color: #f2f2f2;
}
.log-entries td.message {
  white-space: pre-wrap; /* Preserve whitespace/newlines */
  word-break: break-all; /* Wrap long lines */
}

/* Optional: Color coding based on level */
.level-error { background-color: #f8d7da; }
.level-warn { background-color: #fff3cd; }

.pagination {
  margin-top: 20px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 15px;
}
.pagination button {
  padding: 5px 10px;
}
</style>

================================================================================
### PLIK: views/LoginView.vue
================================================================================

<!--
ARCHITECTURE: LoginView authenticates via AuthController and redirects to the intended route.
It follows the manifesto by delegating auth logic to the controller and keeping UI declarative.
Responsibilities:
- Collect credentials, call auth.login(), then navigate to ?r=... or /dashboard.
-->
<template>
  <section class="login">
    <header><h1>Sign in</h1></header>
    <form @submit.prevent="onSubmit">
      <label>Username <input v-model="username" autocomplete="username" /></label>
      <label>Password <input v-model="password" type="password" autocomplete="current-password" /></label>
      <button :disabled="busy" type="submit">{{ busy ? 'Signing in…' : 'Sign in' }}</button>
      <p v-if="err" class="err">{{ err }}</p>
    </form>
  </section>
</template>

<script setup>
import { inject, ref } from "vue";
import { useRoute, useRouter } from "vue-router";

const auth = inject("auth"); // provided in main.js
const route = useRoute();
const router = useRouter();

const username = ref("admin");
const password = ref("pass");
const busy = ref(false);
const err = ref("");

async function onSubmit() {
  err.value = "";
  busy.value = true;
  try {
    const r = await auth.login(username.value, password.value);
    if (!r.ok) throw r.error || new Error("Login failed");
    const go = String(route.query.r || "/dashboard");
    router.push(go);
  } catch (e) {
    err.value = e?.message || "Login failed";
  } finally {
    busy.value = false;
  }
}
</script>

<style scoped>
.login { max-width: 420px; margin: 8vh auto; padding: 16px; border: 1px solid #eee; border-radius: 8px; background: #fff; display: grid; gap: 12px; }
form { display: grid; gap: 10px; }
label { display: grid; gap: 4px; font-size: 12px; }
input { padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; }
button { padding: 8px 10px; font-size: 14px; }
.err { color: #c0392b; margin: 0; }
</style>


================================================================================
### PLIK: views/NotFoundView.vue
================================================================================

<template>
  <div class="flex flex-col items-center justify-center min-h-[calc(100vh-200px)] text-center px-4">
    <div class="bg-white p-8 sm:p-12 rounded-xl shadow-2xl max-w-md w-full">
      <svg class="w-24 h-24 text-indigo-400 mx-auto mb-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
      <h1 class="text-5xl font-extrabold text-indigo-600 mb-3">404</h1>
      <p class="text-xl font-medium text-slate-700 mb-6">Oops! Strona nie została znaleziona.</p>
      <p class="text-slate-500 mb-8">
        Strona, której szukasz, mogła zostać usunięta, jej nazwa uległa zmianie lub jest tymczasowo niedostępna.
      </p>
      <router-link
        to="/"
        class="inline-block px-8 py-3 text-sm font-semibold leading-tight text-white bg-indigo-600 rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-colors"
      >
        Wróć na Stronę Główną
      </router-link>
    </div>
  </div>
</template>

<script setup>
</script>

================================================================================
### PLIK: views/OrderStatusView.vue
================================================================================

<template>
  <div class="bg-white p-6 md:p-8 rounded-xl shadow-lg">
    <h1 class="text-2xl font-bold text-slate-800 mb-6 border-b pb-3">Przegląd Statusów Zamówień</h1>

    <div class="mb-6">
      <input type="text" placeholder="Wyszukaj po kodzie kreskowym..." class="p-3 border border-slate-300 rounded-md w-full md:w-1/2 lg:w-1/3 focus:ring-indigo-500 focus:border-indigo-500 transition shadow-sm">
    </div>

    <div class="text-center py-10 text-slate-500">
      <p class="text-lg">Funkcjonalność przeglądania statusów zamówień jest w trakcie implementacji.</p>
      <p class="text-sm mt-2">Wkrótce pojawią się tutaj dane dotyczące statusów.</p>
      <svg class="w-16 h-16 text-slate-300 mx-auto mt-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
    </div>

    </div>
</template>

<script setup>
</script>

================================================================================
### PLIK: views/ProcessingErrorsListView.vue
================================================================================

<script setup>
import { ref, onMounted } from 'vue';
// Zakładamy, że masz lub stworzysz store do obsługi błędów
// na podstawie pliku stores/errorStore.js
// Jeśli twój store nazywa się inaczej, zaktualizuj import.
import apiService from '@/stores/errorStore'; 

const errors = ref([]);
const isLoading = ref(false);
const error = ref(null);

const fetchErrors = async () => {
  isLoading.value = true;
  error.value = null;
  try {
    // Użycie metody z Twojego serwisu API
    const response = await apiService.getProcessingErrors();
    errors.value = response.data;
  } catch (err) {
    console.error('Failed to fetch processing errors:', err);
    error.value = 'Could not load processing errors. Please try again later.';
  } finally {
    isLoading.value = false;
  }
};

// Pobierz dane, gdy komponent zostanie załadowany
onMounted(fetchErrors);
</script>

<template>
  <div class="bg-white p-6 rounded-lg shadow-md">
    <h1 class="text-2xl font-bold text-gray-800 mb-6">Processing Errors</h1>

    <div v-if="isLoading" class="text-center text-gray-500">
      <p>Loading errors...</p>
    </div>

    <div v-else-if="error" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded" role="alert">
      <strong class="font-bold">Error: </strong>
      <span>{{ error }}</span>
    </div>

    <table v-else-if="errors.length > 0" class="min-w-full bg-white">
      <thead class="bg-gray-200">
        <tr>
          <th class="py-2 px-4 text-left">Error ID</th>
          <th class="py-2 px-4 text-left">Message</th>
          <th class="py-2 px-4 text-left">Timestamp</th>
          <th class="py-2 px-4 text-left">Actions</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="item in errors" :key="item.id" class="border-b hover:bg-gray-50">
          <td class="py-2 px-4 font-mono text-sm">{{ item.id }}</td>
          <td class="py-2 px-4">{{ item.message }}</td>
          <td class="py-2 px-4">{{ new Date(item.timestamp).toLocaleString() }}</td>
          <td class="py-2 px-4">
            <button class="text-blue-600 hover:underline">Details</button>
          </td>
        </tr>
      </tbody>
    </table>
    
    <div v-else class="text-center text-gray-500">
        <p>No processing errors found. Great job! ✅</p>
    </div>

  </div>
</template>

================================================================================
### PLIK: views/RecentlyAddedAddressesView.vue
================================================================================

<template>
  <div class="container mx-auto p-4 sm:p-6 lg:p-8">
    <div class="bg-gradient-to-r from-cyan-700 to-blue-900 text-white p-6 rounded-xl shadow-2xl mb-8">
      <div>
        <h1 class="text-3xl sm:text-4xl font-bold">Ostatnio Dodane Adresy</h1>
        <p class="mt-2 text-blue-200">Historia adresów, które zostały niedawno zweryfikowane i dodane do bazy TrackIT.</p>
      </div>
    </div>

    <div v-if="isLoading" class="text-center py-16">
      <div class="animate-spin rounded-full h-12 w-12 border-t-4 border-b-4 border-blue-500 mx-auto"></div>
      <p class="text-lg text-slate-500 mt-5">Ładowanie historii adresów...</p>
    </div>

    <div v-else-if="addresses.length === 0" class="text-center py-16 bg-white rounded-xl shadow-md">
      <svg class="mx-auto h-16 w-16 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
      <h3 class="mt-3 text-lg font-medium text-slate-800">Brak danych</h3>
      <p class="mt-1 text-sm text-slate-500">Nie znaleziono ostatnio dodanych adresów w bazie danych.</p>
    </div>

    <div v-else class="bg-white rounded-xl shadow-xl overflow-x-auto">
      <table class="min-w-full divide-y divide-slate-200">
        <thead class="bg-slate-50">
          <tr>
            <th class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Alias</th>
            <th class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Nazwa (Attention Name)</th>
            <th class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Adres</th>
            <th class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Data Dodania</th>
            <th class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Cust ID</th>
          </tr>
        </thead>
        <tbody class="bg-white divide-y divide-slate-200">
          <tr v-for="(address, index) in addresses" :key="index" class="hover:bg-slate-50">
            <td class="px-4 py-3 whitespace-nowrap text-sm font-medium text-slate-800">{{ address.alias }}</td>
            <td class="px-4 py-3 whitespace-nowrap text-sm text-slate-600">{{ address.attentionName }}</td>
            <td class="px-4 py-3 whitespace-nowrap text-sm text-slate-600">
              {{ address.street }} {{ address.houseNo }}, {{ address.postalCode }} {{ address.city }}
            </td>
            <td class="px-4 py-3 whitespace-nowrap text-sm text-slate-600">{{ formatDate(address.createdAt) }}</td>
            <td class="px-4 py-3 whitespace-nowrap text-sm text-slate-600">{{ address.custId }}</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import apiClient from '@/services/api';

const addresses = ref([]);
const isLoading = ref(false);

const fetchRecentAddresses = async () => {
  isLoading.value = true;
  try {
    const response = await apiClient.get('/tes-api/address-history/recent?limit=100');
    addresses.value = response.data;
  } catch (error) {
    console.error('Błąd podczas pobierania historii adresów:', error);
    addresses.value = [];
  } finally {
    isLoading.value = false;
  }
};

const formatDate = (dateString) => {
  if (!dateString) return 'N/A';
  const date = new Date(dateString);
  return date.toLocaleString('pl-PL', { dateStyle: 'short', timeStyle: 'medium' });
};

onMounted(() => {
  fetchRecentAddresses();
});
</script>

================================================================================
### PLIK: views/RejectedRequestsView.vue
================================================================================

<template>
  <div class="container mx-auto p-4 sm:p-6 lg:p-8">
    <div class="bg-gradient-to-r from-slate-700 to-slate-900 text-white p-6 rounded-xl shadow-2xl mb-8">
        <div class="flex justify-between items-center">
            <div>
                <h1 class="text-3xl sm:text-4xl font-bold">Odrzucone Żądania</h1>
                <p class="mt-2 text-slate-300">Przeglądaj, filtruj i zarządzaj odrzuconymi zleceniami.</p>
            </div>
            <button 
                @click="triggerRecovery" 
                :disabled="isRecoveryLoading"
                class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition-colors flex items-center disabled:opacity-50 disabled:cursor-wait">
                <svg v-if="!isRecoveryLoading" class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5m-4-1v-4h4"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 9a9 9 0 0114.48-2.73M20 15a9 9 0 01-14.48 2.73"></path></svg>
                <svg v-else class="animate-spin h-5 w-5 mr-2 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span>{{ isRecoveryLoading ? 'Przetwarzanie...' : 'Ponów Przetwarzanie' }}</span>
            </button>
        </div>
    </div>

    <div class="mb-6 p-6 bg-white rounded-xl shadow-lg">
        <h2 class="text-xl font-semibold mb-4 text-slate-700 border-b border-slate-200 pb-3">Filtry</h2>
        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
            <div>
                <label for="filterBarcode" class="block text-xs font-medium text-slate-600 mb-1">Kod Kreskowy:</label>
                <input type="text" id="filterBarcode" v-model="localFilters.barcode" @input="applyFilterDebounced('barcode', $event.target.value)"
                       class="p-2.5 w-full border border-slate-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 text-sm"
                       placeholder="Wpisz kod...">
            </div>
            <div>
                <label for="filterErrorType" class="block text-xs font-medium text-slate-600 mb-1">Typ Błędu:</label>
                <select id="filterErrorType" v-model="localFilters.errorType" @change="applyFilterDebounced('errorType', $event.target.value)"
                        class="p-2.5 w-full border border-slate-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 text-sm bg-white">
                    <option value="">Wszystkie</option>
                    <option value="DELIVERY_ADDRESS_ALIAS_MISSING">Adres Dostawy do Potwierdzenia</option>
                    <option value="PICKUP_ADDRESS_ALIAS_MISSING">Adres Nadawcy do Potwierdzenia</option>
                    <option value="ADDRESS_REPROCESSED">Potwierdzone Adresy</option>
                    <option value="ADDRESS_ALIAS_MISMATCH_DB">Niezgodność Aliasu DB</option>
                    <option value="ADDRESS_PROVIDER_NEEDS_REVIEW">Adres Wymaga Weryfikacji</option>
                    <option value="ADDRESS_PROVIDER_INVALID">Adres Niepoprawny</option>
                    <option value="ADDRESS_CUSTOMER_VERIFICATION_PENDING">Oczekuje na Potw. Klienta</option>
                    <option value="EXTERNAL_SERVICE_FAILURE">Błąd Usługi Zewnętrznej</option>
                    <option value="ADDRESS_DB_ERROR">Błąd DB Adresu</option>
                    <option value="VALIDATION">Błąd Walidacji</option>
                    <option value="PROCESSING">Błąd Przetwarzania</option>
                    <option value="DESERIALIZATION_ERROR">Błąd Deserializacji</option>
                    <option value="CONSTRAINT_VIOLATION">Naruszenie Ograniczeń</option>
                    <option value="LISTENER_EXECUTION_FAILURE">Błąd Listenera</option>
                </select>
            </div>
        </div>
    </div>

    <div v-if="errorStore.isLoading && !errorStore.rejectedRequests.length" class="text-center py-16">
        <div class="animate-spin rounded-full h-12 w-12 border-t-4 border-b-4 border-indigo-500 mx-auto"></div>
        <p class="text-lg text-slate-500 mt-5">Ładowanie danych...</p>
    </div>
    <div v-else-if="!errorStore.isLoading && errorStore.rejectedRequests.length === 0" class="text-center py-16 bg-white rounded-xl shadow-md">
        <svg class="mx-auto h-16 w-16 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
            <path vector-effect="non-scaling-stroke" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 13h6m-3-3v6m-9 1V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2z" />
        </svg>
        <h3 class="mt-3 text-lg font-medium text-slate-800">Brak odrzuconych żądań</h3>
        <p class="mt-1 text-sm text-slate-500">Nie znaleziono żądań pasujących do wybranych filtrów.</p>
    </div>
    <div v-else class="bg-white rounded-xl shadow-xl overflow-x-auto">
        <table class="min-w-full divide-y divide-slate-200">
            <thead class="bg-slate-50">
                <tr>
                    <th @click="changeSort('eventId')" class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider cursor-pointer hover:bg-slate-100">ID Błędu <span v-html="sortIcon('eventId')"></span></th>
                    <th @click="changeSort('requestID')" class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider cursor-pointer hover:bg-slate-100">Request ID <span v-html="sortIcon('requestID')"></span></th>
                    <th @click="changeSort('barcode')" class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider cursor-pointer hover:bg-slate-100">Barcode <span v-html="sortIcon('barcode')"></span></th>
                    <th @click="changeSort('errorType')" class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider cursor-pointer hover:bg-slate-100">Typ Błędu <span v-html="sortIcon('errorType')"></span></th>
                    <th class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Status Weryf. Adr.</th>
                    <th class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Wiadomość</th>
                    <th @click="changeSort('createdAt')" class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider cursor-pointer hover:bg-slate-100">Data <span v-html="sortIcon('createdAt')"></span></th>
                    <th class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Akcje</th>
                </tr>
            </thead>
            <tbody class="bg-white divide-y divide-slate-200">
                <tr v-for="error in errorStore.rejectedRequests" :key="error.id" 
                    :class="[
                        'transition duration-150 ease-in-out',
                        error.resolutionStatus === 'RESOLVED' ? 'bg-green-100 text-slate-500 hover:bg-green-200' : 'hover:bg-slate-50'
                    ]">
                    <td class="px-4 py-3 whitespace-nowrap text-xs font-mono">{{ error.eventId.substring(0,8) }}...</td>
                    <td class="px-4 py-3 whitespace-nowrap text-sm">{{ error.requestID || 'N/A' }}</td>
                    <td class="px-4 py-3 whitespace-nowrap text-sm">{{ error.barcode || 'N/A' }}</td>
                    <td class="px-4 py-3 whitespace-nowrap text-sm">
                        <span :class="getErrorTypeClassForTable(error.errorType, error.resolutionStatus)">{{ error.errorType || 'N/A' }}</span>
                    </td>
                    <td class="px-4 py-3 whitespace-nowrap text-sm">
                        <span v-if="error.resolutionStatus === 'RESOLVED'" class="px-2 py-0.5 rounded-full text-xs font-semibold inline-block leading-tight bg-green-200 text-green-800">
                            ADRES DODANY
                        </span>
                        <span v-else>{{ error.addressVerificationStatus || 'N/A' }}</span>
                    </td>
                    <td class="px-4 py-3 text-sm max-w-sm truncate" :title="error.errorMessage">
                        {{ error.errorMessage ? error.errorMessage.substring(0, 70) + (error.errorMessage.length > 70 ? '...' : '') : 'Brak' }}
                    </td>
                    <td class="px-4 py-3 whitespace-nowrap text-sm">{{ formatDateForTable(error.createdAt) }}</td>
                    <td class="px-4 py-3 whitespace-nowrap text-sm font-medium">
                        <button v-if="error.resolutionStatus !== 'RESOLVED'" @click="openErrorDetailsModal(error)" class="text-indigo-600 hover:text-indigo-800 font-semibold hover:underline text-xs">Szczegóły</button>
                        <span v-else class="text-xs text-slate-400">Rozwiązany</span>
                    </td>
                </tr>
            </tbody>
        </table>

        <div class="py-3 px-4 border-t border-slate-200 bg-slate-50 flex items-center justify-between">
            <div class="text-xs text-slate-600">
                Strona {{ errorStore.pagination.currentPage + 1 }} / {{ errorStore.pagination.totalPages }} ({{ errorStore.pagination.totalElements }} wyników)
            </div>
            <div class="flex space-x-1.5">
                <button @click="goToPage(errorStore.pagination.currentPage - 1)" :disabled="errorStore.pagination.currentPage === 0"
                        class="px-3 py-1.5 border border-slate-300 text-xs font-medium rounded-md text-slate-700 bg-white hover:bg-slate-100 disabled:opacity-50 disabled:cursor-not-allowed transition duration-150 ease-in-out">
                    Poprzednia
                </button>
                <button @click="goToPage(errorStore.pagination.currentPage + 1)" :disabled="errorStore.pagination.currentPage >= errorStore.pagination.totalPages - 1"
                        class="px-3 py-1.5 border border-slate-300 text-xs font-medium rounded-md text-slate-700 bg-white hover:bg-slate-100 disabled:opacity-50 disabled:cursor-not-allowed transition duration-150 ease-in-out">
                    Następna
                </button>
            </div>
        </div>
    </div>
    <ErrorDetailsModal 
        v-if="showModal"
        :error-id="currentSelectedErrorId"
        @close="handleCloseModal"
        @order-resubmitted="handleOrderResubmitted"
    />
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { useErrorStore } from '@/stores/errorStore';
import ErrorDetailsModal from '@/components/modals/ErrorDetailsModal.vue';
import apiClient from '@/services/api.js';

const errorStore = useErrorStore();

const currentSelectedErrorId = ref(null);
const showModal = ref(false);
const isRecoveryLoading = ref(false);

const localFilters = ref({
  barcode: errorStore.filters.barcode,
  errorType: errorStore.filters.errorType,
});

let filterDebounceTimeout = null;
const applyFilterDebounced = (filterName, value) => {
  localFilters.value[filterName] = value;
  clearTimeout(filterDebounceTimeout);
  filterDebounceTimeout = setTimeout(() => {
    errorStore.setFilter(filterName, value);
  }, 500);
};

const triggerRecovery = async () => {
    isRecoveryLoading.value = true;
    try {
        await apiClient.post('/api/admin/address-verification/errors/retry-recoverable');
        await errorStore.fetchRejectedRequests();
    } catch (e) {
        console.error("Błąd podczas uruchamiania ponawiania błędów:", e);
    } finally {
        isRecoveryLoading.value = false;
    }
};

onMounted(() => {
  errorStore.fetchRejectedRequests();
});

const formatDateForTable = (dateString) => {
  if (!dateString) return 'N/A';
  const date = new Date(dateString);
  return date.toLocaleString('pl-PL', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
};

const openErrorDetailsModal = (error) => {
  currentSelectedErrorId.value = error.id;
  showModal.value = true;
};
const handleCloseModal = () => {
  showModal.value = false;
  currentSelectedErrorId.value = null;
};
const handleOrderResubmitted = () => {
    handleCloseModal();
    errorStore.fetchRejectedRequests(errorStore.pagination.currentPage);
};

const goToPage = (pageNumber) => {
  if (pageNumber >= 0 && pageNumber < errorStore.pagination.totalPages) {
    errorStore.fetchRejectedRequests(pageNumber);
  }
};

const changeSort = (field) => {
  let direction = 'ASC';
  if (errorStore.sort.field === field && errorStore.sort.direction === 'ASC') {
    direction = 'DESC';
  }
  errorStore.setSort(field, direction);
};

const sortIcon = (field) => {
  if (errorStore.sort.field === field) {
    return errorStore.sort.direction === 'ASC' ? '&#9650;' : '&#9660;';
  }
  return '';
};

const getErrorTypeClassForTable = (errorType, resolutionStatus) => {
    let base = 'px-2 py-0.5 rounded-full text-xs font-semibold inline-block leading-tight ';
    if (resolutionStatus === 'RESOLVED') return base + 'bg-green-100 text-green-800 border border-green-300';
    if (['DELIVERY_ADDRESS_ALIAS_MISSING', 'PICKUP_ADDRESS_ALIAS_MISSING', 'ADDRESS_ALIAS_MISMATCH_DB', 'ADDRESS_PROVIDER_NEEDS_REVIEW', 'ADDRESS_PROVIDER_INVALID'].includes(errorType)) return base + 'bg-orange-100 text-orange-600 border border-orange-200';
    if (errorType === 'ADDRESS_CUSTOMER_VERIFICATION_PENDING') return base + 'bg-yellow-100 text-yellow-600 border border-yellow-200';
    if (['VALIDATION', 'CONSTRAINT_VIOLATION', 'DESERIALIZATION_ERROR'].includes(errorType)) return base + 'bg-red-100 text-red-600 border border-red-200';
    if (['PROCESSING', 'LISTENER_EXECUTION_FAILURE', 'EXTERNAL_SERVICE_FAILURE', 'ADDRESS_DB_ERROR'].includes(errorType)) return base + 'bg-purple-100 text-purple-600 border border-purple-200';
    return base + 'bg-slate-100 text-slate-600 border border-slate-200';
};
</script>

<style scoped>
.animate-spin {
  animation: spin 1s linear infinite;
}
@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
.max-w-xs { max-width: 20rem; }
.max-w-sm { max-width: 24rem; }
</style>

================================================================================
### PLIK: views/RulesView.vue
================================================================================

<script setup>
import { ref, onMounted, reactive } from 'vue';
import { useInvoicingRulesStore } from '@/stores/invoicingRulesStore';

const rulesStore = useInvoicingRulesStore();

// Sterowanie modalem do dodawania/edycji
const isModalOpen = ref(false);
const isEditing = ref(false);
// Reaktywny obiekt przechowujący dane reguły z formularza
const currentRule = reactive({
  id: null,
  hubId: '',
  // Możesz tu dodać więcej pól, jeśli Twój model 'rule' ich wymaga
});

// Pobierz reguły po załadowaniu komponentu
onMounted(() => {
  rulesStore.fetchHubRules();
});

const openAddModal = () => {
  isEditing.value = false;
  // Resetuj formularz przed otwarciem
  Object.assign(currentRule, { id: null, hubId: '' });
  isModalOpen.value = true;
};

const openEditModal = (rule) => {
  isEditing.value = true;
  // Wczytaj dane istniejącej reguły do formularza
  Object.assign(currentRule, rule);
  isModalOpen.value = true;
};

const closeModal = () => {
  isModalOpen.value = false;
};

const handleSave = async () => {
  await rulesStore.saveRule({ ...currentRule });
  closeModal();
};

const handleDelete = async (ruleId) => {
  if (confirm('Are you sure you want to delete this rule?')) {
    await rulesStore.deleteRule(ruleId);
  }
};
</script>

<template>
  <div class="bg-white p-6 rounded-lg shadow-md">
    <div class="flex justify-between items-center mb-6">
      <h1 class="text-2xl font-bold text-gray-800">Invoicing Rules Management</h1>
      <button @click="openAddModal" class="px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
        Add New Rule
      </button>
    </div>

    <div v-if="rulesStore.isLoading" class="text-center p-4">Loading rules...</div>
    <div v-else-if="rulesStore.error" class="text-red-600 bg-red-100 p-4 rounded-md">{{ rulesStore.error }}</div>

    <table v-else-if="rulesStore.sortedHubRules.length" class="min-w-full bg-white">
      <thead class="bg-gray-100">
        <tr>
          <th class="py-3 px-4 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">HUB ID</th>
          <th class="py-3 px-4 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
        </tr>
      </thead>
      <tbody class="divide-y divide-gray-200">
        <tr v-for="rule in rulesStore.sortedHubRules" :key="rule.id" class="hover:bg-gray-50">
          <td class="py-4 px-4 whitespace-nowrap font-medium text-gray-900">{{ rule.hubId }}</td>
          <td class="py-4 px-4 whitespace-nowrap text-right text-sm font-medium space-x-4">
            <button @click="openEditModal(rule)" class="text-indigo-600 hover:text-indigo-900">Edit</button>
            <button @click="handleDelete(rule.id)" class="text-red-600 hover:text-red-900">Delete</button>
          </td>
        </tr>
      </tbody>
    </table>
    <div v-else class="text-center text-gray-500 p-4">No rules found. Click "Add New Rule" to get started.</div>
  </div>

  <div v-if="isModalOpen" class="fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center z-50">
      <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-md">
          <h2 class="text-xl font-bold mb-6">{{ isEditing ? 'Edit Rule' : 'Add a New Rule' }}</h2>
          <form @submit.prevent="handleSave" class="space-y-4">
              <div>
                  <label for="hubId" class="block text-sm font-medium text-gray-700">HUB ID</label>
                  <input type="text" id="hubId" v-model="currentRule.hubId" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" required />
              </div>
              <div class="flex justify-end space-x-4 pt-4">
                  <button type="button" @click="closeModal" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300">Cancel</button>
                  <button type="submit" :disabled="rulesStore.isLoading" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-blue-300">
                    {{ rulesStore.isLoading ? 'Saving...' : 'Save' }}
                  </button>
              </div>
          </form>
      </div>
  </div>
</template>

================================================================================
### PLIK: views/StatusExportView.vue
================================================================================

<template>
  <div class="p-4 sm:p-6 lg:p-8">
    <div class="sm:flex sm:items-center">
      <div class="sm:flex-auto">
        <h1 class="text-xl font-semibold text-gray-900">Eksport Statusów</h1>
        <p class="mt-2 text-sm text-gray-700">
          Przeglądaj i pobieraj historyczne pliki JSON ze statusami wysłanymi do systemu AED.
        </p>
      </div>
    </div>
    <div class="mt-8 flex flex-col">
      <div class="-my-2 -mx-4 overflow-x-auto sm:-mx-6 lg:-mx-8">
        <div class="inline-block min-w-full py-2 align-middle md:px-6 lg:px-8">
          <div class="overflow-hidden shadow ring-1 ring-black ring-opacity-5 md:rounded-lg">
            <table class="min-w-full divide-y divide-gray-300">
              <thead class="bg-gray-50">
                <tr>
                  <th scope="col" class="py-3.5 pl-4 pr-3 text-left text-sm font-semibold text-gray-900 sm:pl-6">Nazwa Pliku</th>
                  <th scope="col" class="px-3 py-3.5 text-left text-sm font-semibold text-gray-900">Data Utworzenia</th>
                  <th scope="col" class="relative py-3.5 pl-3 pr-4 sm:pr-6">
                    <span class="sr-only">Akcje</span>
                  </th>
                </tr>
              </thead>
              <tbody class="divide-y divide-gray-200 bg-white">
                <tr v-if="isLoadingFiles">
                  <td colspan="3" class="whitespace-nowrap px-3 py-4 text-sm text-center text-gray-500">Ładowanie listy plików...</td>
                </tr>
                <tr v-else-if="files.length === 0">
                  <td colspan="3" class="whitespace-nowrap px-3 py-4 text-sm text-center text-gray-500">Nie znaleziono wygenerowanych plików.</td>
                </tr>
                <tr v-for="file in files" :key="file.id">
                  <td class="whitespace-nowrap py-4 pl-4 pr-3 text-sm font-medium text-gray-900 sm:pl-6">{{ file.fileName }}</td>
                  <td class="whitespace-nowrap px-3 py-4 text-sm text-gray-500">{{ new Date(file.createdAt).toLocaleString() }}</td>
                  <td class="relative whitespace-nowrap py-4 pl-3 pr-4 text-right text-sm font-medium sm:pr-6">
                    <button @click="previewFile(file)" class="text-indigo-600 hover:text-indigo-900">Podgląd</button>
                    <button @click="downloadFile(file)" class="ml-4 text-indigo-600 hover:text-indigo-900">Pobierz</button>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div v-if="selectedFileContent" class="mt-8">
      <h2 class="text-lg font-medium text-gray-900">Podgląd pliku: {{ selectedFileName }}</h2>
      <div class="mt-2 bg-gray-800 text-white p-4 rounded-lg shadow-inner overflow-x-auto">
        <pre class="text-sm">{{ selectedFileContent }}</pre>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import apiClient from '@/services/api'; // Upewnij się, że ścieżka jest poprawna

// === STAN KOMPONENTU ===
const files = ref([]);
const isLoadingFiles = ref(false);
const selectedFileName = ref('');
const selectedFileContent = ref('');

// === METODY ===

/**
 * Pobiera listę wygenerowanych plików z backendu.
 */
const fetchFiles = async () => {
  isLoadingFiles.value = true;
  selectedFileContent.value = ''; // Resetuj podgląd przy odświeżaniu
  try {
    const response = await apiClient.get('/api/status-export/files');
    // Zakładamy, że API zwraca obiekt z polem `content`
    files.value = response.data.content || [];
  } catch (error) {
    console.error('Błąd podczas pobierania listy plików:', error);
    files.value = []; // Wyczyść listę w razie błędu
  } finally {
    isLoadingFiles.value = false;
  }
};

/**
 * Pobiera zawartość pliku i wyświetla ją w sekcji podglądu.
 * @param {object} file - Obiekt pliku z listy (musi zawierać `id` i `fileName`).
 */
const previewFile = async (file) => {
  selectedFileName.value = `Ładowanie podglądu dla: ${file.fileName}...`;
  selectedFileContent.value = 'Proszę czekać...';
  try {
    const response = await apiClient.get(`/api/status-export/files/${file.id}/download`);
    
    // Axios automatycznie parsuje odpowiedź JSON na obiekt JavaScript.
    const jsonObject = response.data;
    
    // KLUCZOWA POPRAWKA:
    // Konwertujemy otrzymany OBIEKT z powrotem na SFORMATOWANY TEKST JSON.
    // Argumenty `null, 2` zapewniają czytelne wcięcia.
    selectedFileContent.value = JSON.stringify(jsonObject, null, 2);
    selectedFileName.value = file.fileName;

  } catch (error) {
    console.error(`Błąd podczas pobierania podglądu pliku ${file.id}:`, error);
    selectedFileName.value = `Błąd ładowania pliku: ${file.fileName}`;
    selectedFileContent.value = 'Nie udało się załadować zawartości pliku. Sprawdź konsolę, aby uzyskać więcej informacji.';
  }
};

/**
 * Pobiera zawartość pliku i inicjuje jego pobranie przez przeglądarkę.
 * @param {object} file - Obiekt pliku z listy (musi zawierać `id` i `fileName`).
 */
const downloadFile = async (file) => {
  try {
    const response = await apiClient.get(`/api/status-export/files/${file.id}/download`);

    const jsonObject = response.data;

    // KLUCZOWA POPRAWKA (taka sama jak w podglądzie):
    const jsonText = JSON.stringify(jsonObject, null, 2);

    // Tworzymy Blob (binarny obiekt) z tekstu JSON
    const blob = new Blob([jsonText], { type: 'application/json;charset=utf-8;' });
    
    // Tworzymy tymczasowy link do pobrania pliku
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', file.fileName);
    link.style.visibility = 'hidden';
    
    // Dodajemy link do dokumentu, klikamy go i usuwamy
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Zwalniamy zasoby
    URL.revokeObjectURL(url);

  } catch (error) {
    console.error(`Błąd podczas pobierania pliku ${file.id}:`, error);
    alert('Nie udało się pobrać pliku. Sprawdź konsolę, aby uzyskać więcej informacji.');
  }
};

// === CYKL ŻYCIA KOMPONENTU ===

// Pobierz listę plików, gdy komponent zostanie zamontowany
onMounted(() => {
  fetchFiles();
});
</script>

================================================================================
### PLIK: views/TriageDashboard.vue
================================================================================

<script setup>
import { ref, onMounted, onUnmounted } from 'vue';
import { TriageDashboardController } from '@/controllers/TriageDashboardController';
import { KpiViewModel } from '@/viewmodels/KpiViewModel';
// *** REMOVED WorklistView and LogDashboardView imports ***

// Controller for fetching dashboard data
const controller = new TriageDashboardController();
const loading = ref(true);
const error = ref(null);
const kpis = ref(new KpiViewModel()); // Use ViewModel for display formatting
const recentBatches = ref([]);
const pendingByErrorType = ref([]);

const loadData = async () => {
  loading.value = true;
  error.value = null;
  const result = await controller.loadAll();
  if (result.ok) {
    const snap = controller.snapshot();
    kpis.value = new KpiViewModel(snap.kpis || {}); // Update ViewModel
    recentBatches.value = snap.recentBatches;
    pendingByErrorType.value = snap.pendingByErrorType;
  } else {
    error.value = result.error?.message || "Failed to load dashboard data.";
    // Reset data on error
    kpis.value = new KpiViewModel();
    recentBatches.value = [];
    pendingByErrorType.value = [];
  }
  loading.value = false;
};

onMounted(async () => {
  await loadData();
  // Optionally start polling if desired
  // controller.startPolling();
});

onUnmounted(() => {
  // controller.stopPolling();
});

</script>

<template>
  <div class="dashboard-view">
    <h1>Dashboard Overview</h1>

    <div v-if="loading" class="loading-indicator">Loading dashboard data...</div>
    <div v-if="error" class="error-message card">{{ error }}</div>

    <section v-if="!loading && !error" class="kpi-section">
      <div class="kpi-card card">
        <h2>Pending Review</h2>
        <div class="kpi-value">{{ kpis.pendingText() }}</div>
        <router-link to="/worklist" class="kpi-link">Go to Worklist</router-link>
      </div>
      <div class="kpi-card card">
        <h2>Auto Cleared</h2>
        <div class="kpi-value">{{ kpis.clearanceText() }}</div>
        <p class="kpi-note">(Based on recent data)</p>
      </div>
      <div class="kpi-card card">
        <h2>Avg. Resolution</h2>
        <div class="kpi-value">{{ kpis.avgResolutionText() }}</div>
        <p class="kpi-note">(Estimated)</p>
      </div>
      <div class="kpi-card card">
        <h2>Pending by Type</h2>
        <ul v-if="pendingByErrorType.length">
          <li v-for="item in pendingByErrorType" :key="item.errorType">
            {{ item.errorType }}: {{ item.count }}
          </li>
        </ul>
        <p v-else>None Pending</p>
        <router-link to="/worklist" class="kpi-link">View Details</router-link>
      </div>
    </section>

  </div>
</template>

<style scoped>
.dashboard-view {
  /* Optional: Add specific styles for the dashboard view itself */
}

.loading-indicator, .error-message {
  padding: calc(var(--spacing-unit) * 2);
  margin-bottom: calc(var(--spacing-unit) * 2);
  border-radius: 4px;
}
.loading-indicator {
  background-color: #e0e0e0;
}
.error-message {
  background-color: var(--color-danger);
  color: white;
}

.kpi-section {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); /* Adjusted minmax */
  gap: calc(var(--spacing-unit) * 2);
  margin-bottom: calc(var(--spacing-unit) * 3);
}

.kpi-card {
  text-align: center;
  display: flex; /* Use flexbox for layout */
  flex-direction: column;
  justify-content: space-between; /* Space out title, value, link */
}
.kpi-card h2 {
  margin-top: 0;
  font-size: 1rem;
  color: var(--color-text-light);
  margin-bottom: var(--spacing-unit);
}
.kpi-value {
  font-size: 2.2rem; /* Slightly larger */
  font-weight: bold;
  color: var(--color-primary);
  margin: auto 0; /* Center vertically */
}
.kpi-card ul {
  list-style: none;
  padding: 0;
  margin: var(--spacing-unit) 0; /* Add some margin */
  font-size: 0.9rem;
  color: var(--color-text);
  text-align: left; /* Align list items left */
  padding-left: var(--spacing-unit); /* Indent list */
}
.kpi-card li {
  margin-bottom: calc(var(--spacing-unit) * 0.5);
}
.kpi-link {
  margin-top: var(--spacing-unit);
  font-size: 0.9rem;
}
.kpi-note {
  font-size: 0.8rem;
  color: var(--color-text-light);
  margin-top: calc(var(--spacing-unit) * 0.5);
  margin-bottom: calc(var(--spacing-unit));
}

/* Removed divider and section styles as they are no longer needed here */

</style>

================================================================================
### PLIK: views/VerificationCockpitView.vue
================================================================================


================================================================================
### PLIK: views/WorklistView.vue
================================================================================

<script setup>
import { ref, computed, onMounted, watch } from 'vue';
import { useRouter } from 'vue-router';
import { useWorklistStore } from "@/stores/WorklistStore.js";
import { storeToRefs } from 'pinia';
import { EditorNavigationController } from '@/controllers/EditorNavigationController';
import StatusBadge from '@/components/common/StatusBadge.vue';

const store = useWorklistStore();
const router = useRouter();
const nav = new EditorNavigationController();

// Use storeToRefs to keep reactivity on store state
const { items, pagination, loading, error, filter, selection } = storeToRefs(store);

// localFilter is now a reactive copy for the v-model bindings
const localFilter = ref({ ...filter.value.toPlainObject() });

// Watch for changes in the store's filter (e.g., after reset) and update local copy
watch(filter, (newFilterState) => {
  localFilter.value = { ...newFilterState.toPlainObject() };
}, { deep: true });

// Fetch data when component mounts
onMounted(async () => {
  await store.loadWorklistPage();
  // Ensure local filter is in sync with store after initial load
  localFilter.value = { ...store.filter.toPlainObject() };
});

// *** MODIFIED: Renamed to handle explicit button click ***
const handleApplyFilter = () => {
  // Pass the local state object to the store action
  store.applyFilterPatch(localFilter.value);
};

const handleResetFilter = () => {
  store.resetFilter(); // This will trigger the watcher to update localFilter.value
};

const goToEditor = (orderId) => {
  // Optional: Pass current filter/page state for 'Back' button context
  const navState = { filter: store.currentFilter, page: pagination.value.currentPage };
  router.push(nav.toEditor(orderId, 'worklist', navState));
};

// --- Selection Helpers ---
const isAllSelectedOnPage = computed(() => {
  const pageIds = items.value.map(item => item.id);
  return pageIds.length > 0 && pageIds.every(id => selection.value.includes(id));
});

const toggleSelectAll = () => {
  if (isAllSelectedOnPage.value) {
    store.clearSelection();
  } else {
    store.selectAllOnPage();
  }
};

// --- Pagination ---
const handlePageChange = (newPage) => {
  store.goToPage(newPage);
};

// Formatting helper
const formatDate = (dateString) => {
  if (!dateString) return 'N/A';
  try {
    return new Date(dateString).toLocaleString();
  } catch (e) {
    return dateString;
  }
};

</script>

<template>
  <div class="worklist-view card">

    <div class="filter-controls">
      <input type="text" v-model="localFilter.barcode" placeholder="Barcode..." />
      <input type="text" v-model="localFilter.customerId" placeholder="Customer ID..." />
      <select v-model="localFilter.status">
        <option value="">All Statuses</option>
        <option value="ADDRESS_NEEDS_REVIEW">Needs Review</option>
        <option value="ADDRESS_VALIDATED">Validated</option>
        <option value="MANUALLY_CORRECTED">Corrected</option>
        <option value="PENDING_ADDRESS_VALIDATION">Pending</option>
        <option value="CDC_PROCESSED">CDC Processed</option>
        <option value="FAILED">Failed</option>
      </select>
      <input type="date" v-model="localFilter.dateFrom" title="Created Date From"/>
      <input type="date" v-model="localFilter.dateTo" title="Created Date To"/>

      <button @click="handleApplyFilter" class="button">Apply Filters</button>
      <button @click="handleResetFilter" class="button secondary">Reset Filters</button>
    </div>

    <div v-if="loading" class="loading-indicator">Loading worklist...</div>
    <div v-if="error" class="error-message">{{ error }}</div>

    <div v-if="!loading && !error" class="worklist-content">
      <div class="table-actions">
        <span>Selected: {{ store.selectedCount }}</span>
      </div>

      <table class="worklist-table">
        <thead>
        <tr>
          <th><input type="checkbox" :checked="isAllSelectedOnPage" @change="toggleSelectAll" /></th>
          <th>Barcode</th>
          <th>Customer ID</th>
          <th>Status</th>
          <th>Created At</th>
          <th>Updated At</th>
          <th>Actions</th>
        </tr>
        </thead>
        <tbody>
        <tr v-if="items.length === 0">
          <td colspan="7">No orders found for the current filters.</td>
        </tr>
        <tr v-for="item in items" :key="item.id" :class="{ 'selected-row': store.isSelected(item.id) }">
          <td><input type="checkbox" :checked="store.isSelected(item.id)" @change="store.toggleSelection(item.id)" /></td>
          <td>{{ item.barcode }}</td>
          <td>{{ item.customerId }}</td>
          <td><StatusBadge :status="item.processingStatus" /></td>
          <td>{{ formatDate(item.createdAt) }}</td>
          <td>{{ formatDate(item.updatedAt) }}</td>
          <td>
            <button @click="goToEditor(item.id)" class="button">Open</button>
          </td>
        </tr>
        </tbody>
      </table>

      <div class="pagination-controls" v-if="pagination.totalPages > 1">
        <button @click="handlePageChange(pagination.currentPage - 1)" :disabled="pagination.currentPage <= 1">Previous</button>
        <span>Page {{ pagination.currentPage }} of {{ pagination.totalPages }} ({{ pagination.totalItems }} items)</span>
        <button @click="handlePageChange(pagination.currentPage + 1)" :disabled="pagination.currentPage >= pagination.totalPages">Next</button>
      </div>
    </div>
  </div>
</template>

<style scoped>
.worklist-view {
  /* Inherits card styles */
}

.filter-controls {
  display: flex;
  flex-wrap: wrap; /* Allow wrapping on smaller screens */
  gap: var(--spacing-unit);
  margin-bottom: calc(var(--spacing-unit) * 2);
  padding-bottom: calc(var(--spacing-unit) * 2);
  border-bottom: 1px solid var(--color-border);
}

.filter-controls input,
.filter-controls select {
  padding: var(--spacing-unit);
  border: 1px solid var(--color-border);
  border-radius: 4px;
  flex-grow: 1; /* Allow inputs to grow */
  min-width: 150px; /* Minimum width for inputs */
}
.filter-controls input[type="date"] {
  flex-grow: 0; /* Don't let date inputs grow too much */
}

.filter-controls button {
  flex-grow: 0; /* Don't let button grow */
}

.loading-indicator, .error-message {
  padding: calc(var(--spacing-unit) * 2);
  margin-bottom: calc(var(--spacing-unit) * 2);
  border-radius: 4px;
}
.loading-indicator { background-color: #f0f0f0; }
.error-message { background-color: var(--color-danger); color: white; }

.worklist-content {
  /* Styles for table and actions */
}

.table-actions {
  margin-bottom: var(--spacing-unit);
  color: var(--color-text-light);
}

.worklist-table {
  width: 100%;
  border-collapse: collapse;
  margin-bottom: calc(var(--spacing-unit) * 2);
}

.worklist-table th,
.worklist-table td {
  border: 1px solid var(--color-border);
  padding: var(--spacing-unit);
  text-align: left;
  vertical-align: middle;
}

.worklist-table th {
  background-color: #f8f9fa;
  font-weight: 600;
}

.selected-row {
  background-color: #fff3cd; /* Light yellow for selected rows */
}

.pagination-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: var(--spacing-unit);
  margin-top: calc(var(--spacing-unit) * 2);
}
.pagination-controls button {
  padding: calc(var(--spacing-unit)*0.5) var(--spacing-unit);
  cursor: pointer;
}
.pagination-controls button:disabled {
  cursor: not-allowed;
  opacity: 0.6;
}
.pagination-controls span {
  color: var(--color-text-light);
}
</style>

================================================================================
### PLIK: views/admin/AddressProvidersView.vue
================================================================================

<template>
  <div class="container mx-auto p-4 sm:p-6 lg:p-8">
    <div class="bg-gradient-to-r from-slate-700 to-slate-900 text-white p-6 rounded-xl shadow-2xl mb-8">
      <h1 class="text-3xl sm:text-4xl font-bold">Zarządzanie Dostawcami Weryfikacji Adresów</h1>
      <p class="mt-2 text-slate-300">Konfiguruj aktywnego dostawcę używanego przez system TES.</p>
    </div>

    <div class="bg-white p-6 md:p-8 rounded-xl shadow-lg">
      <div v-if="isLoadingInitialData && !isPollingAnyOperation()" class="text-center py-10">
        <div class="animate-spin rounded-full h-10 w-10 border-t-4 border-b-4 border-indigo-500 mx-auto mb-4"></div>
        <p class="text-slate-600">Ładowanie początkowej konfiguracji dostawców...</p>
      </div>

      <div v-else-if="loadError" class="p-4 mb-4 text-sm text-red-700 bg-red-100 rounded-lg border border-red-300">
        <strong class="font-bold">Błąd ładowania konfiguracji:</strong> {{ loadError }}
        <button @click="fetchInitialProviderData" :disabled="isLoadingInitialData || isPollingAnyOperation()" class="ml-2 text-xs text-red-700 underline">Spróbuj ponownie</button>
      </div>

      <div v-else>
        <div class="mb-6 pb-4 border-b border-slate-200">
          <h2 class="text-xl font-semibold text-slate-700 mb-1">Aktualnie Aktywny Dostawca</h2>
          <div class="flex items-center">
            <div v-if="pollingStatus.currentProvider.isLoading && !currentProvider" class="text-slate-500 italic text-sm flex items-center">
              <span class="animate-spin h-4 w-4 mr-1 border-2 border-slate-400 border-t-transparent rounded-full"></span>
              Pobieranie... {{ pollingStatus.currentProvider.correlationId ? `(ID: ${pollingStatus.currentProvider.correlationId.substring(0,8)}...)` : '' }}
            </div>
            <p v-else-if="currentProvider" class="text-lg">
              <span class="font-bold px-3 py-1 rounded-full text-white" :class="getProviderBadgeClass(currentProvider)">
                {{ currentProvider.toUpperCase() }}
              </span>
              <span v-if="currentProvider.toLowerCase() === 'none'" class="ml-2 text-sm text-slate-500 italic">
                (Weryfikacja zewnętrzna jest wyłączona)
              </span>
            </p>
            <p v-else class="text-slate-500 italic">Nie można było ustalić aktywnego dostawcy.</p>

            <button @click="refreshCurrentProvider" :disabled="isLoadingInitialData || isPollingAnyOperation()" title="Odśwież aktualnego dostawcę" class="ml-4 text-xs text-indigo-600 hover:text-indigo-800 disabled:opacity-50 disabled:cursor-not-allowed p-1 rounded hover:bg-indigo-50">
              <svg v-if="pollingStatus.currentProvider.isLoading" class="animate-spin h-4 w-4 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              <span v-else>Odśwież</span>
            </button>
          </div>
           <p v-if="pollingStatus.currentProvider.error" class="text-xs text-red-500 mt-1">{{ pollingStatus.currentProvider.error }}</p>
        </div>

        <div class="mb-8">
          <label for="providerSelect" class="block text-sm font-medium text-slate-700 mb-1">Wybierz nowego dostawcę:</label>
          <div class="flex items-center space-x-3">
            <select
              id="providerSelect"
              v-model="selectedProviderToSet"
              class="block w-full max-w-xs p-2.5 border border-slate-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm bg-white transition duration-150"
              :disabled="pollingStatus.setProvider.isLoading || isPollingAnyOperationExcept('setProvider')"
            >
              <option disabled value="">-- Wybierz --</option>
              <option
                v-for="provider in availableProviders"
                :key="provider"
                :value="provider.toLowerCase()"
              >
                {{ provider.toUpperCase() }}
              </option>
              <option value="none">NONE (Wyłącz weryfikację)</option>
            </select>
            <button
              @click="requestSetProvider"
              :disabled="pollingStatus.setProvider.isLoading || !selectedProviderToSet || selectedProviderToSet === currentProvider || isPollingAnyOperationExcept('setProvider')"
              class="inline-flex items-center justify-center px-4 py-2.5 text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
            >
              <span v-if="pollingStatus.setProvider.isLoading" class="animate-spin h-4 w-4 -ml-1 mr-2 border-2 border-white border-t-transparent rounded-full"></span>
              {{ pollingStatus.setProvider.isLoading ? 'Przetwarzanie...' : 'Ustaw Aktywnego' }}
            </button>
          </div>
          <p v-if="selectedProviderToSet && selectedProviderToSet === currentProvider && !pollingStatus.setProvider.isLoading" class="text-xs text-slate-500 mt-1 italic">
            Wybrany dostawca jest już aktywny.
          </p>
        </div>

        <div v-if="operationMessage" :class="operationMessageType === 'success' ? 'bg-green-100 text-green-700 border-green-300' : (operationMessageType === 'info' ? 'bg-blue-100 text-blue-700 border-blue-300' : 'bg-red-100 text-red-700 border-red-300')" class="p-3 rounded-md border text-sm mb-4">
          {{ operationMessage }}
        </div>
         <div v-if="pollingStatus.setProvider.isLoading" class="text-sm text-slate-600 italic mb-4 flex items-center">
            <span class="animate-spin h-4 w-4 mr-2 border-2 border-slate-400 border-t-transparent rounded-full"></span>
            Oczekiwanie na wynik operacji (ID: {{ pollingStatus.setProvider.correlationId?.substring(0,8) || 'Zapisywanie' }})...
        </div>
        <p v-if="pollingStatus.setProvider.error" class="text-xs text-red-500 mt-1 mb-4">{{ pollingStatus.setProvider.error }}</p>

        <div class="mt-8 pt-6 border-t border-slate-200">
          <h3 class="text-lg font-semibold text-slate-700 mb-1">Dostępni Dostawcy w Systemie:</h3>
           <div class="flex items-center">
            <ul v-if="availableProviders.length && !pollingStatus.availableProviders.isLoading" class="list-disc list-inside space-y-1 text-sm text-slate-600">
                <li v-for="provider in availableProviders" :key="provider">{{ provider }}</li>
                <li><b>NONE</b> - opcja wyłączenia zewnętrznej weryfikacji adresów.</li>
            </ul>
            <p v-else-if="pollingStatus.availableProviders.isLoading" class="text-slate-500 italic text-sm ml-2 flex items-center">
                <span class="animate-spin h-4 w-4 mr-1 border-2 border-slate-400 border-t-transparent rounded-full"></span>
                Pobieranie listy... ({{ pollingStatus.availableProviders.correlationId?.substring(0,8) || 'ID' }}...)
            </p>
            <p v-else class="text-slate-500 italic">Brak informacji o dostępnych zaimplementowanych dostawcach.</p>
            <button @click="refreshAvailableProviders" :disabled="isLoadingInitialData || isPollingAnyOperation()" title="Odśwież listę dostępnych dostawców" class="ml-4 text-xs text-indigo-600 hover:text-indigo-800 disabled:opacity-50 disabled:cursor-not-allowed p-1 rounded hover:bg-indigo-50">
               <svg v-if="pollingStatus.availableProviders.isLoading" class="animate-spin h-4 w-4 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              <span v-else>Odśwież listę</span>
            </button>
           </div>
           <p v-if="pollingStatus.availableProviders.error" class="text-xs text-red-500 mt-1">{{ pollingStatus.availableProviders.error }}</p>

          <p class="text-xs text-slate-500 mt-4">
            <strong class="font-semibold">Uwaga:</strong> Zmiana aktywnego dostawcy jest zapisywana w konfiguracji centralnej (TES).
            System TES może wymagać odświeżenia konfiguracji, aby zmiana weszła w pełni w życie.
          </p>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue';
import apiClient from '@/services/api';
import { useAuthStore } from '@/stores/authStore';

const authStore = useAuthStore();

const isLoadingInitialData = ref(true);
const loadError = ref('');
const currentProvider = ref('');
const availableProviders = ref([]);
const selectedProviderToSet = ref('');

const operationMessage = ref('');
const operationMessageType = ref(''); // 'success', 'error', 'info'

const pollingStatus = ref({
    currentProvider: { correlationId: null, isLoading: false, error: null, intervalId: null, description: "Pobieranie aktualnego dostawcy" },
    availableProviders: { correlationId: null, isLoading: false, error: null, intervalId: null, description: "Pobieranie listy dostępnych dostawców" },
    setProvider: { correlationId: null, isLoading: false, error: null, intervalId: null, description: "Ustawianie aktywnego dostawcy" }
});

const MAX_POLLS = 20;
const POLL_INTERVAL_MS = 3000;

const clearPollingForOperation = (operationKey) => {
    if (pollingStatus.value[operationKey]?.intervalId) {
        clearInterval(pollingStatus.value[operationKey].intervalId);
    }
    pollingStatus.value[operationKey] = { 
        ...pollingStatus.value[operationKey],
        isLoading: false, 
        error: null, 
        intervalId: null 
    };
};

const clearAllPolling = () => {
    Object.keys(pollingStatus.value).forEach(key => clearPollingForOperation(key));
};

onUnmounted(() => {
    clearAllPolling();
});

const isPollingAnyOperation = () => {
    return Object.values(pollingStatus.value).some(op => op.isLoading);
};

const isPollingAnyOperationExcept = (exceptKey) => {
    return Object.entries(pollingStatus.value)
        .filter(([key]) => key !== exceptKey)
        .some(([,op]) => op.isLoading);
};


const pollOperation = async (correlationId, operationKey) => {
    const opDesc = pollingStatus.value[operationKey].description;
    
    if (!correlationId) {
        const errorMsg = `Brak CorrelationID dla operacji: ${opDesc}`;
        pollingStatus.value[operationKey].error = errorMsg;
        pollingStatus.value[operationKey].isLoading = false;
        if (operationKey === 'setProvider' || operationKey === 'currentProvider' || operationKey === 'availableProviders') { // Aktualizuj główny komunikat dla wszystkich operacji tego widoku
            operationMessage.value = errorMsg;
            operationMessageType.value = 'error';
        }
        return Promise.reject(new Error(errorMsg));
    }
    
    pollingStatus.value[operationKey].correlationId = correlationId;
    pollingStatus.value[operationKey].isLoading = true;
    pollingStatus.value[operationKey].error = null;
    
    // Komunikat o przetwarzaniu dla wszystkich operacji
    operationMessage.value = `Przetwarzanie: ${opDesc} (ID: ${correlationId.substring(0,8)}...).`;
    operationMessageType.value = 'info';


    return new Promise((resolve, reject) => {
        let polls = 0;
        if (pollingStatus.value[operationKey].intervalId) {
            clearInterval(pollingStatus.value[operationKey].intervalId);
        }

        pollingStatus.value[operationKey].intervalId = setInterval(async () => {
            polls++;
            if (!pollingStatus.value[operationKey].isLoading || polls > MAX_POLLS) {
                if (polls > MAX_POLLS && pollingStatus.value[operationKey].isLoading) {
                    pollingStatus.value[operationKey].error = `Timeout oczekiwania na zakończenie operacji '${opDesc}' (CorrID: ${correlationId}).`;
                }
                const finalErrorMsg = pollingStatus.value[operationKey].error || `Polling for ${opDesc} (CorrID: ${correlationId}) stopped or timed out.`;
                operationMessage.value = finalErrorMsg;
                operationMessageType.value = 'error';
                
                clearPollingForOperation(operationKey);
                return reject(new Error(finalErrorMsg));
            }

            console.debug(`Odpytywanie operacji ${operationKey} (CorrID: ${correlationId}), próba ${polls}`);
            try {
                const res = await apiClient.get(`/api/admin/address-verification/operations/${correlationId}`);
                
                if (res.data && res.data.status === 'COMPLETED') {
                    clearPollingForOperation(operationKey);
                    console.info(`Operacja '${opDesc}' (CorrID: ${correlationId}) zakończona sukcesem.`);
                     if (operationKey === 'setProvider') {
                         operationMessage.value = (res.data.result && typeof res.data.result === 'string') ? res.data.result : `Operacja '${opDesc}' zakończona pomyślnie.`;
                         operationMessageType.value = 'success';
                     } else if (operationMessage.value.startsWith('Przetwarzanie')) { // Tylko jeśli nie ma innego błędu
                        operationMessage.value = `Operacja '${opDesc}' zakończona.`;
                        operationMessageType.value = 'success';
                     }
                    resolve(res.data.result);
                } else if (res.data && res.data.status === 'FAILED') {
                    clearPollingForOperation(operationKey);
                    const errorMsg = res.data.errorDetails || `Operacja ${opDesc} nie powiodła się.`;
                    pollingStatus.value[operationKey].error = errorMsg;
                    operationMessage.value = errorMsg;
                    operationMessageType.value = 'error';
                    console.error(`Operacja '${opDesc}' (CorrID: ${correlationId}) zakończona błędem: ${errorMsg}`);
                    reject(new Error(errorMsg));
                } else if (res.data && (res.data.status === 'PENDING' || res.data.status === 'PROCESSING')) {
                    // Kontynuuj odpytywanie
                    // Można zaktualizować `operationMessage` o statusie PENDING/PROCESSING
                    operationMessage.value = `Operacja '${opDesc}' w toku (Status: ${res.data.status}, ID: ${correlationId.substring(0,8)})...`;
                    operationMessageType.value = 'info';
                } else { 
                    clearPollingForOperation(operationKey);
                    const unexpectedMsg = `Nieoczekiwany status operacji '${res.data?.status || 'BRAK'}' dla '${opDesc}' (CorrID: ${correlationId}).`;
                    pollingStatus.value[operationKey].error = unexpectedMsg;
                    operationMessage.value = unexpectedMsg;
                    operationMessageType.value = 'error';
                    console.error(unexpectedMsg);
                    reject(new Error(unexpectedMsg));
                }
            } catch (pollError) {
                clearPollingForOperation(operationKey);
                const networkErrorMsg = `Błąd sieci podczas odpytywania o status operacji '${opDesc}' (CorrID: ${correlationId}).`;
                pollingStatus.value[operationKey].error = pollError.response?.data?.error || pollError.message || networkErrorMsg;
                operationMessage.value = pollingStatus.value[operationKey].error;
                operationMessageType.value = 'error';
                console.error(networkErrorMsg, pollError);
                reject(new Error(pollingStatus.value[operationKey].error));
            }
        }, POLL_INTERVAL_MS);
    });
};

const initiateOperation = async (endpoint, operationKey, payload = null, httpMethod = 'POST') => {
    if (!authStore.isLoggedIn) {
        loadError.value = "Użytkownik nie jest zalogowany."; // Ustaw loadError zamiast rzucać, aby obsłużyć w UI
        isLoadingInitialData.value = false; // Jeśli to było ładowanie początkowe
        return Promise.reject(new Error("Użytkownik nie jest zalogowany."));
    }
    const opDesc = pollingStatus.value[operationKey].description;
    clearPollingForOperation(operationKey); // Wyczyść poprzedni stan dla tej operacji

    pollingStatus.value[operationKey].isLoading = true;
    pollingStatus.value[operationKey].error = null;
    
    if (operationKey === 'setProvider' || isLoadingInitialData.value) {
         operationMessage.value = `Inicjowanie: ${opDesc}...`;
         operationMessageType.value = 'info';
    }

    try {
        let response;
        const config = (payload && (payload instanceof String || typeof payload === 'string')) ? { headers: { 'Content-Type': 'text/plain' } } : {};

        if (httpMethod.toUpperCase() === 'POST') {
            response = await apiClient.post(endpoint, payload, config);
        } else { // Dla GET, payload jest ignorowany
            response = await apiClient.get(endpoint, config);
        }
        
        const correlationId = response.data.correlationId;
        if (!correlationId) {
            throw new Error(`Nie udało się zainicjować operacji: ${opDesc}. Brak CorrelationID w odpowiedzi serwera: ${JSON.stringify(response.data)}`);
        }
        console.debug(`Zainicjowano ${opDesc}, CorrID: ${correlationId}`);
        pollingStatus.value[operationKey].correlationId = correlationId;
        return pollOperation(correlationId, operationKey);
    } catch (initError) {
        pollingStatus.value[operationKey].isLoading = false;
        const errorDetail = initError.response?.data?.error || initError.response?.data?.message || initError.message || `Nie udało się zainicjować operacji: ${opDesc}.`;
        pollingStatus.value[operationKey].error = errorDetail;
        if (operationKey === 'setProvider' || isLoadingInitialData.value) {
            operationMessage.value = errorDetail;
            operationMessageType.value = 'error';
        }
        console.error(`Błąd inicjacji operacji '${opDesc}':`, initError);
        throw new Error(pollingStatus.value[operationKey].error);
    }
};

const fetchInitialProviderData = async () => {
    isLoadingInitialData.value = true;
    loadError.value = '';
    operationMessage.value = '';
    // clearAllPolling(); // Nie czyść tutaj, bo `initiateOperation` to zrobi dla swoich kluczy

    try {
        // Użyj POST dla endpointów inicjujących
        const results = await Promise.allSettled([
            initiateOperation('/api/admin/address-verification/providers/current/initiate', 'currentProvider', null, 'POST'),
            initiateOperation('/api/admin/address-verification/providers/available/initiate', 'availableProviders', null, 'POST')
        ]);

        let hasFulfilledCurrent = false;
        let hasFulfilledAvailable = false;

        if (results[0].status === 'fulfilled') {
            currentProvider.value = results[0].value || 'none';
            selectedProviderToSet.value = currentProvider.value && currentProvider.value !== 'none' ?
                                       currentProvider.value.toLowerCase() : 'none';
            hasFulfilledCurrent = true;
        } else {
            currentProvider.value = 'N/A (błąd)';
            // pollingStatus.currentProvider.error jest już ustawione przez pollOperation
            loadError.value += `Błąd pobierania aktualnego dostawcy: ${pollingStatus.value.currentProvider.error || results[0].reason?.message || 'Nieznany błąd'}. `;
        }

        if (results[1].status === 'fulfilled') {
            availableProviders.value = Array.isArray(results[1].value) ? results[1].value : [];
            hasFulfilledAvailable = true;
        } else {
            availableProviders.value = [];
            loadError.value += `Błąd pobierania listy dostępnych dostawców: ${pollingStatus.value.availableProviders.error || results[1].reason?.message || 'Nieznany błąd'}.`;
        }

        if (hasFulfilledCurrent && hasFulfilledAvailable) {
            operationMessage.value = "Konfiguracja dostawców załadowana pomyślnie.";
            operationMessageType.value = 'success';
        } else if (loadError.value && !isPollingAnyOperation()) { // Pokaż ogólny błąd tylko jeśli nic nie polluje
             operationMessage.value = "Wystąpiły problemy podczas ładowania konfiguracji. Sprawdź błędy poszczególnych operacji.";
             operationMessageType.value = 'error';
        } else if (isPollingAnyOperation()){
            operationMessage.value = "Trwa ładowanie danych..."; // Ogólny komunikat, jeśli coś jeszcze polluje
            operationMessageType.value = 'info';
        }

    } catch (error) { // Ten catch złapie błędy, które nie są PromiseRejectionEvent
        console.error('Krytyczny błąd podczas inicjowania pobierania konfiguracji:', error);
        loadError.value = error.message || 'Nie udało się załadować początkowej konfiguracji.';
        operationMessage.value = loadError.value;
        operationMessageType.value = 'error';
    } finally {
        isLoadingInitialData.value = false;
    }
};

const requestSetProvider = async () => {
  if (!selectedProviderToSet.value || pollingStatus.value.setProvider.isLoading || isPollingAnyOperationExcept('setProvider')) return;
  
  operationMessage.value = ''; 
  operationMessageType.value = '';

  try {
    // Endpoint `/api/admin/address-verification/providers/current` jest POST i przyjmuje String w ciele
    const result = await initiateOperation(
        '/api/admin/address-verification/providers/current', 
        'setProvider',
        selectedProviderToSet.value, // Payload to string
        'POST' 
    );
    // Komunikat sukcesu jest już ustawiany w pollOperation
    await fetchInitialProviderData(); // Odśwież całą konfigurację po sukcesie

  } catch (error) {
    console.error('Błąd podczas ustawiania aktywnego dostawcy:', error);
    // Komunikat błędu jest już ustawiony w pollOperation lub initiateOperation
    if (!operationMessage.value || operationMessageType.value !== 'error') {
        operationMessage.value = error.message || 'Nie udało się ustawić aktywnego dostawcy.';
        operationMessageType.value = 'error';
    }
  }
};

const refreshCurrentProvider = async () => {
    if (isPollingAnyOperation()) return;
    operationMessage.value = '';
    try {
        const result = await initiateOperation('/api/admin/address-verification/providers/current/initiate', 'currentProvider', null, 'POST');
        currentProvider.value = result || 'none';
        selectedProviderToSet.value = currentProvider.value && currentProvider.value !== 'none' ? currentProvider.value.toLowerCase() : 'none';
        operationMessage.value = "Pomyślnie odświeżono aktualnego dostawcę.";
        operationMessageType.value = 'success';
    } catch (error) {
        operationMessage.value = error.message || "Nie udało się odświeżyć aktualnego dostawcy.";
        operationMessageType.value = 'error';
        // Błąd specyficzny dla operacji jest już w pollingStatus.currentProvider.error
    }
};

const refreshAvailableProviders = async () => {
    if (isPollingAnyOperation()) return;
    operationMessage.value = '';
    try {
        const result = await initiateOperation('/api/admin/address-verification/providers/available/initiate', 'availableProviders', null, 'POST');
        availableProviders.value = Array.isArray(result) ? result : [];
        operationMessage.value = "Pomyślnie odświeżono listę dostępnych dostawców.";
        operationMessageType.value = 'success';
    } catch (error) {
        operationMessage.value = error.message || "Nie udało się odświeżyć listy dostępnych dostawców.";
        operationMessageType.value = 'error';
        // Błąd specyficzny dla operacji jest już w pollingStatus.availableProviders.error
    }
};

const getProviderBadgeClass = (providerName) => {
  if (!providerName) return 'bg-slate-400';
  switch (providerName.toLowerCase()) {
    case 'here': return 'bg-blue-600';
    case 'nominatim': return 'bg-green-600';
    case 'maps': return 'bg-yellow-500 text-black';
    case 'none': return 'bg-slate-500';
    default: return 'bg-gray-500';
  }
};

onMounted(() => {
  fetchInitialProviderData();
});

</script>

<style scoped>
.animate-spin {
  animation: spin 1s linear infinite;
}
@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
</style>

================================================================================
### PLIK: views/admin/AddressUploadView.vue
================================================================================

<script setup>
import { ref } from 'vue';
import { useAddressUploadStore } from '@/stores/addressUploadStore';

const uploadStore = useAddressUploadStore();
const selectedFile = ref(null);
const fileInput = ref(null);

const handleFileChange = (event) => {
  selectedFile.value = event.target.files[0];
};

const handleUpload = () => {
  if (selectedFile.value) {
    uploadStore.uploadFile(selectedFile.value);
    selectedFile.value = null; 
    fileInput.value.value = '';
  }
};

const getStatusClass = (status) => {
    switch(status) {
        case 'COMPLETED': return 'text-green-600';
        case 'PENDING': return 'text-yellow-600';
        case 'PROCESSING': return 'text-blue-600';
        case 'FAILED_WITH_ERRORS': return 'text-red-600';
        case 'POLLING_ERROR': return 'text-red-800';
        default: return 'text-gray-600';
    }
};
</script>

<template>
  <div class="bg-white p-6 rounded-lg shadow-md space-y-8">
    <h1 class="text-2xl font-bold text-gray-800">Address File Upload</h1>

    <div class="border border-gray-200 p-4 rounded-lg">
      <h2 class="text-lg font-semibold text-gray-700 mb-4">Upload New File</h2>
      <div class="flex items-center space-x-4">
        <input type="file" @change="handleFileChange" ref="fileInput" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"/>
        <button @click="handleUpload" :disabled="!selectedFile || uploadStore.isLoading" class="px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75 disabled:bg-gray-400 disabled:cursor-not-allowed">
          {{ uploadStore.isLoading ? 'Uploading...' : 'Upload' }}
        </button>
      </div>
      <div v-if="uploadStore.error" class="text-red-600 mt-2 text-sm">{{ uploadStore.error }}</div>
    </div>

    <div class="border border-gray-200 p-4 rounded-lg">
      <h2 class="text-lg font-semibold text-gray-700 mb-4">Upload History</h2>
      <div v-if="uploadStore.jobList.length === 0" class="text-gray-500">No upload jobs found.</div>
      <div v-else class="space-y-4">
        <div v-for="job in uploadStore.jobList" :key="job.jobId" class="bg-gray-50 p-4 rounded-md">
            <div class="flex justify-between items-center">
                <div>
                    <p class="font-semibold text-gray-800">{{ job.originalFilename }}</p>
                    <p class="text-sm text-gray-500">Job ID: {{ job.jobId }}</p>
                    <p class="text-sm text-gray-500">Started at: {{ new Date(job.createdAt).toLocaleString() }}</p>
                </div>
                <div class="text-right">
                    <p class="font-bold" :class="getStatusClass(job.status)">{{ job.status }}</p>
                    <p v-if="job.status === 'PROCESSING'" class="text-sm">{{ job.progress }}%</p>
                    <p v-if="job.errorDetails" class="text-sm text-red-600">{{ job.errorDetails }}</p>
                </div>
            </div>
            <div v-if="job.status === 'PROCESSING'" class="w-full bg-gray-200 rounded-full h-2.5 mt-2">
                <div class="bg-blue-600 h-2.5 rounded-full" :style="{ width: job.progress + '%' }"></div>
            </div>
        </div>
      </div>
    </div>
  </div>
</template>

================================================================================
### PLIK: views/admin/HubInvoicingRulesView.vue
================================================================================

<script setup>
import { ref, onMounted, reactive } from 'vue';
import { useInvoicingRulesStore } from '@/stores/invoicingRulesStore';

const rulesStore = useInvoicingRulesStore();

const isModalOpen = ref(false);
const isEditing = ref(false);
const currentRule = reactive({
  id: null,
  hubId: '',
  // --- UZUPEŁNIJ ---
  // Dodaj inne pola z Twojego modelu danych 'rule'
  // np. description: '', amount: 0
});

onMounted(() => {
  rulesStore.fetchHubRules();
});

const openAddModal = () => {
  isEditing.value = false;
  Object.assign(currentRule, { id: null, hubId: '' }); // Reset form
  isModalOpen.value = true;
};

const openEditModal = (rule) => {
  isEditing.value = true;
  Object.assign(currentRule, rule); // Load rule data into form
  isModalOpen.value = true;
};

const closeModal = () => {
  isModalOpen.value = false;
};

const handleSave = async () => {
  await rulesStore.saveRule({ ...currentRule });
  closeModal();
};

const handleDelete = async (ruleId) => {
  if (confirm('Are you sure you want to delete this rule?')) {
    await rulesStore.deleteRule(ruleId);
  }
};
</script>

<template>
  <div class="bg-white p-6 rounded-lg shadow-md">
    <div class="flex justify-between items-center mb-6">
      <h1 class="text-2xl font-bold text-gray-800">HUB Invoicing Rules</h1>
      <button @click="openAddModal" class="px-4 py-2 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700">Add New Rule</button>
    </div>

    <div v-if="rulesStore.isLoading">Loading...</div>
    <div v-else-if="rulesStore.error" class="text-red-600">{{ rulesStore.error }}</div>
    
    <table v-else class="min-w-full bg-white">
      <thead class="bg-gray-200">
        <tr>
          <th class="py-2 px-4 text-left">HUB ID</th>
          <th class="py-2 px-4 text-left">Actions</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="rule in rulesStore.sortedHubRules" :key="rule.id" class="border-b">
          <td class="py-2 px-4">{{ rule.hubId }}</td>
          <td class="py-2 px-4 space-x-2">
            <button @click="openEditModal(rule)" class="text-blue-600 hover:underline">Edit</button>
            <button @click="handleDelete(rule.id)" class="text-red-600 hover:underline">Delete</button>
          </td>
        </tr>
      </tbody>
    </table>

    <div v-if="isModalOpen" class="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
            <h2 class="text-xl font-bold mb-4">{{ isEditing ? 'Edit' : 'Add' }} Rule</h2>
            <form @submit.prevent="handleSave" class="space-y-4">
                <div>
                    <label for="hubId" class="block text-sm font-medium">HUB ID</label>
                    <input type="text" id="hubId" v-model="currentRule.hubId" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md" required />
                </div>
                <div class="flex justify-end space-x-4 mt-6">
                    <button type="button" @click="closeModal" class="px-4 py-2 bg-gray-300 rounded-lg">Cancel</button>
                    <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded-lg">{{ rulesStore.isLoading ? 'Saving...' : 'Save' }}</button>
                </div>
            </form>
        </div>
    </div>
  </div>
</template>

================================================================================
### PLIK: assets/main.css
================================================================================

/* ARCHITECTURE: Base styles kept tiny and neutral. */
:root { color-scheme: light; }
body { background:#fff; color:#111; }

================================================================================
### PLIK: assets/theme.css
================================================================================

/* ARCHITECTURE: Base theme variables and minimal global styles */
:root {
    --color-primary: #005A9C; /* A solid blue */
    --color-secondary: #FFC107; /* A bright yellow */
    --color-background: #FFFFFF; /* White background */
    --color-text: #333333; /* Dark gray text */
    --color-text-light: #666666; /* Lighter gray text */
    --color-border: #E0E0E0; /* Light gray border */
    --color-success: #28a745;
    --color-warning: #ffc107; /* Using secondary yellow for warning */
    --color-danger: #dc3545;
    --color-info: #17a2b8;
    --color-neutral: #6c757d;

    --font-family-sans: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    --spacing-unit: 8px; /* Base unit for margins/paddings */
}

/* Minimal body reset */
body {
    margin: 0;
    padding: 0;
    font-family: var(--font-family-sans);
    background-color: var(--color-background);
    color: var(--color-text);
    line-height: 1.6;
}

/* Basic link styling */
a {
    color: var(--color-primary);
    text-decoration: none;
}
a:hover {
    text-decoration: underline;
}

/* Basic container */
.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: calc(var(--spacing-unit) * 2);
}

/* Basic headings */
h1, h2, h3, h4 {
    color: var(--color-primary);
    margin-bottom: var(--spacing-unit);
}

/* Utility class for primary text color */
.text-primary {
    color: var(--color-primary);
}

/* Utility class for secondary text color */
.text-secondary {
    color: var(--color-secondary);
}

/* Simple button style */
.button {
    display: inline-block;
    padding: calc(var(--spacing-unit) * 1.5) calc(var(--spacing-unit) * 3);
    background-color: var(--color-primary);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    text-align: center;
    transition: background-color 0.2s ease;
}
.button:hover {
    background-color: #004477; /* Darker blue */
}
.button.secondary {
    background-color: var(--color-secondary);
    color: var(--color-text);
}
.button.secondary:hover {
    background-color: #e0a800; /* Darker yellow */
}

/* Basic card style */
.card {
    border: 1px solid var(--color-border);
    border-radius: 4px;
    padding: calc(var(--spacing-unit) * 2);
    margin-bottom: calc(var(--spacing-unit) * 2);
    background-color: #fff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

================================================================================
### PLIK: domain/BulkEditPlan.js
================================================================================

/**
 * ARCHITEKTURA: Deklaratywna definicja operacji masowej korekty adresów z podglądem i zastosowaniem.
 * Zaprojektowana do walidacji po stronie serwera oraz ponownej weryfikacji partii.
 */
export class BulkEditPlan {
  constructor(orderIds, field, mode, findPattern, replaceWith) {
    this.orderIds = Array.isArray(orderIds) ? orderIds : [];
    this.field = field;
    this.mode = mode;
    this.findPattern = findPattern;
    this.replaceWith = replaceWith;
  }

  static findReplace(orderIds, field, findPattern, replaceWith) {
    return new BulkEditPlan(orderIds, field, "FIND_REPLACE", findPattern, replaceWith);
  }

  static append(orderIds, field, suffix) {
    return new BulkEditPlan(orderIds, field, "APPEND", null, suffix);
  }

  static prepend(orderIds, field, prefix) {
    return new BulkEditPlan(orderIds, field, "PREPEND", null, prefix);
  }
}


================================================================================
### PLIK: domain/Result.js
================================================================================

/**
 * ARCHITEKTURA: Uniwersalny nośnik wyniku operacji (sukces/porażka) bez nulli i wyjątków sterujących przepływem.
 * Zapewnia spójny kontrakt dla wywołań usług oraz ułatwia kompozycję wyników.
 */
export class Result {
  constructor(ok, value, error) {
    this.ok = ok;
    this._value = value;
    this._error = error;
  }

  static ok(value) {
    return new Result(true, value, undefined);
  }

  static fail(error) {
    return new Result(false, undefined, error instanceof Error ? error : new Error(String(error)));
  }

  get value() {
    if (!this.ok) throw new Error("Attempt to get value from failed Result.");
    return this._value;
    }

  get error() {
    if (this.ok) throw new Error("Attempt to get error from successful Result.");
    return this._error;
  }

  map(fn) {
    return this.ok ? Result.ok(fn(this._value)) : Result.fail(this._error);
  }

  asyncMap(fn) {
    if (!this.ok) return Promise.resolve(Result.fail(this._error));
    return fn(this._value).then(Result.ok).catch(err => Result.fail(err));
  }
}


================================================================================
### PLIK: domain/WorkbenchModels.js
================================================================================

// ============================================================================
// Frontend: Update domain/WorkbenchModels.js
// REASON: Add 'alias' and 'name' fields to the Address model.
// ============================================================================
/**
 * ARCHITECTURE: WorkbenchModels define immutable value objects used by the editor and worklist.
 * It follows the manifesto by centralizing simple data models away from transport and views.
 * Responsibilities:
 * - Provide Address with factory helpers to ensure safe defaults and cloning.
 * - Offer toPlain() for persistence mapping without leaking internal structure.
 * UPDATED: Added 'name' and 'alias' fields.
 */
export class Address {
  constructor({ street = "", houseNumber = null, postalCode = "", city = "", country = "PL", latitude = null, longitude = null, name = null, alias = null } = {}) {
    this.street = street || "";
    this.houseNumber = houseNumber || null;
    this.postalCode = postalCode || "";
    this.city = city || "";
    this.country = country || "PL";
    this.latitude = typeof latitude === "number" ? latitude : null;
    this.longitude = typeof longitude === "number" ? longitude : null;
    // --- NEW FIELDS ---
    this.name = name || null;
    this.alias = alias || null;
    // --- END NEW FIELDS ---
  }

  static from(obj) {
    if (!obj || typeof obj !== "object") return new Address();
    return new Address({
      street: obj.street,
      houseNumber: obj.houseNumber,
      postalCode: obj.postalCode,
      city: obj.city,
      country: obj.country,
      latitude: obj.latitude,
      longitude: obj.longitude,
      // --- NEW FIELDS ---
      name: obj.name,
      alias: obj.alias,
      // --- END NEW FIELDS ---
    });
  }

  clone() {
    return new Address(this);
  }

  toPlain() {
    return {
      street: this.street,
      houseNumber: this.houseNumber,
      postalCode: this.postalCode,
      city: this.city,
      country: this.country,
      latitude: this.latitude,
      longitude: this.longitude,
      // --- NEW FIELDS ---
      name: this.name,
      alias: this.alias,
      // --- END NEW FIELDS ---
    };
  }
}

================================================================================
### PLIK: domain/WorklistFilter.js
================================================================================

// ============================================================================
// Frontend: Update WorklistFilter Domain (Supersedes previous version)
// FILE: src/domain/WorklistFilter.js
// REASON: Align default status with canonical mission state 'PENDING_VERIFICATION'.
// ============================================================================
// FILE: src/domain/WorklistFilter.js (Supersedes previous version)

/**
 * ARCHITEKTURA: Niemutowalny obiekt zapytania do listy roboczej.
 * Odpowiada za serializację filtrów do parametrów URL.
 * Separuje szczegóły filtrowania od komponentów UI oraz usług sieciowych.
 * ENHANCED: Added status, barcode, customerId, dateFrom, dateTo fields.
 * UPDATED: Changed default status to PENDING_VERIFICATION.
 */
export class WorklistFilter {
  // *** MODIFIED: Added constructor parameters and properties ***
  constructor({ status = 'PENDING_VERIFICATION', barcode = '', customerId = '', dateFrom = '', dateTo = '' } = {}) {
    this.status = status || 'PENDING_VERIFICATION'; // Default status aligned
    this.barcode = barcode || '';
    this.customerId = customerId || '';
    this.dateFrom = dateFrom || ''; // Expect YYYY-MM-DD
    this.dateTo = dateTo || '';     // Expect YYYY-MM-DD
  }
  // *** END MODIFIED ***

  withPatch(patch) {
    // *** MODIFIED: Update patch logic for new fields ***
    return new WorklistFilter({
      status: patch.status ?? this.status,
      barcode: patch.barcode ?? this.barcode,
      customerId: patch.customerId ?? this.customerId,
      dateFrom: patch.dateFrom ?? this.dateFrom,
      dateTo: patch.dateTo ?? this.dateTo,
    });
    // *** END MODIFIED ***
  }

  toQueryRecord() {
    // *** MODIFIED: Serialize all filter fields ***
    const q = {};
    if (this.status) q.status = this.status;
    if (this.barcode) q.barcode = this.barcode;
    if (this.customerId) q.customerId = this.customerId;
    if (this.dateFrom) q.dateFrom = this.dateFrom;
    if (this.dateTo) q.dateTo = this.dateTo;
    // page and size are added by the store action
    return q;
    // *** END MODIFIED ***
  }

  // Helper to return plain object state, useful for binding v-model in components
  toPlainObject() {
    return {
      status: this.status,
      barcode: this.barcode,
      customerId: this.customerId,
      dateFrom: this.dateFrom,
      dateTo: this.dateTo,
    };
  }
}

================================================================================
### PLIK: services/AddressAuditTrailService.js
================================================================================

/**
 * ARCHITECTURE: AddressAuditTrailService maintains an in-memory audit stream for user actions.
 * It follows the manifesto by isolating audit appends and allowing later persistence without UI impact.
 * Responsibilities:
 * - Append entries and read them by orderId; provide a clear method for testability.
 */
export class AddressAuditTrailService {
  constructor() {
    this._byOrder = new Map();
  }

  append(entry) {
    const id = entry?.orderId || "unknown";
    const list = this._byOrder.get(id) || [];
    list.push({ ...entry, at: new Date().toISOString() });
    this._byOrder.set(id, list);
    return true;
  }

  list(orderId) {
    return (this._byOrder.get(orderId) || []).slice();
  }

  clear(orderId) {
    if (!orderId) return false;
    this._byOrder.delete(orderId);
    return true;
  }
}


================================================================================
### PLIK: services/AddressClipboardService.js
================================================================================

/**
 * ARCHITECTURE: AddressClipboardService copies formatted addresses to clipboard for quick customer contact.
 * It follows the manifesto by isolating browser clipboard usage and formatting concerns.
 * Responsibilities:
 * - Build single-line and multi-line strings and write to navigator.clipboard if available.
 * - Provide deterministic return values indicating success or failure without throwing.
 */
export class AddressClipboardService {
  constructor() {
    this.available = typeof navigator !== "undefined" && !!navigator.clipboard;
  }

  async copyOneLine(a) {
    const str = this._oneLine(a);
    return this._copy(str);
  }

  async copyTwoLines(a) {
    const str = this._twoLines(a);
    return this._copy(str);
  }

  async _copy(str) {
    if (!this.available) return { ok: false, reason: "Clipboard unavailable" };
    try {
      await navigator.clipboard.writeText(str);
      return { ok: true };
    } catch (_) {
      return { ok: false, reason: "Clipboard write failed" };
    }
  }

  _oneLine(a) {
    const p1 = [a?.street, a?.houseNumber].filter(Boolean).join(" ");
    const p2 = [a?.postalCode, a?.city].filter(Boolean).join(" ");
    const p3 = a?.country || "PL";
    return [p1, p2, p3].filter(Boolean).join(", ");
  }

  _twoLines(a) {
    const p1 = [a?.street, a?.houseNumber].filter(Boolean).join(" ");
    const p2 = [a?.postalCode, a?.city, a?.country || "PL"].filter(Boolean).join(", ");
    return `${p1}\n${p2}`;
  }
}


================================================================================
### PLIK: services/AddressCorrectionService.js
================================================================================

/**
 * ARCHITECTURE: AddressCorrectionService persists address fixes to the backend and records an audit entry.
 * It follows the manifesto by isolating persistence and audit concerns behind one explicit contract.
 * Responsibilities:
 * - Save corrections via AddressExceptionApi with explicit resolution mode.
 * - Append audit entries using AddressAuditTrailService and provide a deterministic Result object.
 */
import { Result } from "@/domain/Result";
import { AddressAuditTrailService } from "@/services/AddressAuditTrailService";
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

export class AddressCorrectionService {
  constructor(api = new AddressExceptionApi(), audit = new AddressAuditTrailService()) {
    this.api = api;
    this.audit = audit;
  }

  async save({ orderId, side, before, after, resolution }) {
    const res = await this.api.saveCorrection({
      orderId,
      side,
      correctedPickup: side === "pickup" || side === "both" ? after?.pickup || null : null,
      correctedDelivery: side === "delivery" || side === "both" ? after?.delivery || null : null,
      resolution: resolution || "MANUAL_EDIT",
    });
    if (!res.ok) return Result.fail(res.error);
    this.audit.append({
      orderId,
      side,
      action: resolution || "MANUAL_EDIT",
      before,
      after,
      diff: null,
    });
    return Result.ok(res.value);
  }
}


================================================================================
### PLIK: services/AddressEqualityService.js
================================================================================

/**
 * ARCHITECTURE: AddressEqualityService computes structural equality and a stable hash for Address DTOs.
 * It follows the manifesto by providing deterministic comparisons without UI or transport concerns.
 * Responsibilities:
 * - Compare two addresses field-by-field with normalization of whitespace and case.
 * - Produce a hash string for use in caches, audit, or deduplication logic.
 */
export class AddressEqualityService {
  constructor() {
    this._fields = ["street", "houseNumber", "postalCode", "city", "country", "latitude", "longitude"];
  }

  equals(a, b) {
    if (!a || !b) return false;
    for (const f of this._fields) {
      if (!this._eq(a[f], b[f])) return false;
    }
    return true;
  }

  hash(a) {
    const s = (x) => (x == null ? "" : String(x).trim().toLowerCase());
    const n = (x) => (typeof x === "number" ? x.toFixed(6) : "");
    const parts = [
      s(a?.street),
      s(a?.houseNumber),
      s(a?.postalCode),
      s(a?.city),
      s(a?.country),
      n(a?.latitude),
      n(a?.longitude),
    ];
    return this._simpleHash(parts.join("|"));
  }

  _eq(a, b) {
    if (typeof a === "number" || typeof b === "number") {
      return Number(a || 0).toFixed(6) === Number(b || 0).toFixed(6);
    }
    return (a || "").toString().trim().toLowerCase() === (b || "").toString().trim().toLowerCase();
  }

  _simpleHash(str) {
    let h = 0;
    for (let i = 0; i < str.length; i++) {
      h = (h << 5) - h + str.charCodeAt(i);
      h |= 0;
    }
    return `h${(h >>> 0).toString(16)}`;
  }
}


================================================================================
### PLIK: services/AddressExceptionApi.js
================================================================================

// ============================================================================
// Frontend: Update AddressExceptionApi (Supersedes previous version)
// FILE: src/services/AddressExceptionApi.js
// REASON: Add 'saveResubmission' method for new save flow.
//         Update _getStoredAddressLabel to show raw reason codes.
// ============================================================================
// FILE: src/services/AddressExceptionApi.js (Supersedes previous version)
import api from "@/services/api";
import { Result } from "@/domain/Result";
import { Address } from "@/domain/WorkbenchModels";

/**
 * ARCHITECTURE: API client for address-related operations.
 * UPDATED: Added saveResubmission.
 * UPDATED: _getStoredAddressLabel now returns the raw reason code.
 */
export class AddressExceptionApi {
    constructor() {
        this.client = api;
    }

    async getWorklist(filter = { page: 0, size: 25, status: 'PENDING_VERIFICATION' }) {
        try {
            const q = new URLSearchParams();
            q.set("page", String(filter.page >= 0 ? filter.page : 0));
            q.set("size", String(filter.size || 25));
            q.set("status", filter.status || 'PENDING_VERIFICATION');
            if (filter.barcode) q.set("barcode", filter.barcode);
            if (filter.sort) q.set("sort", filter.sort);
            if (filter.customerId) q.set("customerId", filter.customerId);
            if (filter.dateFrom) q.set("dateFrom", filter.dateFrom);
            if (filter.dateTo) q.set("dateTo", filter.dateTo);
            const res = await this.client.get(`/api/orders?${q.toString()}`);
            const data = res.data || {};
            return Result.ok({
                items: Array.isArray(data.content) ? data.content : [],
                total: Number(data.totalElements || 0),
            });
        } catch (e) {
            console.error("Error fetching worklist:", e);
            const errorMessage = e.response?.data?.error || e.message || "Failed to fetch worklist.";
            return Result.fail(new Error(errorMessage));
        }
    }

    async getOrderDetail(orderId) {
        if (!orderId) {
            return Result.fail(new Error("Order ID is required."));
        }
        try {
            const res = await this.client.get(`/api/orders/${encodeURIComponent(orderId)}`);
            const backendDto = res.data;
            if (!backendDto || !backendDto.id) {
                return Result.fail(new Error(`Order details not found or invalid response for ID: ${orderId}`));
            }

            // --- Map Original Addresses from OrderEvent (now includes alias/name) ---
            const originalEvent = this._safeParseJson(backendDto.originalOrderEventJson);

            const originalPickup = Address.from({
                ...backendDto.pickupAddress, // Contains street, houseNo, postal, city, lat, lon
                alias: originalEvent?.pickUpAlias || backendDto.pickupAlias, // Get alias from event
                name: originalEvent?.pickUpName || null // Get name from event
            });

            const originalDelivery = Address.from({
                ...backendDto.deliveryAddress,
                alias: originalEvent?.deliveryAlias || backendDto.deliveryAlias,
                name: originalEvent?.deliveryName || null
            });

            // --- Map Stored Addresses (if they exist) ---
            const pickupStoredDisplay = backendDto.pickupStoredAddress ?
                Address.from(backendDto.pickupStoredAddress) : null;
            const deliveryStoredDisplay = backendDto.deliveryStoredAddress ? Address.from(backendDto.deliveryStoredAddress) : null;

            // --- *** FIX: Show raw reason code *** ---
            const pickupStoredLabel = this._getStoredAddressLabel(backendDto.pickupReasonCode, 'Pickup');
            const deliveryStoredLabel = this._getStoredAddressLabel(backendDto.deliveryReasonCode, 'Delivery');
            // --- *** END FIX *** ---

            const frontendDetail = {
                orderId: backendDto.id,
                barcode: backendDto.barcode,
                requestId: backendDto.requestId,
                customerId: backendDto.customerId,
                sourceSystem: backendDto.sourceSystem,
                processingStatus: backendDto.processingStatus,
                createdAt: backendDto.createdAt,
                updatedAt: backendDto.updatedAt,

                // --- Use the newly constructed original addresses ---
                originalPickup: originalPickup,
                originalDelivery: originalDelivery,

                pickupReasonCode: backendDto.pickupReasonCode || null,
                deliveryReasonCode: backendDto.deliveryReasonCode || null,

                pickupStoredAddress: pickupStoredDisplay,
                deliveryStoredAddress: deliveryStoredDisplay,

                pickupStoredLabel: pickupStoredLabel,
                deliveryStoredLabel: deliveryStoredLabel,

                suggestedPickup: Array.isArray(backendDto.suggestedPickup) ?
                    backendDto.suggestedPickup : [],
                suggestedDelivery: Array.isArray(backendDto.suggestedDelivery) ?
                    backendDto.suggestedDelivery : [],

                // --- Pass original event JSON for resubmission ---
                originalOrderEventJson: backendDto.originalOrderEventJson || null,

                // Find the associated errorEventId (if any)
                relatedError: backendDto.relatedError || null // (This DTO needs to include the eventId)
            };
            return Result.ok(frontendDetail);
        } catch (e) {
            console.error(`Error fetching order detail for ${orderId}:`, e);
            const status = e.response?.status;
            const errorMessage = e.response?.data?.error || e.message || `Failed to fetch order details for ID: ${orderId}.`;
            if (status === 404) {
                return Result.fail(new Error(`Order not found: ${orderId}`));
            }
            return Result.fail(new Error(errorMessage));
        }
    }

    /**
     * @deprecated Old save flow. Use saveResubmission instead.
     */
    async saveCorrection(body, idempotencyToken = null) {
        log.warn("DEPRECATED: saveCorrection called. Use saveResubmission.");
        return Result.fail(new Error("saveCorrection is deprecated. Use saveResubmission."));
    }

    /**
     * NEW METHOD: Submits a corrected payload to resolve a processing error.
     * This is the new "Save" logic for the editor.
     * @param {string} errorEventId - The Event ID of the error being resolved.
     * @param {object} resubmitPayload - The ResubmitRequestDto (correctedRawPayload, applyToSimilar).
     */
    async saveResubmission(errorEventId, resubmitPayload) {
        if (!errorEventId) {
            return Result.fail(new Error("Cannot save: Original Error Event ID is missing."));
        }
        if (!resubmitPayload || !resubmitPayload.correctedRawPayload) {
            return Result.fail(new Error("Cannot save: Corrected payload is missing."));
        }

        try {
            // POST /processing-errors/{eventId}/resubmit
            const res = await this.client.post(
                `/processing-errors/${encodeURIComponent(errorEventId)}/resubmit`,
                resubmitPayload
            );
            return Result.ok(res.data || true);
        } catch (e) {
            console.error(`Error saving/resubmitting correction for event ${errorEventId}:`, e);
            const errorMessage = e.response?.data?.error || e.message || "Failed to save correction.";
            return Result.fail(new Error(errorMessage));
        }
    }


    async getTriageKpis() {
        try {
            const res = await this.client.get(`/api/dashboard/kpis`);
            const data = res.data || { pendingReviewCount: 0, automatedClearancePercent: 0, avgResolutionMinutes: null };
            return Result.ok(data);
        } catch (e) {
            console.error("Error fetching triage KPIs:", e);
            const errorMessage = e.response?.data?.error || e.message || "Failed to fetch KPIs.";
            return Result.fail(new Error(errorMessage));
        }
    }

    async getPendingByErrorType() {
        try {
            const res = await this.client.get(`/api/dashboard/pending-by-error-type`);
            const data = res.data || [];
            return Result.ok(Array.isArray(data) ? data : []);
        } catch (e) {
            console.error("Error fetching pending by error type:", e);
            const errorMessage = e.response?.data?.error || e.message || "Failed to fetch pending errors by type.";
            return Result.fail(new Error(errorMessage));
        }
    }

    async sendClientLogs(logEntries) {
        if (!Array.isArray(logEntries) || logEntries.length === 0) {
            return Promise.resolve();
        }
        // Fire-and-forget, don't await, don't return Result
        this.client.post(`/api/log/client`, logEntries).catch(err => {
            console.warn("Failed to send client logs:", err.message);
        });
        return Promise.resolve();
    }

    async requestGetAvailableProviders() { return this.client.get(`/api/admin/address-verification/providers/available`); }
    async requestGetCurrentProvider() { return this.client.get(`/api/admin/address-verification/providers/current`);
    }
    async requestSetProvider(providerName) { return this.client.post(`/api/admin/address-verification/providers/current`, providerName, { headers: { 'Content-Type': 'text/plain' } });
    }
    async getOperationStatus(correlationId) { return this.client.get(`/api/admin/address-verification/operations/${correlationId}`); }

    _getStoredAddressLabel(reasonCode, side) {
        // --- *** FIX: Show raw reason code *** ---
        if (reasonCode) return reasonCode;
        // --- *** END FIX *** ---

        // Fallback for older data that might not have a reason code
        return `Original ${side}`;
    }

    _safeParseJson(jsonString) {
        if (!jsonString) return null;
        try {
            return JSON.parse(jsonString);
        } catch (e) {
            console.warn("Failed to parse JSON string in AddressExceptionApi:", e);
            return null;
        }
    }
}

================================================================================
### PLIK: services/AddressFieldGuard.js
================================================================================

/**
 * ARCHITECTURE: AddressFieldGuard enforces form field enable/disable rules per country and workflow state.
 * It follows the manifesto by isolating editability policies from components and controllers.
 * Responsibilities:
 * - Decide if a field is editable based on country rules, verification status, and role flags.
 * - Provide a stateless canEdit(field, context) API returning a boolean.
 */
export class AddressFieldGuard {
  constructor() {
    this._rules = new Map();
    this._rules.set("PL", {
      postalCode: () => true,
      street: () => true,
      houseNumber: () => true,
      city: () => true,
      country: () => false,
    });
  }

  register(country, rules) {
    this._rules.set((country || "PL").toUpperCase(), rules);
    return true;
  }

  canEdit(field, context) {
    const c = (context?.country || "PL").toUpperCase();
    const rules = this._rules.get(c) || this._rules.get("PL");
    if (typeof rules[field] === "function") return !!rules[field](context);
    return true;
  }
}


================================================================================
### PLIK: services/AddressFormatterService.js
================================================================================

/**
 * ARCHITECTURE: AddressFormatterService produces consistent, locale-aware display strings for addresses.
 * It follows the manifesto by separating presentation formatting from data models and controllers.
 * Responsibilities:
 * - Format single-line and multi-line address strings with optional fallbacks.
 * - Handle missing fields gracefully and avoid mutating inputs.
 */
export class AddressFormatterService {
  constructor(defaultCountry = "PL") {
    this.defaultCountry = defaultCountry;
  }

  oneLine(a) {
    if (!a) return "";
    const parts = [];
    const line1 = [a.street, a.houseNumber].filter(Boolean).join(" ").trim();
    if (line1) parts.push(line1);
    const line2 = [a.postalCode, a.city].filter(Boolean).join(" ").trim();
    if (line2) parts.push(line2);
    const c = a.country || this.defaultCountry;
    if (c) parts.push(c);
    return parts.join(", ");
  }

  twoLines(a) {
    if (!a) return { line1: "", line2: "" };
    const line1 = [a.street, a.houseNumber].filter(Boolean).join(" ").trim();
    const line2 = [[a.postalCode, a.city].filter(Boolean).join(" ").trim(), a.country || this.defaultCountry].filter(Boolean).join(", ");
    return { line1, line2 };
  }
}


================================================================================
### PLIK: services/AddressGeocodeCache.js
================================================================================

import { AddressEqualityService } from "@/services/AddressEqualityService";

/**
 * ARCHITECTURE: AddressGeocodeCache provides an in-memory, session-scoped cache
 * for geocoding results to reduce API calls.
 * It uses AddressEqualityService to create stable keys from address objects.
 */
export class AddressGeocodeCache {
    constructor(equalityService = new AddressEqualityService()) {
        this.cache = new Map();
        this.eq = equalityService;
    }

    _key(address) {
        // Use the hash function from the equality service for a stable key
        return this.eq.hash(address);
    }

    get(address) {
        const key = this._key(address);
        const result = this.cache.get(key) || null;
        if (result) {
            console.debug(`[GeocodeCache] Cache HIT for key: ${key}`);
        }
        return result;
    }

    put(address, result) {
        const key = this._key(address);
        console.debug(`[GeocodeCache] Cache SET for key: ${key}`);
        this.cache.set(key, result);
    }

    clear() {
        this.cache.clear();
    }
}


================================================================================
### PLIK: services/AddressHistoryService.js
================================================================================

/**
 * ARCHITECTURE: AddressHistoryService records a per-order timeline of edits and applied suggestions.
 * It follows the manifesto by providing an append-only log consumable by the audit or session history.
 * Responsibilities:
 * - Append events with before/after snapshots and provider info; read back per orderId.
 */
export class AddressHistoryService {
  constructor() {
    this._byOrder = new Map();
  }

  append(orderId, payload) {
    if (!orderId) return false;
    const list = this._byOrder.get(orderId) || [];
    list.push({
      at: new Date().toISOString(),
      type: payload?.type || "EDIT",
      side: payload?.side || "both",
      provider: payload?.provider || null,
      before: payload?.before || null,
      after: payload?.after || null,
    });
    this._byOrder.set(orderId, list);
    return true;
  }

  list(orderId) {
    return (this._byOrder.get(orderId) || []).slice();
  }

  clear(orderId) {
    if (!orderId) return false;
    this._byOrder.delete(orderId);
    return true;
  }
}


================================================================================
### PLIK: services/AddressInputMaskService.js
================================================================================

/**
 * ARCHITECTURE: AddressInputMaskService (Stub) would provide input masking
 * logic for address fields, specific to country rules (e.g., postal codes).
 * This is a placeholder returning the value as-is.
 */
export class AddressInputMaskService {
    constructor(countryCode = "PL") {
        this.countryCode = countryCode.toUpperCase();
    }

    /**
     * Masks a postal code value (stub).
     * @param {string} value - The input value.
     * @param {string} country - The country context.
     * @returns {string} The masked/formatted value.
     */
    maskPostal(value, country) {
        // TODO: Implement actual postal code masking (e.g., PL: '00123' -> '00-123')
        return value;
    }

    /**
     * Masks a street value (stub).
     * @param {string} value - The input value.
     * @returns {string} The masked/formatted value.
     */
    maskStreet(value) {
        // TODO: Implement street name masking/formatting (e.g., capitalization)
        return value;
    }

    /**
     * Masks a city value (stub).
     * @param {string} value - The input value.
     * @returns {string} The masked/formatted value.
     */
    maskCity(value) {
        // TODO: Implement city name masking/formatting
        return value;
    }

    /**
     * Masks a house number value (stub).
     * @param {string} value - The input value.
     * @returns {string} The masked/formatted value.
     */
    maskHouseNo(value) {
        // TODO: Implement house number masking/formatting
        return value;
    }
}

================================================================================
### PLIK: services/AddressNormalizer.js
================================================================================

/**
 * ARCHITECTURE: AddressNormalizer sanitizes raw address input into a consistent DTO used by verification.
 * It follows the manifesto by providing pure, deterministic transformations without UI or transport coupling.
 * Responsibilities:
 * - Trim whitespace, stabilize casing, and normalize postal code for PL (e.g., "00123" → "00-123").
 * - Guarantee presence of all expected fields with safe defaults.
 *
 * FIX: Removed erroneous circular self-import statement.
 */

export class AddressNormalizer {
  constructor(defaultCountry = "PL") {
    this.defaultCountry = defaultCountry.toUpperCase();
  }

  normalize(a) {
    const street = this._sp(a?.street);
    const houseNumber = this._hn(a?.houseNumber);
    const city = this._cap(this._sp(a?.city));
    const country = this._cc(a?.country);
    const postalCode = this._postal(a?.postalCode, country);
    const latitude = this._num(a?.latitude);
    const longitude = this._num(a?.longitude);
    return { street, houseNumber, postalCode, city, country, latitude, longitude };
  }

  _sp(v) {
    return (v || "").toString().replace(/\s+/g, " ").trim();
  }

  _hn(v) {
    const s = (v == null ? "" : String(v)).replace(/\s+/g, "").trim();
    return s.length ? s : null;
  }

  _cap(v) {
    if (!v) return "";
    return v.charAt(0).toUpperCase() + v.slice(1);
  }

  _cc(v) {
    const s = (v || this.defaultCountry).toString().trim().toUpperCase();
    return s || this.defaultCountry;
  }

  _postal(v, country) {
    const raw = (v || "").replace(/\s|-/g, "");
    if ((country || "").toUpperCase() === "PL") {
      if (raw.length < 5) return raw;
      return `${raw.slice(0, 2)}-${raw.slice(2, 5)}`;
    }
    return v || "";
  }

  _num(v) {
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  }
}


================================================================================
### PLIK: services/AddressPersistenceMapper.js
================================================================================

// ============================================================================
// Frontend: Mark AddressPersistenceMapper as Deprecated
// FILE: src/services/AddressPersistenceMapper.js
// REASON: This mapper is bypassed by the new save flow.
// ============================================================================
// FILE: src/services/AddressPersistenceMapper.js (Supersedes previous version)

/**
 * ARCHITECTURE: AddressPersistenceMapper shapes editor state into backend save payloads.
 * DEPRECATED: This mapper creates a payload for the old /corrections endpoint.
 * The flow is now handled by SaveFlowController -> IdempotentSaveController
 * which build a payload for the /api/orders/{barcode}/approve endpoint.
 * @deprecated
 */
export class AddressPersistenceMapper {
  toSavePayload(orderId, side, before, after, resolution) {
    console.warn("DEPRECATED: AddressPersistenceMapper.toSavePayload called. This logic is obsolete.");
    const s = (side || "both").toLowerCase();
    const body = {
      orderId: orderId,
      side: s === "pickup" || s === "delivery" ? s : "both",
      resolution: resolution || "MANUAL_EDIT",
      correctedPickup: s === "delivery" ? null : (after?.pickup || after?.correctedPickup || after?.editedPickup || after || null),
      correctedDelivery: s === "pickup" ? null : (after?.delivery || after?.correctedDelivery || after?.editedDelivery || after || null),
      beforePickup: s === "delivery" ? null : (before?.pickup || before?.originalPickup || before || null),
      beforeDelivery: s === "pickup" ? null : (before?.delivery || before?.originalDelivery || before || null),
    };
    return body;
  }
}

================================================================================
### PLIK: services/AddressRulesService.js
================================================================================

/**
 * ARCHITECTURE: AddressRulesService centralizes country-specific rules for required fields and masks.
 * It follows the manifesto by separating rule data from controllers and adapters.
 * Responsibilities:
 * - Provide requiredFields(country) and postalRegex(country) for validation and hints.
 */
export class AddressRulesService {
  constructor() {
    this._req = new Map();
    this._req.set("PL", ["street", "postalCode", "city", "country"]);
    this._postal = new Map();
    this._postal.set("PL", /^(\d{2}-\d{3}|\d{5})$/);
  }

  requiredFields(country = "PL") {
    return this._req.get((country || "PL").toUpperCase()) || this._req.get("PL");
  }

  postalRegex(country = "PL") {
    return this._postal.get((country || "PL").toUpperCase()) || /.*/;
  }
}


================================================================================
### PLIK: services/AddressSuggestionMerger.js
================================================================================

/**
 * ARCHITECTURE: AddressSuggestionMerger combines suggestion lists from multiple sources
 * (e.g., client-side geocoding, Places API, TES backend) into a single list,
 * potentially removing duplicates based on address content equality. Adheres to SRP.
 * This is a basic stub implementation assuming simple concatenation.
 */
import { AddressEqualityService } from "@/services/AddressEqualityService"; // Assuming this exists

export class AddressSuggestionMerger {
    constructor(equalityService = new AddressEqualityService()) {
        this.eq = equalityService;
    }

    /**
     * Merges multiple lists of suggestions, attempting basic deduplication.
     * @param {object} baseInput - The original input address (used for context, not currently in stub).
     * @param {Array<Array<object>>} suggestionLists - An array of suggestion lists from different sources.
     * @returns {Array<object>} A single, merged list of suggestions.
     */
    merge(baseInput, suggestionLists) {
        const merged = [];
        const seenHashes = new Set();

        if (!Array.isArray(suggestionLists)) {
            return merged;
        }

        for (const list of suggestionLists) {
            if (!Array.isArray(list)) continue;

            for (const suggestion of list) {
                if (!suggestion) continue;

                // Simple deduplication based on normalized address hash (requires AddressEqualityService)
                const addressPart = {
                    street: suggestion.street,
                    houseNumber: suggestion.houseNumber,
                    postalCode: suggestion.postalCode,
                    city: suggestion.city,
                    country: suggestion.countryCode,
                    // Note: Lat/Lon usually excluded from equality hash for address matching
                };
                const hash = this.eq.hash(addressPart);

                if (!seenHashes.has(hash)) {
                    merged.push(suggestion);
                    seenHashes.add(hash);
                }
            }
        }
        // Further sorting/ranking is typically done by AddressSuggestionRanker
        return merged;
    }
}

================================================================================
### PLIK: services/AddressSuggestionRanker.js
================================================================================

/**
 * ARCHITECTURE: AddressSuggestionRanker orders suggestions by confidence and locality relevance.
 * It follows the manifesto by keeping ranking policy separate from UI and transport details.
 * Responsibilities:
 * - Sort by matchScore desc, then city/postal match with the base input, then provider priority.
 */
export class AddressSuggestionRanker {
  rank(baseInput, list) {
    const arr = Array.isArray(list) ? list.slice() : [];
    const prio = (p) => (p === "GOOGLE_CLIENT" ? 3 : p === "GOOGLE_PLACES" ? 2 : p === "TES" ? 1 : 0);
    const eq = (a, b) => (a || "").toString().trim().toLowerCase() === (b || "").toString().trim().toLowerCase();
    arr.sort((a, b) => {
      const sa = typeof a.matchScore === "number" ? a.matchScore : 0;
      const sb = typeof b.matchScore === "number" ? b.matchScore : 0;
      if (sb !== sa) return sb - sa;
      const ca = eq(a.city, baseInput?.city) ? 1 : 0;
      const cb = eq(b.city, baseInput?.city) ? 1 : 0;
      if (cb !== ca) return cb - ca;
      const pa = eq(a.postalCode, baseInput?.postalCode) ? 1 : 0;
      const pb = eq(b.postalCode, baseInput?.postalCode) ? 1 : 0;
      if (pb !== pa) return pb - pa;
      return prio(b.providerSource) - prio(a.providerSource);
    });
    return arr;
  }
}


================================================================================
### PLIK: services/api.js
================================================================================

/**
 * ARCHITECTURE: Axios singleton configured to cooperate with the Vite proxy in development.
 * Responsibilities:
 * - Use baseURL from env; when set to "/" (recommended for dev), requests are same-origin and get proxied.
 */
import axios from "axios";

function resolveBaseUrl() {
  const w = typeof window !== "undefined" ? window : {};
  const winBase = (w.__API_BASE_URL__ || "").trim();
  const viteBase = (import.meta?.env?.VITE_API_BASE_URL || "").trim();
  const base = (winBase || viteBase);
  if (!base) return "/";          // default to same-origin → dev proxy handles cross-origin
  if (base === "/") return "/";   // explicit proxy mode
  return base.replace(/\/+$/, "");
}

const api = axios.create({
  baseURL: resolveBaseUrl(),
  withCredentials: true,
  headers: {
    "Accept": "application/json",
    "Content-Type": "application/json",
  },
});

api.interceptors.response.use(
  (res) => res,
  (err) => {
    err.message = err?.response?.data?.message || err.message || "Request failed";
    return Promise.reject(err);
  }
);

export default api;


================================================================================
### PLIK: services/ApiAuthBinder.js
================================================================================

/**
 * ARCHITECTURE: ApiAuthBinder binds/unbinds the Authorization header on the shared ApiHttpClient singleton.
 * Responsibilities:
 * - Apply "Authorization: <type> <token>" to axios defaults; remove it on logout.
 */
import apiClient from "@/services/api";

export class ApiAuthBinder {
  constructor() {
    this.headerName = "Authorization";
  }

  bind(accessToken, tokenType = "Bearer") {
    if (!accessToken) return false;
    const scheme = String(tokenType || "Bearer").trim() || "Bearer";
    if (!apiClient.defaults.headers) apiClient.defaults.headers = {};
    if (!apiClient.defaults.headers.common) apiClient.defaults.headers.common = {};
    apiClient.defaults.headers.common[this.headerName] = `${scheme} ${accessToken}`;
    return true;
  }

  unbind() {
    if (apiClient?.defaults?.headers?.common && this.headerName in apiClient.defaults.headers.common) {
      delete apiClient.defaults.headers.common[this.headerName];
      return true;
    }
    return false;
  }
}


================================================================================
### PLIK: services/ApiErrorMapper.js
================================================================================

/**
 * ARCHITECTURE: ApiErrorMapper (Stub) translates backend HTTP error responses
 * into user-facing, domain-specific error messages or error objects.
 * This isolates HTTP error structure from controllers.
 */
import { Result } from "@/domain/Result";

export class ApiErrorMapper {
    constructor() {
        // Map of known backend error codes/messages to frontend-friendly text
        this.errorMap = {
            "validation_failed": "The data provided was invalid. Please check the fields.",
            "duplicate_barcode": "This barcode already exists in the system.",
            "auth_invalid_credentials": "Invalid username or password.",
        };
    }

    /**
     * Maps an Axios error object to a frontend-friendly Error object.
     * @param {Error} axiosError - The error object from an Axios request.
     * @returns {Error} A new Error object with a user-friendly message.
     */
    map(axiosError) {
        if (!axiosError) {
            return new Error("An unknown error occurred.");
        }

        const responseData = axiosError.response?.data;
        const status = axiosError.response?.status;

        if (status === 401) {
            return new Error("Authentication failed. Please log in again.");
        }

        if (status === 403) {
            return new Error("You do not have permission to perform this action.");
        }

        // Check for specific backend error code
        const backendErrorCode = responseData?.errorCode; // Assuming backend sends { "errorCode": "...", ... }
        if (backendErrorCode && this.errorMap[backendErrorCode]) {
            return new Error(this.errorMap[backendErrorCode]);
        }

        // Check for Spring Boot validation errors
        if (status === 422 && Array.isArray(responseData?.details)) {
            return new Error(`Validation failed: ${responseData.details.join(', ')}`);
        }

        // Fallback to message from backend payload or default
        const message = responseData?.error || responseData?.message || axiosError.message || "An unknown server error occurred.";
        return new Error(message);
    }

    /**
     * Wraps an API call (a function returning a Promise) with error mapping.
     * @param {Function} apiCallFn - An async function (e.g., () => apiClient.get('/...')).
     * @returns {Promise<Result<any, Error>>} A Result object.
     */
    async wrap(apiCallFn) {
        try {
            const response = await apiCallFn();
            return Result.ok(response.data); // Assumes success is response.data
        } catch (error) {
            return Result.fail(this.map(error));
        }
    }
}

================================================================================
### PLIK: services/AuthApi.js
================================================================================

/**
 * ARCHITECTURE: AuthApi encapsulates authentication HTTP calls against the backend auth service.
 * It follows the manifesto by isolating transport details and returning deterministic Result objects.
 * Responsibilities:
 * - POST credentials to /auth/login and return a normalized session object on success.
 * - Keep transport client injectable for testing; default to the shared Axios instance.
 */
import api from "@/services/api";
import { Result } from "@/domain/Result";

export class AuthApi {
  constructor(httpClient = api) {
    this.http = httpClient;
  }

  async login(username, password) {
    try {
      const res = await this.http.post("/auth/login", { username, password });
      const data = res?.data || {};
      const session = {
        accessToken: data.accessToken || null,
        refreshToken: data.refreshToken || null,
        tokenType: data.tokenType || "Bearer",
        username: data.username || username || null,
        roles: Array.isArray(data.roles) ? data.roles : [],
      };
      if (!session.accessToken) return Result.fail(new Error("AuthApi: accessToken missing in response."));
      return Result.ok(session);
    } catch (e) {
      return Result.fail(e instanceof Error ? e : new Error("AuthApi: login failed"));
    }
  }
}


================================================================================
### PLIK: services/AuthApi.spec.js
================================================================================

// src/services/AuthApi.spec.js
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { AuthApi } from '@/services/AuthApi';
import { Result } from '@/domain/Result';

// Mock the underlying HTTP client (e.g., axios instance)
const mockHttpClient = {
    post: vi.fn(),
};

describe('AuthApi', () => {
    let authApi;

    beforeEach(() => {
        // Reset mocks before each test
        vi.resetAllMocks();
        // Create a new instance with the mock client for each test
        authApi = new AuthApi(mockHttpClient);
    });

    it('should call login endpoint and return Ok Result on success', async () => {
        // Arrange
        const mockUsername = 'testuser';
        const mockPassword = 'password';
        const mockApiResponse = {
            data: {
                accessToken: 'mockAccessToken',
                refreshToken: 'mockRefreshToken',
                tokenType: 'Bearer',
                username: mockUsername,
                roles: ['USER', 'ADMIN'],
            }
        };
        mockHttpClient.post.mockResolvedValue(mockApiResponse);

        // Act
        const result = await authApi.login(mockUsername, mockPassword);

        // Assert
        expect(mockHttpClient.post).toHaveBeenCalledTimes(1);
        expect(mockHttpClient.post).toHaveBeenCalledWith('/auth/login', { username: mockUsername, password: mockPassword });

        expect(result).toBeInstanceOf(Result);
        expect(result.ok).toBe(true);
        expect(result.value).toEqual({
            accessToken: 'mockAccessToken',
            refreshToken: 'mockRefreshToken',
            tokenType: 'Bearer',
            username: mockUsername,
            roles: ['USER', 'ADMIN'],
        });
    });

    it('should return Fail Result if API call fails', async () => {
        // Arrange
        const mockUsername = 'testuser';
        const mockPassword = 'password';
        const mockError = new Error('Network Error');
        mockHttpClient.post.mockRejectedValue(mockError);

        // Act
        const result = await authApi.login(mockUsername, mockPassword);

        // Assert
        expect(mockHttpClient.post).toHaveBeenCalledTimes(1);
        expect(mockHttpClient.post).toHaveBeenCalledWith('/auth/login', { username: mockUsername, password: mockPassword });

        expect(result).toBeInstanceOf(Result);
        expect(result.ok).toBe(false);
        expect(result.error).toBe(mockError);
    });

    it('should return Fail Result if API response is missing accessToken', async () => {
        // Arrange
        const mockUsername = 'testuser';
        const mockPassword = 'password';
        const mockApiResponse = {
            data: { /* accessToken is missing */ }
        };
        mockHttpClient.post.mockResolvedValue(mockApiResponse);

        // Act
        const result = await authApi.login(mockUsername, mockPassword);

        // Assert
        expect(result).toBeInstanceOf(Result);
        expect(result.ok).toBe(false);
        expect(result.error).toBeInstanceOf(Error);
        expect(result.error.message).toContain('accessToken missing');
    });
});

================================================================================
### PLIK: services/AuthSessionService.js
================================================================================

/**
 * ARCHITECTURE: AuthSessionService persists auth tokens and user profile and exposes accessors.
 * It follows the manifesto by isolating storage mechanics and providing deterministic getters/setters.
 * Responsibilities:
 * - Save/load/remove session in localStorage with a namespaced key.
 * - Expose isAuthenticated(), getAccessToken(), getTokenType(), getUser(), hasRole().
 */
export class AuthSessionService {
  constructor(namespace = "danxils_auth") {
    this.ns = namespace;
    this.store = typeof window !== "undefined" ? window.localStorage : null;
  }

  save(session) {
    if (!this.store) return false;
    const payload = {
      accessToken: session?.accessToken || null,
      refreshToken: session?.refreshToken || null,
      tokenType: session?.tokenType || "Bearer",
      username: session?.username || null,
      roles: Array.isArray(session?.roles) ? session.roles : [],
      at: Date.now(),
    };
    this.store.setItem(this.ns, JSON.stringify(payload));
    return true;
  }

  load() {
    if (!this.store) return null;
    const raw = this.store.getItem(this.ns);
    if (!raw) return null;
    try { return JSON.parse(raw); } catch { return null; }
  }

  clear() {
    if (!this.store) return false;
    this.store.removeItem(this.ns);
    return true;
  }

  isAuthenticated() {
    const s = this.load();
    return !!(s && s.accessToken);
  }

  getAccessToken() {
    const s = this.load();
    return s?.accessToken || null;
  }

  getTokenType() {
    const s = this.load();
    return s?.tokenType || "Bearer";
  }

  getUser() {
    const s = this.load();
    return { username: s?.username || null, roles: Array.isArray(s?.roles) ? s.roles : [] };
  }

  hasRole(role) {
    const s = this.load();
    const roles = Array.isArray(s?.roles) ? s.roles : [];
    return roles.includes(role);
  }
}


================================================================================
### PLIK: services/CsvBuilder.js
================================================================================

/**
 * ARCHITECTURE: CsvBuilder builds CSV text from arrays of objects without UI or transport coupling.
 * It follows the manifesto by providing a pure data-to-text transformation with stable escaping.
 * Responsibilities:
 * - Accept columns definition and rows; output RFC-4180-compliant CSV with quotes/escaping.
 * - Return a string for download or clipboard without side effects.
 */
export class CsvBuilder {
  constructor(columns) {
    if (!Array.isArray(columns) || columns.length === 0) throw new Error("CsvBuilder: columns are required.");
    this.columns = columns; // [{key:'orderId', title:'Order ID'}, ...]
  }

  build(rows) {
    const head = this.columns.map(c => this._q(c.title || c.key)).join(",");
    const body = (Array.isArray(rows) ? rows : []).map(r => this.columns.map(c => this._q(r[c.key])).join(",")).join("\n");
    return [head, body].filter(Boolean).join("\n");
  }

  _q(v) {
    const s = v == null ? "" : String(v);
    if (/[",\n]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
    return s;
  }
}


================================================================================
### PLIK: services/DebounceTimer.js
================================================================================

/**
 * ARCHITECTURE: DebounceTimer provides deterministic debouncing for keystroke-driven verification.
 * It follows the manifesto by encapsulating timing concerns and exposing a minimal, testable contract.
 * Responsibilities:
 * - Debounce a single async task, cancelling the previous one if a new call arrives within the interval.
 * - Prevent overlapping executions by using a monotonically increasing token.
 */
export class DebounceTimer {
  constructor(delayMs = 400) {
    this.delayMs = delayMs;
    this._timer = null;
    this._token = 0;
  }

  run(asyncFn) {
    return new Promise((resolve, reject) => {
      const current = ++this._token;
      if (this._timer) clearTimeout(this._timer);
      this._timer = setTimeout(async () => {
        try {
          if (current !== this._token) return resolve(null);
          const r = await asyncFn();
          if (current !== this._token) return resolve(null);
          resolve(r);
        } catch (e) {
          reject(e);
        }
      }, this.delayMs);
    });
  }

  cancel() {
    if (this._timer) clearTimeout(this._timer);
    this._timer = null;
    this._token++;
  }
}


================================================================================
### PLIK: services/DiffService.js
================================================================================

/**
 * ARCHITECTURE: DiffService computes before/after differences for Address DTO fields.
 * It follows the manifesto by isolating comparison logic from viewmodels and controllers.
 * Responsibilities:
 * - Compare two objects field-by-field; return {entries[], anyChanged}.
 */
export class DiffService {
  constructor(fields = ["street", "houseNumber", "postalCode", "city", "country", "latitude", "longitude"]) {
    this.fields = fields.slice();
  }

  diff(before, after) {
    const entries = this.fields.map(f => {
      const b = this._val(before, f);
      const a = this._val(after, f);
      const changed = !this._eq(b, a);
      return { field: f, before: b, after: a, changed };
    });
    const anyChanged = entries.some(e => e.changed);
    return { entries, anyChanged };
  }

  _val(obj, field) {
    if (!obj) return null;
    return obj[field] ?? null;
  }

  _eq(a, b) {
    if (typeof a === "number" || typeof b === "number") return Number(a || 0).toFixed(6) === Number(b || 0).toFixed(6);
    return (a || "").toString().trim().toLowerCase() === (b || "").toString().trim().toLowerCase();
  }
}


================================================================================
### PLIK: services/EditorStateSerializer.js
================================================================================

/**
 * ARCHITECTURE: EditorStateSerializer persists and restores editor state across reloads in session storage.
 * It follows the manifesto by isolating serialization concerns and avoiding component-level side effects.
 * Responsibilities:
 * - Save minimal editor payload keyed by orderId; restore and clear on demand.
 * - Handle safe JSON parse/stringify and namespace keys to avoid collisions.
 */
export class EditorStateSerializer {
  constructor(namespace = "editor") {
    this.ns = namespace;
    this._store = typeof window !== "undefined" ? window.sessionStorage : null;
  }

  save(orderId, state) {
    if (!this._store || !orderId) return false;
    const key = this._key(orderId);
    const payload = {
      at: Date.now(),
      editedPickup: state?.editedPickup || null,
      editedDelivery: state?.editedDelivery || null,
    };
    this._store.setItem(key, JSON.stringify(payload));
    return true;
  }

  load(orderId) {
    if (!this._store || !orderId) return null;
    const raw = this._store.getItem(this._key(orderId));
    if (!raw) return null;
    try {
      return JSON.parse(raw);
    } catch {
      return null;
    }
  }

  clear(orderId) {
    if (!this._store || !orderId) return false;
    this._store.removeItem(this._key(orderId));
    return true;
  }

  _key(orderId) {
    return `${this.ns}:${orderId}`;
  }
}


================================================================================
### PLIK: services/EnvironmentConfigService.js
================================================================================

/**
 * ARCHITECTURE: EnvironmentConfigService centralizes runtime configuration discovery for the frontend.
 * It follows the manifesto by isolating environment concerns and producing a deterministic config object.
 * Responsibilities:
 * - Load API base URL and flags from environment variables or window-injected globals.
 * - Expose get(key) and typed helpers; set window.__API_BASE_URL__ for ApiHttpClient consumers.
 */
export class EnvironmentConfigService {
  constructor() {
    this._loaded = false;
    this._cfg = {
      API_BASE_URL: "",
      GOOGLE_MAPS_API_KEY: "",
      APP_ENV: "development",
    };
  }

  async load() {
    if (this._loaded) return this._cfg;
    const w = typeof window !== "undefined" ? window : {};
    const env = w.__APP_ENV__ || {};
    const apiFromWindow = (w.__API_BASE_URL__ || "").trim();
    const apiFromEnv = (import.meta && import.meta.env && import.meta.env.VITE_API_BASE_URL) || "";
    const keyFromWindow = (w.__GOOGLE_MAPS_API_KEY__ || "").trim();
    const keyFromEnv = (import.meta && import.meta.env && import.meta.env.VITE_GOOGLE_MAPS_API_KEY) || "";
    const appEnv = (import.meta && import.meta.env && import.meta.env.MODE) || env.MODE || "development";
    this._cfg = {
      API_BASE_URL: apiFromWindow || apiFromEnv || "",
      GOOGLE_MAPS_API_KEY: keyFromWindow || keyFromEnv || "",
      APP_ENV: appEnv,
    };
    if (typeof window !== "undefined") {
      window.__API_BASE_URL__ = this._cfg.API_BASE_URL;
    }
    this._loaded = true;
    return this._cfg;
  }

  get(key, fallback = null) {
    return Object.prototype.hasOwnProperty.call(this._cfg, key) ? this._cfg[key] : fallback;
  }

  apiBase() {
    return this.get("API_BASE_URL", "");
  }

  googleKey() {
    return this.get("GOOGLE_MAPS_API_KEY", "");
  }

  appEnv() {
    return this.get("APP_ENV", "development");
  }
}


================================================================================
### PLIK: services/ErrorTypeDictionary.js
================================================================================

/**
 * ARCHITECTURE: ErrorTypeDictionary maps backend error codes to user-facing labels and severities.
 * It follows the manifesto by isolating presentation-neutral taxonomy from API DTOs.
 * Responsibilities:
 * - Provide stable lookups for label, severity, and suggested actions per error type.
 * - Allow extension via register() without changing existing mappings.
 */
export class ErrorTypeDictionary {
  constructor() {
    this._map = new Map();
    this._map.set("INVALID_POSTAL_CODE", { label: "Invalid ZIP/Postal Code", severity: "critical", actions: ["verify", "fix-postal"] });
    this._map.set("AMBIGUOUS_STREET", { label: "Ambiguous Street (Apt/Suite missing)", severity: "warning", actions: ["add-apartment", "verify"] });
    this._map.set("NON_STANDARDIZED", { label: "Non-standardized Address", severity: "info", actions: ["normalize", "verify"] });
  }

  get(code) {
    return this._map.get(code) || { label: code || "Unknown Error", severity: "info", actions: [] };
  }

  register(code, entry) {
    if (!code || typeof entry !== "object") throw new Error("ErrorTypeDictionary: invalid registration.");
    this._map.set(code, entry);
    return true;
  }
}


================================================================================
### PLIK: services/FeatureFlagService.js
================================================================================

/**
 * ARCHITECTURE: FeatureFlagService loads and caches runtime feature flags that guide UX policies.
 * It follows the manifesto by centralizing flag access behind explicit getters with session caching.
 * Responsibilities:
 * - Fetch flags from backend once; expose booleans for critical flows (requireGeocode, bulkEdit).
 * - Allow local overrides for testing without changing backend state.
 */
import apiClient from "@/services/api";

export class FeatureFlagService {
  constructor(endpoint = "/status/feature-flags") {
    this.endpoint = endpoint;
    this._flags = null;
    this._inFlight = null;
    this._overrides = {};
  }

  async load() {
    if (this._flags) return this._flags;
    if (this._inFlight) return this._inFlight;
    this._inFlight = apiClient.get(this.endpoint).then(r => {
      this._flags = r?.data || {};
      return this._flags;
    }).finally(() => (this._inFlight = null));
    return this._inFlight;
  }

  setOverride(key, value) {
    this._overrides[key] = value;
    return true;
  }

  get(key, fallback = false) {
    const base = this._flags && Object.prototype.hasOwnProperty.call(this._flags, key) ? this._flags[key] : fallback;
    return Object.prototype.hasOwnProperty.call(this._overrides, key) ? this._overrides[key] : base;
  }

  requireGeocode() {
    return !!this.get("REQUIRE_GEOCODE", false);
  }

  allowBulkEdit() {
    return !!this.get("ALLOW_BULK_EDIT", true);
  }
}


================================================================================
### PLIK: services/GoogleErrorTranslator.js
================================================================================

/**
 * ARCHITECTURE: GoogleErrorTranslator maps Google Maps/Places status messages to stable application errors.
 * It follows the manifesto by isolating third-party semantics from business logic and controllers.
 * Responsibilities:
 * - Translate known status/error strings to canonical codes and user-friendly messages.
 * - Provide a simple translate(err) that returns {code,message,retryable}.
 */
export class GoogleErrorTranslator {
  constructor() {
    this._map = new Map();
    this._map.set("OVER_QUERY_LIMIT", { code: "RATE_LIMIT", message: "Google quota exceeded", retryable: true });
    this._map.set("ZERO_RESULTS", { code: "NO_RESULTS", message: "No results found", retryable: false });
    this._map.set("REQUEST_DENIED", { code: "DENIED", message: "Request denied by Google", retryable: false });
    this._map.set("INVALID_REQUEST", { code: "INVALID", message: "Invalid geocoding request", retryable: false });
    this._map.set("UNKNOWN_ERROR", { code: "UNKNOWN", message: "Temporary Google error", retryable: true });
  }

  translate(error) {
    const msg = (error?.message || "").toUpperCase();
    for (const [k, v] of this._map.entries()) {
      if (msg.includes(k)) return v;
    }
    const status = error?.status || error?.response?.status || null;
    if (status === 429) return { code: "RATE_LIMIT", message: "Rate limit reached", retryable: true };
    if (status === 503) return { code: "UNAVAILABLE", message: "Service unavailable", retryable: true };
    return { code: "GENERIC", message: error?.message || "Unexpected Google error", retryable: false };
  }
}


================================================================================
### PLIK: services/GoogleKeyProvider.js
================================================================================

/**
 * ARCHITECTURE: GoogleKeyProvider offers a minimal, cached accessor for the Google Maps API key.
 * Responsibilities:
 * - Resolve the key from EnvironmentConfigService once and memoize it.
 */
import { EnvironmentConfigService } from "@/services/EnvironmentConfigService";

export class GoogleKeyProvider {
  constructor(configService = new EnvironmentConfigService()) {
    this.config = configService;
    this._key = null;
    this._inFlight = null;
  }

  async getKey() {
    if (this._key) return this._key;
    if (this._inFlight) return this._inFlight;
    this._inFlight = this.config.load().then(() => {
      this._key = this.config.googleKey();
      if (!this._key) throw new Error("GoogleKeyProvider: GOOGLE_MAPS_JS_API_KEY missing.");
      return this._key;
    }).finally(() => {
      this._inFlight = null;
    });
    return this._inFlight;
  }
}


================================================================================
### PLIK: services/IdempotencyTokenService.js
================================================================================

/**
 * ARCHITECTURE: IdempotencyTokenService creates deterministic tokens for save requests.
 * It follows the manifesto by isolating token generation from controllers and transport layers.
 * Responsibilities:
 * - Produce a stable hash-like token from orderId, side, and payload string.
 */
export class IdempotencyTokenService {
  create(orderId, side, payloadString) {
    const base = `${orderId || ""}|${side || "both"}|${payloadString || ""}`;
    // Simple Fowler–Noll–Vo (FNV-1a) 32-bit hash for deterministic tokens
    let h = 0x811c9dc5;
    for (let i = 0; i < base.length; i++) {
      h ^= base.charCodeAt(i);
      h = (h + ((h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24))) >>> 0;
    }
    return `idem-${h.toString(16)}`;
  }
}


================================================================================
### PLIK: services/LatencyBudget.js
================================================================================

/**
 * ARCHITECTURE: LatencyBudget enforces per-step execution budgets for snappy UX under load.
 * It follows the manifesto by isolating timing limits and providing a race-with-timeout helper.
 * Responsibilities:
 * - Wrap a promise with a timeout; resolve fallback when exceeded; report elapsed for telemetry.
 */
export class LatencyBudget {
  constructor(defaultMs = 1200) {
    this.defaultMs = Math.max(100, defaultMs);
  }

  async runWithTimeout(promiseFactory, timeoutMs = this.defaultMs, fallback = null) {
    const start = Date.now();
    const to = new Promise(resolve => setTimeout(() => resolve({ timeout: true, value: fallback }), Math.max(50, timeoutMs)));
    const op = Promise.resolve().then(() => promiseFactory()).then(v => ({ timeout: false, value: v }));
    const res = await Promise.race([to, op]);
    const elapsedMs = Date.now() - start;
    return { ...res, elapsedMs };
  }
}


================================================================================
### PLIK: services/LoadingBarrier.js
================================================================================

/**
 * ARCHITECTURE: LoadingBarrier serializes concurrent loads by key and ensures latest-wins semantics.
 * It follows the manifesto by centralizing anti-race logic for order detail fetches and suggestion refreshes.
 * Responsibilities:
 * - Track an incrementing ticket per key; resolve only if the ticket is still current when the promise returns.
 * - Provide a simple run(key, fn) API that callers wrap around their async loads.
 */
export class LoadingBarrier {
  constructor() {
    this._tickets = new Map();
  }

  async run(key, fn) {
    if (!key || typeof fn !== "function") throw new Error("LoadingBarrier: invalid arguments.");
    const next = (this._tickets.get(key) || 0) + 1;
    this._tickets.set(key, next);
    const myTicket = next;
    const result = await fn();
    if (this._tickets.get(key) !== myTicket) return null;
    return result;
  }

  invalidate(key) {
    const next = (this._tickets.get(key) || 0) + 1;
    this._tickets.set(key, next);
    return next;
  }
}


================================================================================
### PLIK: services/OrderDetailPrefetcher.js
================================================================================

/**
 * ARCHITECTURE: OrderDetailPrefetcher warms the cache by fetching the next order detail proactively.
 * It follows the manifesto by separating performance optimizations from core controllers.
 * Responsibilities:
 * - Prefetch via AddressExceptionApi and hold a single-item cache keyed by orderId.
 * - Provide getOrFetch(id) to serve from cache or network.
 */
import { AddressExceptionApi } from "@/services/AddressExceptionApi";

export class OrderDetailPrefetcher {
  constructor(api = new AddressExceptionApi()) {
    this.api = api;
    this._cachedId = null;
    this._cached = null;
  }

  async prefetch(nextOrderId) {
    if (!nextOrderId) return false;
    const r = await this.api.getOrderDetail(nextOrderId);
    if (r.ok) {
      this._cachedId = nextOrderId;
      this._cached = r.value;
      return true;
    }
    return false;
  }

  async getOrFetch(orderId) {
    if (this._cachedId === orderId && this._cached) return this._cached;
    const r = await this.api.getOrderDetail(orderId);
    if (r.ok) {
      this._cachedId = orderId;
      this._cached = r.value;
      return r.value;
    }
    throw r.error;
  }

  clear() {
    this._cachedId = null;
    this._cached = null;
    return true;
  }
}


================================================================================
### PLIK: services/OrdersKpiEstimator.js
================================================================================

/**
 * ARCHITECTURE: OrdersKpiEstimator (Stub) would be responsible for calculating
 * client-side KPIs or estimates based on a list of order data.
 * This is a placeholder implementation.
 */
export class OrdersKpiEstimator {
    constructor() {
        // Configuration for KPI calculation
    }

    /**
     * Calculates KPIs from a list of worklist items.
     * @param {Array<object>} items - The list of order summary DTOs.
     * @returns {object} An object containing calculated KPIs (e.g., { pending, avgAgeMs }).
     */
    calculate(items = []) {
        const pending = items.filter(item => item.processingStatus === 'ADDRESS_NEEDS_REVIEW').length;
        const now = Date.now();
        const ages = items
            .filter(item => item.processingStatus === 'ADDRESS_NEEDS_REVIEW' && item.createdAt)
            .map(item => now - new Date(item.createdAt).getTime());

        const avgAgeMs = ages.length > 0
            ? ages.reduce((a, b) => a + b, 0) / ages.length
            : 0;

        return {
            pending: pending,
            avgAgeMs: avgAgeMs,
        };
    }
}

================================================================================
### PLIK: services/OrdersQueueService.js
================================================================================

/**
 * ARCHITECTURE: OrdersQueueService maintains a FIFO queue of orderIds for Save & Next workflows.
 * It follows the manifesto by isolating queue mechanics from components and views.
 * Responsibilities:
 * - Load from a list, advance to next, remove current, inspect current/size/ids.
 */
export class OrdersQueueService {
  constructor() {
    this._ids = [];
    this._index = 0;
  }

  loadFromItems(items) {
    this._ids = (Array.isArray(items) ? items : []).map(x => x.orderId).filter(Boolean);
    this._index = 0;
    return this.ids();
  }

  ids() {
    return this._ids.slice();
  }

  size() {
    return Math.max(0, this._ids.length - this._index);
  }

  current() {
    return this._ids[this._index] || null;
  }

  next() {
    if (this._index + 1 >= this._ids.length) return null;
    this._index++;
    return this.current();
  }

  remove(orderId) {
    const pos = this._ids.indexOf(orderId);
    if (pos === -1) return false;
    this._ids.splice(pos, 1);
    if (this._index > pos) this._index--;
    return true;
  }

  reset() {
    this._ids = [];
    this._index = 0;
    return true;
  }
}


================================================================================
### PLIK: services/OrderStatusWatcher.js
================================================================================

/**
 * ARCHITECTURE: OrderStatusWatcher polls backend for a single order until a target status is reached.
 * It follows the manifesto by isolating polling semantics from views and controllers with a clear contract.
 * Responsibilities:
 * - Poll /orders/{id} at a fixed interval and resolve when status ∈ target set or when max time elapses.
 * - Expose start(), cancel(), and onTick hooks for progress indicators without leaking transport details.
 */
import apiClient from "@/services/api";

export class OrderStatusWatcher {
  constructor(intervalMs = 2000, timeoutMs = 60000) {
    this.intervalMs = Math.max(250, intervalMs);
    this.timeoutMs = Math.max(this.intervalMs, timeoutMs);
    this._timer = null;
    this._startedAt = 0;
    this._active = false;
    this._onTick = null;
  }

  onTick(fn) {
    this._onTick = typeof fn === "function" ? fn : null;
    return this;
  }

  start(orderId, targetStatuses = ["ADDRESS_VALIDATED", "MANUALLY_CORRECTED"]) {
    if (!orderId) throw new Error("OrderStatusWatcher: orderId required.");
    this.cancel();
    this._active = true;
    this._startedAt = Date.now();
    return new Promise((resolve, reject) => {
      const tick = async () => {
        if (!this._active) return;
        try {
          const r = await apiClient.get(`/orders/${encodeURIComponent(orderId)}`);
          const status = r?.data?.processingStatus || null;
          if (this._onTick) this._onTick({ status, elapsedMs: Date.now() - this._startedAt });
          if (status && targetStatuses.includes(status)) {
            this.cancel();
            return resolve({ status, elapsedMs: Date.now() - this._startedAt });
          }
        } catch (e) {
          this.cancel();
          return reject(e);
        }
        if (Date.now() - this._startedAt > this.timeoutMs) {
          this.cancel();
          return resolve({ status: null, elapsedMs: this.timeoutMs, timeout: true });
        }
        this._timer = setTimeout(tick, this.intervalMs);
      };
      this._timer = setTimeout(tick, this.intervalMs);
    });
  }

  cancel() {
    this._active = false;
    if (this._timer) clearTimeout(this._timer);
    this._timer = null;
    return true;
  }
}


================================================================================
### PLIK: services/PollingService.js
================================================================================

/**
 * ARCHITECTURE: PollingService centralizes controlled, single-instance polling loops per key.
 * It follows the manifesto by isolating timing concerns and exposing explicit start/stop contracts.
 * Responsibilities:
 * - Start a debounced timer for an async function and prevent duplicate loops for the same key.
 * - Provide deterministic cancellation via handles and bulk stop-All capability.
 */
export class PollingService {
  constructor() {
    this._timers = new Map();
  }

  start(key, intervalMs, asyncFn) {
    if (!key || typeof asyncFn !== "function" || typeof intervalMs !== "number" || intervalMs <= 0) {
      throw new Error("PollingService.start: invalid arguments.");
    }
    this.stop(key);
    let active = true;
    const tick = async () => {
      if (!active) return;
      try {
        await asyncFn();
      } catch (_) {
        // Errors are handled upstream; polling continues unless explicitly stopped.
      }
      if (active) {
        this._timers.set(key, setTimeout(tick, intervalMs));
      }
    };
    this._timers.set(key, setTimeout(tick, intervalMs));
    return { key, stop: () => this.stop(key) };
  }

  stop(key) {
    const t = this._timers.get(key);
    if (t) {
      clearTimeout(t);
      this._timers.delete(key);
    }
  }

  stopAll() {
    for (const key of this._timers.keys()) {
      this.stop(key);
    }
  }
}


================================================================================
### PLIK: services/QuotaBackoffService.js
================================================================================

/**
 * ARCHITECTURE: QuotaBackoffService (Stub) would manage client-side rate limiting
 * or backoff strategies when interacting with external APIs (like Google)
 * that enforce quotas. This is a placeholder.
 */
import { RetryPolicy } from "@/services/RetryPolicy"; // Assumes RetryPolicy exists

export class QuotaBackoffService {
    constructor() {
        // Configure retry policy specifically for quota errors
        this.retryPolicy = new RetryPolicy(
            3, // Max 3 attempts
            500, // Base delay 500ms
            200, // Jitter 200ms
            (error) => {
                // Only retry on specific quota-related error messages or status codes
                const msg = (error?.message || "").toLowerCase();
                const status = error?.response?.status;
                return msg.includes("quota") || msg.includes("rate limit") || status === 429 || status === 503;
            }
        );
    }

    /**
     * Executes a function wrapped in the backoff/retry policy.
     * @param {Function} asyncFn - The async function to execute (e.g., () => geocoder.geocode(...)).
     * @returns {Promise<any>} The result of the async function.
     */
    async execute(asyncFn) {
        try {
            return await this.retryPolicy.execute(asyncFn);
        } catch (error) {
            console.warn("[QuotaBackoffService] Execution failed after retries:", error);
            throw error; // Re-throw the final error
        }
    }
}

================================================================================
### PLIK: services/RetryPolicy.js
================================================================================

/**
 * ARCHITECTURE: RetryPolicy executes async operations with bounded retries and jittered backoff.
 * It follows the manifesto by centralizing resilience concerns away from controllers and adapters.
 * Responsibilities:
 * - Execute a provided async function up to maxAttempts with exponential backoff and random jitter.
 * - Allow fast-fail on non-retryable errors via predicate.
 */
export class RetryPolicy {
  constructor(maxAttempts = 5, baseDelayMs = 300, jitterMs = 150, isRetryable = () => true) {
    this.maxAttempts = Math.max(1, maxAttempts);
    this.baseDelayMs = Math.max(0, baseDelayMs);
    this.jitterMs = Math.max(0, jitterMs);
    this.isRetryable = isRetryable;
  }

  async execute(fn) {
    let attempt = 0;
    let lastError = null;
    while (attempt < this.maxAttempts) {
      try {
        return await fn();
      } catch (e) {
        lastError = e;
        attempt++;
        if (attempt >= this.maxAttempts || !this.isRetryable(e)) break;
        const backoff = this.baseDelayMs * Math.pow(2, attempt - 1);
        const jitter = Math.floor(Math.random() * this.jitterMs);
        await new Promise((r) => setTimeout(r, backoff + jitter));
      }
    }
    throw lastError || new Error("RetryPolicy: execution failed.");
  }
}


================================================================================
### PLIK: services/RuntimeHealthService.js
================================================================================

/**
 * ARCHITECTURE: RuntimeHealthService is a tolerant, dev-first health probe that never blocks the UI.
 * It follows the manifesto by eliminating non-essential cross-origin calls that cause startup noise.
 * Responsibilities:
 * - Always return a "ready" structure without performing any network requests in development.
 * - Preserve the method signature so other controllers remain decoupled from transport concerns.
 */
export class RuntimeHealthService {
  constructor() {
    this.devBypass = true; // development-first: suppress all /status calls to avoid 403/5xx noise
  }

  async readiness(googleKey) {
    return {
      ready: true,
      backend: { ok: true, code: 200 },
      provider: { ok: true, code: 200 },
      google: { ok: !!googleKey },
    };
  }
}


================================================================================
### PLIK: services/SessionStorageService.js
================================================================================

/**
 * ARCHITECTURE: SessionStorageService persists small JSON blobs across reloads within the session.
 * It follows the manifesto by isolating storage read/write and providing safe JSON handling.
 * Responsibilities:
 * - Save and load values by key with automatic JSON serialization and prefixing to avoid collisions.
 * - Provide remove and clearNamespace utilities without affecting unrelated storage.
 */
export class SessionStorageService {
  constructor(namespace = "wb") {
    this.ns = namespace;
    this._prefix = `${this.ns}:`;
    this._store = typeof window !== "undefined" ? window.sessionStorage : null;
  }

  save(key, value) {
    if (!this._store) return false;
    this._store.setItem(this._prefix + key, JSON.stringify(value == null ? null : value));
    return true;
  }

  load(key, fallback = null) {
    if (!this._store) return fallback;
    const raw = this._store.getItem(this._prefix + key);
    if (raw == null) return fallback;
    try {
      return JSON.parse(raw);
    } catch {
      return fallback;
    }
  }

  remove(key) {
    if (!this._store) return false;
    this._store.removeItem(this._prefix + key);
    return true;
  }

  clearNamespace() {
    if (!this._store) return 0;
    const keys = [];
    for (let i = 0; i < this._store.length; i++) {
      const k = this._store.key(i);
      if (k && k.startsWith(this._prefix)) keys.push(k);
    }
    keys.forEach(k => this._store.removeItem(k));
    return keys.length;
  }
}


================================================================================
### PLIK: services/SuggestionConflictDetector.js
================================================================================

/**
 * ARCHITECTURE: SuggestionConflictDetector (Stub) would be responsible for
 * analyzing a list of suggestions and flagging potential conflicts
 * (e.g., same street/city but different postal codes).
 * This is a placeholder implementation.
 */
export class SuggestionConflictDetector {
    constructor() {
        // Configuration for conflict detection
    }

    /**
     * Analyzes a list of suggestions and returns conflict metadata.
     * @param {Array<object>} suggestions - List of normalized suggestions.
     * @returns {object} An object describing conflicts (e.g., { hasPostalConflict: true }).
     */
    analyze(suggestions = []) {
        if (suggestions.length < 2) {
            return { hasPostalConflict: false, hasCityConflict: false };
        }

        // Example: Check for postal code conflicts (same street/city, different postal)
        const postalCodes = new Set();
        let hasPostalConflict = false;
        const firstStreet = suggestions[0].street?.toLowerCase();
        const firstCity = suggestions[0].city?.toLowerCase();

        for (const s of suggestions) {
            if (s.postalCode) {
                // Check if this suggestion has same street/city but different postal code
                if (s.street?.toLowerCase() === firstStreet && s.city?.toLowerCase() === firstCity) {
                    postalCodes.add(s.postalCode);
                    if (postalCodes.size > 1) {
                        hasPostalConflict = true;
                        break;
                    }
                }
            }
        }

        return {
            hasPostalConflict: hasPostalConflict,
            hasCityConflict: false, // TODO: Implement city conflict logic
        };
    }
}

================================================================================
### PLIK: services/SuggestionNormalizer.js
================================================================================

// FILE: src/services/SuggestionNormalizer.js
/**
 * ARCHITECTURE: SuggestionNormalizer converts heterogeneous provider responses into a unified Suggestion DTO.
 * It follows the manifesto by isolating mapping/normalization concerns and avoiding provider leakage into UI.
 * Responsibilities:
 * - Accept raw Google Geocoder/Places or TES suggestion objects and output a normalized shape.
 * - Provide batch normalization and safe defaults for missing fields.
 *
 * FIX: Removed erroneous circular self-import statement.
 */
// REMOVED: import { SuggestionNormalizer } from "@/services/SuggestionNormalizer";

export class SuggestionNormalizer {
  constructor(defaultCountry = "PL") {
    this.defaultCountry = defaultCountry;
  }

  fromGoogleGeocoder(geo) {
    if (!geo) return null;
    const comp = this._indexComponents(geo.address_components || []);
    return {
      fullAddressLabel: geo.formatted_address || null,
      street: comp.route ||
          null,
      houseNumber: comp.street_number || null,
      postalCode: comp.postal_code ||
          null,
      city: comp.locality || comp.postal_town || comp.administrative_area_level_2 ||
          null,
      countryCode: comp.country_code || this.defaultCountry,
      countryName: comp.country ||
          null,
      latitude: geo.geometry?.location?.lat?.() ?? null,
      longitude: geo.geometry?.location?.lng?.() ??
          null,
      matchScore: 0.95,
      matchLevel: "GEOCODER",
      providerSource: "GOOGLE_CLIENT",
    };
  }

  fromGooglePlaces(place) {
    if (!place) return null;
    const comp = this._indexComponents(place.address_components || []);
    return {
      fullAddressLabel: null,
      street: comp.route ||
          null,
      houseNumber: comp.street_number || null,
      postalCode: comp.postal_code ||
          null,
      city: comp.locality || comp.postal_town || comp.administrative_area_level_2 ||
          null,
      countryCode: comp.country_code || this.defaultCountry,
      countryName: comp.country ||
          null,
      latitude: place.geometry?.location?.lat?.() ?? null,
      longitude: place.geometry?.location?.lng?.() ??
          null,
      matchScore: 0.9,
      matchLevel: "PLACES",
      providerSource: "GOOGLE_PLACES",
    };
  }

  fromTes(item) {
    if (!item) return null;
    return {
      fullAddressLabel: item.label || null,
      street: item.street ||
          null,
      houseNumber: item.houseNumber || null,
      postalCode: item.postalCode ||
          null,
      city: item.city || null,
      countryCode: item.countryCode ||
          this.defaultCountry,
      countryName: item.country || null,
      latitude: typeof item.latitude === "number" ?
          item.latitude : null,
      longitude: typeof item.longitude === "number" ?
          item.longitude : null,
      matchScore: typeof item.score === "number" ?
          item.score : 0.7,
      matchLevel: item.level ||
          "TES",
      providerSource: "TES",
    };
  }

  normalizeBatch(list, origin) {
    if (!Array.isArray(list)) return [];
    if (origin === "GEOCODER") return list.map(x => this.fromGoogleGeocoder(x)).filter(Boolean);
    if (origin === "PLACES") return list.map(x => this.fromGooglePlaces(x)).filter(Boolean);
    if (origin === "TES") return list.map(x => this.fromTes(x)).filter(Boolean);
    return [];
  }

  _indexComponents(parts) {
    const map = {};
    for (const c of parts) {
      for (const t of c.types) {
        if (t === "country") {
          map.country = c.long_name;
          map.country_code = c.short_name;
        } else if (t === "locality") {
          map.locality = c.long_name;
        } else if (t === "postal_town") {
          map.postal_town = c.long_name;
        } else if (t === "administrative_area_level_2") {
          map.administrative_area_level_2 = c.long_name;
        } else if (t === "route") {
          map.route = c.long_name;
        } else if (t === "street_number") {
          map.street_number = c.long_name;
        } else if (t === "postal_code") {
          map.postal_code = c.long_name;
        }
      }
    }
    return map;
  }
}

================================================================================
### PLIK: services/SuggestionPreviewService.js
================================================================================

/**
 * ARCHITECTURE: SuggestionPreviewService creates a non-destructive preview Address object from a suggestion.
 * It follows the manifesto by isolating conversion rules away from editor state and components.
 * Responsibilities:
 * - Convert a suggestion DTO to an Address-like object the map can display without committing changes.
 */
export class SuggestionPreviewService {
  toAddressLike(s) {
    if (!s) return null;
    return {
      street: s.street || "",
      houseNumber: s.houseNumber || null,
      postalCode: s.postalCode || "",
      city: s.city || "",
      country: s.countryCode || s.country || "PL",
      latitude: typeof s.latitude === "number" ? s.latitude : null,
      longitude: typeof s.longitude === "number" ? s.longitude : null,
    };
  }
}


================================================================================
### PLIK: services/TelemetryService.js
================================================================================

// FILE: src/services/TelemetryService.js
// ENHANCED FILE
import { AddressExceptionApi } from '@/services/AddressExceptionApi'; // For sending logs
import { AuthController } from '@/controllers/AuthController'; // To potentially check auth state
import { ref } from 'vue';

const MAX_BUFFER_SIZE = 50;
const SEND_INTERVAL_MS = 15000; // Send logs every 15 seconds

/**
 * ARCHITECTURE: Simple telemetry for capturing key UI events and errors.
 * ENHANCED: Captures console logs, buffers them, and sends them periodically to the backend.
 */
export class TelemetryService {
    constructor(api = new AddressExceptionApi(), auth = new AuthController()) {
        this.api = api; // Use API service to send logs
        this.auth = auth; // To check if logged in
        this._logBuffer = ref([]); // Use ref for potential reactivity if needed later
        this._originalConsole = {};
        this._sendTimeoutId = null;
        this._isSending = false; // Prevent concurrent sends

        this._wrapConsole();
        this._startSendingInterval();
    }

    _wrapConsole() {
        const levels = ['log', 'info', 'warn', 'error', 'debug'];
        levels.forEach(level => {
            this._originalConsole[level] = console[level];
            console[level] = (...args) => {
                // Call original console method
                this._originalConsole[level]?.apply(console, args);
                // Capture and buffer the log
                this._captureLog(level, args);
            };
        });
        // Capture unhandled errors/rejections
        window.addEventListener('error', (event) => this._captureErrorEvent(event));
        window.addEventListener('unhandledrejection', (event) => this._captureUnhandledRejection(event));
    }

    _captureLog(level, args) {
        if (this._logBuffer.value.length >= MAX_BUFFER_SIZE) {
            // Optionally drop oldest log or stop buffering
            // console.warn("[Telemetry] Log buffer full, dropping oldest entry.");
            // this._logBuffer.value.shift();
            return; // Stop buffering if full for now
        }
        try {
            const message = args.map(arg => this._formatArg(arg)).join(' ');
            const logEntry = {
                timestamp: new Date().toISOString(),
                level: level.toUpperCase(),
                message: message,
                // Add context if needed: location: window.location.pathname, userAgent: navigator.userAgent
            };
            this._logBuffer.value.push(logEntry);
        } catch(e) {
            this._originalConsole.error?.("[Telemetry] Error capturing log:", e);
        }
    }

    _captureErrorEvent(event) {
        // event: ErrorEvent
        const entry = {
            timestamp: new Date().toISOString(),
            level: 'ERROR',
            message: event.message,
            source: 'window.onerror',
            filename: event.filename,
            lineno: event.lineno,
            colno: event.colno,
            error: event.error ? this._formatArg(event.error) : null
        };
        this._logBuffer.value.push(entry);
    }

    _captureUnhandledRejection(event) {
        // event: PromiseRejectionEvent
        const entry = {
            timestamp: new Date().toISOString(),
            level: 'ERROR',
            message: 'Unhandled promise rejection',
            source: 'window.onunhandledrejection',
            reason: event.reason ? this._formatArg(event.reason) : null
        };
        this._logBuffer.value.push(entry);
    }

    _formatArg(arg) {
        if (arg instanceof Error) {
            return `${arg.name}: ${arg.message}\n${arg.stack}`;
        }
        if (typeof arg === 'object' && arg !== null) {
            try {
                // Basic object serialization, limit depth/size if needed
                return JSON.stringify(arg);
            } catch {
                return '[Unserializable Object]';
            }
        }
        return String(arg);
    }

    _startSendingInterval() {
        if (this._sendTimeoutId) clearTimeout(this._sendTimeoutId);
        this._sendTimeoutId = setInterval(() => {
            this._sendBufferedLogs();
        }, SEND_INTERVAL_MS);
    }

    async _sendBufferedLogs() {
        // Check if user is authenticated before sending
        if (!this.auth.isAuthenticatedRef.value || this._isSending) {
            return;
        }
        if (this._logBuffer.value.length === 0) {
            return;
        }

        // Important: Swap buffer immediately to avoid race conditions
        const logsToSend = this._logBuffer.value;
        this._logBuffer.value = [];
        this._isSending = true;

        try {
            this._originalConsole.debug?.(`[Telemetry] Sending ${logsToSend.length} log entries...`);
            // Use the API client method (to be created in AddressExceptionApi)
            await this.api.sendClientLogs(logsToSend);
            // Logs sent successfully
        } catch (error) {
            this._originalConsole.error?.("[Telemetry] Failed to send client logs:", error);
            // Failed: Put logs back into buffer (potentially merging with new ones)
            // Be careful about buffer size limit
            const currentBuffer = this._logBuffer.value;
            this._logBuffer.value = [...logsToSend, ...currentBuffer].slice(0, MAX_BUFFER_SIZE);
            if (this._logBuffer.value.length >= MAX_BUFFER_SIZE) {
                this._originalConsole.warn?.("[Telemetry] Log buffer full after send failure.");
            }
        } finally {
            this._isSending = false;
        }
    }

    // Method to manually trigger send (e.g., on beforeunload)
    flushLogs() {
        if (this._sendTimeoutId) clearTimeout(this._sendTimeoutId);
        this._sendTimeoutId = null; // Stop interval
        // Send any remaining logs synchronously if possible, or async
        this._sendBufferedLogs(); // Fire and forget async send
    }

    // Call this when app unloads
    destroy() {
        this.flushLogs();
        // Restore original console methods
        Object.keys(this._originalConsole).forEach(level => {
            if (console[level] === this._originalConsole[level]) return; // Already restored or never wrapped
            console[level] = this._originalConsole[level];
        });
        window.removeEventListener('error', this._captureErrorEvent);
        window.removeEventListener('unhandledrejection', this._captureUnhandledRejection);
    }

    // Existing methods (can remain or be removed if only log capture is needed)
    event(name, data = {}) {
        // console.log("[Telemetry Event]", name, data);
        this._captureLog('info', [`[Telemetry Event] ${name}`, data]);
    }
    error(err, context = {}) {
        // console.error("[Telemetry Error]", err, context);
        this._captureLog('error', ["[Telemetry Error]", err, context]);
    }
}

================================================================================
### PLIK: services/TesOperationPoller.js
================================================================================

/**
 * ARCHITECTURE: TesOperationPoller handles polling the DANXILS-API status endpoint
 * for asynchronous operations initiated via Kafka proxies.
 * Responsibilities:
 * - Poll a given status URL until the operation status is COMPLETED or FAILED.
 * - Implement configurable retry limits and polling intervals.
 * - Return the final operation status and result/error.
 */
import apiClient from '@/services/api';

export class TesOperationPoller {
    constructor(defaultIntervalMs = 2000, defaultMaxRetries = 15) {
        this.intervalMs = defaultIntervalMs;
        this.maxRetries = defaultMaxRetries;
    }

    async waitFor(correlationId, intervalMs = this.intervalMs, maxRetries = this.maxRetries) {
        if (!correlationId) {
            throw new Error("TesOperationPoller: correlationId is required.");
        }

        const statusUrl = `/api/admin/address-verification/operations/${correlationId}`;
        console.debug(`Polling status for ${correlationId} at ${statusUrl}...`);

        for (let i = 0; i < maxRetries; i++) {
            try {
                if (i > 0) {
                    await new Promise(resolve => setTimeout(resolve, intervalMs));
                }

                const statusResponse = await apiClient.get(statusUrl);
                const operation = statusResponse.data;

                if (!operation || !operation.status) {
                    console.warn(`Polling for ${correlationId}: Received unexpected response. Retrying...`);
                    continue;
                }

                console.debug(`Polling for ${correlationId}: Attempt ${i+1}/${maxRetries}, Status: ${operation.status}`);

                if (operation.status === 'COMPLETED') {
                    let parsedResult = operation.responsePayloadJson;
                    if (parsedResult && typeof parsedResult === 'string') {
                        try {
                            parsedResult = JSON.parse(parsedResult);
                        } catch (parseError) {
                            console.warn(`Polling for ${correlationId}: Completed, but failed to parse responsePayloadJson`, parseError);
                        }
                    }
                    return { ...operation, result: parsedResult };
                }

                if (operation.status === 'FAILED') {
                    return { ...operation, errorDetails: operation.errorMessage };
                }

            } catch (error) {
                if (error.response?.status === 404) {
                    console.warn(`Polling for ${correlationId}: Received 404. Retrying (attempt ${i+1}/${maxRetries})...`);
                } else {
                    console.error(`Polling for ${correlationId}: Error during attempt ${i+1}:`, error);
                }
            }
        }

        throw new Error(`Polling for operation ${correlationId} timed out after ${maxRetries} attempts.`);
    }
}


================================================================================
### PLIK: services/UndoStackService.js
================================================================================

// FILE: services/UndoStackService.js
/**
 * ARCHITECTURE: UndoStackService provides bounded undo/redo stacks for immutable editor state snapshots.
 * It follows the manifesto by isolating time-travel mechanics with a deterministic, dependency-free API.
 * Responsibilities:
 * - Push snapshots, undo, redo, and limit memory with a maximum capacity.
 * - Expose current() without mutating returned objects.
 * REFACTORED: Added canUndo() and canRedo() methods.
 */
export class UndoStackService {
  constructor(capacity = 50) {
    this.capacity = Math.max(1, capacity);
    this._past = [];
    this._future = [];
    this._current = null;
  }

  init(snapshot) {
    this._past = [];
    this._future = [];
    this._current = snapshot ? JSON.parse(JSON.stringify(snapshot)) : null;
    return this.current();
  }

  push(snapshot) {
    if (this._current != null) {
      this._past.push(this._current);
      if (this._past.length > this.capacity) this._past.shift();
    }
    this._current = snapshot ? JSON.parse(JSON.stringify(snapshot)) : null;
    this._future = [];
    return this.current();
  }

  undo() {
    if (!this._past.length) return this.current();
    this._future.unshift(this._current);
    this._current = this._past.pop();
    return this.current();
  }

  redo() {
    if (!this._future.length) return this.current();
    this._past.push(this._current);
    this._current = this._future.shift();
    return this.current();
  }

  clear() {
    this._past = [];
    this._future = [];
    return true;
  }

  current() {
    return this._current ? JSON.parse(JSON.stringify(this._current)) : null;
  }

  // --- ADDED METHODS ---
  /** Checks if an undo operation is possible. */
  canUndo() {
    return this._past.length > 0;
  }

  /** Checks if a redo operation is possible. */
  canRedo() {
    return this._future.length > 0;
  }
  // --- END ADDED METHODS ---
}

================================================================================
### PLIK: services/ValidationService.js
================================================================================

/**
 * ARCHITECTURE: ValidationService provides basic, potentially country-specific,
 * validation rules for address fields. Adheres to SRP by isolating validation logic.
 * This is a basic stub implementation; enhance with actual rules as needed.
 */
export class ValidationService {
    constructor(countryCode = "PL") {
        this.countryCode = countryCode.toUpperCase();
        // Basic required fields for PL example
        this.requiredFields = ["street", "postalCode", "city", "country"];
        // Basic regex for PL postal code example
        this.postalRegex = /^\d{2}-\d{3}$/;
    }

    /**
     * Validates an address object based on configured rules.
     * @param {object} address - The address object to validate (e.g., { street, postalCode, city, country }).
     * @returns {{valid: boolean, errors: object}} - Validation result.
     */
    validate(address) {
        const errors = {};
        let valid = true;

        if (!address) {
            return { valid: false, errors: { general: "Address object is missing." } };
        }

        // Check required fields
        for (const field of this.requiredFields) {
            if (!address[field] || String(address[field]).trim() === "") {
                errors[field] = `${field} is required.`;
                valid = false;
            }
        }

        // Check postal code format (example for PL)
        if (this.countryCode === "PL" && address.postalCode && !this.postalRegex.test(String(address.postalCode).trim())) {
            errors.postalCode = "Invalid postal code format (expected XX-XXX).";
            valid = false;
        }

        // Add more specific validation rules here (length, character sets, etc.)

        return { valid, errors };
    }
}

================================================================================
### PLIK: debug/StartupProbe.js
================================================================================

/**
 * ARCHITECTURE: StartupProbe emits deterministic breadcrumbs during app boot and first render.
 * It follows the manifesto by isolating debug side effects from core logic.
 * Responsibilities:
 * - Log lifecycle milestones; stamp <html data-app-boot="..."> for visual confirmation.
 */
export class StartupProbe {
    constructor() {
        this.marks = [];
    }

    mark(label) {
        const ts = new Date().toISOString();
        const entry = `${ts} :: ${label}`;
        this.marks.push(entry);
        if (typeof console !== "undefined" && console.log) console.log("[startup]", entry);
        try {
            const html = document.documentElement;
            html.setAttribute("data-app-boot", label);
        } catch (_) { /* ignore */ }
        return entry;
    }

    dump() {
        if (typeof console !== "undefined" && console.table) console.table(this.marks.map((m, i) => ({ i, m })));
        return this.marks.slice();
    }
}

================================================================================
### PLIK: router/AuthGuard.js
================================================================================

/**
 * ARCHITECTURE: AuthGuard protects routes by requiring an authenticated session.
 * It follows the manifesto by isolating navigation policy and tolerating a minimal localStorage token.
 * Responsibilities:
 * - Allow /login always.
 * - Accept session from AuthSessionService; if absent, fall back to localStorage.accessToken and bind header.
 */
import { AuthSessionService } from "@/services/AuthSessionService";
import { ApiAuthBinder } from "@/services/ApiAuthBinder";

export class AuthGuard {
    constructor(session = new AuthSessionService(), binder = new ApiAuthBinder()) {
        this.session = session;
        this.binder = binder;
    }

    async canEnter(to) {
        const path = String(to?.path || "");
        if (path.startsWith("/login")) return true;

        // Primary: full session saved by AuthController
        if (this.session.isAuthenticated()) {
            const tok = this.session.getAccessToken();
            const typ = this.session.getTokenType();
            if (tok) this.binder.bind(tok, typ);
            return true;
        }

        // Tolerant fallback: plain token in localStorage (e.g., from earlier minimal form)
        if (typeof window !== "undefined") {
            const raw = window.localStorage?.getItem("accessToken");
            if (raw && raw.length > 10) {
                this.binder.bind(raw, "Bearer");
                return true;
            }
        }

        throw new Error("AuthGuard: unauthenticated.");
    }
}


================================================================================
### PLIK: router/EditorRouteGuard.js
================================================================================

// FILE: src/router/EditorRouteGuard.js
/**
 * ARCHITECTURE: Ensures GeoRuntime is initialized and required providers are ready.
 * Supports Leaflet/Nominatim or Google stacks via configuration.
 */
export class EditorRouteGuard {
  constructor(geoRuntime) {
    if (!geoRuntime) throw new Error("EditorRouteGuard requires GeoRuntime.");
    this._geoRuntime = geoRuntime;
  }

  async canEnter(to) {
    const orderId = to?.params?.id || to?.query?.orderId || null;
    if (!orderId) throw new Error("EditorRouteGuard: orderId is required.");

    // Ensure providers are initialized before checking readiness.
    await this._geoRuntime.init();

    const cfg = this._geoRuntime._config;
    const mustBeReady = [
      ["map", cfg.map],
      ["geocode", cfg.geocode],
      ...(cfg.places && cfg.places !== "none" ? [["places", cfg.places]] : [])
    ];

    for (const [type, provider] of mustBeReady) {
      if (!this._geoRuntime.isProviderReady(type, provider)) {
        throw new Error(`EditorRouteGuard: ${type} provider '${provider}' not available.`);
      }
    }

    return true;
  }
}


================================================================================
### PLIK: router/index.js
================================================================================

// ============================================================================
// Frontend ➜ router/index.js (Final Version)
// REASON: Ensure GeoRuntime is passed, guards are correctly instantiated and used.
// ============================================================================
// FILE: src/router/index.js

import { createRouter as vueCreateRouter, createWebHistory } from "vue-router";
import LoginView from "@/views/LoginView.vue";
import WorklistView from "@/views/WorklistView.vue";
import TriageDashboard from "@/views/TriageDashboard.vue";
import CorrectionEditorView from "@/views/CorrectionEditorView.vue";
import LogDashboardView from "@/views/LogDashboardView.vue";
import AedAdminView from "@/views/AedAdminView.vue";
// *** ADDED IMPORTS FOR NEW ADMIN VIEWS ***
import HubRulesView from "@/views/HubRulesView.vue";
import AddressUploadView from "@/views/AddressUploadView.vue";

import { AuthGuard } from "@/router/AuthGuard";
import { EditorRouteGuard } from "@/router/EditorRouteGuard";
import { AuthSessionService } from "@/services/AuthSessionService";

/**
 * ARCHITECTURE: Creates the Vue Router with guards for authentication and editor prerequisites.
 * REFACTORED: Added routes for Hub Rules, Address Upload, AED SFTP Admin. Corrected admin role check.
 */
export function createRouter(geoRuntime) { // GeoRuntime must be passed from main.js
  if (!geoRuntime) throw new Error("createRouter requires a GeoRuntime instance.");

  const editorGuard = new EditorRouteGuard(geoRuntime);
  const authGuard = new AuthGuard();
  const authSession = new AuthSessionService(); // For role checking

  const routes = [
    { path: "/", redirect: "/login" },
    { path: "/login", name: "login", component: LoginView },

    // Protected routes
    { path: "/dashboard", name: "dashboard", component: TriageDashboard, meta: { requiresAuth: true } },
    { path: "/worklist", name: "worklist", component: WorklistView, meta: { requiresAuth: true } },
    {
      path: "/editor/:id",
      name: "editor",
      component: CorrectionEditorView,
      meta: { requiresAuth: true }, // Editor requires auth
      beforeEnter: async (to, _from, next) => {
        try {
          // Check if geo providers are ready *before* allowing entry
          await editorGuard.canEnter(to);
          next(); // Proceed if guard passes
        } catch (guardError) {
          console.error("EditorRouteGuard failed:", guardError?.message || guardError);
          // Redirect back to worklist with an error query param
          next({ path: "/worklist", query: { error: 'editor_unavailable', reason: guardError?.message || 'Unknown' }});
        }
      },
    },
    // Admin routes grouped under /admin
    {
      path: "/admin/logs",
      name: "log-dashboard",
      component: LogDashboardView,
      meta: { requiresAuth: true, requiresAdmin: true } // Requires admin
    },
    {
      path: "/admin/hub-rules", // New route for Hub Rules
      name: "hub-rules",
      component: HubRulesView,
      meta: { requiresAuth: true, requiresAdmin: true }
    },
    {
      path: "/admin/address-upload", // New route for Address Upload
      name: "address-upload",
      component: AddressUploadView,
      meta: { requiresAuth: true, requiresAdmin: true }
    },
    {
      path: "/admin/aed-sftp", // New route for AED SFTP Admin
      name: "aed-admin",
      component: AedAdminView,
      meta: { requiresAuth: true, requiresAdmin: true }
    },

    // Catch-all redirect (redirects unauthenticated to login, authenticated to dashboard)
    {
      path: "/:pathMatch(.*)*",
      redirect: to => {
        // Use session service to check current auth state without async call
        return authSession.isAuthenticated() ? '/dashboard' : '/login';
      }
    },
  ];

  const router = vueCreateRouter({
    history: createWebHistory(import.meta.env.BASE_URL),
    routes
  });

  // Global Navigation Guard
  router.beforeEach(async (to, from, next) => {
    // 1. Skip auth checks for the login page itself
    if (to.path === '/login') {
      // If already authenticated, redirect away from login to dashboard
      if (authSession.isAuthenticated()) {
        next('/dashboard');
      } else {
        next(); // Allow access to login if not authenticated
      }
      return;
    }

    // 2. Check if the route requires authentication
    if (to.meta.requiresAuth || to.meta.requiresAdmin) {
      try {
        // Verify authentication using the AuthGuard
        await authGuard.canEnter(to); // This throws if not authenticated

        // 3. Check for Admin role if required
        if (to.meta.requiresAdmin && !authSession.hasRole('ADMIN')) {
          console.warn("AuthGuard: Admin role required for", to.path, ". User roles:", authSession.getUser()?.roles, "Redirecting to dashboard.");
          next("/dashboard"); // Redirect non-admins trying to access admin pages
          return;
        }

        // Authentication and Authorization passed
        next();

      } catch (authError) {
        // AuthGuard failed (not authenticated or token invalid)
        console.warn("AuthGuard failed:", authError?.message || authError, "Redirecting to login.");
        // Redirect to login, preserving the intended destination
        next({ path: "/login", query: { redirect: to.fullPath } });
      }
    } else {
      // Route does not require authentication
      next();
    }
  });

  return router;
}
