
================================================================================
### PLIK: App.vue
================================================================================

<template>
  <router-view />
</template>

<script setup>
// Logika specyficzna dla App.vue, jeśli potrzebna,
// ale dla głównego layoutu dashboardu logika będzie w DashboardLayout.vue
</script>

<style>
/* Globalne style są już importowane w main.js poprzez import './style.css'; */
/* Jeśli potrzebujesz tutaj specyficznych stylów tylko dla #app-container lub globalnych styli,
   które nie są w style.css, możesz je tu dodać, ale NIE importuj ponownie './style.css' */
</style>

================================================================================
### PLIK: main.js
================================================================================

import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import { createPinia } from 'pinia'
import './assets/main.css'

const app = createApp(App)

const pinia = createPinia()
app.use(pinia)
app.use(router)
app.mount('#app')


================================================================================
### PLIK: assets\main.css
================================================================================

@tailwind base;
@tailwind components;
@tailwind utilities;


================================================================================
### PLIK: components\AddressDisplay.vue
================================================================================

<template>
  <div class="p-3 rounded-md shadow-sm" :class="containerClasses">
    <strong class="block text-sm font-semibold mb-2" :class="titleClasses">{{ title }}</strong>
    <div v-if="parsedAddress && !parsingError" class="space-y-1 text-xs">
      <div v-for="field in displayFields" :key="field.key" class="flex items-baseline">
        <span class="text-slate-500 w-24 sm:w-28 shrink-0">{{ field.label }}:</span>
        <span
          class="font-medium break-words"
          :class="getFieldClass(field.key, parsedAddress[field.key])"
        >
          {{ parsedAddress[field.key] || 'N/A' }}
        </span>
      </div>
      <div v-if="!hasAddressData(parsedAddress) && !parsingError" class="text-xs text-slate-400 italic mt-2">
        (Brak danych adresowych w źródle)
      </div>
    </div>
    <div v-else-if="parsingError" class="text-xs text-red-500 italic">
      {{ parsingError }}
    </div>
    <div v-else class="text-xs text-slate-400 italic">
      Brak danych adresowych.
    </div>
  </div>
</template>

<script setup>
import { computed, ref, watch } from 'vue';

const props = defineProps({
  title: { type: String, required: true },
  addressString: { type: String, default: '' },
  compareToAddressString: { type: String, default: '' },
  addressContext: { type: String, default: 'delivery' }, // 'pickup', 'delivery', 'database_dto', 'here_suggestion', 'provider_suggestion'
  highlightAsSource: { type: String, default: 'neutral' }
});

const parsingError = ref(null);

const displayFields = [
  { key: 'name', label: 'Nazwa/Kontakt' },
  { key: 'street', label: 'Ulica' },
  { key: 'houseNumber', label: 'Nr domu' },
  { key: 'postalCode', label: 'Kod pocztowy' },
  { key: 'city', label: 'Miasto' },
  { key: 'countryName', label: 'Kraj' }
];

const normalizeString = (str) => {
  return str ? String(str).trim().toLowerCase() : '';
};

const parseAddressDataInternal = (jsonString, context, errorObject) => {
  if (!jsonString) {
    errorObject.value = 'Brak danych wejściowych (null lub pusty string).';
    return null;
  }
  try {
    const data = JSON.parse(jsonString);
    errorObject.value = null;

    if (context === 'pickup') {
      return {
        street: data.PickUpStreet,
        houseNumber: data.PickUpHouseNo,
        postalCode: data.PickUpPostalCode,
        city: data.PickUpCity,
        name: data.PickUpName,
        countryName: data.PickUpCountry || ''
      };
    } else if (context === 'delivery') {
      return {
        street: data.DeliveryStreet,
        houseNumber: data.DeliveryHouseNo,
        postalCode: data.DeliveryPostalCode,
        city: data.DeliveryCity,
        name: data.DeliveryName,
        countryName: data.DeliveryCountry || ''
      };
    } else if (context === 'database_dto') {
      return {
        street: data.street,
        houseNumber: data.houseNo,
        postalCode: data.postalCode,
        city: data.city,
        name: data.name || '',
        countryName: data.country || ''
      };
    } else if (context === 'here_suggestion') { // Kontekst dla specyficznej struktury HERE (jeśli jest inna)
      return {
        street: data.street,
        houseNumber: data.houseNumber,
        postalCode: data.postalCode,
        city: data.city,
        name: data.label, // HERE używa 'label'
        countryName: data.countryName
      };
    } else if (context === 'provider_suggestion') { // NOWY KONTEKST dla InternalAddressSuggestionDTO
      return {
        street: data.street,
        houseNumber: data.houseNumber,
        postalCode: data.postalCode,
        city: data.city,
        name: data.fullAddressLabel || data.name, // Użyj fullAddressLabel jako głównego opisu/nazwy
        countryName: data.countryName
      };
    }

    // Fallback, jeśli kontekst nie jest dokładnie dopasowany, ale próbujemy zgadnąć
    if (data.DeliveryStreet || data.PickUpStreet) {
        console.warn(`AddressDisplay: Próba zgadnięcia kontekstu 'delivery' dla: ${jsonString.substring(0,100)}...`);
        return parseAddressDataInternal(jsonString, 'delivery', errorObject);
    } else if (data.street && data.city && data.postalCode && data.fullAddressLabel) { // Heurystyka dla InternalAddressSuggestionDTO
        console.warn(`AddressDisplay: Próba zgadnięcia kontekstu 'provider_suggestion' dla: ${jsonString.substring(0,100)}...`);
        return parseAddressDataInternal(jsonString, 'provider_suggestion', errorObject);
    } else if (data.street && data.city && data.postalCode) { // Heurystyka dla DatabaseAddressDTO
        console.warn(`AddressDisplay: Próba zgadnięcia kontekstu 'database_dto' dla: ${jsonString.substring(0,100)}...`);
        return parseAddressDataInternal(jsonString, 'database_dto', errorObject);
    }

    console.error(`AddressDisplay: Nieznany lub nieobsługiwany kontekst '${context}' w parseAddressDataInternal.`, data);
    errorObject.value = `Nie można zinterpretować danych adresowych dla kontekstu: ${context}.`;
    return data; // Zwróć surowe dane, jeśli nie można zmapować

  } catch (e) {
    console.error(`AddressDisplay: Błąd parsowania JSON dla kontekstu '${context}':`, e, jsonString.substring(0,200));
    errorObject.value = `Niepoprawny format danych adresowych. Szczegóły: ${e.message}`;
    return null;
  }
};

const parsedAddress = computed(() => {
  parsingError.value = null;
  return parseAddressDataInternal(props.addressString, props.addressContext, parsingError);
});

const parsedCompareToAddress = computed(() => {
  if (!props.compareToAddressString) return null;
  const compareContext = (props.addressContext === 'pickup' || props.addressContext === 'delivery')
                           ? 'database_dto'
                           : props.addressContext;
  const tempError = ref(null);
  return parseAddressDataInternal(props.compareToAddressString, compareContext, tempError);
});

const hasAddressData = (addressObject) => {
  if (!addressObject) return false;
  return displayFields.some(field => {
    const value = addressObject[field.key];
    return value !== null && value !== undefined && String(value).trim() !== '';
  });
};

const containerClasses = computed(() => {
  switch(props.highlightAsSource) {
    case 'error': return 'bg-red-50 border border-red-200';
    case 'truth': return 'bg-green-50 border border-green-200';
    default: return 'bg-slate-50 border border-slate-200';
  }
});

const titleClasses = computed(() => {
  switch(props.highlightAsSource) {
    case 'error': return 'text-red-700';
    case 'truth': return 'text-green-700';
    default: return 'text-slate-700';
  }
});

const getFieldClass = (fieldKey, fieldValue) => {
  if (props.compareToAddressString && parsedCompareToAddress.value && parsedAddress.value) {
    const compareValue = parsedCompareToAddress.value[fieldKey];
    const originalValue = fieldValue;
    if (normalizeString(originalValue) !== normalizeString(compareValue)) {
      return 'text-red-600 font-semibold bg-red-100 px-1 rounded-sm';
    }
  }
  return 'text-slate-800';
};

watch(() => props.addressString, () => {
  parsingError.value = null;
});
</script>

================================================================================
### PLIK: components\ErrorDetailsModal.vue
================================================================================

<template>
  <div
    v-if="error"
    class="fixed inset-0 bg-black bg-opacity-50 backdrop-blur-sm overflow-y-auto h-full w-full flex items-center justify-center z-50 transition-opacity duration-300 ease-out px-4"
    @click.self="handleClose"
    role="dialog"
    aria-modal="true"
    :aria-labelledby="'modal-title-' + error.eventId"
  >
    <div class="relative w-full max-w-6xl mx-auto my-6 transform transition-all duration-300 ease-out">
      <div class="border-0 rounded-xl shadow-2xl relative flex flex-col w-full bg-white outline-none focus:outline-none max-h-[90vh]">
        <div class="flex items-start justify-between p-5 border-b border-solid border-slate-200 rounded-t-xl bg-slate-50">
          <h3 :id="'modal-title-' + error.eventId" class="text-xl lg:text-2xl font-semibold text-slate-700">
            Szczegóły Błędu: <span class="text-indigo-600">{{ error.eventId ? error.eventId.substring(0,12) : 'N/A' }}...</span>
          </h3>
          <button
            class="p-1 ml-auto bg-transparent border-0 text-slate-600 hover:text-slate-900 opacity-70 hover:opacity-100 text-2xl leading-none font-semibold outline-none focus:outline-none transition-colors"
            @click="handleClose"
            aria-label="Zamknij modal"
          >
            <span class="bg-transparent h-6 w-6 block outline-none focus:outline-none">×</span>
          </button>
        </div>

        <div class="relative p-6 flex-auto overflow-y-auto">
          <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-3 mb-6 text-sm">
            <div><strong class="text-slate-500 block">Request ID:</strong> <span class="text-slate-700 break-all">{{ error.requestID || 'N/A' }}</span></div>
            <div><strong class="text-slate-500 block">Barcode:</strong> <span class="text-slate-700">{{ error.barcode || 'N/A' }}</span></div>
            <div><strong class="text-slate-500 block">Source Topic:</strong> <span class="text-slate-700">{{ error.sourceTopic || 'N/A' }}</span></div>
            <div>
              <strong class="text-slate-500 block">Error Type:</strong>
              <span :class="getErrorTypeClass(error.errorType)" class="px-2.5 py-1 rounded-full text-xs font-bold inline-block leading-tight">{{ error.errorType || 'N/A' }}</span>
            </div>
            <div><strong class="text-slate-500 block">Address Verification Status:</strong> <span class="text-slate-700">{{ error.addressVerificationStatus || 'N/A' }}</span></div>
            <div><strong class="text-slate-500 block">Data Utworzenia Rekordu:</strong> <span class="text-slate-700">{{ formatDate(error.createdAt) }}</span></div>
            <div v-if="error.kafkaMessageTimestamp" class="md:col-span-1 lg:col-span-1">
                <strong class="text-slate-500 block">Czas Odebrania Wiadomości:</strong>
                <span class="text-slate-700">{{ formatDate(error.kafkaMessageTimestamp) }}</span>
            </div>
            <div><strong class="text-slate-500 block">Status Ponowienia:</strong> <span class="text-slate-700">{{ error.resubmissionStatus || 'N/A' }}</span></div>
          </div>

          <div v-if="error.errorMessage" class="mb-5 p-4 bg-red-50 border border-red-200 rounded-lg">
            <strong class="text-red-700 block mb-1.5 text-xs uppercase font-bold">Komunikat Błędu:</strong>
            <pre class="text-sm whitespace-pre-wrap text-red-600 p-2 rounded bg-red-100/50">{{ error.errorMessage }}</pre>
          </div>

          <div v-if="error.stacktrace" class="mb-5 p-4 bg-slate-50 border border-slate-200 rounded-lg">
            <strong class="text-slate-700 block mb-1.5 text-xs uppercase font-bold">Stacktrace:</strong>
            <pre class="text-xs whitespace-pre-wrap max-h-48 overflow-y-auto p-2 rounded bg-slate-100/80 font-mono">{{ error.stacktrace }}</pre>
          </div>
          <div v-if="isAddressErrorType(error.errorType)" class="mb-5 p-4 border-2 border-orange-300 rounded-lg bg-orange-50 shadow-sm">
            <h4 class="text-lg font-semibold text-orange-700 mb-4">Weryfikacja Adresu</h4>

            <div class="mb-4 p-3 bg-orange-100 border border-orange-200 rounded-md">
              <p class="text-sm font-medium text-orange-700">
                Problem dotyczy adresu:
                <span class="font-bold">{{ determineAddressContextTitle(error, 'order_relevant') }}</span>.
              </p>
              <div v-if="error.providerRawQuery" class="mt-2">
                <p class="text-xs text-slate-600 mb-1">
                    Zapytanie wysłane do dostawcy
                    <span v-if="providerNameFromSuggestionsOrQuery">
                        ({{ providerNameFromSuggestionsOrQuery }}):
                    </span>
                </p>
                <pre class="text-xs whitespace-pre-wrap p-2 rounded bg-slate-100 font-mono">{{ error.providerRawQuery }}</pre>
              </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-12 gap-6">
              <div class="lg:col-span-5 space-y-4">
                <AddressDisplay
                    :title="determineAddressContextTitle(error, 'order_relevant') + ' (Oryginalny ze zlecenia)'"
                    :address-string="error.originalAddressJson || error.rawPayload"
                    :address-context="determineAddressContextFromError(error, 'order_relevant')"
                    :compare-to-address-string="error.errorType === 'ADDRESS_ALIAS_MISMATCH_DB' ? error.dbAddressJson : null"
                    :highlight-as-source="error.errorType === 'ADDRESS_ALIAS_MISMATCH_DB' ? 'neutral' : 'error'"
                />
                <AddressDisplay
                    v-if="error.errorType === 'ADDRESS_ALIAS_MISMATCH_DB'"
                    title="Adres w Bazie Danych (oczekiwany dla aliasu)"
                    :address-string="error.dbAddressJson"
                    address-context="database_dto"
                    highlight-as-source="truth"
                />
                
                <div v-if="editableOrderData && activeAddressEditorContext" class="mt-4 p-4 border rounded-md bg-white shadow">
                  <h5 class="text-sm font-semibold mb-3 text-slate-700">
                    Uzupełnij / Popraw Dane Adresu {{ activeAddressEditorContext === 'pickup' ? 'Nadania' : 'Dostawy' }}:
                  </h5>
                  <div class="space-y-3">
                    <div v-for="field in (activeAddressEditorContext === 'pickup' ? addressFieldsDefinition.pickup : addressFieldsDefinition.delivery)" :key="field.modelKey">
                      <label :for="field.id" class="block text-xs font-medium text-slate-600 mb-0.5">{{ field.label }}:</label>
                      <input 
                        type="text" 
                        :id="field.id"
                        v-model="editableOrderData[field.modelKey]" 
                        class="text-xs p-2 border rounded-md w-full shadow-sm transition-colors"
                        :class="validationErrors[field.modelKey] ? 'border-red-500 focus:ring-red-500 focus:border-red-500 bg-red-50' : 'border-slate-300 focus:ring-indigo-500 focus:border-indigo-500'"
                        :placeholder="field.label"
                      />
                      <p v-if="validationErrors[field.modelKey]" class="text-xs text-red-600 mt-1">{{ validationErrors[field.modelKey] }}</p>
                    </div>
                  </div>
                </div>
              </div>

              <div class="lg:col-span-7">
                <div v-if="showSuggestions" class="mb-6">
                  <p class="text-orange-700 font-medium mb-2 text-sm">
                    Początkowe sugestie od dostawcy ({{ providerNameFromSuggestionsOrQuery }}):
                  </p>
                  <div class="space-y-3 max-h-60 overflow-y-auto pr-2">
                    <div
                      v-for="(suggestion, index) in error.suggestedAddresses"
                      :key="'initial-suggestion-' + error.eventId + '-' + index"
                      @click="selectSuggestion(suggestion, index, 'initial')"
                      class="p-1 rounded-lg hover:ring-2 hover:ring-indigo-500 focus:ring-indigo-500 focus:outline-none transition-all duration-150 ease-in-out cursor-pointer"
                      :class="selectedSuggestionIndex === index && lastSelectedSuggestionSource === 'initial' ? 'ring-2 ring-indigo-600 bg-indigo-50' : 'ring-1 ring-slate-300 hover:ring-slate-400'"
                      tabindex="0" @keypress.enter.space="selectSuggestion(suggestion, index, 'initial')">
                      <AddressDisplay
                        :title="'Sugestia ' + (suggestion.providerSource || 'Dostawcy') + ' ' + (index + 1)"
                        :address-string="JSON.stringify(suggestion)"
                        address-context="provider_suggestion"
                        :highlight-as-source="selectedSuggestionIndex === index && lastSelectedSuggestionSource === 'initial' ? 'truth' : 'neutral'"
                      />
                    </div>
                  </div>
                </div>

                <div v-if="activeAddressEditorContext && (isLoadingDynamicSuggestions || dynamicSuggestionsPolling.isLoading || dynamicSuggestions.length > 0 || dynamicSuggestionsPolling.error || dynamicSuggestionsError)">
                  <h5 class="text-sm font-semibold text-slate-700 mb-2 mt-4 border-t pt-3">
                    Dynamiczne Sugestie (na podstawie wprowadzanych danych):
                  </h5>
                  <div v-if="isLoadingDynamicSuggestions && !dynamicSuggestionsPolling.isLoading" class="text-xs text-slate-500 italic">Inicjowanie...</div>
                  <div v-if="dynamicSuggestionsPolling.isLoading" class="text-xs text-slate-500 italic flex items-center">
                     <span class="animate-spin h-3 w-3 mr-1 border-2 border-slate-400 border-t-transparent rounded-full"></span>
                    Ładowanie sugestii (ID: {{ dynamicSuggestionsPolling.correlationId?.substring(0,8) }})...
                  </div>
                  <div v-if="dynamicSuggestionsPolling.error || dynamicSuggestionsError" class="text-xs text-red-500 p-2 bg-red-50 rounded-md">
                    {{ dynamicSuggestionsPolling.error || dynamicSuggestionsError }}
                  </div>
                  
                  <div v-if="!isLoadingDynamicSuggestions && !dynamicSuggestionsPolling.isLoading && dynamicSuggestions.length > 0" class="space-y-3 max-h-60 overflow-y-auto pr-2">
                    <div
                      v-for="(suggestion, index) in dynamicSuggestions"
                      :key="'dyn-suggestion-' + index"
                      @click="selectSuggestion(suggestion, index, 'dynamic')"
                      class="p-1 rounded-lg hover:ring-2 hover:ring-teal-500 focus:ring-teal-500 focus:outline-none transition-all duration-150 ease-in-out cursor-pointer"
                      :class="selectedSuggestionIndex === index && lastSelectedSuggestionSource === 'dynamic' ? 'ring-2 ring-teal-600 bg-teal-50' : 'ring-1 ring-slate-300 hover:ring-slate-400'"
                      tabindex="0" @keypress.enter.space="selectSuggestion(suggestion, index, 'dynamic')">
                      <AddressDisplay
                        :title="'Dynamiczna Sugestia ' + (suggestion.providerSource || 'Dostawcy') + ' ' + (index + 1)"
                        :address-string="JSON.stringify(suggestion)"
                        address-context="provider_suggestion"
                        :highlight-as-source="selectedSuggestionIndex === index && lastSelectedSuggestionSource === 'dynamic' ? 'truth' : 'neutral'"
                      />
                    </div>
                  </div>
                   <div v-if="!isLoadingDynamicSuggestions && !dynamicSuggestionsPolling.isLoading && dynamicSuggestions.length === 0 && !dynamicSuggestionsPolling.error && !dynamicSuggestionsError && (editableOrderData && activeAddressEditorContext && (editableOrderData[activeAddressEditorContext === 'pickup' ? 'PickUpStreet' : 'DeliveryStreet'] || editableOrderData[activeAddressEditorContext === 'pickup' ? 'PickUpCity' : 'DeliveryCity']))" class="text-xs text-slate-500 italic mt-1">
                      Brak dynamicznych sugestii dla wprowadzonych danych.
                  </div>
                </div>
                <div v-if="showInvalidAddressMessage && !showSuggestions">
                    <p class="text-red-600 font-medium text-sm">
                        Adres nie został poprawnie zweryfikowany
                        <span v-if="providerNameFromSuggestionsOrQuery"> przez {{ providerNameFromSuggestionsOrQuery }}</span>
                        <span v-else> przez dostawcę</span>
                        i nie ma dostępnych sugestii lub wystąpił błąd usługi. Proszę ręcznie poprawić dane.
                    </p>
                     <p v-if="error.errorMessage && error.errorMessage.includes('java.lang.IllegalArgumentException')" class="text-xs text-red-500 mt-1">
                        Wskazówka: Błąd 'IllegalArgumentException' często oznacza problem z formatem danych wysyłanych do dostawcy (np. nieoczekiwane znaki).
                    </p>
                </div>
                <div v-if="error.errorType === 'ADDRESS_CUSTOMER_VERIFICATION_PENDING'" class="p-3 bg-yellow-100 text-yellow-700 rounded-md text-sm">
                    <p class="font-medium">Wysłano email do klienta z prośbą o weryfikację adresu. Oczekiwanie na odpowiedź.</p>
                </div>
              </div>
            </div>
          </div>

          <div>
            <label for="rawPayloadModal" class="block text-xs font-semibold text-slate-600 mb-1 uppercase">Raw Payload (JSON do edycji - oryginalne zlecenie):</label>
            <textarea
              id="rawPayloadModal"
              v-model="editablePayload"
              rows="10"
              class="mt-1 p-3 w-full border rounded-md shadow-sm sm:text-sm font-mono text-xs leading-relaxed focus:shadow-lg"
              :class="payloadJsonError ? 'border-red-500 focus:ring-red-500 focus:border-red-500 bg-red-50' : 'border-slate-300 focus:ring-indigo-500 focus:border-indigo-500'"
              placeholder="Edytuj JSON payload..."></textarea>
            <p v-if="payloadJsonError" class="text-xs text-red-600 mt-1">{{ payloadJsonError }}</p>
             <div v-if="validationErrors.general && !payloadJsonError" class="text-xs text-red-600 mt-1">
               {{ validationErrors.general }}
             </div>
          </div>
        </div>

        <div class="flex items-center justify-end p-5 border-t border-solid border-slate-200 rounded-b-xl bg-slate-50 space-x-3">
          <button
            @click="triggerSendVerificationEmail"
            v-if="canTriggerSendVerificationEmail(error.errorType)"
            :disabled="props.isEmailSending || !isPayloadValid"
            class="inline-flex items-center justify-center px-4 py-2 text-sm font-medium rounded-md shadow-sm text-white bg-gradient-to-r from-yellow-500 to-orange-500 hover:from-yellow-600 hover:to-orange-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-yellow-500 disabled:opacity-60 disabled:cursor-not-allowed transition-all duration-150 ease-in-out"
          >
            <span v-if="props.isEmailSending" class="animate-spin h-4 w-4 -ml-1 mr-2 border-2 border-white border-t-transparent rounded-full"></span>
            Wyślij Email do Klienta
          </button>
          <button
            @click="triggerResubmit"
            :disabled="props.isResubmitting || !isPayloadValid"
            class="inline-flex items-center justify-center px-4 py-2 text-sm font-medium rounded-md shadow-sm text-white bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 disabled:opacity-60 disabled:cursor-not-allowed transition-all duration-150 ease-in-out"
          >
            <span v-if="props.isResubmitting" class="animate-spin h-4 w-4 -ml-1 mr-2 border-2 border-white border-t-transparent rounded-full"></span>
            Zapisz i Prześlij Ponownie
          </button>
          <button
            @click="handleClose"
            class="px-4 py-2 text-sm font-medium rounded-md shadow-sm text-slate-700 bg-slate-200 hover:bg-slate-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-slate-400 transition-colors duration-150 ease-in-out"
          >
            Anuluj
          </button>
        </div>
        <div v-if="localResubmitMessage || localEmailSendMessage" class="px-5 pb-3 bg-slate-50 rounded-b-xl text-center">
            <p v-if="localResubmitMessage" :class="localResubmitMessageType === 'success' ? 'text-green-600' : 'text-red-600'" class="text-xs">{{ localResubmitMessage }}</p>
            <p v-if="localEmailSendMessage" :class="localEmailSendMessageType === 'success' ? 'text-green-600' : 'text-red-600'" class="text-xs mt-1">{{ localEmailSendMessage }}</p>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, watch, onMounted, onUnmounted, computed, nextTick } from 'vue';
import AddressDisplay from './AddressDisplay.vue';
import apiClient from '@/services/api.js';
import { debounce } from 'lodash-es';

const props = defineProps({
  error: { type: Object, required: true },
  isResubmitting: { type: Boolean, default: false },
  isEmailSending: { type: Boolean, default: false },
  resubmitMessage: String,
  resubmitMessageType: String,
  emailSendMessage: String,
  emailSendMessageType: String
});

const emit = defineEmits(['close', 'resubmit', 'send-verification-email']);

const editablePayload = ref('');
const originalPayloadForComparison = ref('');
const editableOrderData = ref(null);
const payloadJsonError = ref('');
const validationErrors = ref({});
const localResubmitMessage = ref('');
const localResubmitMessageType = ref('');
const localEmailSendMessage = ref('');
const localEmailSendMessageType = ref('');
const selectedSuggestionIndex = ref(null);
const lastSelectedSuggestionSource = ref(null);
const showAddressEditorAfterSuggestion = ref(false);

// --- ZMIENNE REAKTYWNE DLA DYNAMICZNYCH SUGESTII ---
const dynamicSuggestions = ref([]);
const isLoadingDynamicSuggestions = ref(false); // Główna flaga ładowania dla UI (debounce)
const dynamicSuggestionsError = ref('');       // Błąd wyświetlany użytkownikowi
const dynamicSuggestionsPolling = ref({        // Stan wewnętrzny dla logiki odpytywania
    correlationId: null,
    isActive: false, // Czy odpytywanie jest aktywne
    errorInternal: null, // Błędy specyficzne dla odpytywania
    intervalId: null
});

const REQUIRED_FIELDS_GENERAL = ['RequestID', 'Triggerdate', 'CustID', 'Barcode', 'PickUpDate', 'DeliveryType', 'Weight', 'Volume'];
const REQUIRED_FIELDS_PICKUP_ADDRESS = ['PickUpAlias', 'PickUpName', 'PickUpStreet', 'PickUpHouseNo', 'PickUpPostalCode', 'PickUpCity'];
const REQUIRED_FIELDS_DELIVERY_ADDRESS = ['DeliveryAlias', 'DeliveryName', 'DeliveryStreet', 'DeliveryHouseNo', 'DeliveryPostalCode', 'DeliveryCity'];

const addressFieldsDefinition = {
  pickup: [
    { label: 'Nazwa/Kontakt', modelKey: 'PickUpName', id: 'editPickUpName' },
    { label: 'Ulica', modelKey: 'PickUpStreet', id: 'editPickUpStreet' },
    { label: 'Nr domu', modelKey: 'PickUpHouseNo', id: 'editPickUpHouseNo' },
    { label: 'Kod pocztowy', modelKey: 'PickUpPostalCode', id: 'editPickUpPostalCode', validation: validatePostalCode },
    { label: 'Miasto', modelKey: 'PickUpCity', id: 'editPickUpCity' },
  ],
  delivery: [
    { label: 'Nazwa/Kontakt', modelKey: 'DeliveryName', id: 'editDeliveryName' },
    { label: 'Ulica', modelKey: 'DeliveryStreet', id: 'editDeliveryStreet' },
    { label: 'Nr domu', modelKey: 'DeliveryHouseNo', id: 'editDeliveryHouseNo' },
    { label: 'Kod pocztowy', modelKey: 'DeliveryPostalCode', id: 'editDeliveryPostalCode', validation: validatePostalCode },
    { label: 'Miasto', modelKey: 'DeliveryCity', id: 'editDeliveryCity' },
  ]
};

const isPayloadValid = computed(() => {
  return Object.keys(validationErrors.value).length === 0 && !payloadJsonError.value;
});

const activeAddressEditorContext = computed(() => {
    if (!editableOrderData.value || !props.error || !props.error.errorType) return null;
    const relevantContextOnError = determineAddressContextFromError(props.error, 'order_relevant');
    const requiredFieldsForContext = relevantContextOnError === 'pickup' ? REQUIRED_FIELDS_PICKUP_ADDRESS : REQUIRED_FIELDS_DELIVERY_ADDRESS;
    const hasRelevantValidationError = requiredFieldsForContext.some(fieldKey => !!validationErrors.value[fieldKey]);
    const errorTypeSuggestsEditorForContext =
        props.error.errorType === 'CONSTRAINT_VIOLATION' &&
        props.error.errorMessage &&
        ( (relevantContextOnError === 'pickup' && REQUIRED_FIELDS_PICKUP_ADDRESS.some(field => props.error.errorMessage.toLowerCase().includes(field.toLowerCase().replace("pickup","")))) ||
          (relevantContextOnError === 'delivery' && REQUIRED_FIELDS_DELIVERY_ADDRESS.some(field => props.error.errorMessage.toLowerCase().includes(field.toLowerCase().replace("delivery",""))))
        );
    const needsReviewDueToProviderError = [
        'ADDRESS_PROVIDER_NEEDS_REVIEW', 'ADDRESS_PROVIDER_INVALID', 'EXTERNAL_SERVICE_FAILURE'
    ].includes(props.error.errorType);

    if (showAddressEditorAfterSuggestion.value) return relevantContextOnError;
    if (errorTypeSuggestsEditorForContext && hasRelevantValidationError) return relevantContextOnError;
    if (needsReviewDueToProviderError) return relevantContextOnError;
    return null;
});

const showSuggestions = computed(() => {
  return props.error &&
         (props.error.errorType === 'ADDRESS_PROVIDER_NEEDS_REVIEW' ||
         (props.error.errorType === 'EXTERNAL_SERVICE_FAILURE' && props.error.addressVerificationStatus === 'NEEDS_REVIEW')) &&
         props.error.suggestedAddresses && props.error.suggestedAddresses.length > 0;
});

const showInvalidAddressMessage = computed(() => {
  return props.error &&
         (props.error.errorType === 'ADDRESS_PROVIDER_INVALID' ||
         (props.error.errorType === 'EXTERNAL_SERVICE_FAILURE' &&
          (!props.error.suggestedAddresses || props.error.suggestedAddresses.length === 0) &&
          (props.error.addressVerificationStatus === 'INVALID' || props.error.addressVerificationStatus === 'SERVICE_ERROR')));
});

const providerNameFromSuggestionsOrQuery = computed(() => {
  if (props.error?.suggestedAddresses?.length > 0 && props.error.suggestedAddresses[0].providerSource) {
    return props.error.suggestedAddresses[0].providerSource;
  }
  if (props.error?.providerRawQuery) {
    const queryLower = props.error.providerRawQuery.toLowerCase();
    if (queryLower.includes('nominatim')) return 'Nominatim';
    if (queryLower.includes('here')) return 'HERE Maps';
    if (queryLower.includes('google') || queryLower.includes('maps')) return 'Google Maps';
  }
  return null;
});

function validatePostalCode(value) {
  if (value && !/^\d{2}-\d{3}$/.test(String(value).trim())) {
    return "Niepoprawny format kodu pocztowego (oczekiwano XX-XXX).";
  }
  return null;
}

const determineAddressContextFromError = (error, baseContextType) => {
    if (!error) return 'delivery';
    if (baseContextType === 'database_dto') return 'database_dto';
    if (baseContextType === 'provider_suggestion') return 'provider_suggestion';
    let relevantContext = 'delivery';
    if (error.errorMessage) {
        const msgLower = error.errorMessage.toLowerCase();
        const pickupKeywords = ['pickup', 'nadania', 'nadawcy', 'pickuphouseno', 'pickuppostalcode', 'pickupcity', 'pickupname', 'pickupalias', 'pick up'];
        const deliveryKeywords = ['delivery', 'dostawy', 'odbiorcy', 'deliveryhouseno', 'deliverypostalcode', 'deliverycity', 'deliveryname', 'deliveryalias'];
        if (pickupKeywords.some(kw => msgLower.includes(kw))) relevantContext = 'pickup';
        else if (deliveryKeywords.some(kw => msgLower.includes(kw))) relevantContext = 'delivery';
    }
     if (error.errorType) {
        const typeUpper = error.errorType.toUpperCase();
        const pickupErrorTypes = ["PICKUP", "NADAWCY", "NADANIA"];
        const deliveryErrorTypes = ["DELIVERY", "ODBIORCY", "DOSTAWY"];
        if (pickupErrorTypes.some(pet => typeUpper.includes(pet))) relevantContext = 'pickup';
        else if (deliveryErrorTypes.some(det => typeUpper.includes(det))) relevantContext = 'delivery';
    }
    if (error.errorType === 'CONSTRAINT_VIOLATION' && error.errorMessage) {
        const msgLower = error.errorMessage.toLowerCase();
        const fieldViolationMatch = msgLower.match(/pole '([^']*)'/);
        if (fieldViolationMatch && fieldViolationMatch[1]) {
            const violatedField = fieldViolationMatch[1].toLowerCase();
            if (violatedField.startsWith('pickup')) relevantContext = 'pickup';
            else if (violatedField.startsWith('delivery')) relevantContext = 'delivery';
        }
    }
    if (baseContextType === 'order_relevant') return relevantContext;
    if (baseContextType === 'order_pickup') return 'pickup';
    if (baseContextType === 'order_delivery') return 'delivery';
    if (baseContextType === 'order') return relevantContext;
    return relevantContext;
};

const determineAddressContextTitle = (error, baseContextType) => {
    const context = determineAddressContextFromError(error, baseContextType);
    if (context === 'pickup') return "Adres Nadania";
    if (context === 'delivery') return "Adres Dostawy";
    return "Adres w Zleceniu";
};

const formatDate = (dateString) => {
  if (!dateString) return 'N/A';
  const date = new Date(dateString);
  return date.toLocaleString('pl-PL', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' });
};

const validateField = (data, fieldName, errorsObject, isRequired = true, customValidator = null) => {
  const value = data ? data[fieldName] : undefined;
  if (isRequired && (value === undefined || value === null || String(value).trim() === '')) {
    errorsObject[fieldName] = `Pole ${fieldName} jest wymagane.`;
    return false;
  }
  if (!isRequired && (value === undefined || value === null || String(value).trim() === '')) {
    delete errorsObject[fieldName];
    return true;
  }
  if (value && customValidator) {
    const errorMsg = customValidator(String(value));
    if (errorMsg) {
      errorsObject[fieldName] = errorMsg;
      return false;
    }
  }
  delete errorsObject[fieldName];
  return true;
};

const validateEditablePayload = () => {
  const errors = {};
  if (!editableOrderData.value) {
    errors.general = "Payload JSON jest pusty lub nie został poprawnie sparsowany. Nie można przeprowadzić walidacji pól.";
    validationErrors.value = errors;
    return;
  }
  const data = editableOrderData.value;
  REQUIRED_FIELDS_GENERAL.forEach(field => validateField(data, field, errors));
  REQUIRED_FIELDS_PICKUP_ADDRESS.forEach(field => {
    const fieldDef = addressFieldsDefinition.pickup.find(f => f.modelKey === field);
    validateField(data, field, errors, true, fieldDef?.validation);
  });
  REQUIRED_FIELDS_DELIVERY_ADDRESS.forEach(field => {
    const fieldDef = addressFieldsDefinition.delivery.find(f => f.modelKey === field);
    validateField(data, field, errors, true, fieldDef?.validation);
  });
  validationErrors.value = errors;
};

const clearDynamicSuggestionsPollingState = () => {
    if (dynamicSuggestionsPolling.value.intervalId) {
        clearInterval(dynamicSuggestionsPolling.value.intervalId);
    }
    dynamicSuggestionsPolling.value = { correlationId: null, isActive: false, errorInternal: null, intervalId: null };
};

const _pollDynamicSuggestions = async (correlationId) => {
    const MAX_POLLS = 15;
    const POLL_INTERVAL = 2000;
    let polls = 0;

    dynamicSuggestionsPolling.value.correlationId = correlationId;
    dynamicSuggestionsPolling.value.isActive = true;
    dynamicSuggestionsPolling.value.errorInternal = null;

    return new Promise((resolve, reject) => {
        dynamicSuggestionsPolling.value.intervalId = setInterval(async () => {
            polls++;
            if (!dynamicSuggestionsPolling.value.isActive || polls > MAX_POLLS) {
                if (polls > MAX_POLLS && dynamicSuggestionsPolling.value.isActive) {
                    dynamicSuggestionsPolling.value.errorInternal = `Timeout oczekiwania na dynamiczne sugestie (ID: ${correlationId?.substring(0,8)}).`;
                }
                clearDynamicSuggestionsPollingState();
                return reject(new Error(dynamicSuggestionsPolling.value.errorInternal || 'Polling anulowany lub przekroczono limit prób.'));
            }

            try {
                const res = await apiClient.get(`/api/admin/address-verification/operations/${correlationId}`);
                if (res.data && res.data.status === 'COMPLETED') {
                    clearDynamicSuggestionsPollingState();
                    resolve(res.data.result);
                } else if (res.data && res.data.status === 'FAILED') {
                    clearDynamicSuggestionsPollingState();
                    reject(new Error(res.data.errorDetails || 'Operacja pobierania sugestii nie powiodła się.'));
                }
                // Kontynuuj polling dla PENDING/PROCESSING
            } catch (pollError) {
                clearDynamicSuggestionsPollingState();
                reject(pollError.response?.data?.error || pollError.message || 'Błąd sieci podczas odpytywania o status sugestii.');
            }
        }, POLL_INTERVAL);
    });
};


const fetchDynamicSuggestionsInternal = async (addressDataForQuery) => {
  isLoadingDynamicSuggestions.value = true;
  dynamicSuggestions.value = [];
  dynamicSuggestionsError.value = 'Inicjowanie pobierania sugestii...';
  clearDynamicSuggestionsPollingState(); // Wyczyść poprzedni polling

  try {
    const queryParams = {
      street: String(addressDataForQuery.street || '').trim(),
      houseNumber: String(addressDataForQuery.houseNumber || '').trim(),
      city: String(addressDataForQuery.city || '').trim(),
      postalCode: String(addressDataForQuery.postalCode || '').trim(),
      country: 'Polska',
    };
    Object.keys(queryParams).forEach(key => { if (!queryParams[key]) delete queryParams[key]; });

    if (Object.keys(queryParams).length < 2 && !queryParams.street && !queryParams.city && !queryParams.postalCode) {
      dynamicSuggestionsError.value = 'Zbyt mało danych do wyszukania sugestii.';
      isLoadingDynamicSuggestions.value = false;
      return;
    }

    const initResponse = await apiClient.post('/api/admin/address-verification/suggest-on-demand', queryParams);
    const operationCorrelationId = initResponse.data.correlationId;

    if (!operationCorrelationId) {
      throw new Error("Nie otrzymano CorrelationID dla operacji dynamicznych sugestii.");
    }
    dynamicSuggestionsError.value = `Przetwarzanie dynamicznych sugestii (ID: ${operationCorrelationId.substring(0,8)})...`;

    const resultData = await _pollDynamicSuggestions(operationCorrelationId);

    if (resultData && typeof resultData.status === 'string' && Array.isArray(resultData.suggestions)) {
        const providerStatus = resultData.status.toUpperCase();
        if (providerStatus === 'SERVICE_ERROR' || providerStatus === 'INVALID') {
            dynamicSuggestions.value = resultData.suggestions.length > 0 ? resultData.suggestions : [];
            dynamicSuggestionsError.value = resultData.message || 'Dostawca zwrócił błąd lub brak wyników.';
        } else { // VALID lub NEEDS_REVIEW
            dynamicSuggestions.value = resultData.suggestions;
            dynamicSuggestionsError.value = (providerStatus === 'NEEDS_REVIEW' && resultData.message) ? `Uwaga od dostawcy: ${resultData.message}` : '';
        }
        if (dynamicSuggestions.value.length === 0 && !dynamicSuggestionsError.value) {
           dynamicSuggestionsError.value = 'Brak dynamicznych sugestii dla wprowadzonych danych.';
        }
    } else {
        dynamicSuggestions.value = [];
        dynamicSuggestionsError.value = 'Nieoczekiwany format wyniku dynamicznych sugestii.';
    }

  } catch (error) {
    console.error("Błąd podczas pobierania/przetwarzania dynamicznych sugestii:", error);
    dynamicSuggestionsError.value = error.message || 'Błąd serwera podczas pobierania dynamicznych sugestii.';
    dynamicSuggestions.value = [];
  } finally {
    isLoadingDynamicSuggestions.value = false;
    // Upewnij się, że isActive jest false jeśli nie było błędu krytycznego w pollDynamicSuggestions, który by to zrobił
    if (dynamicSuggestionsPolling.value.isActive && !dynamicSuggestionsPolling.value.errorInternal && !dynamicSuggestionsPolling.value.intervalId) {
        dynamicSuggestionsPolling.value.isActive = false;
    }
  }
};

const debouncedFetchDynamicSuggestions = debounce(fetchDynamicSuggestionsInternal, 850);

watch(() => props.resubmitMessage, (newVal) => localResubmitMessage.value = newVal, { immediate: true });
watch(() => props.resubmitMessageType, (newVal) => localResubmitMessageType.value = newVal, { immediate: true });
watch(() => props.emailSendMessage, (newVal) => localEmailSendMessage.value = newVal, { immediate: true });
watch(() => props.emailSendMessageType, (newVal) => localEmailSendMessageType.value = newVal, { immediate: true });

watch(() => props.error, (newError, oldError) => {
  const payloadSource = newError?.originalAddressJson || newError?.rawPayload || '';
  selectedSuggestionIndex.value = null;
  showAddressEditorAfterSuggestion.value = false;
  lastSelectedSuggestionSource.value = null;
  localResubmitMessage.value = '';
  localEmailSendMessage.value = '';
  dynamicSuggestions.value = [];
  dynamicSuggestionsError.value = '';
  clearDynamicSuggestionsPollingState();


  if (newError && (!oldError || newError.eventId !== oldError.eventId)) {
    validationErrors.value = {};
    if (payloadSource) {
      try {
        const parsed = JSON.parse(payloadSource);
        editableOrderData.value = { ...parsed };
        originalPayloadForComparison.value = JSON.stringify(parsed, null, 2);
        editablePayload.value = JSON.stringify(parsed, null, 2);
        payloadJsonError.value = '';
      } catch (e) {
        editablePayload.value = payloadSource;
        originalPayloadForComparison.value = payloadSource;
        editableOrderData.value = null;
        payloadJsonError.value = "Nie można sparsować początkowego payloadu JSON. Sprawdź jego poprawność.";
        validationErrors.value = { general: "Nie można sparsować początkowego payloadu JSON." };
      }
    } else {
      editablePayload.value = '';
      originalPayloadForComparison.value = '';
      editableOrderData.value = null;
      validationErrors.value = { general: "Brak payloadu do edycji." };
    }
    nextTick(() => {
        validateEditablePayload();
    });
  }
}, { immediate: true, deep: true });

watch(editablePayload, (newValue) => {
  if (!String(localResubmitMessage.value).startsWith("Wybrano sugestię")) {
    localResubmitMessage.value = '';
  }
  if (!newValue) {
    payloadJsonError.value = '';
    if (editableOrderData.value !== null) editableOrderData.value = null;
    validationErrors.value = { general: "Payload jest pusty." };
    return;
  }
  try {
    const parsedData = JSON.parse(newValue);
    payloadJsonError.value = '';
    if (newValue !== JSON.stringify(editableOrderData.value, null, 2)) {
      editableOrderData.value = parsedData;
    } else {
      validateEditablePayload();
    }
  } catch (e) {
    payloadJsonError.value = 'Niepoprawny format JSON. Popraw błędy w edytorze tekstowym.';
    validationErrors.value = { general: "Niepoprawny format JSON w edytorze tekstowym." };
  }
});

watch(editableOrderData, (newData, oldData) => {
  if (newData) {
    const newPayloadString = JSON.stringify(newData, null, 2);
    if (newPayloadString !== editablePayload.value) {
      editablePayload.value = newPayloadString;
    }
    validateEditablePayload();

    const context = activeAddressEditorContext.value;
    if (context && newData !== oldData) {
        const prefix = context === 'pickup' ? 'PickUp' : 'Delivery';
        const addressQueryData = {
            street: newData[`${prefix}Street`],
            houseNumber: newData[`${prefix}HouseNo`],
            city: newData[`${prefix}City`],
            postalCode: newData[`${prefix}PostalCode`],
        };
        if (String(addressQueryData.street||'').trim().length > 2 ||
            String(addressQueryData.city||'').trim().length > 2 ||
            String(addressQueryData.postalCode||'').trim().length >= 5) {
             debouncedFetchDynamicSuggestions(addressQueryData);
        } else {
            dynamicSuggestions.value = [];
            dynamicSuggestionsError.value = '';
            clearDynamicSuggestionsPollingState(); // Anuluj poprzednie odpytywanie jeśli dane zbyt krótkie
        }
    }
  } else if (editablePayload.value) {
    editablePayload.value = '';
  }
}, { deep: true });

onMounted(() => document.addEventListener('keydown', handleKeydown));
onUnmounted(() => {
    document.removeEventListener('keydown', handleKeydown);
    clearDynamicSuggestionsPollingState(); // Wyczyść przy odmontowaniu komponentu
});

const handleClose = () => {
  emit('close');
  selectedSuggestionIndex.value = null;
  lastSelectedSuggestionSource.value = null;
  showAddressEditorAfterSuggestion.value = false;
  dynamicSuggestions.value = [];
  dynamicSuggestionsError.value = '';
  clearDynamicSuggestionsPollingState();
};

const triggerResubmit = () => {
  validateEditablePayload();
  if (!isPayloadValid.value) {
    localResubmitMessage.value = "Formularz zlecenia zawiera błędy lub JSON jest niepoprawny. Popraw je przed wysłaniem.";
    localResubmitMessageType.value = 'error';
    return;
  }
  const hasPayloadChanged = editablePayload.value !== originalPayloadForComparison.value;
  if (hasPayloadChanged) {
    if (!confirm("Dane zlecenia zostały zmodyfikowane. Czy na pewno chcesz je zapisać i przesłać ponownie?")) {
      return;
    }
  } else {
    if (!confirm("Dane zlecenia nie zostały zmienione. Czy na pewno chcesz przesłać oryginalne zlecenie ponownie?")) {
      return;
    }
  }
  localResubmitMessage.value = '';
  localEmailSendMessage.value = '';
  emit('resubmit', {
    eventId: props.error.eventId,
    correctedRawPayload: editablePayload.value,
  });
};

const triggerSendVerificationEmail = () => {
  validateEditablePayload();
  if (props.error.errorType === 'ADDRESS_CUSTOMER_VERIFICATION_PENDING') {
      localEmailSendMessage.value = "Email weryfikacyjny został już prawdopodobnie wysłany. Sprawdź status.";
      localEmailSendMessageType.value = 'info';
      return;
  }
  if (!isPayloadValid.value) {
     localEmailSendMessage.value = "Payload JSON zlecenia zawiera błędy lub jest niepoprawny. Popraw go przed wysłaniem emaila do klienta.";
     localEmailSendMessageType.value = 'error';
     return;
  }
  localResubmitMessage.value = '';
  localEmailSendMessage.value = '';
  emit('send-verification-email', { eventId: props.error.eventId });
};

const selectSuggestion = (suggestion, index, source) => {
  selectedSuggestionIndex.value = index;
  lastSelectedSuggestionSource.value = source;
  if (!editableOrderData.value) {
    console.error("ErrorDetailsModal: editableOrderData jest null, nie można zaktualizować adresu na podstawie sugestii.");
    localResubmitMessage.value = "BŁĄD KRYTYCZNY: Brak danych zlecenia do aktualizacji.";
    localResubmitMessageType.value = 'error';
    return;
  }

  const orderDataCopy = { ...editableOrderData.value };
  const addressContext = determineAddressContextFromError(props.error, 'order_relevant');
  const prefix = addressContext === 'pickup' ? 'PickUp' : 'Delivery';

  orderDataCopy[`${prefix}Street`] = suggestion.street || '';
  orderDataCopy[`${prefix}HouseNo`] = suggestion.houseNumber || '';
  orderDataCopy[`${prefix}PostalCode`] = suggestion.postalCode || '';
  orderDataCopy[`${prefix}City`] = suggestion.city || '';

  editableOrderData.value = orderDataCopy;
  showAddressEditorAfterSuggestion.value = true;

  if (source === 'dynamic') {
    dynamicSuggestions.value = []; // Wyczyść dynamiczne sugestie po wyborze
    clearDynamicSuggestionsPollingState(); // Zatrzymaj odpytywanie
  }
  localResubmitMessage.value = `Wybrano ${lastSelectedSuggestionSource.value === 'initial' ? 'początkową' : 'dynamiczną'} sugestię. Pola adresu ${addressContext === 'pickup' ? 'nadania' : 'dostawy'} zostały zaktualizowane. Sprawdź i uzupełnij ewentualne braki, zwłaszcza Nazwę/Kontakt.`;
  localResubmitMessageType.value = 'info';
};

const handleKeydown = (event) => {
  if (event.key === 'Escape') handleClose();
};

const isAddressErrorType = (errorType) => {
  const types = [
    'ADDRESS_ALIAS_MISMATCH_DB', 'ADDRESS_PROVIDER_NEEDS_REVIEW', 'ADDRESS_PROVIDER_INVALID',
    'ADDRESS_CUSTOMER_VERIFICATION_PENDING', 'EXTERNAL_SERVICE_FAILURE', 'ADDRESS_DB_ERROR'
  ];
  if (errorType === 'CONSTRAINT_VIOLATION' && props.error && props.error.errorMessage) {
    const msg = props.error.errorMessage.toLowerCase();
    const addressKeywords = ['pickup', 'delivery', 'street', 'houseno', 'city', 'postalcode', 'alias',
                             'pickuphouseno', 'deliveryhouseno', 'pickuppostalcode', 'deliverypostalcode',
                             'pickupcity', 'deliverycity', 'pickupname', 'deliveryname'];
    if (addressKeywords.some(keyword => msg.includes(keyword.replace(/pickup|delivery/gi, '')))) {
      return true;
    }
  }
  return types.includes(errorType);
};

const canTriggerSendVerificationEmail = (errorType) => {
  return [
    'ADDRESS_ALIAS_MISMATCH_DB', 'ADDRESS_PROVIDER_NEEDS_REVIEW',
    'ADDRESS_PROVIDER_INVALID', 'EXTERNAL_SERVICE_FAILURE', 'CONSTRAINT_VIOLATION', 'ADDRESS_DB_ERROR'
  ].includes(errorType) && errorType !== 'ADDRESS_CUSTOMER_VERIFICATION_PENDING';
};

const getErrorTypeClass = (errorType) => {
    let base = 'px-2.5 py-1 rounded-full text-xs font-bold leading-tight inline-block ';
    if (errorType === 'CONSTRAINT_VIOLATION' && props.error && props.error.errorMessage) {
        const msg = props.error.errorMessage.toLowerCase();
        const addressKeywords = ['pickup', 'delivery', 'street', 'houseno', 'city', 'postalcode', 'alias', 'pickuphouseno', 'deliveryhouseno', 'pickuppostalcode', 'deliverypostalcode', 'pickupcity', 'deliverycity', 'pickupname', 'deliveryname'];
        if (addressKeywords.some(keyword => msg.includes(keyword.replace(/pickup|delivery/i, '')))) {
            return base + 'bg-orange-100 text-orange-600 border border-orange-200';
        }
        return base + 'bg-red-100 text-red-600 border border-red-200';
    }
    if (['ADDRESS_ALIAS_MISMATCH_DB', 'ADDRESS_PROVIDER_NEEDS_REVIEW', 'ADDRESS_PROVIDER_INVALID'].includes(errorType)) return base + 'bg-orange-100 text-orange-600 border border-orange-200';
    if (errorType === 'ADDRESS_CUSTOMER_VERIFICATION_PENDING') return base + 'bg-yellow-100 text-yellow-600 border border-yellow-200';
    if (['VALIDATION', 'DESERIALIZATION_ERROR'].includes(errorType)) return base + 'bg-red-100 text-red-600 border border-red-200';
    if (['PROCESSING', 'LISTENER_EXECUTION_FAILURE', 'EXTERNAL_SERVICE_FAILURE', 'ADDRESS_DB_ERROR'].includes(errorType)) return base + 'bg-purple-100 text-purple-600 border border-purple-200';
    return base + 'bg-slate-100 text-slate-600 border border-slate-200';
};
</script>

<style scoped>
/* Styl dla animacji ładowania, jeśli potrzebny gdzieś indziej */
.animate-spin {
  animation: spin 1s linear infinite;
}
@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
/* Można dodać dodatkowe style specyficzne dla modala, jeśli potrzebne */
</style>

================================================================================
### PLIK: components\Sidebar.vue
================================================================================

// Fragment z src/components/Sidebar.vue
<template>
  <aside
    class="fixed inset-y-0 left-0 z-50 flex flex-col bg-gradient-to-b from-slate-800 to-slate-900 text-slate-100 transition-transform duration-300 ease-in-out shadow-xl print:hidden"
    :class="isOpen ? 'translate-x-0 w-64' : '-translate-x-full w-64 lg:translate-x-0 lg:w-16'"
    aria-label="Sidebar"
  >
    <div 
      class="flex items-center h-16 px-4 border-b border-slate-700 shrink-0"
      :class="isOpen ? 'justify-between' : 'justify-center'"
    >
      <router-link to="/dashboard" class="text-xl font-bold text-white whitespace-nowrap" v-if="isOpen">
        Danxils Panel
      </router-link>
      <router-link to="/dashboard" class="text-white" v-else>
        <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 16v-2m0-10v2M6 12H4m16 0h-2m-10 0h2m4 4l2-2m-4-4l2-2m4 4l-2-2m-4-4l-2-2"></path></svg>
      </router-link>
      <button @click="$emit('toggle-sidebar')" class="text-slate-400 hover:text-white lg:hidden p-1 rounded-md focus:outline-none focus:ring-2 focus:ring-white" v-if="isOpen">
         <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
      </button>
    </div>

    <nav class="flex-1 space-y-1 px-2 py-4 overflow-y-auto">
      <SidebarLink to="/dashboard" icon-class="home" :is-open="isOpen">Dashboard</SidebarLink>

     <SidebarLink
        v-if="authStore.userHasRole('ADMIN')"
        to="/dashboard/rejected-requests" icon-class="exclamation-triangle"
        :is-open="isOpen"
      >
        Odrzucone Żądania
      </SidebarLink>

      <SidebarLink
        v-if="authStore.userHasRole('ADMIN')"
        to="/dashboard/admin/address-providers"
        icon-class="cog-6-tooth" :is-open="isOpen"
      >
        Dostawcy Adresów
      </SidebarLink>

      <SidebarLink
        to="/dashboard/order-statuses" icon-class="list-ul"
        :is-open="isOpen"
      >
        Statusy Zamówień
      </SidebarLink>

      <div class="pt-4 mt-4 space-y-1 border-t border-slate-700">
        <SidebarLink to="/dashboard/change-password" icon-class="key" :is-open="isOpen">Zmień Hasło</SidebarLink> <button
          @click="handleUserLogout"
          class="w-full flex items-center px-2 py-2.5 text-sm font-medium rounded-md text-slate-300 hover:bg-slate-700 hover:text-white group transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          :title="isOpen ? '' : 'Wyloguj'"
        >
          <component :is="getIcon('arrow-right-on-rectangle')" 
            class="flex-shrink-0 h-5 w-5 text-slate-400 group-hover:text-slate-300 transition-colors" 
            :class="isOpen ? 'mr-3' : 'mx-auto'"
            aria-hidden="true" />
          <span v-if="isOpen" class="truncate">Wyloguj</span>
        </button>
      </div>
    </nav>

    <div class="p-4 mt-auto border-t border-slate-700 shrink-0" v-if="isOpen">
      <p class="text-xs text-slate-400 text-center">&copy; {{ new Date().getFullYear() }}</p>
    </div>
  </aside>
</template>

<script setup>
import { defineAsyncComponent } from 'vue';
import { useAuthStore } from '@/stores/authStore';
import { useRouter } from 'vue-router';
import SidebarLink from '@/components/SidebarLink.vue'; // Upewnij się, że ścieżka jest poprawna

defineProps({
  isOpen: Boolean,
});
const emit = defineEmits(['toggle-sidebar']);

const authStore = useAuthStore();
const router = useRouter();

const handleUserLogout = () => { // Zmieniono nazwę z handleLogout
  authStore.logout();
  router.push('/login');
};

const getIcon = (iconName) => {
  const icons = {
    'home': () => import('@heroicons/vue/24/outline/HomeIcon'),
    'exclamation-triangle': () => import('@heroicons/vue/24/outline/ExclamationTriangleIcon'),
    'key': () => import('@heroicons/vue/24/outline/KeyIcon'),
    'arrow-right-on-rectangle': () => import('@heroicons/vue/24/outline/ArrowRightOnRectangleIcon'),
    'list-ul': () => import('@heroicons/vue/24/outline/ListBulletIcon'),
    'cog-6-tooth': () => import('@heroicons/vue/24/outline/Cog6ToothIcon'), // DODAJ NOWĄ IKONĘ
  };
  return defineAsyncComponent(icons[iconName] || icons['home']); //
};
</script>

<style scoped>
aside {
  scrollbar-width: thin;
  scrollbar-color: theme('colors.slate.600') theme('colors.slate.800');
  transition-property: width, transform; /* Dodaj transform do transition */
}
aside::-webkit-scrollbar {
  width: 6px;
}
aside::-webkit-scrollbar-track {
  background: theme('colors.slate.800');
}
aside::-webkit-scrollbar-thumb {
  background-color: theme('colors.slate.600');
  border-radius: 3px;
}
</style>

================================================================================
### PLIK: components\SidebarLink.vue
================================================================================

<template>
  <router-link
    :to="to"
    custom
    v-slot="{ href, navigate, isActive, isExactActive }"
  >
    <a
      :href="href"
      @click="navigate"
      class="flex items-center px-2 py-2.5 text-sm font-medium rounded-md group transition-colors"
      :class="[
        (isActive || isExactActive) ? 'bg-indigo-600 text-white shadow-lg' : 'text-slate-300 hover:bg-slate-700 hover:text-white',
        { 'justify-center': !isOpen }
      ]"
      :title="isOpen ? '' : $slots.default()[0].children"
    >
      <component
        :is="getIcon(iconClass)"
        class="flex-shrink-0 h-5 w-5 group-hover:text-white transition-colors"
        :class="[(isActive || isExactActive) ? 'text-white' : 'text-slate-400 group-hover:text-slate-300', isOpen ? 'mr-3' : 'mx-auto']"
        aria-hidden="true"
      />
      <span v-if="isOpen" class="truncate"><slot></slot></span>
    </a>
  </router-link>
</template>

<script setup>
import { defineAsyncComponent } from 'vue';

const props = defineProps({
  to: {
    type: [String, Object],
    required: true,
  },
  iconClass: {
    type: String,
    required: true,
  },
  isOpen: {
    type: Boolean,
    default: true,
  }
});

const getIcon = (iconName) => {
  const icons = {
    'home': () => import('@heroicons/vue/24/outline/HomeIcon'),
    'exclamation-triangle': () => import('@heroicons/vue/24/outline/ExclamationTriangleIcon'),
    'key': () => import('@heroicons/vue/24/outline/KeyIcon'),
    'list-ul': () => import('@heroicons/vue/24/outline/ListBulletIcon'),
  };
  return defineAsyncComponent(icons[iconName] || icons['home']);
};
</script>

================================================================================
### PLIK: components\forms\AddressCorrectionForm.vue
================================================================================

<template>
    <div>
        <h4 class="font-semibold text-md text-slate-700 mb-2">{{ title }}</h4>
        <div class="bg-white p-4 border border-slate-200 rounded-lg space-y-3">
            
            <div>
                <label class="block text-xs font-medium text-slate-600 mb-1">Nazwa Miejsca / Firmy (wyszukaj):</label>
                <input type="text" v-model="placeSearchQuery" @input="debouncedNameSearch"
                       placeholder="np. Stadion Narodowy, Galeria Młociny..."
                       class="p-2 w-full border border-slate-300 rounded-md shadow-sm text-sm" />
            </div>

            <div class="border-t border-slate-200 my-3"></div>

            <div>
                <label class="block text-xs font-medium text-slate-600 mb-1">Alias:</label>
                <input type="text" :value="addressData.alias" @input="updateField('alias', $event.target.value)"
                       class="p-2 w-full border border-slate-300 rounded-md shadow-sm text-sm" />
            </div>
            <div>
                <label class="block text-xs font-medium text-slate-600 mb-1">Ulica:</label>
                <input type="text" :value="addressData.street" @input="onInput('street', $event.target.value)"
                       class="p-2 w-full border border-slate-300 rounded-md shadow-sm text-sm" />
            </div>
            <div class="grid grid-cols-3 gap-3">
                <div>
                    <label class="block text-xs font-medium text-slate-600 mb-1">Nr domu:</label>
                    <input type="text" :value="addressData.houseNo" @input="onInput('houseNo', $event.target.value)"
                           class="p-2 w-full border border-slate-300 rounded-md shadow-sm text-sm" />
                </div>
                <div>
                    <label class="block text-xs font-medium text-slate-600 mb-1">Kod pocztowy:</label>
                    <input type="text" :value="addressData.postalCode" @input="onInput('postalCode', $event.target.value)"
                           class="p-2 w-full border border-slate-300 rounded-md shadow-sm text-sm" />
                </div>
                <div>
                    <label class="block text-xs font-medium text-slate-600 mb-1">Miasto:</label>
                    <input type="text" :value="addressData.city" @input="onInput('city', $event.target.value)"
                           class="p-2 w-full border border-slate-300 rounded-md shadow-sm text-sm" />
                </div>
            </div>
            <div v-if="isLoadingSuggestions" class="text-center text-sm text-slate-500 pt-2 flex items-center justify-center">
                <div class="animate-spin rounded-full h-4 w-4 border-t-2 border-b-2 border-indigo-500 mr-2"></div>
                <span>Szukanie sugestii...</span>
            </div>
            <div v-if="suggestions.length > 0" class="border-t pt-2 mt-2">
                 <ul class="border border-slate-200 rounded-lg bg-white max-h-32 overflow-y-auto">
                    <li v-for="(suggestion, index) in suggestions" :key="index" @click="selectDynamicSuggestion(suggestion)"
                        class="p-2 border-b last:border-b-0 text-xs text-slate-600 hover:bg-indigo-50 cursor-pointer transition-colors">
                        {{ suggestion.fullAddressLabel }}
                    </li>
                </ul>
            </div>
        </div>
    </div>
</template>

<script setup>
import { ref } from 'vue';
import { fetchOnDemandSuggestions, fetchByNameSearch } from '@/services/addressSuggestionService.js';

const props = defineProps({
    title: String,
    addressData: Object,
});

const emit = defineEmits(['update']);

const suggestions = ref([]);
const isLoadingSuggestions = ref(false);
const placeSearchQuery = ref('');
let debounceTimer = null;

const updateField = (field, value) => {
    emit('update', { ...props.addressData, [field]: value });
};

const onInput = (field, value) => {
    updateField(field, value);
    
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => {
        getDynamicSuggestionsByAddress();
    }, 600);
};

const getDynamicSuggestionsByAddress = async () => {
    const query = {
        street: props.addressData.street,
        houseNumber: props.addressData.houseNo,
        postalCode: props.addressData.postalCode,
        city: props.addressData.city,
        country: 'Polska'
    };
    if (Object.values(query).every(v => !v || v.trim() === '')) {
        suggestions.value = [];
        return;
    }
    isLoadingSuggestions.value = true;
    suggestions.value = await fetchOnDemandSuggestions(query);
    isLoadingSuggestions.value = false;
};

const getDynamicSuggestionsByName = async () => {
    isLoadingSuggestions.value = true;
    suggestions.value = await fetchByNameSearch(placeSearchQuery.value);
    isLoadingSuggestions.value = false;
};

const debouncedNameSearch = () => {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(getDynamicSuggestionsByName, 600);
};

const selectDynamicSuggestion = (suggestion) => {
    emit('update', {
        ...props.addressData,
        street: suggestion.street || '',
        houseNo: suggestion.houseNumber || '',
        postalCode: suggestion.postalCode || '',
        city: suggestion.city || '',
    });
    suggestions.value = [];
    placeSearchQuery.value = suggestion.fullAddressLabel;
};
</script>

================================================================================
### PLIK: components\modals\ErrorDetailsModal.vue
================================================================================

<template>
    <div class="fixed inset-0 bg-black bg-opacity-60 z-40 flex justify-center items-center" @click.self="emit('close')">
        <div v-if="isLoadingDetails" class="text-center text-white">
            <div class="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-white mx-auto"></div>
            <p class="mt-3">Ładowanie szczegółów błędu...</p>
        </div>
        <div v-else-if="error" class="bg-slate-50 rounded-2xl shadow-2xl w-full max-w-6xl max-h-[90vh] flex flex-col" @click.stop>
            <header class="p-5 border-b border-slate-200 flex justify-between items-center flex-shrink-0">
                <div>
                    <h2 class="text-xl font-bold text-slate-800">Szczegóły Błędu</h2>
                    <p class="text-xs text-slate-500 font-mono mt-1">Event ID: {{ error.eventId }}</p>
                </div>
                <button @click="emit('close')" class="p-2 rounded-full hover:bg-slate-200 transition-colors">
                    <svg class="w-6 h-6 text-slate-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
            </header>

            <main class="p-5 overflow-y-auto">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="font-semibold text-lg text-slate-700 mb-3 pb-2 border-b">Informacje o Błędzie</h3>
                        <div class="space-y-3 text-sm">
                            <p><strong class="text-slate-500 w-32 inline-block">Barcode:</strong> <span class="font-medium text-slate-800">{{ error.barcode }}</span></p>
                            <p><strong class="text-slate-500 w-32 inline-block">Typ Błędu:</strong> <span class="font-semibold text-red-600">{{ error.errorType }}</span></p>
                            <p><strong class="text-slate-500 w-32 inline-block">Status Weryf.:</strong> <span class="font-semibold text-orange-600">{{ error.addressVerificationStatus }}</span></p>
                            <p><strong class="text-slate-500 w-32 inline-block align-top">Wiadomość:</strong> <span class="text-slate-800">{{ error.errorMessage }}</span></p>
                        </div>
                        
                        <div v-if="error.suggestedAddresses && error.suggestedAddresses.length" class="mt-6">
                            <h4 class="font-semibold text-md text-slate-700 mb-2">Początkowe sugestie od dostawcy ({{ error.suggestedAddresses[0].providerSource }}):</h4>
                            <ul class="border border-slate-200 rounded-lg bg-white">
                                <li v-for="(suggestion, index) in error.suggestedAddresses" :key="index" @click="selectInitialSuggestion(suggestion)"
                                    class="p-3 border-b last:border-b-0 text-xs text-slate-600 hover:bg-indigo-50 cursor-pointer transition-colors">
                                    {{ suggestion.fullAddressLabel }} <span class="font-bold text-indigo-600">(Score: {{ (suggestion.matchScore || 0).toFixed(2) }})</span>
                                </li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="space-y-6">
                        <AddressCorrectionForm
                            title="Uzupełnij / Popraw Dane Adresu Nadania:"
                            :address-data="editablePickupAddress"
                            @update="handleFormUpdate('pickup', $event)"
                        />
                        <AddressCorrectionForm
                            title="Uzupełnij / Popraw Dane Adresu Dostawy:"
                            :address-data="editableDeliveryAddress"
                            @update="handleFormUpdate('delivery', $event)"
                        />
                    </div>
                </div>
            </main>

            <footer class="p-5 border-t border-slate-200 flex-shrink-0 bg-slate-100/70 rounded-b-2xl">
                 <div v-if="resubmitMessage" :class="resubmitMessageType === 'success' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'" class="p-3 rounded-lg text-sm mb-4 text-center">
                    {{ resubmitMessage }}
                </div>
                <div class="flex justify-between items-center">
                    <button @click="emit('close')" type="button" class="px-5 py-2.5 text-sm font-medium text-slate-700 bg-white border border-slate-300 rounded-lg hover:bg-slate-100 transition-colors">
                        Zamknij
                    </button>
                    <div class="flex items-center space-x-3">
                         <button v-if="isAddressError" @click="handleSendEmail" :disabled="isActionLoading"
                                class="px-5 py-2.5 text-sm font-medium text-amber-800 bg-amber-100 border border-amber-200 rounded-lg hover:bg-amber-200 transition-colors disabled:opacity-50 disabled:cursor-wait">
                            <span v-if="!isEmailSending">Wyślij Email Weryfikacyjny</span>
                            <span v-else>Wysyłanie...</span>
                        </button>
                        <button @click="handleResubmit" :disabled="isActionLoading"
                                class="px-5 py-2.5 text-sm font-medium text-white bg-indigo-600 rounded-lg hover:bg-indigo-700 transition-colors disabled:opacity-50 disabled:cursor-wait">
                            <span v-if="!isResubmitting">Prześlij Ponownie Poprawione Dane</span>
                            <span v-else>Przetwarzanie...</span>
                        </button>
                    </div>
                </div>
            </footer>
        </div>
    </div>
</template>

<script setup>
import { ref, onMounted, reactive, watch, computed } from 'vue';
import { useErrorStore } from '@/stores/errorStore';
import AddressCorrectionForm from '@/components/forms/AddressCorrectionForm.vue';

const props = defineProps({
  errorId: {
    type: Number,
    required: true,
  },
});

const emit = defineEmits(['close', 'order-resubmitted']);

const errorStore = useErrorStore();

const error = ref(null);
const isLoadingDetails = ref(true);

const isResubmitting = ref(false);
const isEmailSending = ref(false);
const resubmitMessage = ref('');
const resubmitMessageType = ref('');

const isActionLoading = computed(() => isResubmitting.value || isEmailSending.value);
const isAddressError = computed(() => error.value?.errorType?.includes('ADDRESS'));

const editablePickupAddress = reactive({ alias: '', street: '', houseNo: '', postalCode: '', city: '' });
const editableDeliveryAddress = reactive({ alias: '', street: '', houseNo: '', postalCode: '', city: '' });

const parseAndSetFormData = () => {
    if (!error.value || !error.value.originalAddressJson) return;
    try {
        const data = JSON.parse(error.value.originalAddressJson);
        Object.assign(editablePickupAddress, {
            alias: data.PickUpAlias || '',
            street: data.PickUpStreet || '',
            houseNo: data.PickUpHouseNo || '',
            postalCode: data.PickUpPostalCode || '',
            city: data.PickUpCity || '',
        });
        Object.assign(editableDeliveryAddress, {
            alias: data.DeliveryAlias || '',
            street: data.DeliveryStreet || '',
            houseNo: data.DeliveryHouseNo || '',
            postalCode: data.DeliveryPostalCode || '',
            city: data.DeliveryCity || '',
        });
    } catch (e) {
        console.error("Błąd parsowania originalAddressJson:", e);
        resubmitMessage.value = "Błąd odczytu oryginalnych danych zlecenia.";
        resubmitMessageType.value = "error";
    }
};

onMounted(async () => {
    isLoadingDetails.value = true;
    try {
        await errorStore.fetchErrorDetails(props.errorId);
        error.value = errorStore.selectedRequestDetails;
        parseAndSetFormData();
    } catch (e) {
        resubmitMessage.value = "Nie udało się załadować szczegółów błędu.";
        resubmitMessageType.value = "error";
    } finally {
        isLoadingDetails.value = false;
    }
});

const handleFormUpdate = (type, data) => {
    if (type === 'pickup') {
        Object.assign(editablePickupAddress, data);
    } else {
        Object.assign(editableDeliveryAddress, data);
    }
};

const selectInitialSuggestion = (suggestion) => {
    if (confirm(`Czy na pewno chcesz użyć adresu: "${suggestion.fullAddressLabel}"? Spowoduje to nadpisanie danych w formularzu.`)) {
        const targetForm = error.value.errorType.includes('PICKUP') ? editablePickupAddress : editableDeliveryAddress;
        targetForm.street = suggestion.street || '';
        targetForm.houseNo = suggestion.houseNumber || '';
        targetForm.postalCode = suggestion.postalCode || '';
        targetForm.city = suggestion.city || '';
    }
};

const handleResubmit = async () => {
    if (!error.value) return;
    isResubmitting.value = true;
    resubmitMessage.value = '';

    try {
        const originalData = JSON.parse(error.value.originalAddressJson);
        
        const correctedData = {
            ...originalData,
            PickUpAlias: editablePickupAddress.alias,
            PickUpStreet: editablePickupAddress.street,
            PickUpHouseNo: editablePickupAddress.houseNo,
            PickUpPostalCode: editablePickupAddress.postalCode,
            PickUpCity: editablePickupAddress.city,
            DeliveryAlias: editableDeliveryAddress.alias,
            DeliveryStreet: editableDeliveryAddress.street,
            DeliveryHouseNo: editableDeliveryAddress.houseNo,
            DeliveryPostalCode: editableDeliveryAddress.postalCode,
            DeliveryCity: editableDeliveryAddress.city,
            ResubmissionOverride: true,
        };

        const payload = {
            errorEventId: error.value.eventId,
            correctedRawPayload: JSON.stringify(correctedData)
        };
        
        const message = await errorStore.resubmitRequest(payload);
        resubmitMessage.value = message;
        resubmitMessageType.value = 'success';
        
        setTimeout(() => {
            emit('order-resubmitted');
        }, 2000);

    } catch (e) {
        console.error("Błąd podczas ponownego przesyłania:", e);
        resubmitMessage.value = e.message || "Wystąpił nieoczekiwany błąd.";
        resubmitMessageType.value = 'error';
    } finally {
        isResubmitting.value = false;
    }
};

const handleSendEmail = async () => {
    if (!error.value) return;
    isEmailSending.value = true;
    resubmitMessage.value = '';

    try {
        const message = await errorStore.sendVerificationEmailToCustomer(error.value.eventId);
        resubmitMessage.value = message;
        resubmitMessageType.value = 'success';
    } catch(e) {
        resubmitMessage.value = e.message || "Nie udało się wysłać emaila.";
        resubmitMessageType.value = 'error';
    } finally {
        isEmailSending.value = false;
    }
};
</script>

================================================================================
### PLIK: layouts\DashboardLayout.vue
================================================================================

<template>
  <div class="min-h-screen bg-slate-100 flex antialiased">
    <Sidebar :is-open="isSidebarEffectivelyOpen" @toggle-sidebar="toggleSidebarPreference" />

    <div
      class="flex-1 flex flex-col transition-all duration-300 ease-in-out"
      :style="{ 'margin-left': contentMarginLeft }"
    >
      <header class="bg-white shadow-sm sticky top-0 z-30 print:hidden">
        <div class="px-4 sm:px-6 lg:px-8">
          <div class="flex items-center justify-between h-16">
            <div class="flex items-center">
              <button
                @click="toggleSidebarPreference"
                class="text-slate-500 hover:text-slate-700 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500 p-2 -ml-2 rounded-md"
                aria-label="Toggle sidebar"
              >
                <svg class="h-6 w-6" stroke="currentColor" fill="none" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
                </svg>
              </button>
            </div>
            <div class="flex items-center">
              <span class="text-sm text-slate-700 mr-3 hidden sm:block">
                Witaj, {{ authStore.user?.username || 'Użytkowniku' }}
              </span>
              <button
                @click="performUserLogout"
                class="text-sm font-medium text-indigo-600 hover:text-indigo-500 p-2 rounded-md hover:bg-indigo-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
              >
                Wyloguj
              </button>
            </div>
          </div>
        </div>
      </header>

      <main class="flex-1 p-4 sm:p-6 lg:p-8">
        <router-view />
      </main>

      <footer class="bg-slate-100 text-center p-4 border-t border-slate-200 text-xs text-slate-500 print:hidden">
        &copy; {{ new Date().getFullYear() }} Danxils Enterprise System
      </footer>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted, computed } from 'vue';
import { useRouter } from 'vue-router';
import Sidebar from '@/components/Sidebar.vue';
import { useAuthStore } from '@/stores/authStore';

const authStore = useAuthStore();
const router = useRouter();

const screenWidth = ref(window.innerWidth);
const userPrefersSidebarOpen = ref(true); // Preferencja użytkownika (np. z localStorage)

const isLargeScreen = computed(() => screenWidth.value >= 1024); // lg breakpoint

const isSidebarEffectivelyOpen = computed(() => {
  // Na małych ekranach, sidebar jest mobilnym overlayem, jego "otwarcie" jest kontrolowane przez userPrefersSidebarOpen
  // Na dużych ekranach, sidebar jest zawsze "obecny" (albo szeroki albo wąski), kontrolowany przez userPrefersSidebarOpen
  return userPrefersSidebarOpen.value;
});

const sidebarCollapsedWidth = '4rem'; // 64px (w-16)
const sidebarExpandedWidth = '16rem'; // 256px (w-64)

const contentMarginLeft = computed(() => {
  if (isLargeScreen.value) {
    // Na dużych ekranach, content ma margines w zależności od stanu sidebara
    return userPrefersSidebarOpen.value ? sidebarExpandedWidth : sidebarCollapsedWidth;
  }
  // Na małych ekranach, sidebar jest nakładką (fixed, absolute), więc content nie potrzebuje marginesu
  return '0px';
});

const toggleSidebarPreference = () => {
  userPrefersSidebarOpen.value = !userPrefersSidebarOpen.value;
  if (isLargeScreen.value) {
    localStorage.setItem('sidebarUserPrefersOpen', JSON.stringify(userPrefersSidebarOpen.value));
  }
};

const performUserLogout = () => {
  authStore.logout();
  router.push('/login');
};

const updateScreenWidth = () => {
  screenWidth.value = window.innerWidth;
  // Dostosuj domyślny stan sidebara przy zmianie rozmiaru ekranu, jeśli preferencja nie była ustawiona
  if (localStorage.getItem('sidebarUserPrefersOpen') === null) {
    if (isLargeScreen.value) {
      userPrefersSidebarOpen.value = true; // Domyślnie otwarty na dużych
    } else {
      userPrefersSidebarOpen.value = false; // Domyślnie zamknięty na małych
    }
  }
};

onMounted(() => {
  const storedPreference = localStorage.getItem('sidebarUserPrefersOpen');
  if (storedPreference !== null) {
    userPrefersSidebarOpen.value = JSON.parse(storedPreference);
  } else {
    // Ustaw domyślny stan na podstawie początkowej szerokości ekranu
    userPrefersSidebarOpen.value = isLargeScreen.value;
  }
  window.addEventListener('resize', updateScreenWidth);
});

onUnmounted(() => {
  window.removeEventListener('resize', updateScreenWidth);
});
</script>

<style scoped>
.flex-1 {
  transition: margin-left 0.25s ease-in-out;
}
</style>

================================================================================
### PLIK: router\index.js
================================================================================

// src/router/index.js

import { createRouter, createWebHistory } from 'vue-router';
import DashboardLayout from '@/layouts/DashboardLayout.vue';
import { useAuthStore } from '@/stores/authStore';

const routes = [
    // --- POCZĄTEK POPRAWKI ---
    // Przekierowanie ze strony głównej prosto do panelu
    { path: '/', redirect: '/dashboard' }, 
    
    // "Pułapka" na błędne przekierowanie - jeśli cokolwiek przekieruje na /websites_Overview,
    // zostanie to natychmiast naprawione i przekierowane do /dashboard
    { path: '/websites_Overview', redirect: '/dashboard' },
    // --- KONIEC POPRAWKI ---

    { path: '/login', name: 'login', component: () => import('@/views/LoginView.vue') },
    // Usunęliśmy starą ścieżkę dla '/', ponieważ teraz jest to przekierowanie

    {
      path: '/dashboard',
      component: DashboardLayout,
      meta: { requiresAuth: true },
      children: [
        { path: '', name: 'dashboard', component: () => import('@/views/DashboardView.vue') },
        { path: 'change-password', name: 'changePassword', component: () => import('@/views/ChangePasswordView.vue') },
        {
          path: 'rejected-requests',
          name: 'rejectedRequests',
          component: () => import('@/views/RejectedRequestsView.vue'),
          meta: { roles: ['ADMIN'] }
        },
        {
          path: 'order-statuses',
          name: 'orderStatuses',
          component: () => import('@/views/OrderStatusView.vue'),
          meta: { requiresAuth: true }
        },
        {
          path: 'admin/address-providers',
          name: 'adminAddressProviders',
          component: () => import('@/views/admin/AddressProvidersView.vue'),
          meta: { roles: ['ADMIN'] }
        }
      ]
    },
    { path: '/:pathMatch(.*)*', name: 'NotFound', component: () => import('@/views/NotFoundView.vue') }
];

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes
});

// Reszta pliku bez zmian...
router.beforeEach(async (to, from, next) => {
    const authStore = useAuthStore();
    const requiresAuth = to.matched.some(record => record.meta.requiresAuth);
    const requiredRoles = to.matched.find(record => record.meta.roles)?.meta.roles;

    if (requiresAuth && !authStore.isLoggedIn) {
        next({ name: 'login', query: { redirect: to.fullPath } });
    } else if (to.name === 'login' && authStore.isLoggedIn) {
        next({ name: 'dashboard' });
    } else if (requiresAuth && requiredRoles && !requiredRoles.some(role => authStore.userHasRole(role))) {
        console.warn(`User ${authStore.user?.username} does not have required roles: ${requiredRoles} for route ${to.name}`);
        next({ name: 'dashboard' });
    } else {
        next();
    }
});

export default router;

================================================================================
### PLIK: services\addressSuggestionService.js
================================================================================

import apiClient from '@/services/api.js';

const pollForResults = async (correlationId) => {
  const maxRetries = 10;
  const interval = 2000;

  for (let i = 0; i < maxRetries; i++) {
    await new Promise(resolve => setTimeout(resolve, interval));
    
    const statusResponse = await apiClient.get(`/api/admin/address-verification/operations/${correlationId}`);
    const operation = statusResponse.data;

    if (operation.status === 'COMPLETED') {
      return operation.result?.suggestions || [];
    }
    if (operation.status === 'FAILED') {
      throw new Error(operation.errorDetails || 'Operacja wyszukiwania sugestii nie powiodła się.');
    }
  }
  throw new Error('Przekroczono czas oczekiwania na sugestie adresowe.');
};

export const fetchOnDemandSuggestions = async (addressQuery) => {
  if (!addressQuery || Object.values(addressQuery).every(v => !v)) {
    return [];
  }
  
  try {
    const initiateResponse = await apiClient.post('/api/admin/address-verification/suggest-on-demand', addressQuery);
    const correlationId = initiateResponse.data.correlationId;
    if (!correlationId) {
        throw new Error("API nie zwróciło correlationId dla operacji sugestii.");
    }
    return await pollForResults(correlationId);
  } catch (error) {
    console.error('Błąd podczas pobierania dynamicznych sugestii:', error);
    return [];
  }
};

export const fetchByNameSearch = async (searchQuery) => {
  if (!searchQuery || searchQuery.trim() === '') {
    return [];
  }
  
  try {
    const initiateResponse = await apiClient.post('/api/admin/address-verification/search-by-name', searchQuery, {
        headers: { 'Content-Type': 'text/plain' }
    });
    const correlationId = initiateResponse.data.correlationId;
    if (!correlationId) {
        throw new Error("API nie zwróciło correlationId dla operacji wyszukiwania.");
    }
    return await pollForResults(correlationId);
  } catch (error) {
    console.error('Błąd podczas wyszukiwania po nazwie:', error);
    return [];
  }
};

================================================================================
### PLIK: services\api.js
================================================================================

// src/services/api.js
import axios from 'axios';

const apiClient = axios.create({
  baseURL: 'https://api.danxils.com',
  headers: {
    'Content-Type': 'application/json',
  },
});

apiClient.interceptors.request.use(
  async (config) => {
    try {
      const { useAuthStore } = await import('@/stores/authStore');
      const authStore = useAuthStore();
      const token = authStore.accessToken;
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
    } catch (e) {
      console.error('Error dynamically importing authStore in request interceptor:', e);
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;
    try {
      const { useAuthStore } = await import('@/stores/authStore');
      const authStore = useAuthStore();

      if (error.response && error.response.status === 401 && !originalRequest._retry) {
        originalRequest._retry = true;
        try {
          const newAccessToken = await authStore.refreshTokenAction();
          originalRequest.headers.Authorization = `Bearer ${newAccessToken}`;
          return apiClient(originalRequest);
        } catch (refreshError) {
          return Promise.reject(refreshError);
        }
      }
    } catch (e) {
      console.error('Error dynamically importing authStore in response interceptor:', e);
    }
    return Promise.reject(error);
  }
);

export default apiClient;

================================================================================
### PLIK: stores\authStore.js
================================================================================

// Plik: src/stores/authStore.js
import { defineStore } from 'pinia';
import apiClient from '@/services/api.js';
import router from '@/router'; // ZAIMPORTUJ ROUTER

export const useAuthStore = defineStore('auth', {
  // ... state, getters ...
  state: () => ({
    accessToken: localStorage.getItem('accessToken') || null,
    refreshToken: localStorage.getItem('refreshToken') || null,
    user: JSON.parse(localStorage.getItem('user')) || { username: null, roles: [] },
  }),
  getters: {
    isLoggedIn: (state) => !!state.accessToken,
    userRoles: (state) => {
      return state.user && Array.isArray(state.user.roles) ? state.user.roles : [];
    },
    isAdmin: (state) => { // Zmieniono z userHasRole('ADMIN') na bezpośrednie sprawdzenie
      return state.user && Array.isArray(state.user.roles) && state.user.roles.includes('ADMIN');
    },
  },
  actions: {
    // ... (login, refreshTokenAction, changePassword - jak w VUE.txt, ale bez this.router)

    logoutSilently() {
      this.accessToken = null;
      this.refreshToken = null;
      this.user = { username: null, roles: [] };
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
      localStorage.removeItem('user');
      delete apiClient.defaults.headers.common['Authorization'];
    },
    logout() {
      this.logoutSilently();
      router.push('/login'); // UŻYJ ZAIMPORTOWANEGO ROUTERA
    },
    // ... (reszta akcji - login, refreshTokenAction, changePassword, userHasRole)
    // Skopiujmy je z poprzedniej poprawionej wersji errorStore.js dla kompletności
    async login(credentials) {
      try {
        const response = await apiClient.post('/auth/login', credentials);
        if (response.data && response.data.accessToken) {
          const { accessToken, refreshToken, username, roles } = response.data;
          this.accessToken = accessToken;
          this.refreshToken = refreshToken;
          this.user = {
            username: username || credentials.username,
            roles: Array.isArray(roles) ? roles : []
          };
          localStorage.setItem('accessToken', accessToken);
          localStorage.setItem('refreshToken', refreshToken);
          localStorage.setItem('user', JSON.stringify(this.user));
          apiClient.defaults.headers.common['Authorization'] = `Bearer ${accessToken}`;
          return Promise.resolve(response.data);
        } else {
          throw new Error('Odpowiedź API nie zawiera tokenu dostępu.');
        }
      } catch (error) {
        console.error('Błąd logowania w authStore:', error.response?.data || error.message);
        this.logoutSilently(); // Wyloguj po błędzie
        let errorMessage = 'Nie udało się zalogować.';
        if (error.response && error.response.data) {
            if (typeof error.response.data === 'string') errorMessage = error.response.data;
            else if (error.response.data.message) errorMessage = error.response.data.message;
            else if (error.response.data.error) errorMessage = error.response.data.error;
        } else if (error.message) {
            errorMessage = error.message;
        }
        throw new Error(errorMessage);
      }
    },
    async refreshTokenAction() {
      if (!this.refreshToken) {
        this.logout(); // Tutaj wywołanie this.logout() jest OK, bo ono użyje zaimportowanego routera
        return Promise.reject(new Error('Brak refresh tokenu. Wymagane ponowne logowanie.'));
      }
      try {
        const response = await apiClient.post('/auth/refresh', { refreshToken: this.refreshToken });
        if (response.data && response.data.accessToken) {
          const { accessToken, username, roles } = response.data; // Zakładamy, że refresh też zwraca username i roles
          this.accessToken = accessToken;
          localStorage.setItem('accessToken', accessToken);
          apiClient.defaults.headers.common['Authorization'] = `Bearer ${accessToken}`;
           if (username && roles) { // Aktualizuj dane użytkownika, jeśli są w odpowiedzi
            this.user = { username, roles: Array.isArray(roles) ? roles : [] };
            localStorage.setItem('user', JSON.stringify(this.user));
          }
          return Promise.resolve(accessToken);
        } else {
          throw new Error('Odpowiedź API odświeżania nie zawiera nowego tokenu dostępu.');
        }
      } catch (error) {
        console.error('Błąd odświeżania tokenu:', error.response?.data || error.message);
        this.logout(); // Tutaj też OK
        throw new Error('Sesja wygasła lub refresh token jest nieprawidłowy. Proszę zalogować się ponownie.');
      }
    },
    async changePassword(payload) {
      if (!this.isLoggedIn) {
        throw new Error("Użytkownik nie jest zalogowany.");
      }
      try {
        const requestBody = {
          oldPassword: payload.oldPassword,
          newPassword: payload.newPassword,
          confirmNewPassword: payload.confirmNewPassword
        };
        const response = await apiClient.post('/auth/change-password', requestBody);
        return Promise.resolve(response.data);
      } catch (error) {
        console.error('Błąd podczas zmiany hasła w authStore:', error.response?.data || error.message);
        let errorMessage = 'Nie udało się zmienić hasła.';
         if (error.response && error.response.data) {
            if (typeof error.response.data === 'string') errorMessage = error.response.data;
            else if (error.response.data.message) errorMessage = error.response.data.message;
            else if (Array.isArray(error.response.data.details) && error.response.data.details.length > 0) errorMessage = error.response.data.details.join(' ');
            else if (error.response.data.error) errorMessage = error.response.data.error;
        } else if (error.message) {
            errorMessage = error.message;
        }
        throw new Error(errorMessage);
      }
    },
    userHasRole(roleName) {
      if (this.user && Array.isArray(this.user.roles)) {
        return this.user.roles.some(role => role.toUpperCase() === roleName.toUpperCase());
      }
      return false;
    }
  },
});

================================================================================
### PLIK: stores\errorStore.js
================================================================================

import { defineStore } from 'pinia'
import apiClient from '@/services/api.js';

export const useErrorStore = defineStore('error', {
  state: () => ({
    rejectedRequests: [],
    selectedRequestDetails: null,
    isLoading: false,
    pagination: {
      currentPage: 0,
      totalPages: 0,
      totalElements: 0,
      size: 15,
    },
    filters: {
      errorType: '',
      barcode: '',
      dateFrom: '',
      dateTo: '',
    },
    sort: {
      field: 'createdAt',
      direction: 'DESC',
    }
  }),
  actions: {
    async fetchRejectedRequests(page = this.pagination.currentPage, size = this.pagination.size) {
      this.isLoading = true;
      try {
        const params = new URLSearchParams();
        params.append('page', page);
        params.append('size', size);
        params.append('sort', `${this.sort.field},${this.sort.direction}`);

        if (this.filters.errorType) params.append('errorType', this.filters.errorType);
        if (this.filters.barcode) params.append('barcode', this.filters.barcode);
        if (this.filters.dateFrom) params.append('dateFrom', this.filters.dateFrom);
        if (this.filters.dateTo) params.append('dateTo', this.filters.dateTo);

        const response = await apiClient.get(`/processing-errors?${params.toString()}`);
        if (response.data && response.data.content) {
            if (page === 0) {
                this.rejectedRequests = response.data.content;
            } else {
                this.rejectedRequests = [...this.rejectedRequests, ...response.data.content];
            }
            this.pagination.currentPage = response.data.number;
            this.pagination.totalPages = response.data.totalPages;
            this.pagination.totalElements = response.data.totalElements;
            this.pagination.size = response.data.size;
        } else {
            this.rejectedRequests = [];
            this.pagination = { currentPage: 0, totalPages: 0, totalElements: 0, size: this.pagination.size };
        }
      } catch (error) {
        console.error('Błąd podczas pobierania odrzuconych żądań:', error.response?.data || error.message);
        this.rejectedRequests = [];
        this.pagination = { currentPage: 0, totalPages: 0, totalElements: 0, size: this.pagination.size };
      } finally {
        this.isLoading = false;
      }
    },

    async fetchErrorDetails(errorId) {
      this.isLoading = true;
      this.selectedRequestDetails = null;
      try {
        const response = await apiClient.get(`/processing-errors/${errorId}`);
        this.selectedRequestDetails = response.data;
      } catch (error) {
        console.error(`Błąd podczas pobierania szczegółów błędu ${errorId}:`, error.response?.data || error.message);
        throw error;
      } finally {
        this.isLoading = false;
      }
    },

    async resubmitRequest(payload) {
      this.isLoading = true;
      try {
        const response = await apiClient.post('/processing-errors/resubmit', payload);
        await this.fetchRejectedRequests(this.pagination.currentPage, this.pagination.size);
        return Promise.resolve(response.data?.message || "Żądanie zostało pomyślnie przesłane ponownie.");
      } catch (error) {
        console.error('Błąd podczas ponownego przesyłania żądania:', error.response?.data || error.message);
        throw new Error(error.response?.data?.message || error.response?.data || 'Nie udało się ponownie przesłać żądania.');
      } finally {
        this.isLoading = false;
      }
    },

    async sendVerificationEmailToCustomer(errorEventId) {
        if (!errorEventId) {
            throw new Error("EventID błędu jest wymagany do wysłania emaila.");
        }
        this.isLoading = true;
        try {
            const response = await apiClient.post(`/admin/address-verification/error/${errorEventId}/send-verification-email`);
            await this.fetchRejectedRequests(this.pagination.currentPage);
            if (this.selectedRequestDetails && this.selectedRequestDetails.eventId === errorEventId) {
            }
            return Promise.resolve(response.data?.message || "Proces wysyłania emaila weryfikacyjnego został zainicjowany.");
        } catch (error) {
            console.error(`Błąd podczas inicjowania wysyłki emaila weryfikacyjnego dla błędu ${errorEventId}:`, error.response?.data || error.message);
            const errorMessage = error.response?.data?.message || error.response?.data || 'Nie udało się zainicjować wysyłki emaila weryfikacyjnego.';
            throw new Error(errorMessage);
        } finally {
            this.isLoading = false;
        }
    },

    setFilter(filterName, value) {
      if (this.filters.hasOwnProperty(filterName)) {
        this.filters[filterName] = value;
        this.fetchRejectedRequests(0);
      }
    },
    setSort(field, direction) {
      this.sort.field = field;
      this.sort.direction = direction;
      this.fetchRejectedRequests(0);
    }
  }
})

================================================================================
### PLIK: views\ChangePasswordView.vue
================================================================================

<template>
  <div class="flex items-center justify-center min-h-[calc(100vh-200px)]">
    <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-md">
      <h2 class="text-3xl font-bold text-center text-indigo-600 mb-8">Zmień Hasło</h2>
      <form @submit.prevent="handleChangePassword">
        <div v-if="message" :class="messageType === 'success' ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'" class="mb-4 p-3 rounded text-sm">
          {{ message }}
        </div>

        <div class="mb-6">
          <label for="oldPassword" class="block text-sm font-medium text-gray-700 mb-1">Stare Hasło</label>
          <input
            type="password"
            id="oldPassword"
            v-model="oldPassword"
            required
            class="mt-1 block w-full px-4 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
            placeholder="••••••••"
          />
        </div>

        <div class="mb-6">
          <label for="newPassword" class="block text-sm font-medium text-gray-700 mb-1">Nowe Hasło</label>
          <input
            type="password"
            id="newPassword"
            v-model="newPassword"
            required
            minlength="8"
            class="mt-1 block w-full px-4 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
            placeholder="Minimum 8 znaków"
          />
        </div>

        <div class="mb-6">
          <label for="confirmNewPassword" class="block text-sm font-medium text-gray-700 mb-1">Potwierdź Nowe Hasło</label>
          <input
            type="password"
            id="confirmNewPassword"
            v-model="confirmNewPassword"
            required
            class="mt-1 block w-full px-4 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
            placeholder="••••••••"
          />
        </div>

        <div>
          <button
            type="submit"
            :disabled="isLoading"
            class="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
          >
            <span v-if="isLoading" class="animate-spin mr-2">⏳</span>
            Zmień Hasło
          </button>
        </div>
      </form>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import { useRouter } from 'vue-router';
import { useAuthStore } from '@/stores/authStore';

const oldPassword = ref('');
const newPassword = ref('');
const confirmNewPassword = ref('');

const authStore = useAuthStore();
const router = useRouter();
const isLoading = ref(false);
const message = ref('');
const messageType = ref('');

const handleChangePassword = async () => {
  message.value = '';
  messageType.value = '';

  if (newPassword.value !== confirmNewPassword.value) {
    message.value = 'Nowe hasła nie są identyczne.';
    messageType.value = 'error';
    return;
  }

  if (newPassword.value.length < 8) {
    message.value = 'Nowe hasło musi mieć co najmniej 8 znaków.';
    messageType.value = 'error';
    return;
  }

  isLoading.value = true;
  try {
    await authStore.changePassword({
      oldPassword: oldPassword.value,
      newPassword: newPassword.value,
      confirmNewPassword: confirmNewPassword.value
    });
    message.value = 'Hasło zostało pomyślnie zmienione. Zostaniesz wylogowany.';
    messageType.value = 'success';
    oldPassword.value = '';
    newPassword.value = '';
    confirmNewPassword.value = '';
    setTimeout(() => {
      authStore.logout();
      router.push('/login');
    }, 3000);
  } catch (error) {
    message.value = error.message || 'Nie udało się zmienić hasła. Spróbuj ponownie.';
    messageType.value = 'error';
    console.error('Change password failed:', error);
  } finally {
    isLoading.value = false;
  }
};
</script>

<style scoped>
.animate-spin {
  animation: spin 1s linear infinite;
}
@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
</style>

================================================================================
### PLIK: views\DashboardView.vue
================================================================================

<template>
  <div class="bg-white p-8 rounded-lg shadow-md">
    <h1 v-if="authStore.user" class="text-3xl font-bold text-gray-800 mb-4">
      Witaj na Dashboardzie, {{ authStore.user.username }}!
    </h1>
    <p class="text-gray-600">To jest chroniona zawartość.</p>
    <p class="mt-4">Twój Access Token (fragment): <code class="bg-gray-200 p-1 rounded text-sm">{{ shortAccessToken }}</code></p>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import { useAuthStore } from '@/stores/authStore';

const authStore = useAuthStore()

const shortAccessToken = computed(() => {
  if (authStore.accessToken) {
    return authStore.accessToken.substring(0, 20) + '...'
  }
  return 'Brak tokenu'
})
</script>

================================================================================
### PLIK: views\HomeView.vue
================================================================================

<template>
  <div class="min-h-screen bg-gradient-to-tr from-[#121212] via-[#1e1e1e] to-[#000000] text-white">
    <div class="min-h-screen flex flex-col items-center justify-center px-6 py-12 relative">
      <div class="absolute top-0 left-0 right-0 p-6 flex justify-between items-center">
        <h1 class="text-3xl font-extrabold tracking-tight text-white">Danxils<span class="text-green-500">.js</span></h1>
        <button @click="toggleDarkMode" class="px-4 py-2 text-sm font-medium text-white bg-zinc-800 hover:bg-zinc-700 rounded-md">Toggle Theme</button>
      </div>

      <div class="text-center z-10">
        <h2 class="text-6xl md:text-7xl font-bold mb-6 leading-tight">
          <span class="text-white">Zanurz się w</span>
          <span class="block bg-gradient-to-r from-green-400 to-blue-500 text-transparent bg-clip-text">Nowoczesny Panel</span>
        </h2>
        <p class="text-zinc-400 text-lg md:text-xl max-w-2xl mx-auto mb-10">
          Zarządzaj błędami, kontroluj adresy, przetwarzaj dane i optymalizuj wszystko w czasie rzeczywistym. Z estetyką, która inspiruje.
        </p>

        <div class="flex flex-col sm:flex-row justify-center gap-4">
          <router-link to="/dashboard" class="inline-flex items-center justify-center px-8 py-3 text-base font-semibold text-black bg-green-400 hover:bg-green-300 rounded-full shadow-xl transition-all">Wejdź do Panelu</router-link>
          <router-link to="/login" class="inline-flex items-center justify-center px-8 py-3 text-base font-semibold text-white border border-white hover:bg-white hover:text-black rounded-full transition-all">Zaloguj się</router-link>
        </div>
      </div>

      <div class="absolute inset-0 -z-10 overflow-hidden">
        <div class="absolute -top-20 left-1/3 w-[600px] h-[600px] bg-green-600 rounded-full blur-[150px] opacity-30 animate-blob"></div>
        <div class="absolute top-1/2 right-1/4 w-[400px] h-[400px] bg-blue-600 rounded-full blur-[150px] opacity-20 animate-blob animation-delay-2000"></div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'
const darkMode = ref(false)
const toggleDarkMode = () => {
  darkMode.value = !darkMode.value
}
</script>

<style scoped>
@keyframes blob {
  0%, 100% {
    transform: translate(0px, 0px) scale(1);
  }
  33% {
    transform: translate(30px, -50px) scale(1.1);
  }
  66% {
    transform: translate(-20px, 20px) scale(0.9);
  }
}

.animate-blob {
  animation: blob 15s infinite ease-in-out;
}
.animation-delay-2000 {
  animation-delay: -7s;
}
</style>


================================================================================
### PLIK: views\LoginView.vue
================================================================================

<template>
  <div class="flex items-center justify-center min-h-[calc(100vh-200px)]">
    <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-md">
      <h2 class="text-3xl font-bold text-center text-indigo-600 mb-8">Logowanie</h2>
      <form @submit.prevent="handleLogin">
        <div v-if="errorMessage" class="mb-4 p-3 bg-red-100 text-red-700 rounded-md border border-red-200">
          {{ errorMessage }}
        </div>
        <div class="mb-6">
          <label for="username" class="block text-sm font-medium text-gray-700 mb-1">Nazwa użytkownika</label>
          <input
            type="text"
            id="username"
            v-model="username"
            required
            class="mt-1 block w-full px-4 py-2.5 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm transition duration-150 ease-in-out"
            placeholder="username"
          />
        </div>
        <div class="mb-6">
          <label for="password" class="block text-sm font-medium text-gray-700 mb-1">Hasło</label>
          <input
            type="password"
            id="password"
            v-model="password"
            required
            class="mt-1 block w-full px-4 py-2.5 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm transition duration-150 ease-in-out"
            placeholder="••••••••"
          />
        </div>
        <div>
          <button
            type="submit"
            :disabled="isLoading"
            class="w-full flex items-center justify-center py-2.5 px-4 border border-transparent rounded-md shadow-lg text-base font-semibold text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50 transition-all duration-200"
          >
            <span v-if="isLoading" class="animate-spin mr-2 h-5 w-5 border-2 border-white border-t-transparent rounded-full"></span>
            Zaloguj
          </button>
        </div>
      </form>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import { useRouter } from 'vue-router'
import { useAuthStore } from '@/stores/authStore';

const username = ref('')
const password = ref('')
const authStore = useAuthStore()
const router = useRouter()
const isLoading = ref(false)
const errorMessage = ref('')

const handleLogin = async () => {
  isLoading.value = true
  errorMessage.value = ''
  try {
    await authStore.login({ username: username.value, password: password.value })
    router.push('/dashboard')
  } catch (error) {
    errorMessage.value = error.message || 'Logowanie nie powiodło się. Sprawdź dane lub spróbuj później.'
    console.error('Login failed:', error)
  } finally {
    isLoading.value = false
  }
}
</script>
<style scoped>
.animate-spin {
  animation: spin 1s linear infinite;
}
@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
</style>

================================================================================
### PLIK: views\NotFoundView.vue
================================================================================

<template>
  <div class="flex flex-col items-center justify-center min-h-[calc(100vh-200px)] text-center px-4">
    <div class="bg-white p-8 sm:p-12 rounded-xl shadow-2xl max-w-md w-full">
      <svg class="w-24 h-24 text-indigo-400 mx-auto mb-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
      <h1 class="text-5xl font-extrabold text-indigo-600 mb-3">404</h1>
      <p class="text-xl font-medium text-slate-700 mb-6">Oops! Strona nie została znaleziona.</p>
      <p class="text-slate-500 mb-8">
        Strona, której szukasz, mogła zostać usunięta, jej nazwa uległa zmianie lub jest tymczasowo niedostępna.
      </p>
      <router-link
        to="/"
        class="inline-block px-8 py-3 text-sm font-semibold leading-tight text-white bg-indigo-600 rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-colors"
      >
        Wróć na Stronę Główną
      </router-link>
    </div>
  </div>
</template>

<script setup>
</script>

================================================================================
### PLIK: views\OrderStatusView.vue
================================================================================

<template>
  <div class="bg-white p-6 md:p-8 rounded-xl shadow-lg">
    <h1 class="text-2xl font-bold text-slate-800 mb-6 border-b pb-3">Przegląd Statusów Zamówień</h1>

    <div class="mb-6">
      <input type="text" placeholder="Wyszukaj po kodzie kreskowym..." class="p-3 border border-slate-300 rounded-md w-full md:w-1/2 lg:w-1/3 focus:ring-indigo-500 focus:border-indigo-500 transition shadow-sm">
    </div>

    <div class="text-center py-10 text-slate-500">
      <p class="text-lg">Funkcjonalność przeglądania statusów zamówień jest w trakcie implementacji.</p>
      <p class="text-sm mt-2">Wkrótce pojawią się tutaj dane dotyczące statusów.</p>
      <svg class="w-16 h-16 text-slate-300 mx-auto mt-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
    </div>

    </div>
</template>

<script setup>
</script>

================================================================================
### PLIK: views\RejectedRequestsView.vue
================================================================================

<template>
    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        <div class="bg-gradient-to-r from-slate-700 to-slate-900 text-white p-6 rounded-xl shadow-2xl mb-8">
            <h1 class="text-3xl sm:text-4xl font-bold">Odrzucone Żądania</h1>
            <p class="mt-2 text-slate-300">Przeglądaj, filtruj i zarządzaj odrzuconymi zleceniami.</p>
        </div>

        <div class="mb-6 p-6 bg-white rounded-xl shadow-lg">
            <h2 class="text-xl font-semibold mb-4 text-slate-700 border-b border-slate-200 pb-3">Filtry</h2>
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
                <div>
                    <label for="filterBarcode" class="block text-xs font-medium text-slate-600 mb-1">Kod Kreskowy:</label>
                    <input type="text" id="filterBarcode" v-model="localFilters.barcode" @input="applyFilterDebounced('barcode', $event.target.value)"
                           class="p-2.5 w-full border border-slate-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 text-sm"
                           placeholder="Wpisz kod...">
                </div>
                <div>
                    <label for="filterErrorType" class="block text-xs font-medium text-slate-600 mb-1">Typ Błędu:</label>
                    <select id="filterErrorType" v-model="localFilters.errorType" @change="applyFilterDebounced('errorType', $event.target.value)"
                            class="p-2.5 w-full border border-slate-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 text-sm bg-white">
                        <option value="">Wszystkie</option>
                        <option value="ADDRESS_ALIAS_MISMATCH_DB">Niezgodność Aliasu DB</option>
                        <option value="ADDRESS_PROVIDER_NEEDS_REVIEW">Adres Wymaga Weryfikacji</option>
                        <option value="ADDRESS_PROVIDER_INVALID">Adres Niepoprawny</option>
                        <option value="ADDRESS_CUSTOMER_VERIFICATION_PENDING">Oczekuje na Potw. Klienta</option>
                        <option value="EXTERNAL_SERVICE_FAILURE">Błąd Usługi Zewnętrznej</option>
                        <option value="ADDRESS_DB_ERROR">Błąd DB Adresu</option>
                        <option value="VALIDATION">Błąd Walidacji</option>
                        <option value="PROCESSING">Błąd Przetwarzania</option>
                        <option value="DESERIALIZATION_ERROR">Błąd Deserializacji</option>
                        <option value="CONSTRAINT_VIOLATION">Naruszenie Ograniczeń</option>
                        <option value="LISTENER_EXECUTION_FAILURE">Błąd Listenera</option>
                    </select>
                </div>
            </div>
        </div>

        <div v-if="errorStore.isLoading && !errorStore.rejectedRequests.length" class="text-center py-16">
            <div class="animate-spin rounded-full h-12 w-12 border-t-4 border-b-4 border-indigo-500 mx-auto"></div>
            <p class="text-lg text-slate-500 mt-5">Ładowanie danych...</p>
        </div>
        <div v-else-if="!errorStore.isLoading && errorStore.rejectedRequests.length === 0" class="text-center py-16 bg-white rounded-xl shadow-md">
            <svg class="mx-auto h-16 w-16 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
                <path vector-effect="non-scaling-stroke" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 13h6m-3-3v6m-9 1V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2z" />
            </svg>
            <h3 class="mt-3 text-lg font-medium text-slate-800">Brak odrzuconych żądań</h3>
            <p class="mt-1 text-sm text-slate-500">Nie znaleziono żądań pasujących do wybranych filtrów.</p>
        </div>

        <div v-else class="bg-white rounded-xl shadow-xl overflow-x-auto">
            <table class="min-w-full divide-y divide-slate-200">
                <thead class="bg-slate-50">
                    <tr>
                        <th @click="changeSort('eventId')" class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider cursor-pointer hover:bg-slate-100">ID Błędu <span v-html="sortIcon('eventId')"></span></th>
                        <th @click="changeSort('requestID')" class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider cursor-pointer hover:bg-slate-100">Request ID <span v-html="sortIcon('requestID')"></span></th>
                        <th @click="changeSort('barcode')" class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider cursor-pointer hover:bg-slate-100">Barcode <span v-html="sortIcon('barcode')"></span></th>
                        <th @click="changeSort('errorType')" class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider cursor-pointer hover:bg-slate-100">Typ Błędu <span v-html="sortIcon('errorType')"></span></th>
                        <th class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Status Weryf. Adr.</th>
                        <th class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Wiadomość</th>
                        <th @click="changeSort('createdAt')" class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider cursor-pointer hover:bg-slate-100">Data <span v-html="sortIcon('createdAt')"></span></th>
                        <th class="px-4 py-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Akcje</th>
                    </tr>
                </thead>
                <tbody class="bg-white divide-y divide-slate-200">
                    <tr v-for="error in errorStore.rejectedRequests" :key="error.id" class="hover:bg-slate-50/70 transition duration-150 ease-in-out">
                        <td class="px-4 py-3 whitespace-nowrap text-xs text-slate-600 font-mono">{{ error.eventId.substring(0,8) }}...</td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm text-slate-700">{{ error.requestID || 'N/A' }}</td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm text-slate-700">{{ error.barcode || 'N/A' }}</td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm">
                            <span :class="getErrorTypeClassForTable(error.errorType)">{{ error.errorType || 'N/A' }}</span>
                        </td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm text-slate-700">{{ error.addressVerificationStatus || 'N/A' }}</td>
                        <td class="px-4 py-3 text-sm text-slate-600 max-w-sm truncate" :title="error.errorMessage">
                            {{ error.errorMessage ? error.errorMessage.substring(0, 70) + (error.errorMessage.length > 70 ? '...' : '') : 'Brak' }}
                        </td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm text-slate-600">{{ formatDateForTable(error.createdAt) }}</td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm font-medium">
                            <button @click="openErrorDetailsModal(error)" class="text-indigo-600 hover:text-indigo-800 font-semibold hover:underline text-xs">Szczegóły</button>
                        </td>
                    </tr>
                </tbody>
            </table>

            <div class="py-3 px-4 border-t border-slate-200 bg-slate-50 flex items-center justify-between">
                <div class="text-xs text-slate-600">
                    Strona {{ errorStore.pagination.currentPage + 1 }} / {{ errorStore.pagination.totalPages }} ({{ errorStore.pagination.totalElements }} wyników)
                </div>
                <div class="flex space-x-1.5">
                    <button @click="goToPage(errorStore.pagination.currentPage - 1)" :disabled="errorStore.pagination.currentPage === 0"
                            class="px-3 py-1.5 border border-slate-300 text-xs font-medium rounded-md text-slate-700 bg-white hover:bg-slate-100 disabled:opacity-50 disabled:cursor-not-allowed transition duration-150 ease-in-out">
                        Poprzednia
                    </button>
                    <button @click="goToPage(errorStore.pagination.currentPage + 1)" :disabled="errorStore.pagination.currentPage >= errorStore.pagination.totalPages - 1"
                            class="px-3 py-1.5 border border-slate-300 text-xs font-medium rounded-md text-slate-700 bg-white hover:bg-slate-100 disabled:opacity-50 disabled:cursor-not-allowed transition duration-150 ease-in-out">
                        Następna
                    </button>
                </div>
            </div>
        </div>
        
        <ErrorDetailsModal 
            v-if="showModal"
            :error-id="currentSelectedErrorId"
            @close="handleCloseModal"
            @order-resubmitted="handleOrderResubmitted"
        />
    </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { useErrorStore } from '@/stores/errorStore';
import ErrorDetailsModal from '@/components/modals/ErrorDetailsModal.vue';

const errorStore = useErrorStore();

const currentSelectedErrorId = ref(null);
const showModal = ref(false);

const localFilters = ref({
  barcode: errorStore.filters.barcode,
  errorType: errorStore.filters.errorType,
});

let filterDebounceTimeout = null;
const applyFilterDebounced = (filterName, value) => {
  localFilters.value[filterName] = value;
  clearTimeout(filterDebounceTimeout);
  filterDebounceTimeout = setTimeout(() => {
    errorStore.setFilter(filterName, value);
  }, 500);
};

onMounted(() => {
  errorStore.fetchRejectedRequests();
});

const formatDateForTable = (dateString) => {
  if (!dateString) return 'N/A';
  const date = new Date(dateString);
  return date.toLocaleString('pl-PL', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
};

const openErrorDetailsModal = (error) => {
  currentSelectedErrorId.value = error.id;
  showModal.value = true;
};

const handleCloseModal = () => {
  showModal.value = false;
  currentSelectedErrorId.value = null;
};

const handleOrderResubmitted = () => {
    handleCloseModal();
    errorStore.fetchRejectedRequests(errorStore.pagination.currentPage);
};

const goToPage = (pageNumber) => {
  if (pageNumber >= 0 && pageNumber < errorStore.pagination.totalPages) {
    errorStore.fetchRejectedRequests(pageNumber);
  }
};

const changeSort = (field) => {
  let direction = 'ASC';
  if (errorStore.sort.field === field && errorStore.sort.direction === 'ASC') {
    direction = 'DESC';
  }
  errorStore.setSort(field, direction);
};

const sortIcon = (field) => {
  if (errorStore.sort.field === field) {
    return errorStore.sort.direction === 'ASC' ? '&#9650;' : '&#9660;';
  }
  return '';
};

const getErrorTypeClassForTable = (errorType) => {
    let base = 'px-2 py-0.5 rounded-full text-xs font-semibold inline-block leading-tight ';
    if (['ADDRESS_ALIAS_MISMATCH_DB', 'ADDRESS_PROVIDER_NEEDS_REVIEW', 'ADDRESS_PROVIDER_INVALID'].includes(errorType)) return base + 'bg-orange-100 text-orange-600 border border-orange-200';
    if (errorType === 'ADDRESS_CUSTOMER_VERIFICATION_PENDING') return base + 'bg-yellow-100 text-yellow-600 border border-yellow-200';
    if (['VALIDATION', 'CONSTRAINT_VIOLATION', 'DESERIALIZATION_ERROR'].includes(errorType)) return base + 'bg-red-100 text-red-600 border border-red-200';
    if (['PROCESSING', 'LISTENER_EXECUTION_FAILURE', 'EXTERNAL_SERVICE_FAILURE', 'ADDRESS_DB_ERROR'].includes(errorType)) return base + 'bg-purple-100 text-purple-600 border border-purple-200';
    return base + 'bg-slate-100 text-slate-600 border border-slate-200';
};
</script>

<style scoped>
.animate-spin {
  animation: spin 1s linear infinite;
}
@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
.max-w-xs { max-width: 20rem; }
.max-w-sm { max-width: 24rem; }
</style>

================================================================================
### PLIK: views\admin\AddressProvidersView.vue
================================================================================

<template>
  <div class="container mx-auto p-4 sm:p-6 lg:p-8">
    <div class="bg-gradient-to-r from-slate-700 to-slate-900 text-white p-6 rounded-xl shadow-2xl mb-8">
      <h1 class="text-3xl sm:text-4xl font-bold">Zarządzanie Dostawcami Weryfikacji Adresów</h1>
      <p class="mt-2 text-slate-300">Konfiguruj aktywnego dostawcę używanego przez system TES.</p>
    </div>

    <div class="bg-white p-6 md:p-8 rounded-xl shadow-lg">
      <div v-if="isLoadingInitialData && !isPollingAnyOperation()" class="text-center py-10">
        <div class="animate-spin rounded-full h-10 w-10 border-t-4 border-b-4 border-indigo-500 mx-auto mb-4"></div>
        <p class="text-slate-600">Ładowanie początkowej konfiguracji dostawców...</p>
      </div>

      <div v-else-if="loadError" class="p-4 mb-4 text-sm text-red-700 bg-red-100 rounded-lg border border-red-300">
        <strong class="font-bold">Błąd ładowania konfiguracji:</strong> {{ loadError }}
        <button @click="fetchInitialProviderData" :disabled="isLoadingInitialData || isPollingAnyOperation()" class="ml-2 text-xs text-red-700 underline">Spróbuj ponownie</button>
      </div>

      <div v-else>
        <div class="mb-6 pb-4 border-b border-slate-200">
          <h2 class="text-xl font-semibold text-slate-700 mb-1">Aktualnie Aktywny Dostawca</h2>
          <div class="flex items-center">
            <div v-if="pollingStatus.currentProvider.isLoading && !currentProvider" class="text-slate-500 italic text-sm flex items-center">
              <span class="animate-spin h-4 w-4 mr-1 border-2 border-slate-400 border-t-transparent rounded-full"></span>
              Pobieranie... {{ pollingStatus.currentProvider.correlationId ? `(ID: ${pollingStatus.currentProvider.correlationId.substring(0,8)}...)` : '' }}
            </div>
            <p v-else-if="currentProvider" class="text-lg">
              <span class="font-bold px-3 py-1 rounded-full text-white" :class="getProviderBadgeClass(currentProvider)">
                {{ currentProvider.toUpperCase() }}
              </span>
              <span v-if="currentProvider.toLowerCase() === 'none'" class="ml-2 text-sm text-slate-500 italic">
                (Weryfikacja zewnętrzna jest wyłączona)
              </span>
            </p>
            <p v-else class="text-slate-500 italic">Nie można było ustalić aktywnego dostawcy.</p>

            <button @click="refreshCurrentProvider" :disabled="isLoadingInitialData || isPollingAnyOperation()" title="Odśwież aktualnego dostawcę" class="ml-4 text-xs text-indigo-600 hover:text-indigo-800 disabled:opacity-50 disabled:cursor-not-allowed p-1 rounded hover:bg-indigo-50">
              <svg v-if="pollingStatus.currentProvider.isLoading" class="animate-spin h-4 w-4 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              <span v-else>Odśwież</span>
            </button>
          </div>
           <p v-if="pollingStatus.currentProvider.error" class="text-xs text-red-500 mt-1">{{ pollingStatus.currentProvider.error }}</p>
        </div>

        <div class="mb-8">
          <label for="providerSelect" class="block text-sm font-medium text-slate-700 mb-1">Wybierz nowego dostawcę:</label>
          <div class="flex items-center space-x-3">
            <select
              id="providerSelect"
              v-model="selectedProviderToSet"
              class="block w-full max-w-xs p-2.5 border border-slate-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm bg-white transition duration-150"
              :disabled="pollingStatus.setProvider.isLoading || isPollingAnyOperationExcept('setProvider')"
            >
              <option disabled value="">-- Wybierz --</option>
              <option
                v-for="provider in availableProviders"
                :key="provider"
                :value="provider.toLowerCase()"
              >
                {{ provider.toUpperCase() }}
              </option>
              <option value="none">NONE (Wyłącz weryfikację)</option>
            </select>
            <button
              @click="requestSetProvider"
              :disabled="pollingStatus.setProvider.isLoading || !selectedProviderToSet || selectedProviderToSet === currentProvider || isPollingAnyOperationExcept('setProvider')"
              class="inline-flex items-center justify-center px-4 py-2.5 text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
            >
              <span v-if="pollingStatus.setProvider.isLoading" class="animate-spin h-4 w-4 -ml-1 mr-2 border-2 border-white border-t-transparent rounded-full"></span>
              {{ pollingStatus.setProvider.isLoading ? 'Przetwarzanie...' : 'Ustaw Aktywnego' }}
            </button>
          </div>
          <p v-if="selectedProviderToSet && selectedProviderToSet === currentProvider && !pollingStatus.setProvider.isLoading" class="text-xs text-slate-500 mt-1 italic">
            Wybrany dostawca jest już aktywny.
          </p>
        </div>

        <div v-if="operationMessage" :class="operationMessageType === 'success' ? 'bg-green-100 text-green-700 border-green-300' : (operationMessageType === 'info' ? 'bg-blue-100 text-blue-700 border-blue-300' : 'bg-red-100 text-red-700 border-red-300')" class="p-3 rounded-md border text-sm mb-4">
          {{ operationMessage }}
        </div>
         <div v-if="pollingStatus.setProvider.isLoading" class="text-sm text-slate-600 italic mb-4 flex items-center">
            <span class="animate-spin h-4 w-4 mr-2 border-2 border-slate-400 border-t-transparent rounded-full"></span>
            Oczekiwanie na wynik operacji (ID: {{ pollingStatus.setProvider.correlationId?.substring(0,8) || 'Zapisywanie' }})...
        </div>
        <p v-if="pollingStatus.setProvider.error" class="text-xs text-red-500 mt-1 mb-4">{{ pollingStatus.setProvider.error }}</p>

        <div class="mt-8 pt-6 border-t border-slate-200">
          <h3 class="text-lg font-semibold text-slate-700 mb-1">Dostępni Dostawcy w Systemie:</h3>
           <div class="flex items-center">
            <ul v-if="availableProviders.length && !pollingStatus.availableProviders.isLoading" class="list-disc list-inside space-y-1 text-sm text-slate-600">
                <li v-for="provider in availableProviders" :key="provider">{{ provider }}</li>
                <li><b>NONE</b> - opcja wyłączenia zewnętrznej weryfikacji adresów.</li>
            </ul>
            <p v-else-if="pollingStatus.availableProviders.isLoading" class="text-slate-500 italic text-sm ml-2 flex items-center">
                <span class="animate-spin h-4 w-4 mr-1 border-2 border-slate-400 border-t-transparent rounded-full"></span>
                Pobieranie listy... ({{ pollingStatus.availableProviders.correlationId?.substring(0,8) || 'ID' }}...)
            </p>
            <p v-else class="text-slate-500 italic">Brak informacji o dostępnych zaimplementowanych dostawcach.</p>
            <button @click="refreshAvailableProviders" :disabled="isLoadingInitialData || isPollingAnyOperation()" title="Odśwież listę dostępnych dostawców" class="ml-4 text-xs text-indigo-600 hover:text-indigo-800 disabled:opacity-50 disabled:cursor-not-allowed p-1 rounded hover:bg-indigo-50">
               <svg v-if="pollingStatus.availableProviders.isLoading" class="animate-spin h-4 w-4 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              <span v-else>Odśwież listę</span>
            </button>
           </div>
           <p v-if="pollingStatus.availableProviders.error" class="text-xs text-red-500 mt-1">{{ pollingStatus.availableProviders.error }}</p>

          <p class="text-xs text-slate-500 mt-4">
            <strong class="font-semibold">Uwaga:</strong> Zmiana aktywnego dostawcy jest zapisywana w konfiguracji centralnej (TES).
            System TES może wymagać odświeżenia konfiguracji, aby zmiana weszła w pełni w życie.
          </p>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue';
import apiClient from '@/services/api';
import { useAuthStore } from '@/stores/authStore';

const authStore = useAuthStore();

const isLoadingInitialData = ref(true);
const loadError = ref('');
const currentProvider = ref('');
const availableProviders = ref([]);
const selectedProviderToSet = ref('');

const operationMessage = ref('');
const operationMessageType = ref(''); // 'success', 'error', 'info'

const pollingStatus = ref({
    currentProvider: { correlationId: null, isLoading: false, error: null, intervalId: null, description: "Pobieranie aktualnego dostawcy" },
    availableProviders: { correlationId: null, isLoading: false, error: null, intervalId: null, description: "Pobieranie listy dostępnych dostawców" },
    setProvider: { correlationId: null, isLoading: false, error: null, intervalId: null, description: "Ustawianie aktywnego dostawcy" }
});

const MAX_POLLS = 20;
const POLL_INTERVAL_MS = 3000;

const clearPollingForOperation = (operationKey) => {
    if (pollingStatus.value[operationKey]?.intervalId) {
        clearInterval(pollingStatus.value[operationKey].intervalId);
    }
    pollingStatus.value[operationKey] = { 
        ...pollingStatus.value[operationKey],
        isLoading: false, 
        error: null, 
        intervalId: null 
    };
};

const clearAllPolling = () => {
    Object.keys(pollingStatus.value).forEach(key => clearPollingForOperation(key));
};

onUnmounted(() => {
    clearAllPolling();
});

const isPollingAnyOperation = () => {
    return Object.values(pollingStatus.value).some(op => op.isLoading);
};

const isPollingAnyOperationExcept = (exceptKey) => {
    return Object.entries(pollingStatus.value)
        .filter(([key]) => key !== exceptKey)
        .some(([,op]) => op.isLoading);
};


const pollOperation = async (correlationId, operationKey) => {
    const opDesc = pollingStatus.value[operationKey].description;
    
    if (!correlationId) {
        const errorMsg = `Brak CorrelationID dla operacji: ${opDesc}`;
        pollingStatus.value[operationKey].error = errorMsg;
        pollingStatus.value[operationKey].isLoading = false;
        if (operationKey === 'setProvider' || operationKey === 'currentProvider' || operationKey === 'availableProviders') { // Aktualizuj główny komunikat dla wszystkich operacji tego widoku
            operationMessage.value = errorMsg;
            operationMessageType.value = 'error';
        }
        return Promise.reject(new Error(errorMsg));
    }
    
    pollingStatus.value[operationKey].correlationId = correlationId;
    pollingStatus.value[operationKey].isLoading = true;
    pollingStatus.value[operationKey].error = null;
    
    // Komunikat o przetwarzaniu dla wszystkich operacji
    operationMessage.value = `Przetwarzanie: ${opDesc} (ID: ${correlationId.substring(0,8)}...).`;
    operationMessageType.value = 'info';


    return new Promise((resolve, reject) => {
        let polls = 0;
        if (pollingStatus.value[operationKey].intervalId) {
            clearInterval(pollingStatus.value[operationKey].intervalId);
        }

        pollingStatus.value[operationKey].intervalId = setInterval(async () => {
            polls++;
            if (!pollingStatus.value[operationKey].isLoading || polls > MAX_POLLS) {
                if (polls > MAX_POLLS && pollingStatus.value[operationKey].isLoading) {
                    pollingStatus.value[operationKey].error = `Timeout oczekiwania na zakończenie operacji '${opDesc}' (CorrID: ${correlationId}).`;
                }
                const finalErrorMsg = pollingStatus.value[operationKey].error || `Polling for ${opDesc} (CorrID: ${correlationId}) stopped or timed out.`;
                operationMessage.value = finalErrorMsg;
                operationMessageType.value = 'error';
                
                clearPollingForOperation(operationKey);
                return reject(new Error(finalErrorMsg));
            }

            console.debug(`Odpytywanie operacji ${operationKey} (CorrID: ${correlationId}), próba ${polls}`);
            try {
                const res = await apiClient.get(`/api/admin/address-verification/operations/${correlationId}`);
                
                if (res.data && res.data.status === 'COMPLETED') {
                    clearPollingForOperation(operationKey);
                    console.info(`Operacja '${opDesc}' (CorrID: ${correlationId}) zakończona sukcesem.`);
                     if (operationKey === 'setProvider') {
                         operationMessage.value = (res.data.result && typeof res.data.result === 'string') ? res.data.result : `Operacja '${opDesc}' zakończona pomyślnie.`;
                         operationMessageType.value = 'success';
                     } else if (operationMessage.value.startsWith('Przetwarzanie')) { // Tylko jeśli nie ma innego błędu
                        operationMessage.value = `Operacja '${opDesc}' zakończona.`;
                        operationMessageType.value = 'success';
                     }
                    resolve(res.data.result);
                } else if (res.data && res.data.status === 'FAILED') {
                    clearPollingForOperation(operationKey);
                    const errorMsg = res.data.errorDetails || `Operacja ${opDesc} nie powiodła się.`;
                    pollingStatus.value[operationKey].error = errorMsg;
                    operationMessage.value = errorMsg;
                    operationMessageType.value = 'error';
                    console.error(`Operacja '${opDesc}' (CorrID: ${correlationId}) zakończona błędem: ${errorMsg}`);
                    reject(new Error(errorMsg));
                } else if (res.data && (res.data.status === 'PENDING' || res.data.status === 'PROCESSING')) {
                    // Kontynuuj odpytywanie
                    // Można zaktualizować `operationMessage` o statusie PENDING/PROCESSING
                    operationMessage.value = `Operacja '${opDesc}' w toku (Status: ${res.data.status}, ID: ${correlationId.substring(0,8)})...`;
                    operationMessageType.value = 'info';
                } else { 
                    clearPollingForOperation(operationKey);
                    const unexpectedMsg = `Nieoczekiwany status operacji '${res.data?.status || 'BRAK'}' dla '${opDesc}' (CorrID: ${correlationId}).`;
                    pollingStatus.value[operationKey].error = unexpectedMsg;
                    operationMessage.value = unexpectedMsg;
                    operationMessageType.value = 'error';
                    console.error(unexpectedMsg);
                    reject(new Error(unexpectedMsg));
                }
            } catch (pollError) {
                clearPollingForOperation(operationKey);
                const networkErrorMsg = `Błąd sieci podczas odpytywania o status operacji '${opDesc}' (CorrID: ${correlationId}).`;
                pollingStatus.value[operationKey].error = pollError.response?.data?.error || pollError.message || networkErrorMsg;
                operationMessage.value = pollingStatus.value[operationKey].error;
                operationMessageType.value = 'error';
                console.error(networkErrorMsg, pollError);
                reject(new Error(pollingStatus.value[operationKey].error));
            }
        }, POLL_INTERVAL_MS);
    });
};

const initiateOperation = async (endpoint, operationKey, payload = null, httpMethod = 'POST') => {
    if (!authStore.isLoggedIn) {
        loadError.value = "Użytkownik nie jest zalogowany."; // Ustaw loadError zamiast rzucać, aby obsłużyć w UI
        isLoadingInitialData.value = false; // Jeśli to było ładowanie początkowe
        return Promise.reject(new Error("Użytkownik nie jest zalogowany."));
    }
    const opDesc = pollingStatus.value[operationKey].description;
    clearPollingForOperation(operationKey); // Wyczyść poprzedni stan dla tej operacji

    pollingStatus.value[operationKey].isLoading = true;
    pollingStatus.value[operationKey].error = null;
    
    if (operationKey === 'setProvider' || isLoadingInitialData.value) {
         operationMessage.value = `Inicjowanie: ${opDesc}...`;
         operationMessageType.value = 'info';
    }

    try {
        let response;
        const config = (payload && (payload instanceof String || typeof payload === 'string')) ? { headers: { 'Content-Type': 'text/plain' } } : {};

        if (httpMethod.toUpperCase() === 'POST') {
            response = await apiClient.post(endpoint, payload, config);
        } else { // Dla GET, payload jest ignorowany
            response = await apiClient.get(endpoint, config);
        }
        
        const correlationId = response.data.correlationId;
        if (!correlationId) {
            throw new Error(`Nie udało się zainicjować operacji: ${opDesc}. Brak CorrelationID w odpowiedzi serwera: ${JSON.stringify(response.data)}`);
        }
        console.debug(`Zainicjowano ${opDesc}, CorrID: ${correlationId}`);
        pollingStatus.value[operationKey].correlationId = correlationId;
        return pollOperation(correlationId, operationKey);
    } catch (initError) {
        pollingStatus.value[operationKey].isLoading = false;
        const errorDetail = initError.response?.data?.error || initError.response?.data?.message || initError.message || `Nie udało się zainicjować operacji: ${opDesc}.`;
        pollingStatus.value[operationKey].error = errorDetail;
        if (operationKey === 'setProvider' || isLoadingInitialData.value) {
            operationMessage.value = errorDetail;
            operationMessageType.value = 'error';
        }
        console.error(`Błąd inicjacji operacji '${opDesc}':`, initError);
        throw new Error(pollingStatus.value[operationKey].error);
    }
};

const fetchInitialProviderData = async () => {
    isLoadingInitialData.value = true;
    loadError.value = '';
    operationMessage.value = '';
    // clearAllPolling(); // Nie czyść tutaj, bo `initiateOperation` to zrobi dla swoich kluczy

    try {
        // Użyj POST dla endpointów inicjujących
        const results = await Promise.allSettled([
            initiateOperation('/api/admin/address-verification/providers/current/initiate', 'currentProvider', null, 'POST'),
            initiateOperation('/api/admin/address-verification/providers/available/initiate', 'availableProviders', null, 'POST')
        ]);

        let hasFulfilledCurrent = false;
        let hasFulfilledAvailable = false;

        if (results[0].status === 'fulfilled') {
            currentProvider.value = results[0].value || 'none';
            selectedProviderToSet.value = currentProvider.value && currentProvider.value !== 'none' ?
                                       currentProvider.value.toLowerCase() : 'none';
            hasFulfilledCurrent = true;
        } else {
            currentProvider.value = 'N/A (błąd)';
            // pollingStatus.currentProvider.error jest już ustawione przez pollOperation
            loadError.value += `Błąd pobierania aktualnego dostawcy: ${pollingStatus.value.currentProvider.error || results[0].reason?.message || 'Nieznany błąd'}. `;
        }

        if (results[1].status === 'fulfilled') {
            availableProviders.value = Array.isArray(results[1].value) ? results[1].value : [];
            hasFulfilledAvailable = true;
        } else {
            availableProviders.value = [];
            loadError.value += `Błąd pobierania listy dostępnych dostawców: ${pollingStatus.value.availableProviders.error || results[1].reason?.message || 'Nieznany błąd'}.`;
        }

        if (hasFulfilledCurrent && hasFulfilledAvailable) {
            operationMessage.value = "Konfiguracja dostawców załadowana pomyślnie.";
            operationMessageType.value = 'success';
        } else if (loadError.value && !isPollingAnyOperation()) { // Pokaż ogólny błąd tylko jeśli nic nie polluje
             operationMessage.value = "Wystąpiły problemy podczas ładowania konfiguracji. Sprawdź błędy poszczególnych operacji.";
             operationMessageType.value = 'error';
        } else if (isPollingAnyOperation()){
            operationMessage.value = "Trwa ładowanie danych..."; // Ogólny komunikat, jeśli coś jeszcze polluje
            operationMessageType.value = 'info';
        }

    } catch (error) { // Ten catch złapie błędy, które nie są PromiseRejectionEvent
        console.error('Krytyczny błąd podczas inicjowania pobierania konfiguracji:', error);
        loadError.value = error.message || 'Nie udało się załadować początkowej konfiguracji.';
        operationMessage.value = loadError.value;
        operationMessageType.value = 'error';
    } finally {
        isLoadingInitialData.value = false;
    }
};

const requestSetProvider = async () => {
  if (!selectedProviderToSet.value || pollingStatus.value.setProvider.isLoading || isPollingAnyOperationExcept('setProvider')) return;
  
  operationMessage.value = ''; 
  operationMessageType.value = '';

  try {
    // Endpoint `/api/admin/address-verification/providers/current` jest POST i przyjmuje String w ciele
    const result = await initiateOperation(
        '/api/admin/address-verification/providers/current', 
        'setProvider',
        selectedProviderToSet.value, // Payload to string
        'POST' 
    );
    // Komunikat sukcesu jest już ustawiany w pollOperation
    await fetchInitialProviderData(); // Odśwież całą konfigurację po sukcesie

  } catch (error) {
    console.error('Błąd podczas ustawiania aktywnego dostawcy:', error);
    // Komunikat błędu jest już ustawiony w pollOperation lub initiateOperation
    if (!operationMessage.value || operationMessageType.value !== 'error') {
        operationMessage.value = error.message || 'Nie udało się ustawić aktywnego dostawcy.';
        operationMessageType.value = 'error';
    }
  }
};

const refreshCurrentProvider = async () => {
    if (isPollingAnyOperation()) return;
    operationMessage.value = '';
    try {
        const result = await initiateOperation('/api/admin/address-verification/providers/current/initiate', 'currentProvider', null, 'POST');
        currentProvider.value = result || 'none';
        selectedProviderToSet.value = currentProvider.value && currentProvider.value !== 'none' ? currentProvider.value.toLowerCase() : 'none';
        operationMessage.value = "Pomyślnie odświeżono aktualnego dostawcę.";
        operationMessageType.value = 'success';
    } catch (error) {
        operationMessage.value = error.message || "Nie udało się odświeżyć aktualnego dostawcy.";
        operationMessageType.value = 'error';
        // Błąd specyficzny dla operacji jest już w pollingStatus.currentProvider.error
    }
};

const refreshAvailableProviders = async () => {
    if (isPollingAnyOperation()) return;
    operationMessage.value = '';
    try {
        const result = await initiateOperation('/api/admin/address-verification/providers/available/initiate', 'availableProviders', null, 'POST');
        availableProviders.value = Array.isArray(result) ? result : [];
        operationMessage.value = "Pomyślnie odświeżono listę dostępnych dostawców.";
        operationMessageType.value = 'success';
    } catch (error) {
        operationMessage.value = error.message || "Nie udało się odświeżyć listy dostępnych dostawców.";
        operationMessageType.value = 'error';
        // Błąd specyficzny dla operacji jest już w pollingStatus.availableProviders.error
    }
};

const getProviderBadgeClass = (providerName) => {
  if (!providerName) return 'bg-slate-400';
  switch (providerName.toLowerCase()) {
    case 'here': return 'bg-blue-600';
    case 'nominatim': return 'bg-green-600';
    case 'maps': return 'bg-yellow-500 text-black';
    case 'none': return 'bg-slate-500';
    default: return 'bg-gray-500';
  }
};

onMounted(() => {
  fetchInitialProviderData();
});

</script>

<style scoped>
.animate-spin {
  animation: spin 1s linear infinite;
}
@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
</style>
